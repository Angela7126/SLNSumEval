<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Logical Inference on Dependency-based Compositional Semantics</title>
<!--Generated on Tue Jun 10 17:14:51 2014 by LaTeXML (version 0.8.0) http://dlmf.nist.gov/LaTeXML/.-->
<!--Document created on .-->

<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8"/>
<link rel="stylesheet" href="LaTeXML.css" type="text/css"/>
<link rel="stylesheet" href="ltx-article.css" type="text/css"/>
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<div class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Logical Inference on Dependency-based Compositional Semantics</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Ran Tian  Yusuke Miyao   Takuya Matsuzaki
<br class="ltx_break"/>National Institute of Informatics, Japan 
<br class="ltx_break"/>{tianran,yusuke,takuya-matsuzaki}@nii.ac.jp 
<br class="ltx_break"/>
</span></span></div>
<div class="ltx_date ltx_role_creation"/>

<div class="ltx_abstract"><h6 class="ltx_title ltx_title_abstract">Abstract</h6>
<p class="ltx_p">Dependency-based Compositional Semantics (DCS) is a framework of
natural language semantics with easy-to-process structures as well as
strict semantics.
In this paper, we equip the DCS framework with logical inference, by defining <span class="ltx_text ltx_font_italic">abstract
denotations</span> as an abstraction of the computing process of denotations in original DCS. An inference
engine is built to achieve inference on abstract denotations. Furthermore, we propose a way to
generate on-the-fly knowledge in logical inference, by combining our framework with the
idea of tree transformation. Experiments on FraCaS and PASCAL RTE datasets show
promising results.</p>
</div>
<div id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section"><span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p class="ltx_p">Dependency-based Compositional Semantics (DCS) provides an intuitive way to model semantics of
questions, by using simple dependency-like trees <cite class="ltx_cite">[]</cite>.
It is expressive enough to represent complex natural language queries on a relational
database, yet
simple enough to be latently learned from question-answer pairs. In this paper, we equip DCS with
<em class="ltx_emph">logical inference</em>,
which, in one point of view, is “the best way of testing an NLP system’s semantic capacity” <cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p class="ltx_p">It should be noted that, however, a framework primarily designed for question answering
is not readily suited for logical inference. Because, answers returned by a query
depend on the specific database, but implication is independent of any databases.
For example, answers to the question “<span class="ltx_text ltx_font_italic">What books are read by students?</span>”, should always
be a subset of answers to “<span class="ltx_text ltx_font_italic">What books are ever read by anyone?</span>”, no matter how we store
the data of students and how many records of books are there in our database.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p class="ltx_p">Thus, our first step is to fix a notation which abstracts the calculation process of DCS trees,
so as to clarify its meaning without the aid of any existing database. The idea is to
borrow a minimal set of operators from relational algebra <cite class="ltx_cite">[]</cite>, which is already able
to formulate
the calculation in DCS and define <span class="ltx_text ltx_font_italic">abstract denotation</span>, which is an abstraction of
the <em class="ltx_emph">computation</em> of denotations guided by DCS trees. Meanings of sentences then can be represented
by primary relations among abstract denotations. This formulation keeps
the simpleness and computability of DCS trees mostly unaffected; for example, our semantic calculation
for DCS trees is parallel to the denotation computation in original DCS.</p>
</div>
<div id="S1.p4" class="ltx_para">
<p class="ltx_p">An inference engine is built to handle inference on abstract denotations. Moreover, to compensate
the lack of background knowledge in practical inference, we combine our
framework with the idea of tree
transformation <cite class="ltx_cite">[]</cite>, to propose a way of generating knowledge in
logical representation from entailment rules <cite class="ltx_cite">[]</cite>, which are by now typically
considered as syntactic rewriting rules.</p>
</div>
<div id="S1.p5" class="ltx_para">
<p class="ltx_p">We test our system on FraCaS <cite class="ltx_cite">[]</cite> and PASCAL RTE datasets <cite class="ltx_cite">[]</cite>.
The experiments show: (i) a competitive performance on FraCaS dataset; (ii) a big impact of
our automatically generated on-the-fly knowledge in achieving high recall for a logic-based RTE system;
and (iii) a result that outperforms state-of-the-art RTE system on RTE5 data. Our
whole system is publicly released and can be downloaded from
<a href="http://kmcs.nii.ac.jp/tianran/tifmo/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://kmcs.nii.ac.jp/tianran/tifmo/</span></a>.</p>
</div>
</div>
<div id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section"><span class="ltx_tag ltx_tag_section">2 </span>The Idea</h2>

<div id="S2.p1" class="ltx_para">
<p class="ltx_p">In this section we describe the idea of representing natural
language semantics by DCS trees, and achieving inference by computing logical
relations among the corresponding abstract denotations.</p>
</div>
<div id="S2.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">2.1 </span>DCS trees</h3>

<div id="S2.F1" class="ltx_figure"><img src="" id="S2.F1.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>The DCS tree of “<em class="ltx_emph">students read books</em>”</div>
</div>
<div id="S2.T1" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center"><em class="ltx_emph ltx_font_script">student</em></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_typewriter ltx_font_script">ARG</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_script">Mark</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">John</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">Emily</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">…</span></td></tr>
</tbody>
</table>
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center"><em class="ltx_emph ltx_font_script">book</em></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_typewriter ltx_font_script">ARG</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_script">A Tale of Two Cities</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">Ulysses</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">…</span></td></tr>
</tbody>
</table>
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center" colspan="2"><em class="ltx_emph ltx_font_script">read</em></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_typewriter ltx_font_script">SUBJ</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_typewriter ltx_font_script">OBJ</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_script">Mark</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_script">New York Times</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">Mary</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_script">A Tale of Two Cities</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">John</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_script">Ulysses</span></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_script">…</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_script">…</span></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_script"><span class="ltx_tag ltx_tag_table">Table 1: </span>Databases of <em class="ltx_emph">student</em>, <em class="ltx_emph">book</em>, and <em class="ltx_emph">read</em></div>
</div>
<div id="S2.SS1.p1" class="ltx_para">
<p class="ltx_p">DCS trees has been proposed to
represent natural language semantics with a structure similar to
dependency trees <cite class="ltx_cite">[]</cite> (Figure <a href="#S2.F1" title="Figure 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>).
For the sentence “<em class="ltx_emph">students read books</em>”, imagine a
database consists of three tables, namely, a set of students, a set
of books, and a set of “reading” events (Table <a href="#S2.T1" title="Table 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>).
The DCS tree in Figure <a href="#S2.F1" title="Figure 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> is interpreted as a command
for querying these tables, obtaining “reading” entries whose
“<span class="ltx_text ltx_font_typewriter">SUBJ</span>” field is <span class="ltx_text ltx_font_bold">student</span> and whose “<span class="ltx_text ltx_font_typewriter">OBJ</span>”
field is <span class="ltx_text ltx_font_bold">book</span>. The result is
a set <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS1.p1.m1" class="ltx_Math" alttext="\{\textit{John reads Ulysses},\ldots\}" display="inline"><mrow><mo>{</mo><mrow><mtext mathvariant="italic">John reads Ulysses</mtext><mo>,</mo><mi mathvariant="normal">…</mi></mrow><mo>}</mo></mrow></math>, which is called a
<em class="ltx_emph">denotation</em>.</p>
</div>
<div id="S2.SS1.p2" class="ltx_para">
<p class="ltx_p">DCS trees can be extended to represent
linguistic phenomena such as quantification and coreference, with additional markers
introducing additional operations on tables.
Figure <a href="#S2.F2" title="Figure 2 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> shows an example with a quantifier “<em class="ltx_emph">every</em>”,
which is marked as “<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS1.p2.m1" class="ltx_Math" alttext="\subset" display="inline"><mo>⊂</mo></math>” on
the edge <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS1.p2.m2" class="ltx_Math" alttext="(\textbf{love})\texttt{OBJ-ARG}(\textbf{dog})" display="inline"><mrow><mrow><mo>(</mo><mtext>𝐥𝐨𝐯𝐞</mtext><mo>)</mo></mrow><mo>⁢</mo><mtext mathvariant="monospace">OBJ-ARG</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐝𝐨𝐠</mtext><mo>)</mo></mrow></mrow></math> and interpreted
as a <em class="ltx_emph">division operator</em> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS1.p2.m3" class="ltx_Math" alttext="q_{\subset}^{\texttt{OBJ}}" display="inline"><msubsup><mi>q</mi><mo>⊂</mo><mtext>𝙾𝙱𝙹</mtext></msubsup></math> (§<a href="#S2.SS2" title="2.2 Abstract denotations ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.2</span></a>).
Optimistically, we believe DCS can provide a framework of semantic representation with
sufficiently wide coverage for real-world texts.</p>
</div>
<div id="S2.F2" class="ltx_figure"><img src="" id="S2.F2.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>DCS trees of “<span class="ltx_text ltx_font_italic">Mary loves every dog</span>” (Left-Up), “<span class="ltx_text ltx_font_italic">Tom has a dog</span>” (Left-Down),
and “<span class="ltx_text ltx_font_italic">Tom has an animal that Mary loves</span>” (Right).</div>
</div>
<div id="S2.SS1.p3" class="ltx_para">
<p class="ltx_p">The strict semantics of DCS trees brings us the idea of applying DCS
to logical inference. This is not trivial, however, because
DCS works under the assumption that databases are explicitly available.
Obviously this is unrealistic for logical inference on
unrestricted texts, because we cannot prepare a database for everything
in the world. This fact fairly restricts the applicable tasks of DCS.</p>
</div>
<div id="S2.SS1.p4" class="ltx_para">
<p class="ltx_p">Our solution is to redefine DCS trees without the aid of any databases,
by considering each node of a DCS tree as a content word in a sentence
(but may no longer be a table in a specific database),
while each edge represents semantic relations between two words.
The labels on both ends of an edge, such as <span class="ltx_text ltx_font_typewriter">SUBJ</span> (subject) and
<span class="ltx_text ltx_font_typewriter">OBJ</span> (object), are considered as <em class="ltx_emph">semantic roles</em> of the
corresponding words<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup>The semantic role
<span class="ltx_text ltx_font_typewriter">ARG</span> is specifically defined for denoting nominal
predicate.</span></span></span>. To formulate the database querying process defined by a
DCS tree, we provide formal semantics to DCS trees by employing
<em class="ltx_emph">relational algebra</em> <cite class="ltx_cite">[]</cite> for representing the query.
As described below, we represent meanings of sentences with
<em class="ltx_emph">abstract denotations</em>, and logical relations among sentences are computed
as relations among their abstract denotations. In this way, we can
perform inference over formulas of
relational algebra, without computing database entries explicitly.</p>
</div>
</div>
<div id="S2.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">2.2 </span>Abstract denotations</h3>

<div id="S2.SS2.p1" class="ltx_para">
<p class="ltx_p"><em class="ltx_emph">Abstract denotations</em> are formulas constructed from a minimal set of relational
algebra <cite class="ltx_cite">[]</cite> operators, which is already able to formulate the database queries
defined by DCS trees.</p>
</div>
<div id="S2.SS2.p2" class="ltx_para">
<p class="ltx_p">For example, the semantics of “<em class="ltx_emph">students read books</em>” is
given by the abstract denotation:</p>
<table id="S2.Ex1" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.Ex1.m1" class="ltx_Math" alttext="F_{1}=\textbf{read}\cap(\textbf{student}_{\texttt{SUBJ}}\times\textbf{book}_{%&#10;\texttt{OBJ}})," display="block"><mrow><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mrow><mtext>𝐫𝐞𝐚𝐝</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐬𝐭𝐮𝐝𝐞𝐧𝐭</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext>𝐛𝐨𝐨𝐤</mtext><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
<p class="ltx_p">where <span class="ltx_text ltx_font_bold">read</span>, <span class="ltx_text ltx_font_bold">student</span> and <span class="ltx_text ltx_font_bold">book</span> denote sets
represented by these words respectively, and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m1" class="ltx_Math" alttext="w_{r}" display="inline"><msub><mi>w</mi><mi>r</mi></msub></math> represents the set
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m2" class="ltx_Math" alttext="w" display="inline"><mi>w</mi></math> considered as the domain of the semantic role <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m3" class="ltx_Math" alttext="r" display="inline"><mi>r</mi></math> (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m4" class="ltx_Math" alttext="\textbf{book}_{\texttt{OBJ}}" display="inline"><msub><mtext>𝐛𝐨𝐨𝐤</mtext><mtext>𝙾𝙱𝙹</mtext></msub></math> is
the set of books considered as objects). The operators
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m5" class="ltx_Math" alttext="\cap" display="inline"><mo>∩</mo></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m6" class="ltx_Math" alttext="\times" display="inline"><mo>×</mo></math> represent intersection and Cartesian product
respectively, both borrowed from relational algebra.
It is not hard to see the abstract denotation denotes the intersection of the
“<em class="ltx_emph">reading</em>” set (as illustrated by the “<em class="ltx_emph">read</em>” table in Table <a href="#S2.T1" title="Table 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>)
with the product of “<em class="ltx_emph">student</em>” set and “<em class="ltx_emph">book</em>” set,
which results in the same denotation as computed by the DCS tree in Figure <a href="#S2.F1" title="Figure 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>,
i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m7" class="ltx_Math" alttext="\{\textit{John reads Ulysses},\ldots\}" display="inline"><mrow><mo>{</mo><mrow><mtext mathvariant="italic">John reads Ulysses</mtext><mo>,</mo><mi mathvariant="normal">…</mi></mrow><mo>}</mo></mrow></math>. However, the point is that
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS2.p2.m8" class="ltx_Math" alttext="F_{1}" display="inline"><msub><mi>F</mi><mn>1</mn></msub></math> itself is an algebraic formula that does not depend on any concrete databases.</p>
</div>
<div id="S2.SS2.p3" class="ltx_para">
<p class="ltx_p">Formally, we introduce the following <em class="ltx_emph">constants</em>:</p>
<ul id="I1" class="ltx_itemize">
<li id="I1.i1" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i1.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I1.i1.p1.m1" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>: a universal set containing all entities.</p>
</div></li>
<li id="I1.i2" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I1.i2.p1" class="ltx_para">
<p class="ltx_p">Content words: a content word (e.g. <span class="ltx_text ltx_font_italic">read</span>) defines a set
representing the word (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="I1.i2.p1.m1" class="ltx_Math" alttext="\textbf{read}\!=\!\{(x,y)\;|\;read(x,y)\}" display="inline"><mrow><mpadded width="-1.7pt"><mtext>𝐫𝐞𝐚𝐝</mtext></mpadded><mo rspace="0.8pt">=</mo><mrow><mo>{</mo><mrow><mrow><mo>(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>)</mo></mrow><mo separator="true">| </mo><mrow><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>)</mo></mrow></mrow></mrow><mo>}</mo></mrow></mrow></math>).</p>
</div></li>
</ul>
</div>
<div id="S2.SS2.p4" class="ltx_para">
<p class="ltx_p">In addition we introduce following <em class="ltx_emph">functions</em>:</p>
<ul id="I2" class="ltx_itemize">
<li id="I2.i1" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i1.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i1.p1.m1" class="ltx_Math" alttext="\times" display="inline"><mo>×</mo></math>: the Cartesian product of two sets.</p>
</div></li>
<li id="I2.i2" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i2.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i2.p1.m1" class="ltx_Math" alttext="\cap" display="inline"><mo>∩</mo></math>: the intersection of two sets.</p>
</div></li>
<li id="I2.i3" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i3.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i3.p1.m1" class="ltx_Math" alttext="\pi_{r}" display="inline"><msub><mi>π</mi><mi>r</mi></msub></math>: projection onto domain of semantic role <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i3.p1.m2" class="ltx_Math" alttext="r" display="inline"><mi>r</mi></math> (e.g.
<math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i3.p1.m3" class="ltx_Math" alttext="\pi_{\texttt{OBJ}}(\textbf{read})\!=\!\{y\;|\;\exists x;read(x,y)\}" display="inline"><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mpadded width="-1.7pt"><mrow><mo>(</mo><mtext>𝐫𝐞𝐚𝐝</mtext><mo>)</mo></mrow></mpadded></mrow><mo rspace="0.8pt">=</mo><mrow><mo>{</mo><mrow><mpadded width="+2.8pt"><mi>y</mi></mpadded><mo separator="true">| </mo><mrow><mrow><mo>∃</mo><mi>x</mi></mrow><mo>;</mo><mrow><mi>r</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>)</mo></mrow></mrow></mrow></mrow><mo>}</mo></mrow></mrow></math>). Generally
we admit projections onto multiple semantics roles, denoted by <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i3.p1.m4" class="ltx_Math" alttext="\pi_{R}" display="inline"><msub><mi>π</mi><mi>R</mi></msub></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i3.p1.m5" class="ltx_Math" alttext="R" display="inline"><mi>R</mi></math> is
a set of semantic roles.</p>
</div></li>
<li id="I2.i4" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i4.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i4.p1.m1" class="ltx_Math" alttext="\iota_{r}" display="inline"><msub><mi>ι</mi><mi>r</mi></msub></math>: relabeling (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i4.p1.m2" class="ltx_Math" alttext="\iota_{\texttt{OBJ}}(\textbf{book})=\textbf{book}_{\texttt{OBJ}}" display="inline"><mrow><mrow><msub><mi>ι</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐨𝐨𝐤</mtext><mo>)</mo></mrow></mrow><mo>=</mo><msub><mtext>𝐛𝐨𝐨𝐤</mtext><mtext>𝙾𝙱𝙹</mtext></msub></mrow></math>).</p>
</div></li>
<li id="I2.i5" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_itemize">•</span> 
<div id="I2.i5.p1" class="ltx_para">
<p class="ltx_p"><math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m1" class="ltx_Math" alttext="q_{\subset}^{r}" display="inline"><msubsup><mi>q</mi><mo>⊂</mo><mi>r</mi></msubsup></math>: the division operator, where <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m2" class="ltx_Math" alttext="q_{\subset}^{r}(A,B)" display="inline"><mrow><msubsup><mi>q</mi><mo>⊂</mo><mi>r</mi></msubsup><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>)</mo></mrow></mrow></math> is defined as the
largest set <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m3" class="ltx_Math" alttext="X" display="inline"><mi>X</mi></math> which satisfies <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m4" class="ltx_Math" alttext="B_{r}\times X\subset A" display="inline"><mrow><mrow><msub><mi>B</mi><mi>r</mi></msub><mo>×</mo><mi>X</mi></mrow><mo>⊂</mo><mi>A</mi></mrow></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup>If <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m5" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m6" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math> has
the same dimension, <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m7" class="ltx_Math" alttext="q_{\subset}(A,B)" display="inline"><mrow><msub><mi>q</mi><mo>⊂</mo></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>)</mo></mrow></mrow></math> is either <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m8" class="ltx_Math" alttext="\emptyset" display="inline"><mi mathvariant="normal">∅</mi></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m9" class="ltx_Math" alttext="\{*\}" display="inline"><mrow><mo>{</mo><mo>*</mo><mo>}</mo></mrow></math> (<math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m10" class="ltx_Math" alttext="0" display="inline"><mn>0</mn></math>-dimension point set),
depending on if <math xmlns="http://www.w3.org/1998/Math/MathML" id="I2.i5.p1.m11" class="ltx_Math" alttext="A\subset B" display="inline"><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi></mrow></math>.</span></span></span>
This is used to formulate universal quantifiers, such as
“<span class="ltx_text ltx_font_italic">Mary loves every dog</span>” and “<span class="ltx_text ltx_font_italic">books read by all students</span>”.</p>
</div></li>
</ul>
<p class="ltx_p">An <em class="ltx_emph">abstract denotation</em> is then defined as finite applications of functions on either constants
or other abstract denotations.</p>
</div>
</div>
<div id="S2.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">2.3 </span>Statements</h3>

<div id="S2.SS3.p1" class="ltx_para">
<p class="ltx_p">As the semantics of DCS trees is formulated by abstract denotations,
the meanings of declarative sentences are represented by <em class="ltx_emph">statements</em>
on abstract denotations. Statements are declarations of some relations
among abstract denotations, for which we consider the following set relations:</p>
</div>
<div id="S2.SS3.p2" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">Non-emptiness</span> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p2.m1" class="ltx_Math" alttext="A\neq\emptyset" display="inline"><mrow><mi>A</mi><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>: the set <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p2.m2" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> is not empty.</p>
</div>
<div id="S2.SS3.p3" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_italic">Subsumption</span> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m1" class="ltx_Math" alttext="A\subset B" display="inline"><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi></mrow></math>: set <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m2" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> is subsumed by <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m3" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">3</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">3</sup>Using
division operator, subsumption can be represented by non-emptiness, since for sets <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m4" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m5" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math>
of the same dimension, <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p3.m6" class="ltx_Math" alttext="q_{\subset}(A,B)\neq\emptyset\Leftrightarrow A\subset B" display="inline"><mrow><mrow><mrow><msub><mi>q</mi><mo>⊂</mo></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>)</mo></mrow></mrow><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow><mo>⇔</mo><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi></mrow></mrow></math>.</span></span></span></p>
</div>
<div id="S2.SS3.p4" class="ltx_para">
<p class="ltx_p">Roughly speaking, the relations correspond to
the logical concepts <em class="ltx_emph">satisfiability</em> and <em class="ltx_emph">entailment</em>.</p>
</div>
<div id="S2.T2" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_border_t"><span class="ltx_text ltx_font_script"></span></td>
<th class="ltx_td ltx_align_left ltx_border_t"><span class="ltx_text ltx_font_script">example phrase</span></th>
<th class="ltx_td ltx_align_left ltx_border_t"><span class="ltx_text ltx_font_script">abstract denotation / statement</span></th></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_t"><span class="ltx_text ltx_font_script">compound noun</span></td>
<td class="ltx_td ltx_align_left ltx_border_t"><em class="ltx_emph ltx_font_script">pet fish</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left ltx_border_t"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m1" class="ltx_Math" alttext="\textbf{pet}\cap\textbf{fish}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐩𝐞𝐭</mtext><mo>∩</mo><mtext mathsize="small" stretchy="false">𝐟𝐢𝐬𝐡</mtext></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">modification</span></td>
<td class="ltx_td ltx_align_left"><em class="ltx_emph ltx_font_script">nice day</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m2" class="ltx_Math" alttext="\textbf{day}\cap(W_{\texttt{ARG}}\times\textbf{nice}_{\texttt{MOD}})" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐚𝐲</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mi>W</mi><mtext>𝙰𝚁𝙶</mtext></msub><mo>×</mo><msub><mtext mathsize="small" stretchy="false">𝐧𝐢𝐜𝐞</mtext><mtext>𝙼𝙾𝙳</mtext></msub></mrow><mo>)</mo></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">temporal relation</span></td>
<td class="ltx_td ltx_align_left"><em class="ltx_emph ltx_font_script">boys study at night</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m3" class="ltx_Math" alttext="\textbf{study}\cap(\textbf{boy}_{\texttt{SUBJ}}\times\textbf{night}_{\texttt{%&#10;TIME}})" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐬𝐭𝐮𝐝𝐲</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext mathsize="small" stretchy="false">𝐛𝐨𝐲</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext mathsize="small" stretchy="false">𝐧𝐢𝐠𝐡𝐭</mtext><mtext>𝚃𝙸𝙼𝙴</mtext></msub></mrow><mo>)</mo></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">relative clause</span></td>
<td class="ltx_td ltx_align_left"><em class="ltx_emph ltx_font_script">books that</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m4" class="ltx_Math" alttext="\textbf{book}\cap\pi_{\texttt{OBJ}}(\textbf{read}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐛𝐨𝐨𝐤</mtext><mo>∩</mo><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mrow><mo>(</mo><mtext mathsize="small" stretchy="false">𝐫𝐞𝐚𝐝</mtext></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td"><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">  </span><em class="ltx_emph ltx_font_script">students read</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">  </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m5" class="ltx_Math" alttext="\cap(\textbf{student}_{\texttt{SUBJ}}\times W_{\texttt{OBJ}}))" display="inline"><mrow><mo>∩</mo><mrow><mo>(</mo><msub><mtext mathsize="small" stretchy="false">𝐬𝐭𝐮𝐝𝐞𝐧𝐭</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mi>W</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>)</mo></mrow><mo>)</mo></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">quantification</span></td>
<td class="ltx_td ltx_align_left"><em class="ltx_emph ltx_font_script">all men die</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m6" class="ltx_Math" alttext="\textbf{man}\subset\pi_{\texttt{SUBJ}}(\textbf{die})" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐦𝐚𝐧</mtext><mo>⊂</mo><mrow><msub><mi>π</mi><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mtext mathsize="small" stretchy="false">𝐝𝐢𝐞</mtext><mo>)</mo></mrow></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">hypernym</span></td>
<td class="ltx_td"><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m7" class="ltx_Math" alttext="\textbf{dog}\subset\textbf{animal}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo>⊂</mo><mtext mathsize="small" stretchy="false">𝐚𝐧𝐢𝐦𝐚𝐥</mtext></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">derivation</span></td>
<td class="ltx_td ltx_align_left"><em class="ltx_emph ltx_font_script">all criminals commit</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m8" class="ltx_Math" alttext="\textbf{criminal}\subset\pi_{\texttt{SUBJ}}(\textbf{commit}\cap" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐥</mtext><mo>⊂</mo><msub><mi>π</mi><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mrow><mo>(</mo><mtext mathsize="small" stretchy="false">𝐜𝐨𝐦𝐦𝐢𝐭</mtext><mo>∩</mo></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td"><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">      </span><em class="ltx_emph ltx_font_script">a crime</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">    </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m9" class="ltx_Math" alttext="(W_{\texttt{SUBJ}}\times\textbf{crime}_{\texttt{OBJ}}))" display="inline"><mrow><mrow><mo>(</mo><msub><mi>W</mi><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext mathsize="small" stretchy="false">𝐜𝐫𝐢𝐦𝐞</mtext><mtext>𝙾𝙱𝙹</mtext></msub><mo>)</mo></mrow><mo>)</mo></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">antonym</span></td>
<td class="ltx_td"><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m10" class="ltx_Math" alttext="\textbf{rise}\parallel\textbf{fall}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐫𝐢𝐬𝐞</mtext><mo>∥</mo><mtext mathsize="small" stretchy="false">𝐟𝐚𝐥𝐥</mtext></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_b"><span class="ltx_text ltx_font_script">negation</span></td>
<td class="ltx_td ltx_align_left ltx_border_b"><em class="ltx_emph ltx_font_script">no dogs are hurt</em><span class="ltx_text ltx_font_script"></span></td>
<td class="ltx_td ltx_align_left ltx_border_b"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T2.m11" class="ltx_Math" alttext="\textbf{dog}\parallel\pi_{\texttt{OBJ}}(\textbf{hurt})" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo>∥</mo><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mrow><mo>(</mo><mtext mathsize="small" stretchy="false">𝐡𝐮𝐫𝐭</mtext><mo>)</mo></mrow></mrow></math></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_script"><span class="ltx_tag ltx_tag_table">Table 2: </span>Abstract denotations and statements</div>
</div>
<div id="S2.SS3.p5" class="ltx_para">
<p class="ltx_p">Abstract denotations and statements are convenient for
representing semantics of various types of expressions and linguistic
knowledge. Some examples are shown in
Table <a href="#S2.T2" title="Table 2 ‣ 2.3 Statements ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">4</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">4</sup>Negation and disjointness (“<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS3.p5.m1" class="ltx_Math" alttext="\parallel" display="inline"><mo>∥</mo></math>”) are
explained in §<a href="#S2.SS5" title="2.5 Extensions ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.5</span></a>.</span></span></span></p>
</div>
</div>
<div id="S2.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">2.4 </span>Logical inference on DCS</h3>

<div id="S2.SS4.p1" class="ltx_para">
<p class="ltx_p">Based on abstract denotations, we briefly describe our process to apply DCS to
textual inference.</p>
</div>
<div id="S2.SS4.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">2.4.1 </span>Natural language to DCS trees</h4>

<div id="S2.SS4.SSS1.p1" class="ltx_para">
<p class="ltx_p">To obtain DCS trees from natural language, we use Stanford
CoreNLP<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">5</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">5</sup><a href="http://nlp.stanford.edu/software/corenlp.shtml" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://nlp.stanford.edu/software/corenlp.shtml</span></a></span></span></span>
for dependency parsing <cite class="ltx_cite">[]</cite>, and convert Stanford dependencies to DCS trees by pattern matching on POS tags and dependency
labels.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">6</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">6</sup>In
<cite class="ltx_cite">[]</cite> DCS trees are learned from QA
pairs and database entries. We obtain DCS trees from dependency trees, to bypass the
need of a concrete database.</span></span></span>
Currently we use the following
semantic roles: <span class="ltx_text ltx_font_typewriter">ARG</span>, <span class="ltx_text ltx_font_typewriter">SUBJ</span>, <span class="ltx_text ltx_font_typewriter">OBJ</span>,
<span class="ltx_text ltx_font_typewriter">IOBJ</span>, <span class="ltx_text ltx_font_typewriter">TIME</span> and <span class="ltx_text ltx_font_typewriter">MOD</span>. The semantic role <span class="ltx_text ltx_font_typewriter">MOD</span> is used for any
restrictive modifiers. Determiners such as “all”, “every” and “each”
trigger quantifiers, as shown in Figure <a href="#S2.F2" title="Figure 2 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>.</p>
</div>
<div id="S2.F3" class="ltx_figure"><span class="ltx_ERROR undefined ltx_centering">{prooftree}</span><span class="ltx_ERROR undefined ltx_centering">\AxiomC</span>
<p class="ltx_p ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m1" class="ltx_Math" alttext="\pi_{\texttt{OBJ}}(F_{4})=F_{3}\cap F_{7}" display="inline"><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>4</mn></msub><mo>)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>F</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>F</mi><mn>7</mn></msub></mrow></mrow></math><span class="ltx_text ltx_font_script">
<span class="ltx_ERROR undefined">\AxiomC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m2" class="ltx_Math" alttext="\pi_{\texttt{OBJ}}(F_{6})=\textbf{dog}\cap F_{7}" display="inline"><mrow><mrow><msub><mi mathsize="normal" stretchy="false">π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo mathsize="small" stretchy="false">⁢</mo><mrow><mo mathsize="small" stretchy="false">(</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">6</mn></msub><mo mathsize="small" stretchy="false">)</mo></mrow></mrow><mo mathsize="normal" stretchy="false">=</mo><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">∩</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">7</mn></msub></mrow></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span><span class="ltx_text ltx_font_bold">T</span>
<span class="ltx_ERROR undefined">\UnaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m3" class="ltx_Math" alttext="F_{6}\neq\emptyset" display="inline"><mrow><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">6</mn></msub><mo mathsize="normal" stretchy="false">≠</mo><mi mathsize="normal" mathvariant="normal" stretchy="false">∅</mi></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span>Axiom 4
<span class="ltx_ERROR undefined">\TrinaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m4" class="ltx_Math" alttext="\textbf{dog}\cap F_{7}\neq\emptyset" display="inline"><mrow><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">∩</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">7</mn></msub></mrow><mo mathsize="normal" stretchy="false">≠</mo><mi mathsize="normal" mathvariant="normal" stretchy="false">∅</mi></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span><span class="ltx_text ltx_font_bold">T</span>
<span class="ltx_ERROR undefined">\UnaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m5" class="ltx_Math" alttext="\textbf{dog}\subset\pi_{\texttt{OBJ}}(F_{2})" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">⊂</mo><mrow><msub><mi mathsize="normal" stretchy="false">π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo mathsize="small" stretchy="false">⁢</mo><mrow><mo mathsize="small" stretchy="false">(</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">2</mn></msub><mo mathsize="small" stretchy="false">)</mo></mrow></mrow></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m6" class="ltx_Math" alttext="\textbf{dog}\subset\textbf{animal}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">⊂</mo><mtext mathsize="small" stretchy="false">𝐚𝐧𝐢𝐦𝐚𝐥</mtext></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span>Axiom 8
<span class="ltx_ERROR undefined">\TrinaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m7" class="ltx_Math" alttext="\textbf{dog}\subset F_{3}" display="inline"><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">⊂</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">3</mn></msub></mrow></math>
<span class="ltx_ERROR undefined">\UnaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m8" class="ltx_Math" alttext="\textbf{dog}\cap F_{7}\subset F_{3}\cap F_{7}" display="inline"><mrow><mrow><mtext mathsize="small" stretchy="false">𝐝𝐨𝐠</mtext><mo mathsize="normal" stretchy="false">∩</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">7</mn></msub></mrow><mo mathsize="normal" stretchy="false">⊂</mo><mrow><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">3</mn></msub><mo mathsize="normal" stretchy="false">∩</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">7</mn></msub></mrow></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span>Axiom 6
<span class="ltx_ERROR undefined">\TrinaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m9" class="ltx_Math" alttext="F_{3}\cap F_{7}\neq\emptyset" display="inline"><mrow><mrow><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">3</mn></msub><mo mathsize="normal" stretchy="false">∩</mo><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">7</mn></msub></mrow><mo mathsize="normal" stretchy="false">≠</mo><mi mathsize="normal" mathvariant="normal" stretchy="false">∅</mi></mrow></math>
<span class="ltx_ERROR undefined">\AxiomC</span>Axiom 4
<span class="ltx_ERROR undefined">\TrinaryInfC</span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.F3.m10" class="ltx_Math" alttext="F_{4}\neq\emptyset" display="inline"><mrow><msub><mi mathsize="normal" stretchy="false">F</mi><mn mathsize="normal" stretchy="false">4</mn></msub><mo mathsize="normal" stretchy="false">≠</mo><mi mathsize="normal" mathvariant="normal" stretchy="false">∅</mi></mrow></math></span></p>
<div class="ltx_caption ltx_centering ltx_font_script"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>An example of proof using abstract denotations</div>
</div>
</div>
<div id="S2.SS4.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">2.4.2 </span>DCS trees to statements</h4>

<div id="S2.SS4.SSS2.p1" class="ltx_para">
<p class="ltx_p">A DCS tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m1" class="ltx_Math" alttext="\mathcal{T}=(\mathcal{N},\mathcal{E})" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>=</mo><mrow><mo>(</mo><mrow><mi class="ltx_font_mathcaligraphic">𝒩</mi><mo>,</mo><mi class="ltx_font_mathcaligraphic">ℰ</mi></mrow><mo>)</mo></mrow></mrow></math> is defined as a rooted tree,
where each node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m2" class="ltx_Math" alttext="\sigma\in\mathcal{N}" display="inline"><mrow><mi>σ</mi><mo>∈</mo><mi class="ltx_font_mathcaligraphic">𝒩</mi></mrow></math> is labeled with a content word
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m3" class="ltx_Math" alttext="w(\sigma)" display="inline"><mrow><mi>w</mi><mo>⁢</mo><mrow><mo>(</mo><mi>σ</mi><mo>)</mo></mrow></mrow></math> and each edge <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m4" class="ltx_Math" alttext="(\sigma,\sigma^{\prime})\in\mathcal{E}\subset\mathcal{N}\times\mathcal{N}" display="inline"><mrow><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msup><mi>σ</mi><mo>′</mo></msup></mrow><mo>)</mo></mrow><mo>∈</mo><mi class="ltx_font_mathcaligraphic">ℰ</mi><mo>⊂</mo><mrow><mi class="ltx_font_mathcaligraphic">𝒩</mi><mo>×</mo><mi class="ltx_font_mathcaligraphic">𝒩</mi></mrow></mrow></math>
is labeled with a pair of semantic roles <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m5" class="ltx_Math" alttext="(r,r^{\prime})" display="inline"><mrow><mo>(</mo><mrow><mi>r</mi><mo>,</mo><msup><mi>r</mi><mo>′</mo></msup></mrow><mo>)</mo></mrow></math><span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">7</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">7</sup>The
definition differs slightly from the original <cite class="ltx_cite"/>,
mainly for the sake of simplicity and clarity.</span></span></span>.
Here <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m6" class="ltx_Math" alttext="\sigma" display="inline"><mi>σ</mi></math> is the node nearer to the root. Furthermore, for each edge <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p1.m7" class="ltx_Math" alttext="(\sigma,\sigma^{\prime})" display="inline"><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msup><mi>σ</mi><mo>′</mo></msup></mrow><mo>)</mo></mrow></math> we
can optionally assign a quantification marker.</p>
</div>
<div id="S2.SS4.SSS2.p2" class="ltx_para">
<p class="ltx_p">Abstract denotation of a DCS tree can be calculated in a bottom-up manner.
For example, the abstract denotation of <span class="ltx_text ltx_font_bold">H</span> in Figure <a href="#S2.F2" title="Figure 2 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> is
calculated from the leaf node <span class="ltx_text ltx_markedasmath ltx_font_bold">Mary</span>, and then:</p>
</div>
<div id="S2.SS4.SSS2.p3" class="ltx_para">
<p class="ltx_p">Node <span class="ltx_text ltx_markedasmath ltx_font_bold">love</span> (<em class="ltx_emph">Mary loves</em>): 
<br class="ltx_break"/> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p3.m2" class="ltx_Math" alttext="F_{2}=\textbf{love}\cap(\textbf{Mary}_{\texttt{SUBJ}}\times W_{\texttt{OBJ}})" display="inline"><mrow><msub><mi>F</mi><mn>2</mn></msub><mo>=</mo><mrow><mtext>𝐥𝐨𝐯𝐞</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐌𝐚𝐫𝐲</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mi>W</mi><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow></mrow></math></p>
</div>
<div id="S2.SS4.SSS2.p4" class="ltx_para">
<p class="ltx_p">Node <span class="ltx_text ltx_markedasmath ltx_font_bold">animal</span> (<em class="ltx_emph">Animal that Mary loves</em>): 
<br class="ltx_break"/> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p4.m2" class="ltx_Math" alttext="F_{3}=\textbf{animal}\cap\pi_{\texttt{OBJ}}(F_{2})" display="inline"><mrow><msub><mi>F</mi><mn>3</mn></msub><mo>=</mo><mrow><mtext>𝐚𝐧𝐢𝐦𝐚𝐥</mtext><mo>∩</mo><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>)</mo></mrow></mrow></mrow></mrow></math></p>
</div>
<div id="S2.SS4.SSS2.p5" class="ltx_para">
<p class="ltx_p">Node <span class="ltx_text ltx_markedasmath ltx_font_bold">have</span> (<em class="ltx_emph">Tom has an animal that Mary loves</em>): 
<br class="ltx_break"/> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p5.m2" class="ltx_Math" alttext="F_{4}=\textbf{have}\cap(\textbf{Tom}_{\texttt{SUBJ}}\times(F_{3})_{\texttt{OBJ%&#10;}})" display="inline"><mrow><msub><mi>F</mi><mn>4</mn></msub><mo>=</mo><mrow><mtext>𝐡𝐚𝐯𝐞</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐓𝐨𝐦</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mrow><mo>(</mo><msub><mi>F</mi><mn>3</mn></msub><mo>)</mo></mrow><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow></mrow></math>.</p>
</div>
<div id="S2.SS4.SSS2.p6" class="ltx_para">
<p class="ltx_p">Formally, suppose the root <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m1" class="ltx_Math" alttext="\sigma" display="inline"><mi>σ</mi></math> of a DCS tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m2" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> has children
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m3" class="ltx_Math" alttext="\tau_{1},\ldots,\tau_{n}" display="inline"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>τ</mi><mi>n</mi></msub></mrow></math>, and edges <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m4" class="ltx_Math" alttext="(\sigma,\tau_{1}),\ldots,(\sigma,\tau_{n})" display="inline"><mrow><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msub><mi>τ</mi><mi>n</mi></msub></mrow><mo>)</mo></mrow></mrow></math>
labeled by <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m5" class="ltx_Math" alttext="(r_{1},r^{\prime}_{1}),\ldots,(r_{n},r^{\prime}_{n})" display="inline"><mrow><mrow><mo>(</mo><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>r</mi><mn>1</mn><mo>′</mo></msubsup></mrow><mo>)</mo></mrow><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><mrow><mo>(</mo><mrow><msub><mi>r</mi><mi>n</mi></msub><mo>,</mo><msubsup><mi>r</mi><mi>n</mi><mo>′</mo></msubsup></mrow><mo>)</mo></mrow></mrow></math>, respectively.
The abstract denotation of <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m6" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> is defined as:</p>
<table id="S2.Ex2" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.Ex2.m1" class="ltx_Math" alttext="[\![\mathcal{T}]\!]\!=\!w(\sigma)\cap(\bigcap_{i=1}^{n}\iota_{r_{i}}(\pi_{r^{%&#10;\prime}_{i}}([\![\mathcal{T}_{\tau_{i}}]\!]))\times W_{R_{\sigma}\setminus r_{%&#10;i}})," display="block"><mrow><mrow><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded><mo rspace="0.8pt">=</mo><mrow><mrow><mi>w</mi><mo>⁢</mo><mrow><mo>(</mo><mi>σ</mi><mo>)</mo></mrow></mrow><mo>∩</mo><mrow><mo>(</mo><mrow><munderover><mo largeop="true" mathsize="1.5em" movablelimits="false" stretchy="false" symmetric="true">⋂</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mrow><msub><mi>ι</mi><msub><mi>r</mi><mi>i</mi></msub></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><msub><mi>π</mi><msubsup><mi>r</mi><mi>i</mi><mo>′</mo></msubsup></msub><mo>⁢</mo><mpadded width="-1.7pt"><mrow><mo fence="true">([[</mo><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><msub><mi>τ</mi><mi>i</mi></msub></msub><mo fence="true">]])</mo></mrow></mpadded></mrow><mo>)</mo></mrow></mrow><mo>×</mo><msub><mi>W</mi><mrow><msub><mi>R</mi><mi>σ</mi></msub><mo>∖</mo><msub><mi>r</mi><mi>i</mi></msub></mrow></msub></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
<p class="ltx_p">where <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m7" class="ltx_Math" alttext="\mathcal{T}_{\tau_{i}}" display="inline"><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><msub><mi>τ</mi><mi>i</mi></msub></msub></math> is the subtree of <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m8" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> rooted at
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m9" class="ltx_Math" alttext="\tau_{i}" display="inline"><msub><mi>τ</mi><mi>i</mi></msub></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m10" class="ltx_Math" alttext="R_{\sigma}" display="inline"><msub><mi>R</mi><mi>σ</mi></msub></math> is the set of possible semantic roles for content word
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m11" class="ltx_Math" alttext="w(\sigma)" display="inline"><mrow><mi>w</mi><mo>⁢</mo><mrow><mo>(</mo><mi>σ</mi><mo>)</mo></mrow></mrow></math> (e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m12" class="ltx_Math" alttext="R_{\textbf{love}}=\{\texttt{SUBJ},\texttt{OBJ}\}" display="inline"><mrow><msub><mi>R</mi><mtext>𝐥𝐨𝐯𝐞</mtext></msub><mo>=</mo><mrow><mo>{</mo><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>,</mo><mtext>𝙾𝙱𝙹</mtext></mrow><mo>}</mo></mrow></mrow></math>),
and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m13" class="ltx_Math" alttext="W_{R_{\sigma}\setminus r_{i}}" display="inline"><msub><mi>W</mi><mrow><msub><mi>R</mi><mi>σ</mi></msub><mo>∖</mo><msub><mi>r</mi><mi>i</mi></msub></mrow></msub></math> is the product of <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m14" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>
which has dimension <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m15" class="ltx_Math" alttext="R_{\sigma}\setminus r_{i}" display="inline"><mrow><msub><mi>R</mi><mi>σ</mi></msub><mo>∖</mo><msub><mi>r</mi><mi>i</mi></msub></mrow></math> (e.g.
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p6.m16" class="ltx_Math" alttext="W_{\{\texttt{SUBJ},\texttt{OBJ}\}\setminus\texttt{SUBJ}}=W_{\texttt{OBJ}}" display="inline"><mrow><msub><mi>W</mi><mrow><mrow><mo>{</mo><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>,</mo><mtext>𝙾𝙱𝙹</mtext></mrow><mo>}</mo></mrow><mo>∖</mo><mtext>𝚂𝚄𝙱𝙹</mtext></mrow></msub><mo>=</mo><msub><mi>W</mi><mtext>𝙾𝙱𝙹</mtext></msub></mrow></math>).</p>
</div>
<div id="S2.SS4.SSS2.p7" class="ltx_para">
<p class="ltx_p">When universal quantifiers are involved, we need to add division operators
to the formula. If <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m1" class="ltx_Math" alttext="(\sigma,\tau_{i})" display="inline"><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msub><mi>τ</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></math> is assigned by a
quantification marker “<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m2" class="ltx_Math" alttext="\subset" display="inline"><mo>⊂</mo></math>”<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">8</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">8</sup>Multiple quantifiers
can be processed similarly.</span></span></span>, then the abstract denotation
is<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">9</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">9</sup>The result of <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m3" class="ltx_Math" alttext="[\![\mathcal{T}]\!]" display="inline"><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded></math>
depends on the order of the children <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m4" class="ltx_Math" alttext="\tau_{1},\ldots,\tau_{n}" display="inline"><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>τ</mi><mi>n</mi></msub></mrow></math>. Different orders
correspond to readings of different quantifier scopes.</span></span></span></p>
<table id="S2.Ex3" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.Ex3.m1" class="ltx_Math" alttext="[\![\mathcal{T}]\!]\!=\!q_{\subset}^{r_{i}}(\pi_{R_{\sigma}\setminus\{r_{1},%&#10;\ldots,r_{i-1}\}}([\![\mathcal{T}^{\prime}]\!]),\pi_{r_{i}^{\prime}}([\![%&#10;\mathcal{T}_{\tau_{i}}]\!]))," display="block"><mrow><mrow><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded><mo rspace="0.8pt">=</mo><mrow><msubsup><mi>q</mi><mo>⊂</mo><msub><mi>r</mi><mi>i</mi></msub></msubsup><mo>⁢</mo><mrow><mo>(</mo><mrow><mrow><msub><mi>π</mi><mrow><msub><mi>R</mi><mi>σ</mi></msub><mo>∖</mo><mrow><mo>{</mo><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo>,</mo><msub><mi>r</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow><mo>}</mo></mrow></mrow></msub><mo>⁢</mo><mpadded width="-1.7pt"><mrow><mo fence="true">([[</mo><msup><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>′</mo></msup><mo fence="true">]])</mo></mrow></mpadded></mrow><mo>,</mo><mrow><msub><mi>π</mi><msubsup><mi>r</mi><mi>i</mi><mo>′</mo></msubsup></msub><mo>⁢</mo><mpadded width="-1.7pt"><mrow><mo fence="true">([[</mo><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><msub><mi>τ</mi><mi>i</mi></msub></msub><mo fence="true">]])</mo></mrow></mpadded></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
<p class="ltx_p">where <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m5" class="ltx_Math" alttext="\mathcal{T}^{\prime}" display="inline"><msup><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>′</mo></msup></math> is the same tree as <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m6" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> except that
the edge <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m7" class="ltx_Math" alttext="(\sigma,\tau_{i})" display="inline"><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><msub><mi>τ</mi><mi>i</mi></msub></mrow><mo>)</mo></mrow></math> is removed. For example, the abstract
denotation of the first sentence of <span class="ltx_text ltx_font_bold">T</span> in Figure <a href="#S2.F2" title="Figure 2 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>
(<span class="ltx_text ltx_font_italic">Mary loves every dog</span>) is calculated from <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p7.m8" class="ltx_Math" alttext="F_{2}" display="inline"><msub><mi>F</mi><mn>2</mn></msub></math> (<em class="ltx_emph">Mary loves</em>) as</p>
<table id="S2.Ex4" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.Ex4.m1" class="ltx_Math" alttext="F_{5}=q_{\subset}^{\texttt{OBJ}}(\pi_{\texttt{OBJ}}(F_{2}),\textbf{dog})." display="block"><mrow><mrow><msub><mi>F</mi><mn>5</mn></msub><mo>=</mo><mrow><msubsup><mi>q</mi><mo>⊂</mo><mtext>𝙾𝙱𝙹</mtext></msubsup><mo>⁢</mo><mrow><mo>(</mo><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>)</mo></mrow></mrow><mo>,</mo><mtext>𝐝𝐨𝐠</mtext></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
</div>
<div id="S2.SS4.SSS2.p8" class="ltx_para">
<p class="ltx_p">After the abstract denotation <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p8.m1" class="ltx_Math" alttext="[\![\mathcal{T}]\!]" display="inline"><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded></math> is calculated,
the statement representing the meaning of the sentence is defined as
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p8.m2" class="ltx_Math" alttext="[\![\mathcal{T}]\!]\neq\emptyset" display="inline"><mrow><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>. For example, the statement of “<span class="ltx_text ltx_font_italic">students read books</span>”
is <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p8.m3" class="ltx_Math" alttext="\textbf{read}\cap(\textbf{student}_{\texttt{SUBJ}}\times\textbf{book}_{\texttt%&#10;{OBJ}})\neq\emptyset" display="inline"><mrow><mrow><mtext>𝐫𝐞𝐚𝐝</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐬𝐭𝐮𝐝𝐞𝐧𝐭</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext>𝐛𝐨𝐨𝐤</mtext><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>, and
the statement of “<span class="ltx_text ltx_font_italic">Mary loves every dog</span>”
is <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p8.m4" class="ltx_Math" alttext="q_{\subset}^{\texttt{OBJ}}(\pi_{\texttt{OBJ}}(F_{2}),\textbf{dog})\neq\emptyset" display="inline"><mrow><mrow><msubsup><mi>q</mi><mo>⊂</mo><mtext>𝙾𝙱𝙹</mtext></msubsup><mo>⁢</mo><mrow><mo>(</mo><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>)</mo></mrow></mrow><mo>,</mo><mtext>𝐝𝐨𝐠</mtext></mrow><mo>)</mo></mrow></mrow><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>,
which is logically equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS2.p8.m5" class="ltx_Math" alttext="\textbf{dog}\subset\pi_{\texttt{OBJ}}(F_{2})" display="inline"><mrow><mtext>𝐝𝐨𝐠</mtext><mo>⊂</mo><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>)</mo></mrow></mrow></mrow></math>.<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">10</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">10</sup>See
Footnote 2,3.</span></span></span></p>
</div>
</div>
<div id="S2.SS4.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">2.4.3 </span>Logical inference</h4>

<div id="S2.T3" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_t"><span class="ltx_text ltx_font_script">1. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m1" class="ltx_Math" alttext="W\neq\emptyset" display="inline"><mrow><mi>W</mi><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">2. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m2" class="ltx_Math" alttext="A\cap B\subset A" display="inline"><mrow><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><mo>⊂</mo><mi>A</mi></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">3. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m3" class="ltx_Math" alttext="B_{r}\times q^{r}_{\subset}(A,B)\subset A" display="inline"><mrow><mrow><mrow><msub><mi>B</mi><mi>r</mi></msub><mo>×</mo><msubsup><mi>q</mi><mo>⊂</mo><mi>r</mi></msubsup></mrow><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><mo>)</mo></mrow></mrow><mo>⊂</mo><mi>A</mi></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_b"><span class="ltx_text ltx_font_script">4. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m4" class="ltx_Math" alttext="\pi_{R}(A)\neq\emptyset\Leftrightarrow A\neq\emptyset" display="inline"><mrow><mrow><mrow><msub><mi>π</mi><mi>R</mi></msub><mo>⁢</mo><mrow><mo>(</mo><mi>A</mi><mo>)</mo></mrow></mrow><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow><mo>⇔</mo><mrow><mi>A</mi><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></mrow></math></td></tr>
</tbody>
</table>
<table class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_t"><span class="ltx_text ltx_font_script">5. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m5" class="ltx_Math" alttext="(A\subset B\;\&amp;\;B\subset C)\Rightarrow A\subset C" display="inline"><mrow><mrow><mo>(</mo><mi>A</mi><mo>⊂</mo><mpadded width="+2.8pt"><mi>B</mi></mpadded><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mi>B</mi><mo>⊂</mo><mi>C</mi><mo>)</mo></mrow><mo>⇒</mo><mi>A</mi><mo>⊂</mo><mi>C</mi></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">6. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m6" class="ltx_Math" alttext="(A\subset B\;\&amp;\;A\neq\emptyset)\Rightarrow B\neq\emptyset" display="inline"><mrow><mrow><mo>(</mo><mi>A</mi><mo>⊂</mo><mpadded width="+2.8pt"><mi>B</mi></mpadded><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mi>A</mi><mo>≠</mo><mi mathvariant="normal">∅</mi><mo>)</mo></mrow><mo>⇒</mo><mi>B</mi><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left"><span class="ltx_text ltx_font_script">7. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m7" class="ltx_Math" alttext="A\subset B\Rightarrow\pi_{R}(A)\subset\pi_{R}(B)" display="inline"><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi><mo>⇒</mo><mrow><msub><mi>π</mi><mi>R</mi></msub><mo>⁢</mo><mrow><mo>(</mo><mi>A</mi><mo>)</mo></mrow></mrow><mo>⊂</mo><mrow><msub><mi>π</mi><mi>R</mi></msub><mo>⁢</mo><mrow><mo>(</mo><mi>B</mi><mo>)</mo></mrow></mrow></mrow></math></td></tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_left ltx_border_b"><span class="ltx_text ltx_font_script">8. </span><math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.T3.m8" class="ltx_Math" alttext="(C\subset A\;\&amp;\;C\subset B)\Rightarrow C\subset A\cap B" display="inline"><mrow><mrow><mo>(</mo><mi>C</mi><mo>⊂</mo><mpadded width="+2.8pt"><mi>A</mi></mpadded><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mi>C</mi><mo>⊂</mo><mi>B</mi><mo>)</mo></mrow><mo>⇒</mo><mi>C</mi><mo>⊂</mo><mi>A</mi><mo>∩</mo><mi>B</mi></mrow></math></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_script"><span class="ltx_tag ltx_tag_table">Table 3: </span>An excerpt of axioms</div>
</div>
<div id="S2.SS4.SSS3.p1" class="ltx_para">
<p class="ltx_p">Since meanings of sentences are represented by
statements on abstract denotations, logical inference
among sentences is reduced to deriving new relations among
abstract denotations. This is done by applying axioms to known statements, and approximately
30 axioms are implemented (Table <a href="#S2.T3" title="Table 3 ‣ 2.4.3 Logical inference ‣ 2.4 Logical inference on DCS ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>).
These are algebraic properties of abstract denotations,
among which we choose a set of axioms that can be handled efficiently and enable
most common types of inference seen in natural language.</p>
</div>
<div id="S2.SS4.SSS3.p2" class="ltx_para">
<p class="ltx_p">For the example in Figure <a href="#S2.F2" title="Figure 2 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a>, by constructing the following abstract denotations:</p>
</div>
<div id="S2.SS4.SSS3.p3" class="ltx_para">
<p class="ltx_p"><em class="ltx_emph">Tom has a dog</em>: 
<br class="ltx_break"/> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p3.m1" class="ltx_Math" alttext="F_{6}=\textbf{have}\cap(\textbf{Tom}_{\texttt{SUBJ}}\times\textbf{dog}_{%&#10;\texttt{OBJ}})" display="inline"><mrow><msub><mi>F</mi><mn>6</mn></msub><mo>=</mo><mrow><mtext>𝐡𝐚𝐯𝐞</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐓𝐨𝐦</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext>𝐝𝐨𝐠</mtext><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow></mrow></math></p>
</div>
<div id="S2.SS4.SSS3.p4" class="ltx_para">
<p class="ltx_p">Objects <em class="ltx_emph">that Tom has</em>: 
<br class="ltx_break"/> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p4.m1" class="ltx_Math" alttext="F_{7}=\pi_{\texttt{OBJ}}(\textbf{have}\cap(\textbf{Tom}_{\texttt{SUBJ}}\times W%&#10;_{\texttt{OBJ}}))" display="inline"><mrow><msub><mi>F</mi><mn>7</mn></msub><mo>=</mo><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mtext>𝐡𝐚𝐯𝐞</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐓𝐨𝐦</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mi>W</mi><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow></math>,</p>
</div>
<div id="S2.SS4.SSS3.p5" class="ltx_para">
<p class="ltx_p">we can use the lexical knowledge
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m1" class="ltx_Math" alttext="\textbf{dog}\subset\textbf{animal}" display="inline"><mrow><mtext>𝐝𝐨𝐠</mtext><mo>⊂</mo><mtext>𝐚𝐧𝐢𝐦𝐚𝐥</mtext></mrow></math>, the statements of <span class="ltx_text ltx_font_bold">T</span>
(i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m2" class="ltx_Math" alttext="\textbf{dog}\subset\pi_{\texttt{OBJ}}(F_{2})" display="inline"><mrow><mtext>𝐝𝐨𝐠</mtext><mo>⊂</mo><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>2</mn></msub><mo>)</mo></mrow></mrow></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m3" class="ltx_Math" alttext="F_{6}\neq\emptyset" display="inline"><mrow><msub><mi>F</mi><mn>6</mn></msub><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>), and the axioms in
Table <a href="#S2.T3" title="Table 3 ‣ 2.4.3 Logical inference ‣ 2.4 Logical inference on DCS ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>,<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">11</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">11</sup>Algebraic identities, such as <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m4" class="ltx_Math" alttext="\pi_{\texttt{OBJ}}(F_{4})=F_{3}\cap F_{7}" display="inline"><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>4</mn></msub><mo>)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>F</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>F</mi><mn>7</mn></msub></mrow></mrow></math>
and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m5" class="ltx_Math" alttext="\pi_{\texttt{OBJ}}(F_{6})=\textbf{dog}\cap F_{7}" display="inline"><mrow><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mi>F</mi><mn>6</mn></msub><mo>)</mo></mrow></mrow><mo>=</mo><mrow><mtext>𝐝𝐨𝐠</mtext><mo>∩</mo><msub><mi>F</mi><mn>7</mn></msub></mrow></mrow></math>, are also axioms.</span></span></span>
to prove the statement of <span class="ltx_text ltx_font_bold">H</span> (i.e. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS4.SSS3.p5.m6" class="ltx_Math" alttext="F_{4}\neq\emptyset" display="inline"><mrow><msub><mi>F</mi><mn>4</mn></msub><mo>≠</mo><mi mathvariant="normal">∅</mi></mrow></math>) (Figure <a href="#S2.F3" title="Figure 3 ‣ 2.4.1 Natural language to DCS trees ‣ 2.4 Logical inference on DCS ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>).</p>
</div>
<div id="S2.SS4.SSS3.p6" class="ltx_para">
<p class="ltx_p">We built an inference engine to perform logical inference on abstract denotations
as above. In this logical system, we treat abstract denotations as <em class="ltx_emph">terms</em> and
statements as <em class="ltx_emph">atomic sentences</em>, which are far more easier to handle than
first order predicate logic (FOL) formulas. Furthermore, all implemented axioms are
horn clauses, hence we can employ forward-chaining, which is very efficient.</p>
</div>
</div>
</div>
<div id="S2.SS5" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">2.5 </span>Extensions</h3>

<div id="S2.SS5.p1" class="ltx_para">
<p class="ltx_p">Further extensions of our framework are made to deal with additional linguistic
phenomena, as briefly explained below.</p>
</div>
<div id="S2.SS5.SSS3.P1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Negation</h5>

<div id="S2.SS5.SSS3.P1.p1" class="ltx_para">
<p class="ltx_p">To deal with negation in our forward-chaining inference engine, we introduce
one more relation on abstract denotations, namely <em class="ltx_emph">disjointness</em>
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m1" class="ltx_Math" alttext="A\parallel B" display="inline"><mrow><mi>A</mi><mo>∥</mo><mi>B</mi></mrow></math>, meaning that <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m2" class="ltx_Math" alttext="A" display="inline"><mi>A</mi></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m3" class="ltx_Math" alttext="B" display="inline"><mi>B</mi></math> are disjoint sets. Using disjointness
we implemented two types of negations: (i) atomic negation, for each content word <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m4" class="ltx_Math" alttext="w" display="inline"><mi>w</mi></math>
we allow negation <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m5" class="ltx_Math" alttext="\bar{w}" display="inline"><mover accent="true"><mi>w</mi><mo stretchy="false">¯</mo></mover></math> of that word,
characterized by the property <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m6" class="ltx_Math" alttext="w\parallel\bar{w}" display="inline"><mrow><mi>w</mi><mo>∥</mo><mover accent="true"><mi>w</mi><mo stretchy="false">¯</mo></mover></mrow></math>; and (ii)
root negation, for a DCS tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m7" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> and its denotation <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m8" class="ltx_Math" alttext="[\![\mathcal{T}]\!]" display="inline"><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded></math>,
the negation of <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m9" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> is represented by <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m10" class="ltx_Math" alttext="\mathcal{T}\parallel\mathcal{T}" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>∥</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi></mrow></math>,
meaning that <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P1.p1.m11" class="ltx_Math" alttext="\mathcal{T}=\emptyset" display="inline"><mrow><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow></math> in its effect.</p>
</div>
</div>
<div id="S2.SS5.SSS3.P2" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Selection</h5>

<div id="S2.SS5.SSS3.P2.p1" class="ltx_para">
<p class="ltx_p">Selection operators in relational algebra select a subset from a set to satisfy some specific
properties. This can be employed to represent linguistic phenomena such as
downward monotonicity and
generalized quantifiers. In the current system, we implement (i)
superlatives,
e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P2.p1.m1" class="ltx_Math" alttext="s_{highest}(\textbf{mountain}\cap(W_{\texttt{ARG}}\times\textbf{Asia}_{\texttt%&#10;{MOD}}))" display="inline"><mrow><msub><mi>s</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mtext>𝐦𝐨𝐮𝐧𝐭𝐚𝐢𝐧</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mi>W</mi><mtext>𝙰𝚁𝙶</mtext></msub><mo>×</mo><msub><mtext>𝐀𝐬𝐢𝐚</mtext><mtext>𝙼𝙾𝙳</mtext></msub></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></math>
(the highest mountain in Asia) and (ii) numerics, e.g. <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P2.p1.m2" class="ltx_Math" alttext="s_{two}(\textbf{pet}\cap\textbf{fish})" display="inline"><mrow><msub><mi>s</mi><mrow><mi>t</mi><mo>⁢</mo><mi>w</mi><mo>⁢</mo><mi>o</mi></mrow></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mtext>𝐩𝐞𝐭</mtext><mo>∩</mo><mtext>𝐟𝐢𝐬𝐡</mtext></mrow><mo>)</mo></mrow></mrow></math>
(two pet fish), where <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P2.p1.m3" class="ltx_Math" alttext="s_{f}" display="inline"><msub><mi>s</mi><mi>f</mi></msub></math> is a selection marker.
Selection operators are implemented as markers assigned to abstract denotations,
with specially designed axioms. For example
superlatives satisfy the following property:
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P2.p1.m4" class="ltx_Math" alttext="A\subset B\;\&amp;\;s_{highest}(B)\subset A\Rightarrow s_{highest}(B)=s_{highest}(A)" display="inline"><mrow><mi>A</mi><mo>⊂</mo><mrow><mpadded width="+2.8pt"><mi>B</mi></mpadded><mo>⁢</mo><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mo>⁢</mo><msub><mi>s</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>⁢</mo><mrow><mo>(</mo><mi>B</mi><mo>)</mo></mrow></mrow><mo>⊂</mo><mi>A</mi><mo>⇒</mo><mrow><msub><mi>s</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>⁢</mo><mrow><mo>(</mo><mi>B</mi><mo>)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>s</mi><mrow><mi>h</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>t</mi></mrow></msub><mo>⁢</mo><mrow><mo>(</mo><mi>A</mi><mo>)</mo></mrow></mrow></mrow></math>.
New rules can be added if necessary.</p>
</div>
</div>
<div id="S2.SS5.SSS3.P3" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Coreference</h5>

<div id="S2.SS5.SSS3.P3.p1" class="ltx_para">
<p class="ltx_p">We use Stanford CoreNLP to resolve coreferences <cite class="ltx_cite">[]</cite>,
whereas coreference is implemented as a special type of selection.
If a node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P3.p1.m1" class="ltx_Math" alttext="\sigma" display="inline"><mi>σ</mi></math> in a DCS tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P3.p1.m2" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math> belongs to a mention cluster <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P3.p1.m3" class="ltx_Math" alttext="m" display="inline"><mi>m</mi></math>,
we take the abstract denotation <math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P3.p1.m4" class="ltx_Math" alttext="[\![\mathcal{T}_{\sigma}]\!]" display="inline"><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><mi>σ</mi></msub><mo fence="true">]]</mo></mrow></mpadded></math> and make a selection
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S2.SS5.SSS3.P3.p1.m5" class="ltx_Math" alttext="s_{m}([\![\mathcal{T}_{\sigma}]\!])" display="inline"><mrow><msub><mi>s</mi><mi>m</mi></msub><mo>⁢</mo><mpadded width="-1.7pt"><mrow><mo fence="true">([[</mo><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><mi>σ</mi></msub><mo fence="true">]])</mo></mrow></mpadded></mrow></math>, which is regarded as the abstract denotation
of that mention. Then all selections of the same mention cluster are declared to be equal.</p>
</div>
</div>
</div>
</div>
<div id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section"><span class="ltx_tag ltx_tag_section">3 </span>Generating On-the-fly Knowledge</h2>

<div id="S3.p1" class="ltx_para">
<p class="ltx_p">Recognizing textual entailment (RTE) is the task of determining whether a given textual
statement <span class="ltx_text ltx_font_bold">H</span> can be inferred by a text passage <span class="ltx_text ltx_font_bold">T</span>. For this,
our primary textual inference system operates as:</p>
</div>
<div id="S3.p2" class="ltx_para">
<ol id="I3" class="ltx_enumerate">
<li id="I3.i1" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">1.</span> 
<div id="I3.i1.p1" class="ltx_para">
<p class="ltx_p">For a <span class="ltx_text ltx_font_bold">T</span>-<span class="ltx_text ltx_font_bold">H</span> pair, apply dependency parsing and coreference resolution.</p>
</div></li>
<li id="I3.i2" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">2.</span> 
<div id="I3.i2.p1" class="ltx_para">
<p class="ltx_p">Perform rule-based conversion from dependency parses to DCS trees, which are
translated to statements on abstract denotations.</p>
</div></li>
<li id="I3.i3" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">3.</span> 
<div id="I3.i3.p1" class="ltx_para">
<p class="ltx_p">Use statements of <span class="ltx_text ltx_font_bold">T</span> and linguistic knowledge as premises, and try to prove
statements of <span class="ltx_text ltx_font_bold">H</span> by our inference engine.</p>
</div></li>
</ol>
</div>
<div id="S3.p3" class="ltx_para">
<p class="ltx_p">However, this method does not work for real-world datasets
such as PASCAL RTE <cite class="ltx_cite">[]</cite>, because of the knowledge bottleneck: it is often
the case that the lack of sufficient linguistic knowledge causes
failure of inference, thus the system outputs “no entailment”
for almost all pairs <cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S3.F4" class="ltx_figure"><img src="" id="S3.F4.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>RTE system</div>
</div>
<div id="S3.p4" class="ltx_para">
<p class="ltx_p">The transparent syntax-to-semantics interface of DCS enables us to
back off to NLP techniques during inference for catching
up the lack of knowledge. We extract fragments of DCS
trees as paraphrase candidates, translate them back
to linguistic expressions, and apply distributional similarity to judge their
validity. In this way, our
framework combines distributional and logical semantics, which is
also the main subject of <cite class="ltx_cite"/> and <cite class="ltx_cite"/>.</p>
</div>
<div id="S3.p5" class="ltx_para">
<p class="ltx_p">As follows, our full system (Figure <a href="#S3.F4" title="Figure 4 ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>) additionally invokes
linguistic knowledge on-the-fly:</p>
<ol id="I4" class="ltx_enumerate">
<li id="I4.i4" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">4.</span> 
<div id="I4.i4.p1" class="ltx_para">
<p class="ltx_p">If <span class="ltx_text ltx_font_bold">H</span> is not proven, compare DCS trees of <span class="ltx_text ltx_font_bold">T</span> and
<span class="ltx_text ltx_font_bold">H</span>, and generate path alignments.</p>
</div></li>
<li id="I4.i5" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">5.</span> 
<div id="I4.i5.p1" class="ltx_para">
<p class="ltx_p">Aligned paths are evaluated by a similarity score to estimate
their likelihood of being paraphrases. Path alignments with scores
higher than a threshold are accepted.</p>
</div></li>
<li id="I4.i6" class="ltx_item" style="list-style-type:none;"><span class="ltx_tag ltx_tag_enumerate">6.</span> 
<div id="I4.i6.p1" class="ltx_para">
<p class="ltx_p">Convert accepted path alignments into statements on
abstract denotations, use them in logical inference as new
knowledge, and try to prove <span class="ltx_text ltx_font_bold">H</span> again.</p>
</div></li>
</ol>
</div>
<div id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">3.1 </span>Generating path alignments</h3>

<div id="S3.SS1.p1" class="ltx_para">
<p class="ltx_p">On-the-fly knowledge is generated by aligning paths in DCS trees.
A path is considered as joining two <em class="ltx_emph">germs</em> in a DCS tree, where a <em class="ltx_emph">germ</em> is defined
as a specific semantic role of a node. For example, Figure <a href="#S3.F5" title="Figure 5 ‣ 3.2 Aligning germs by logical clues ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> shows DCS
trees of the following sentences (a simplified pair from RTE2-dev):</p>
</div>
<div id="S3.SS1.p2" class="ltx_para">
<p class="ltx_p"><span class="ltx_text ltx_font_bold">T:</span> <span class="ltx_text ltx_font_italic">Tropical storm Debby is blamed for deaths.
<br class="ltx_break"/></span><span class="ltx_text ltx_font_bold">H:</span> <span class="ltx_text ltx_font_italic">A storm has caused loss of life.</span></p>
</div>
<div id="S3.SS1.p3" class="ltx_para">
<p class="ltx_p">The germ <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS1.p3.m1" class="ltx_Math" alttext="\texttt{OBJ}(\textbf{blame})" display="inline"><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow></math> and
germ <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS1.p3.m2" class="ltx_Math" alttext="\texttt{ARG}(\textbf{death})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐝𝐞𝐚𝐭𝐡</mtext><mo>)</mo></mrow></mrow></math> in DCS tree of <span class="ltx_text ltx_font_bold">T</span> are joined by the
underscored path. Two paths are aligned if the joined germs are aligned,
and we impose constraints on aligned germs to inhibit meaningless alignments,
as described below.</p>
</div>
</div>
<div id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">3.2 </span>Aligning germs by logical clues</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p class="ltx_p">Two germs are aligned if they are both at leaf nodes (e.g.
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p1.m1" class="ltx_Math" alttext="\texttt{ARG}(\textbf{death})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐝𝐞𝐚𝐭𝐡</mtext><mo>)</mo></mrow></mrow></math> in <span class="ltx_text ltx_font_bold">T</span> and <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p1.m2" class="ltx_Math" alttext="\texttt{ARG}(\textbf{life})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐥𝐢𝐟𝐞</mtext><mo>)</mo></mrow></mrow></math> in <span class="ltx_text ltx_font_bold">H</span>,
Figure <a href="#S3.F5" title="Figure 5 ‣ 3.2 Aligning germs by logical clues ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>),
or they already have part of their meanings in common, by some logical clues.</p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<p class="ltx_p">To formulate this properly, we define the abstract denotation of a germ, which,
intuitively, represents the meaning of the germ in the specific sentence.
The abstract denotation of a germ is defined in a top-down manner:
for the root node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m1" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math> of a DCS tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m2" class="ltx_Math" alttext="\mathcal{T}" display="inline"><mi class="ltx_font_mathcaligraphic">𝒯</mi></math>,
we define its denotation <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m3" class="ltx_Math" alttext="[\![\rho]\!]_{\mathcal{T}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi>ρ</mi><mo fence="true">]]</mo></mrow></mpadded><mi class="ltx_font_mathcaligraphic">𝒯</mi></msub></math> as the denotation
of the entire tree <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m4" class="ltx_Math" alttext="[\![\mathcal{T}]\!]" display="inline"><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi class="ltx_font_mathcaligraphic">𝒯</mi><mo fence="true">]]</mo></mrow></mpadded></math>; for a non-root node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m5" class="ltx_Math" alttext="\tau" display="inline"><mi>τ</mi></math> and its
parent node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m6" class="ltx_Math" alttext="\sigma" display="inline"><mi>σ</mi></math>, let the edge <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m7" class="ltx_Math" alttext="(\sigma,\tau)" display="inline"><mrow><mo>(</mo><mrow><mi>σ</mi><mo>,</mo><mi>τ</mi></mrow><mo>)</mo></mrow></math> be labeled by semantic roles
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m8" class="ltx_Math" alttext="(r,r^{\prime})" display="inline"><mrow><mo>(</mo><mrow><mi>r</mi><mo>,</mo><msup><mi>r</mi><mo>′</mo></msup></mrow><mo>)</mo></mrow></math>, then define</p>
<table id="S3.Ex5" class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.Ex5.m1" class="ltx_Math" alttext="[\![\tau]\!]_{\mathcal{T}}=[\![\mathcal{T}_{\tau}]\!]\cap(\iota_{r^{\prime}}(%&#10;\pi_{r}([\![\sigma]\!]_{\mathcal{T}}))\times W_{R_{\tau}\setminus r^{\prime}})." display="block"><mrow><mrow><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi>τ</mi><mo fence="true">]]</mo></mrow></mpadded><mi class="ltx_font_mathcaligraphic">𝒯</mi></msub><mo>=</mo><mrow><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><msub><mi class="ltx_font_mathcaligraphic">𝒯</mi><mi>τ</mi></msub><mo fence="true">]]</mo></mrow></mpadded><mo>∩</mo><mrow><mo>(</mo><mrow><mrow><msub><mi>ι</mi><msup><mi>r</mi><mo>′</mo></msup></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><msub><mi>π</mi><mi>r</mi></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi>σ</mi><mo fence="true">]]</mo></mrow></mpadded><mi class="ltx_font_mathcaligraphic">𝒯</mi></msub><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow><mo>×</mo><msub><mi>W</mi><mrow><msub><mi>R</mi><mi>τ</mi></msub><mo>∖</mo><msup><mi>r</mi><mo>′</mo></msup></mrow></msub></mrow><mo>)</mo></mrow></mrow></mrow><mo>.</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
<p class="ltx_p">Now for a germ <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m9" class="ltx_Math" alttext="r(\sigma)" display="inline"><mrow><mi>r</mi><mo>⁢</mo><mrow><mo>(</mo><mi>σ</mi><mo>)</mo></mrow></mrow></math>, the denotation is defined as the projection of the denotation of
node <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m10" class="ltx_Math" alttext="\sigma" display="inline"><mi>σ</mi></math> onto the specific semantic role <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m11" class="ltx_Math" alttext="r" display="inline"><mi>r</mi></math>:
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p2.m12" class="ltx_Math" alttext="[\![r(\sigma)]\!]_{\mathcal{T}}=\pi_{r}([\![\sigma]\!]_{\mathcal{T}})" display="inline"><mrow><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mi>r</mi><mo>⁢</mo><mrow><mo>(</mo><mi>σ</mi><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mi class="ltx_font_mathcaligraphic">𝒯</mi></msub><mo>=</mo><mrow><msub><mi>π</mi><mi>r</mi></msub><mo>⁢</mo><mrow><mo>(</mo><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mi>σ</mi><mo fence="true">]]</mo></mrow></mpadded><mi class="ltx_font_mathcaligraphic">𝒯</mi></msub><mo>)</mo></mrow></mrow></mrow></math>.</p>
</div>
<div id="S3.SS2.p3" class="ltx_para">
<p class="ltx_p">For example, the abstract denotation of germ <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p3.m1" class="ltx_Math" alttext="\texttt{ARG}(\textbf{book})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐨𝐨𝐤</mtext><mo>)</mo></mrow></mrow></math> in
Figure <a href="#S2.F1" title="Figure 1 ‣ 2.1 DCS trees ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a> is defined as <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p3.m2" class="ltx_Math" alttext="\pi_{\texttt{ARG}}(\textbf{book}\cap\pi_{\texttt{OBJ}}(\textbf{read}\cap(%&#10;\textbf{student}_{\texttt{SUBJ}}\times\textbf{book}_{\texttt{OBJ}})))" display="inline"><mrow><msub><mi>π</mi><mtext>𝙰𝚁𝙶</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mtext>𝐛𝐨𝐨𝐤</mtext><mo>∩</mo><mrow><msub><mi>π</mi><mtext>𝙾𝙱𝙹</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mrow><mtext>𝐫𝐞𝐚𝐝</mtext><mo>∩</mo><mrow><mo>(</mo><mrow><msub><mtext>𝐬𝐭𝐮𝐝𝐞𝐧𝐭</mtext><mtext>𝚂𝚄𝙱𝙹</mtext></msub><mo>×</mo><msub><mtext>𝐛𝐨𝐨𝐤</mtext><mtext>𝙾𝙱𝙹</mtext></msub></mrow><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow></math>,
meaning “<em class="ltx_emph">books read by students</em>”.
Similarly, denotation of germ <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p3.m3" class="ltx_Math" alttext="\texttt{OBJ}(\textbf{blame})" display="inline"><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow></math> in <span class="ltx_text ltx_font_bold">T</span> of
Figure <a href="#S3.F5" title="Figure 5 ‣ 3.2 Aligning germs by logical clues ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a> indicates the object of “<span class="ltx_text ltx_font_italic">blame</span>” as in the sentence
“<span class="ltx_text ltx_font_italic">Tropical storm Debby is blamed for death</span>”, which is a <span class="ltx_text ltx_font_italic">tropical storm</span>,
is <span class="ltx_text ltx_font_italic">Debby</span>, etc.
Technically, each germ in a DCS tree indicates a variable when the DCS tree is translated to
a FOL formula, and the abstract denotation of the germ corresponds to the set of
<em class="ltx_emph">consistent values</em> <cite class="ltx_cite">[]</cite> of that variable.</p>
</div>
<div id="S3.F5" class="ltx_figure"><img src="" id="S3.F5.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Aligned paths (underscored by the solid lines) and aligned germs
(joined by the dotted line)</div>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p class="ltx_p">The logical clue to align germs is: if there exists an abstract denotation, other than
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m1" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>, that is a superset of both abstract denotations of two germs, then the two germs
can be aligned. A simple example is that
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m2" class="ltx_Math" alttext="\texttt{ARG}(\textbf{storm})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow></math> in <span class="ltx_text ltx_font_bold">T</span> can be aligned to
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m3" class="ltx_Math" alttext="\texttt{ARG}(\textbf{storm})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow></math> in <span class="ltx_text ltx_font_bold">H</span>, because their denotations have a common
superset other than <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m4" class="ltx_Math" alttext="W" display="inline"><mi>W</mi></math>, namely <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m5" class="ltx_Math" alttext="\pi_{\texttt{ARG}}(\textbf{storm})" display="inline"><mrow><msub><mi>π</mi><mtext>𝙰𝚁𝙶</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow></math>.
A more complicated example
is that <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m6" class="ltx_Math" alttext="\texttt{OBJ}(\textbf{blame})" display="inline"><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow></math> and
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m7" class="ltx_Math" alttext="\texttt{SUBJ}(\textbf{cause})" display="inline"><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐜𝐚𝐮𝐬𝐞</mtext><mo>)</mo></mrow></mrow></math> can be aligned, because inference can
induce
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m8" class="ltx_Math" alttext="[\![\mbox{{OBJ}}(\mbox{{blame}})]\!]_{\mbox{{T}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐓</mtext></msub></math> =
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m9" class="ltx_Math" alttext="[\![\mbox{{ARG}}(\mbox{{Debby}})]\!]_{\mbox{{T}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐃𝐞𝐛𝐛𝐲</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐓</mtext></msub></math> =
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m10" class="ltx_Math" alttext="[\![\mbox{{ARG}}(\mbox{{storm}})]\!]_{\mbox{{T}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐓</mtext></msub></math>,
as well as
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m11" class="ltx_Math" alttext="[\![\mbox{{SUBJ}}(\mbox{{cause}})]\!]_{\mbox{{H}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐜𝐚𝐮𝐬𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐇</mtext></msub></math> =
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m12" class="ltx_Math" alttext="[\![\mbox{{ARG}}(\mbox{{storm}})]\!]_{\mbox{{H}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐇</mtext></msub></math>,
so they also have the common superset <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m13" class="ltx_Math" alttext="\pi_{\texttt{ARG}}(\textbf{storm})" display="inline"><mrow><msub><mi>π</mi><mtext>𝙰𝚁𝙶</mtext></msub><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow></math>.
However, for example, logical clues can avoid aligning
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m14" class="ltx_Math" alttext="\texttt{ARG}(\textbf{storm})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐬𝐭𝐨𝐫𝐦</mtext><mo>)</mo></mrow></mrow></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS2.p4.m15" class="ltx_Math" alttext="\texttt{ARG}(\textbf{loss})" display="inline"><mrow><mtext>𝙰𝚁𝙶</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐥𝐨𝐬𝐬</mtext><mo>)</mo></mrow></mrow></math>, which
is obviously meaningless.</p>
</div>
</div>
<div id="S3.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">3.3 </span>Scoring path alignments by similarity</h3>

<div id="S3.SS3.p1" class="ltx_para">
<p class="ltx_p">Aligned paths are evaluated by a similarity score, for which we use
distributional similarity of the words that appear in the paths (§<a href="#S4.SS1" title="4.1 Language Resources ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.1</span></a>).
Only path alignments with high similarity scores can be accepted.
Also, we only accept paths of length <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS3.p1.m1" class="ltx_Math" alttext="\leq 5" display="inline"><mrow><mi/><mo>≤</mo><mn>5</mn></mrow></math>, to prevent too long paths to be aligned.</p>
</div>
</div>
<div id="S3.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">3.4 </span>Applying path alignments</h3>

<div id="S3.F6" class="ltx_figure"><img src="" id="S3.F6.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Tree transformation and generated on-the-fly knowledge
(subsumption of denotations shown above the trees)</div>
</div>
<div id="S3.SS4.p1" class="ltx_para">
<p class="ltx_p">Accepted aligned paths are converted into statements, which are used as
new knowledge. The conversion is done by first performing a DCS tree transformation
according to the aligned paths, and then declare a subsumption relation between the
denotations of aligned germs.
For example, to apply the aligned path pair generated in Figure <a href="#S3.F5" title="Figure 5 ‣ 3.2 Aligning germs by logical clues ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, we use it
to transform <span class="ltx_text ltx_font_bold">T</span> into a new tree <span class="ltx_text ltx_font_bold">T’</span> (Figure <a href="#S3.F6" title="Figure 6 ‣ 3.4 Applying path alignments ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>), and then the aligned germs, <span class="ltx_text ltx_font_typewriter">OBJ</span>(<span class="ltx_text ltx_font_bold">blame</span>) in <span class="ltx_text ltx_font_bold">T</span> and <span class="ltx_text ltx_font_typewriter">SUBJ</span>(<span class="ltx_text ltx_font_bold">cause</span>) in <span class="ltx_text ltx_font_bold">T’</span>, will
generate the on-the-fly knowledge:
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p1.m1" class="ltx_Math" alttext="[\![\mbox{{OBJ}}(\mbox{{blame}})]\!]_{\mbox{{T}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐓</mtext></msub></math> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p1.m2" class="ltx_Math" alttext="\subset" display="inline"><mo>⊂</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p1.m3" class="ltx_Math" alttext="[\![\mbox{{SUBJ}}(\mbox{{cause}})]\!]_{\mbox{{T'}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐜𝐚𝐮𝐬𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext mathvariant="bold">T’</mtext></msub></math>.</p>
</div>
<div id="S3.SS4.p2" class="ltx_para">
<p class="ltx_p">Similar to the tree transformation based approach to RTE <cite class="ltx_cite">[]</cite>,
this process can also utilize lexical-syntactic entailment rules <cite class="ltx_cite">[]</cite>.
Furthermore, since the on-the-fly knowledge is generated by transformed
pairs of DCS trees, all contexts are preserved: in Figure <a href="#S3.F6" title="Figure 6 ‣ 3.4 Applying path alignments ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>,
though the tree transformation can be seen as generated from the entailment rule
“<span class="ltx_text ltx_font_italic">X is blamed for death <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p2.m1" class="ltx_Math" alttext="\rightarrow" display="inline"><mo mathvariant="normal">→</mo></math> X causes loss of life</span>”, the generated
on-the-fly knowledge, as shown above the trees, only fires with the additional
condition that <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p2.m2" class="ltx_Math" alttext="X" display="inline"><mi>X</mi></math> is a <span class="ltx_text ltx_font_italic">tropical storm</span> and is <span class="ltx_text ltx_font_italic">Debby</span>. Hence, the
process can also be used to generate
knowledge from context sensitive rules <cite class="ltx_cite">[]</cite>, which are known to have higher quality
<cite class="ltx_cite">[]</cite>.</p>
</div>
<div id="S3.SS4.p3" class="ltx_para">
<p class="ltx_p">However, it should be noted that using on-the-fly knowledge in logical inference is not a
trivial task. For example, the FOL formula of
the rule “<span class="ltx_text ltx_font_italic">X is blamed for death <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p3.m1" class="ltx_Math" alttext="\rightarrow" display="inline"><mo mathvariant="normal">→</mo></math> X causes loss of life</span>” is:</p>
<table class="ltx_equation">

<tr class="ltx_equation ltx_align_baseline">
<td class="ltx_eqn_center_padleft"/>
<td class="ltx_align_center"><math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p3.m2" class="ltx_Math" alttext="\forall x;(\exists a;blame(x,a)\;\&amp;\;death(a))\rightarrow\\&#10;(\exists b,c;cause(x,b)\;\&amp;\;loss(b,c)\;\&amp;\;life(c))," display="block"><mrow><mrow><mrow><mrow><mo>∀</mo><mi>x</mi></mrow><mo>;</mo><mrow><mo>(</mo><mrow><mrow><mo>∃</mo><mi>a</mi></mrow><mo>;</mo><mrow><mi>b</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>x</mi><mo>,</mo><mi>a</mi></mrow><mo>)</mo></mrow><mo>⁢</mo><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mrow><mo>(</mo><mi>a</mi><mo>)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow><mo>→</mo><mrow><mo>(</mo><mrow><mrow><mo>∃</mo><mi>b</mi></mrow><mo>,</mo><mi>c</mi><mo>;</mo><mrow><mi>c</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>u</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>x</mi><mo>,</mo><mi>b</mi></mrow><mo>)</mo></mrow><mo>⁢</mo><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mrow><mo>(</mo><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mo>)</mo></mrow><mo>⁢</mo><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mrow><mo>(</mo><mi>c</mi><mo>)</mo></mrow></mrow></mrow><mo>)</mo></mrow></mrow><mo>,</mo></mrow></math></td>
<td class="ltx_eqn_center_padright"/></tr>
</table>
<p class="ltx_p">which is not a horn clause. The FOL formula for the context-preserved rule in
Figure <a href="#S3.F6" title="Figure 6 ‣ 3.4 Applying path alignments ‣ 3 Generating On-the-fly Knowledge ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>
is even more involved. Still, it can be efficiently treated by our inference engine because
as a statement, the formula <math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p3.m3" class="ltx_Math" alttext="[\![\mbox{{OBJ}}(\mbox{{blame}})]\!]_{\mbox{{T}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝙾𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐛𝐥𝐚𝐦𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext>𝐓</mtext></msub></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p3.m4" class="ltx_Math" alttext="\subset" display="inline"><mo>⊂</mo></math>
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S3.SS4.p3.m5" class="ltx_Math" alttext="[\![\mbox{{SUBJ}}(\mbox{{cause}})]\!]_{\mbox{{T'}}}" display="inline"><msub><mpadded width="-1.7pt"><mrow><mo fence="true">[[</mo><mrow><mtext>𝚂𝚄𝙱𝙹</mtext><mo>⁢</mo><mrow><mo>(</mo><mtext>𝐜𝐚𝐮𝐬𝐞</mtext><mo>)</mo></mrow></mrow><mo fence="true">]]</mo></mrow></mpadded><mtext mathvariant="bold">T’</mtext></msub></math> is an atomic sentence,
more than a horn clause.</p>
</div>
</div>
</div>
<div id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section"><span class="ltx_tag ltx_tag_section">4 </span>Experiments</h2>

<div id="S4.p1" class="ltx_para">
<p class="ltx_p">In this section, we evaluate our system on FraCaS (§<a href="#S4.SS2" title="4.2 Experiments on FraCaS ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.2</span></a>) and
PASCAL RTE datasets (§<a href="#S4.SS3" title="4.3 Experiments on PASCAL RTE datasets ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4.3</span></a>).</p>
</div>
<div id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">4.1 </span>Language Resources</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p class="ltx_p">The lexical knowledge we use are synonyms, hypernyms and
antonyms extracted from WordNet<span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">12</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">12</sup><a href="http://wordnet.princeton.edu/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://wordnet.princeton.edu/</span></a></span></span></span>.
We also add axioms on named entities,
stopwords, numerics and superlatives. For example, named entities
are singletons, so we add axioms such as
<math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS1.p1.m1" class="ltx_Math" alttext="\forall x;(x\subset\mbox{{Tom}}\;\&amp;\;x\neq\emptyset)\rightarrow\mbox{{Tom}}\subset&#10;x" display="inline"><mrow><mo>∀</mo><mi>x</mi><mo>;</mo><mrow><mo>(</mo><mi>x</mi><mo>⊂</mo><mpadded width="+2.8pt"><mtext>𝐓𝐨𝐦</mtext></mpadded><mpadded width="+2.8pt"><mi mathvariant="normal">&amp;</mi></mpadded><mi>x</mi><mo>≠</mo><mi mathvariant="normal">∅</mi><mo>)</mo></mrow><mo>→</mo><mtext>𝐓𝐨𝐦</mtext><mo>⊂</mo><mi>x</mi></mrow></math>.</p>
</div>
<div id="S4.SS1.p2" class="ltx_para">
<p class="ltx_p">To calculate the similarity scores of path alignments, we use the sum of
word vectors of the words from each path, and calculate the cosine similarity.
For example, the similarity score of the path alignment
“<span class="ltx_text ltx_font_typewriter">OBJ</span>(<span class="ltx_text ltx_font_bold">blame</span>)<span class="ltx_text ltx_font_typewriter">IOBJ</span>-<span class="ltx_text ltx_font_typewriter">ARG</span>(<span class="ltx_text ltx_font_bold">death</span>) <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS1.p2.m1" class="ltx_Math" alttext="\approx" display="inline"><mo>≈</mo></math>
<span class="ltx_text ltx_font_typewriter">SUBJ</span>(<span class="ltx_text ltx_font_bold">cause</span>)<span class="ltx_text ltx_font_typewriter">OBJ</span>-<span class="ltx_text ltx_font_typewriter">ARG</span>(<span class="ltx_text ltx_font_bold">loss</span>)<span class="ltx_text ltx_font_typewriter">MOD</span>-<span class="ltx_text ltx_font_typewriter">ARG</span>(<span class="ltx_text ltx_font_bold">life</span>)” is calculated as the cosine similarity of vectors
<span class="ltx_text ltx_font_bold">blame</span>+<span class="ltx_text ltx_font_bold">death</span> and <span class="ltx_text ltx_font_bold">cause</span>+<span class="ltx_text ltx_font_bold">loss</span>+<span class="ltx_text ltx_font_bold">life</span>.
Other structures in the paths, such as semantic roles, are ignored in the calculation.
The word vectors we use are from
<cite class="ltx_cite"/><span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">13</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">13</sup><a href="http://code.google.com/p/word2vec/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://code.google.com/p/word2vec/</span></a></span></span></span> (<span class="ltx_text ltx_font_italic">Mikolov13</span>),
and additional results are also shown using
<cite class="ltx_cite"/><span class="ltx_note ltx_role_footnote"><sup class="ltx_note_mark">14</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">14</sup><a href="http://metaoptimize.com/projects/wordreprs/" title="" class="ltx_ref ltx_url"><span class="ltx_text ltx_font_typewriter">http://metaoptimize.com/projects/wordreprs/</span></a></span></span></span>
(<span class="ltx_text ltx_font_italic">Turian10</span>).
The threshold for accepted path alignments is set to <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS1.p2.m2" class="ltx_Math" alttext="0.4" display="inline"><mn>0.4</mn></math>,
based on pre-experiments on RTE development sets.</p>
</div>
</div>
<div id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">4.2 </span>Experiments on FraCaS</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p class="ltx_p">The FraCaS test suite contains 346 inference problems divided into 9 sections, each focused on a category of semantic phenomena. We use the data by <cite class="ltx_cite"/>, and experiment on the first section, <span class="ltx_text ltx_font_italic">Quantifiers</span>, following <cite class="ltx_cite"/>.
This section has 44 single premise and 30 multi premise problems.
Most of the problems do not require lexical knowledge, so we use our primary textual
inference system without on-the-fly knowledge nor WordNet, to test the performance
of the DCS framework as formal semantics. To obtain the three-valued output (i.e. <em class="ltx_emph">yes</em>,
<em class="ltx_emph">no</em>, and <em class="ltx_emph">unknown</em>), we output “<em class="ltx_emph">yes</em>” if <span class="ltx_text ltx_font_bold">H</span> is proven, or try to
prove the negation of <span class="ltx_text ltx_font_bold">H</span> if <span class="ltx_text ltx_font_bold">H</span> is not proven. To negate <span class="ltx_text ltx_font_bold">H</span>, we use the root
negation as described in §<a href="#S2.SS5" title="2.5 Extensions ‣ 2 The Idea ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">2.5</span></a>. If the negation of <span class="ltx_text ltx_font_bold">H</span> is proven, we
output “<em class="ltx_emph">no</em>”, otherwise we output “<em class="ltx_emph">unknown</em>”.</p>
</div>
<div id="S4.SS2.p2" class="ltx_para">
<p class="ltx_p">The result is shown in Table <a href="#S4.T4" title="Table 4 ‣ 4.2 Experiments on FraCaS ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a>. Since
our system uses an off-the-shelf dependency parser, and semantic representations are obtained
from simple rule-based conversion from dependency trees, there will be only one (right or wrong) interpretation in face of ambiguous sentences.
Still, our system outperforms <cite class="ltx_cite"/>’s probabilistic CCG-parser.
Compared to <cite class="ltx_cite"/> and <cite class="ltx_cite"/>,
our system does not need a pre-trained alignment model,
and it improves by making multi-sentence inferences.
To sum up, the result shows that DCS is good at handling universal quantifiers and negations.</p>
</div>
<div id="S4.T4" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_border_l ltx_border_r ltx_border_t"/>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Single Prem.</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Multi Prem.</span></th></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Lewis13</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">70</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">50</span></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">MacCartney07</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">84.1</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">MacCartney08</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_bold ltx_font_footnote">97.7</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Our Sys.</span></th>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">79.5</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">80.0</span></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_footnote"><span class="ltx_tag ltx_tag_table">Table 4: </span>Accuracy (%) on FraCaS</div>
</div>
<div id="S4.SS2.p3" class="ltx_para">
<p class="ltx_p">Most errors are due to wrongly generated DCS trees (e.g. wrongly assigned semantic roles) or
unimplemented quantifier triggers (e.g. “<span class="ltx_text ltx_font_italic">neither</span>”) or generalized quantifiers
(e.g. “<span class="ltx_text ltx_font_italic">at least a few</span>”). These could be addressed by future work.</p>
</div>
<div id="S4.T5" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_border_l ltx_border_r ltx_border_t"/>
<th class="ltx_td ltx_align_center ltx_border_l ltx_border_r ltx_border_t" colspan="3"><span class="ltx_text ltx_font_footnote">RTE2</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t" colspan="3"><span class="ltx_text ltx_font_footnote">RTE3</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t" colspan="3"><span class="ltx_text ltx_font_footnote">RTE4</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t" colspan="3"><span class="ltx_text ltx_font_footnote">RTE5</span></th></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_border_l ltx_border_r"/>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Prec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Rec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Acc.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Prec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Rec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Acc.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Prec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Rec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Acc.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Prec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">Rec.</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Acc.</span></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Primary</span></th>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_bold ltx_font_footnote">70.9</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">9.8</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">52.9</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_bold ltx_font_footnote">73.2</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">7.3</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">51.1</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_bold ltx_font_footnote">89.7</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">5.2</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">52.3</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_bold ltx_font_footnote">82.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">6.3</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">52.5</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">+On-the-fly</span></th>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">57.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_bold ltx_font_footnote">66.5</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">58.8</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">63.7</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_bold ltx_font_footnote">64.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">63.0</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">60.0</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_bold ltx_font_footnote">57.4</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">59.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">69.9</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_bold ltx_font_footnote">55.7</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">65.8</span></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_footnote"><span class="ltx_tag ltx_tag_table">Table 5: </span>Impact of on-the-fly knowledge</div>
</div>
</div>
<div id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection"><span class="ltx_tag ltx_tag_subsection">4.3 </span>Experiments on PASCAL RTE datasets</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p class="ltx_p">On PASCAL RTE datasets, strict logical inference is known to have very low recall <cite class="ltx_cite">[]</cite>,
so on-the-fly knowledge is crucial in this setting. We test the effect of on-the-fly knowledge
on RTE2, RTE3, RTE4 and RTE5 datasets, and compare our system with other approaches.</p>
</div>
<div id="S4.SS3.SSS1" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">4.3.1 </span>Impact of on-the-fly knowledge</h4>

<div id="S4.SS3.SSS1.p1" class="ltx_para">
<p class="ltx_p">Results on test data are shown in Table <a href="#S4.T5" title="Table 5 ‣ 4.2 Experiments on FraCaS ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>. When only
primary knowledge is used in inference (the first row), recalls are actually very low; After
we activate the on-the-fly knowledge, recalls jump to over 50%, with a moderate fall of precision.
As a result, accuracies significantly increase.</p>
</div>
</div>
<div id="S4.SS3.SSS2" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">4.3.2 </span>Comparison to other RTE systems</h4>

<div id="S4.T6" class="ltx_table">
<table class="ltx_tabular ltx_centering ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_border_l ltx_border_r ltx_border_t"/>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">RTE2</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">RTE3</span></th>
<th class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">RTE4</span></th>
<th class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">RTE5</span></th></tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">Bos06</span></th>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">60.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_t"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_r ltx_border_t"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">MacCartney08</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">59.4</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Clark08</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">56.5</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Wang10</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_bold ltx_font_footnote">63.0</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">61.1</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">-</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Stern11</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">61.6</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_bold ltx_font_footnote">67.1</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">63.5</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Stern12</span></th>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center"><span class="ltx_text ltx_font_footnote">-</span></td>
<td class="ltx_td ltx_align_center ltx_border_r"><span class="ltx_text ltx_font_footnote">64.0</span></td></tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_border_b ltx_border_l ltx_border_r"><span class="ltx_text ltx_font_footnote">Our Sys.</span></th>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">58.8</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_footnote">63.0</span></td>
<td class="ltx_td ltx_align_center ltx_border_b"><span class="ltx_text ltx_font_bold ltx_font_footnote">59.6</span></td>
<td class="ltx_td ltx_align_center ltx_border_b ltx_border_r"><span class="ltx_text ltx_font_bold ltx_font_footnote">65.8</span></td></tr>
</tbody>
</table>
<div class="ltx_caption ltx_centering ltx_font_footnote"><span class="ltx_tag ltx_tag_table">Table 6: </span>Comparison with other systems</div>
</div>
<div id="S4.SS3.SSS2.p1" class="ltx_para">
<p class="ltx_p">A comparison between our system and other RTE systems is shown in Table <a href="#S4.T6" title="Table 6 ‣ 4.3.2 Comparison to other RTE systems ‣ 4.3 Experiments on PASCAL RTE datasets ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a>.
Bos06 <cite class="ltx_cite">[]</cite> is a hybrid system combining deep features from a theorem prover and a model
builder, together with shallow features such as lexical overlap and text length. MacCartney08
<cite class="ltx_cite">[]</cite> uses natural logic to calculate inference relations between two superficially
aligned sentences.
Clark08 <cite class="ltx_cite">[]</cite> is a logic-based system utilizing various resources including WordNet and
DIRT paraphrases <cite class="ltx_cite">[]</cite>, and is tolerant to partially unproven <span class="ltx_text ltx_font_bold">H</span> sentences in some degree.
All of the three systems pursue a logical approach, while combining various techniques to achieve robustness.
The result shows that our system has comparable performance. On the other hand, Wang10 <cite class="ltx_cite">[]</cite>
learns a tree-edit model from training data, and captures entailment relation by tree edit distance.
Stern11 <cite class="ltx_cite">[]</cite> and Stern12 <cite class="ltx_cite">[]</cite> extend this framework to utilize entailment
rules as tree transformations. These are more tailored systems using machine learning with many
handcrafted features. Still, our unsupervised system outperforms the state-of-the-art on RTE5 dataset.</p>
</div>
</div>
<div id="S4.SS3.SSS3" class="ltx_subsubsection">
<h4 class="ltx_title ltx_title_subsubsection"><span class="ltx_tag ltx_tag_subsubsection">4.3.3 </span>Analysis</h4>

<div id="S4.F7" class="ltx_figure"><img src="" id="S4.F7.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>Proportion of proven pairs and their precision, w.r.t. pieces of on-the-fly
knowledge.</div>
</div>
<div id="S4.SS3.SSS3.p1" class="ltx_para">
<p class="ltx_p">Summing up test data from RTE2 to RTE5, Figure <a href="#S4.F7" title="Figure 7 ‣ 4.3.3 Analysis ‣ 4.3 Experiments on PASCAL RTE datasets ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a> shows the proportion of
all proven pairs and their precision. Less than 5% pairs can be proven primarily,
with a precision of 77%. Over 40%
pairs can be proven by one piece of on-the-fly knowledge, yet pairs do exist
in which more than 2 pieces are necessary.
The precisions of 1 and 2 pieces on-the-fly knowledge application are over 60%, which is fairly
high, given our rough estimation of the similarity score. As a comparison,
<cite class="ltx_cite"/> studied the proportion of proven pairs
and precision by applying DIRT rules to tree skeletons in RTE2 and RTE3 data. The proportion
is 8% with precision 65% on RTE2, and proportion 6% with precision 72% on RTE3. Applied
by our logical system, the noisy on-the-fly knowledge can achieve a precision comparable to higher
quality resources such as DIRT.</p>
</div>
<div id="S4.SS3.SSS3.p2" class="ltx_para">
<p class="ltx_p">A major type of error is caused by the ignorance of semantic roles in calculation of
similarity scores. For example, though “<span class="ltx_text ltx_font_italic">Italy beats Kazakhstan</span>” is not primarily proven
from “<span class="ltx_text ltx_font_italic">Italy is defeated by Kazakhstan</span>”, our system does produce the path alignment
“<span class="ltx_text ltx_font_typewriter">SUBJ</span>(<span class="ltx_text ltx_font_bold">beat</span>)<span class="ltx_text ltx_font_typewriter">OBJ</span> <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p2.m1" class="ltx_Math" alttext="\approx" display="inline"><mo>≈</mo></math>
<span class="ltx_text ltx_font_typewriter">OBJ</span>(<span class="ltx_text ltx_font_bold">defeat</span>)<span class="ltx_text ltx_font_typewriter">SUBJ</span>” with a high similarity score.
The impact of such errors depends on the data making methodology, though. It lowers
precisions in RTE2 and RTE3 data, particularly in “IE” subtask (where precisions drop under <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p2.m2" class="ltx_Math" alttext="0.5" display="inline"><mn>0.5</mn></math>).
On the other hand, it occurs less often in “IR” subtask.</p>
</div>
<div id="S4.SS3.SSS3.p3" class="ltx_para">
<p class="ltx_p">Finally, to see if we “get lucky” on RTE5 data in the choice of word vectors
and thresholds, we change the thresholds from <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p3.m1" class="ltx_Math" alttext="0.1" display="inline"><mn>0.1</mn></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p3.m2" class="ltx_Math" alttext="0.7" display="inline"><mn>0.7</mn></math> and draw the precision-recall curve,
using two types of word vectors, <span class="ltx_text ltx_font_italic">Mikolov13</span> and <span class="ltx_text ltx_font_italic">Turian10</span>. As shown in
Figure <a href="#S4.F8" title="Figure 8 ‣ 4.3.3 Analysis ‣ 4.3 Experiments on PASCAL RTE datasets ‣ 4 Experiments ‣ Logical Inference on Dependency-based Compositional Semantics" class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a>, though the precision drops for <span class="ltx_text ltx_font_italic">Turian10</span>, both curves
show the pattern that our system keeps gaining recall while maintaining precision to a certain level.
Not too much “magic” in <span class="ltx_text ltx_font_italic">Mikolov13</span> actually: for over 80% pairs, every node in DCS
tree of <span class="ltx_text ltx_font_bold">H</span> can be covered by a path of length <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p3.m3" class="ltx_Math" alttext="\leq 5" display="inline"><mrow><mi/><mo>≤</mo><mn>5</mn></mrow></math>
that has a corresponding path of length <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p3.m4" class="ltx_Math" alttext="\leq 5" display="inline"><mrow><mi/><mo>≤</mo><mn>5</mn></mrow></math> in <span class="ltx_text ltx_font_bold">T</span> with a similarity score <math xmlns="http://www.w3.org/1998/Math/MathML" id="S4.SS3.SSS3.p3.m5" class="ltx_Math" alttext="&gt;0.4" display="inline"><mrow><mi/><mo>&gt;</mo><mn>0.4</mn></mrow></math>.</p>
</div>
<div id="S4.F8" class="ltx_figure"><img src="" id="S4.F8.g1" class="ltx_graphics ltx_centering" alt=""/>
<div class="ltx_caption ltx_centering"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Precision-Recall curve.</div>
</div>
</div>
</div>
</div>
<div id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section"><span class="ltx_tag ltx_tag_section">5 </span>Conclusion and Discussion</h2>

<div id="S5.p1" class="ltx_para">
<p class="ltx_p">We have presented a method of deriving abstract denotation from DCS trees,
which enables logical inference on DCS, and we developed a textual inference
system based on the framework.
Experimental results have shown the power of the representation that allows
both strict inference as on FraCaS data and robust reasoning as on RTE data.</p>
</div>
<div id="S5.p2" class="ltx_para">
<p class="ltx_p">Exploration of an appropriate meaning representation
for querying and reasoning on knowledge bases has a long history.
Description logic, being less expressive than FOL but featuring more efficient reasoning,
is used as a theory base for Semantic Web <cite class="ltx_cite">[]</cite>.
Ideas similar to our framework, including the
use of sets in a representation that benefits efficient reasoning,
are also found in description logic and knowledge representation community <cite class="ltx_cite">[]</cite>.
To our knowledge, however, their applications to logical inference beyond
the use for database querying have not been much explored in the context of NLP.</p>
</div>
<div id="S5.p3" class="ltx_para">
<p class="ltx_p">The pursue of a logic more suitable for natural language inference is not new.
For instance, <cite class="ltx_cite"/> has implemented a model of natural logic <cite class="ltx_cite">[]</cite>.
While being computationally efficient,
various inference patterns are out of the scope of their system.</p>
</div>
<div id="S5.p4" class="ltx_para">
<p class="ltx_p">Much work has been done in mapping natural language into database queries
<cite class="ltx_cite">[]</cite>.
Among these, the (<math xmlns="http://www.w3.org/1998/Math/MathML" id="S5.p4.m1" class="ltx_Math" alttext="\lambda" display="inline"><mi>λ</mi></math>-)DCS <cite class="ltx_cite">[]</cite> framework defines algorithms
that transparently map a labeled tree to a database querying procedure.
Essentially, this is because DCS trees restrict the querying process to
a very limited subset of possible operations.
Our main contribution, the abstract denotation of DCS trees, can thus be considered as
an attempt to characterize a fragment of FOL that is suited for both natural language
inference <span class="ltx_text ltx_font_italic">and</span> transparent syntax-semantics mapping, through the choice of
operations and relations on sets.</p>
</div>
<div id="S5.p5" class="ltx_para">
<p class="ltx_p">We have demonstrated the utility of logical inference on DCS through the RTE task.
A wide variety of strategies tackling the RTE task have been investigated
<cite class="ltx_cite">[]</cite>, including the
comparison of surface strings <cite class="ltx_cite">[]</cite>, syntactic and semantic structures <cite class="ltx_cite">[]</cite>,
semantic vectors <cite class="ltx_cite">[]</cite> and logical representations <cite class="ltx_cite">[]</cite>.
Acquisition of basic knowledge for RTE is also a huge stream of research <cite class="ltx_cite">[]</cite>.
These previous works include various techniques for acquiring and incorporating different kinds of
linguistic and world knowledge,
and further fight against the knowledge bottleneck problem,
e.g. by back-off to shallower representations.</p>
</div>
<div id="S5.p6" class="ltx_para">
<p class="ltx_p">Logic-based RTE systems employ various approaches to bridge knowledge gaps. <cite class="ltx_cite"/> proposes
features from a model builder; <cite class="ltx_cite"/> proposes an abduction process;
<cite class="ltx_cite"/> shows handcrafted rules could drastically improve the performance of a
logic-based RTE system.</p>
</div>
<div id="S5.p7" class="ltx_para">
<p class="ltx_p">As such, our current RTE system is at a proof-of-concept stage, in that many of
the above techniques are yet to be implemented.
Nonetheless, we would like to emphasize that it already shows performance competitive to
state-of-the-art systems on one data set (RTE5).
Other directions of our future work include further exploitation of the
new semantic representation.
For example, since abstract denotations are readily suited for data querying, they can be
used to verify newly generated assumptions by fact search in a database.
This may open a way towards a hybrid approach to RTE wherein logical inference is intermingled with
large scale database querying.</p>
</div>
<div id="S5.SS3.SSS3.P1" class="ltx_paragraph">
<h5 class="ltx_title ltx_title_paragraph">Acknowledgments</h5>

<div id="S5.SS3.SSS3.P1.p1" class="ltx_para">
<p class="ltx_p">This research was supported by the Todai Robot Project at National
Institute of Informatics.</p>
</div>
</div>
</div>
<div id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul id="L1" class="ltx_biblist">
</ul>
</div>
</div>
</div>
<div class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Tue Jun 10 17:14:51 2014 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"/></a></div></div>
</div>
</body>
</html>
