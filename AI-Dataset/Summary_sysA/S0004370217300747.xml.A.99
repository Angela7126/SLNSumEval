<html>
<head>
<meta name="TextLength" content="SENT_NUM:7, WORD_NUM:211">
</head>
<body bgcolor="white">
<a href="#0" id="0">CP provides a richer language of discrete variables with domains either given in extension or expressed in terms of upper and lower bounds, arithmetic and logical operators over these variables, and a library of ‘ global ’ constraints that capture common reasoning patterns.</a>
<a href="#1" id="1">These languages provide facilities to model parameterised classes of problems (where an individual problem instance is specified by giving values for the class parameters), such as arrays and iteration or comprehension, and to abstract away from the specific details of the many available individual constraint solvers.</a>
<a href="#2" id="2">The fourth step is to extract common subsets of terms between row constraints and (simplified) scalar product constraints.</a>
<a href="#3" id="3">For example, given the product {a mathematical formula}X×(Y+Z) and a target solver that does not allow sums inside products, the flattening process will add a new variable aux, replace the product with the new expression {a mathematical formula}X×aux and add a new constraint {a mathematical formula}aux=Y+Z.</a>
<a href="#4" id="4">We reviewed the related work in Section 2.5.</a>
<a href="#5" id="5">As an example, suppose we have {a mathematical formula}x=y and {a mathematical formula}x ≠ y in the model.</a>
<a href="#6" id="6">We can introduce a single Boolean variable a and a new constraint {a mathematical formula}a ↔ (x=y), then replace {a mathematical formula}x=y with a and {a mathematical formula}x ≠ y with ¬a.</a>
</body>
</html>