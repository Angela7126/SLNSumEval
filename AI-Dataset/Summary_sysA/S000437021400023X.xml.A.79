<html>
<head>
<meta name="TextLength" content="SENT_NUM:4, WORD_NUM:250">
</head>
<body bgcolor="white">
<a href="#0" id="0">For this proof, we implicitly match up nodes generated by Algorithm 1 with points in the code generated by Algorithm 2.By the same argument used in Lemma 1, the Deletions generated on line 1 can also be removed from S. If applying these deletions to S leads to a domain wipe-out, then the constraint solver sets {a mathematical formula}S(x)= ∅ for all {a mathematical formula}x ∈ scope(c), and the propagator has established GAC, no matter what happens in the rest of the tree.If no domain wipe-out occurs, we progress to line 9.</a>
<a href="#1" id="1">We compare eight models of LABS: Product, the model with ternary product constraints; Propagator tree, where the new 5-ary constraint has a propagator tree, and this is either compiled or executed in the VM; Table, Lighttable, MDDC and {a mathematical formula}STR2+ where the 5-ary constraint is implemented with a generic propagator using a table with 16 satisfying tuples; and Regular[17] which has 10 states and uses a ternary table constraint (representing the transition table) with 17 satisfying tuples.</a>
<a href="#2" id="2">The Propagator Tree, Table, Lighttable, MDDC, Regular and {a mathematical formula}STR2+ models search the same number of nodes as each other, and exhibit stronger propagation than Product, but their node rate is lower than Product in all cases.</a>
<a href="#3" id="3">That is, establishing GAC during search can take time {a mathematical formula}dn, compared to our worst case of {a mathematical formula}O(nd), or {a mathematical formula}O(n2d2) with symmetry reduction (assuming the solver can query and remove domain values in {a mathematical formula}O(1) time).</a>
</body>
</html>