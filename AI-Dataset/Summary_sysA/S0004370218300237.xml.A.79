<html>
<head>
<meta name="TextLength" content="SENT_NUM:6, WORD_NUM:238">
</head>
<body bgcolor="white">
<a href="#0" id="0">This example shows that our parallel SMT solving framework can be advantageous over the sequential DPLL({a mathematical formula}T) in two aspects: (1) the search space for interpretations is substantially reduced, as in this running example, the interpretation space for the original problem involves 10 constants while the space for shared interpretations involves only 2, thus the conflicts could be discovered faster, (2) parallel threads share derived interpolants, which enables multiple threads to prune the search space in different manners simultaneously.</a>
<a href="#1" id="1">RefineSharedInterp refines the valuations of shared function symbols in {a mathematical formula}MS in order to make {a mathematical formula}MS have valuations on all the shared function applications over {a mathematical formula}M1, … ,Mk.</a>
<a href="#2" id="2">Algorithm 6 illustrates its procedure which is to specify arbitrary values for shared function applications that formerly have no valuations in {a mathematical formula}MS.</a>
<a href="#3" id="3">Therefore, on each C-node in the iteration sequence, the shared interpretation {a mathematical formula}MS derived by ComputeSharedInterp is the congruence relation on a subset of the term set {a mathematical formula}T={t|d(t) ⩽ (N+1)S}.</a>
<a href="#4" id="4">When {a mathematical formula} Δ Φ is near 0, Φ can probably be more efficiently solved by Z3 because it is easier for a lazy solver to perform theory propagation and clause learning by deciding truth values of some literals.</a>
<a href="#5" id="5">When {a mathematical formula} Δ Φ is near 1, however, the solver has to traverse the whole interpretation space while theory propagation and clause learning are not effective.</a>
</body>
</html>