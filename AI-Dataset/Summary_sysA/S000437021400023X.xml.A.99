<html>
<head>
<meta name="TextLength" content="SENT_NUM:7, WORD_NUM:250">
</head>
<body bgcolor="white">
<a href="#0" id="0">For this proof, we implicitly match up nodes generated by Algorithm 1 with points in the code generated by Algorithm 2.By the same argument used in Lemma 1, the Deletions generated on line 1 can also be removed from S. If applying these deletions to S leads to a domain wipe-out, then the constraint solver sets {a mathematical formula}S(x)= ∅ for all {a mathematical formula}x ∈ scope(c), and the propagator has established GAC, no matter what happens in the rest of the tree.If no domain wipe-out occurs, we progress to line 9.</a>
<a href="#1" id="1">Since the tree on the left is strictly smaller, we can appeal to the induction hypothesis that we have generated a correct GAC propagator for {a mathematical formula}S ∖ Deletions.</a>
<a href="#2" id="2">Since we know that Deletions were correctly deleted from S, we have a correct GAC propagator at this node for S.If {a mathematical formula}l ∉ S(y), the generated propagator branches right.</a>
<a href="#3" id="3">The propagator on the right is generated from the tree given by {a mathematical formula}SimpleGenTree(c,SD ′ ∖ (y,l),ValsIn ′ ) on {a mathematical formula}S ∖ Deletions.</a>
<a href="#4" id="4">Here we have {a mathematical formula}ValsIn ′ ⊆ S ∖ Deletions ⊆ SD ′ ∖ (y,l).</a>
<a href="#5" id="5">As in the previous case, the requirements of the induction hypothesis are met and we have a correct GAC propagator for S.Finally we note that the set {a mathematical formula}SD ∖ ValsIn is always reduced by at least one literal on each recursive call to Algorithm 1.</a>
<a href="#6" id="6">Therefore we know the algorithm will eventually terminate.</a>
</body>
</html>