<html>
<head>
<meta name="TextLength" content="SENT_NUM:28, WORD_NUM:1127">
</head>
<body bgcolor="white">
<a href="#0" id="0">Our main aim in this paper has been to present a formal approach to describe both finite and infinite af structures, the argument set being the set of words within some regular language, {a mathematical formula}X⊆Σ⁎, and the attack relation, {a mathematical formula}A over {a mathematical formula}X×X being given through a sentence, {a mathematical formula}a∈AE(Σ) constructed by a limited set of operations so that for {a mathematical formula}S⊆X, {a mathematical formula}a̲(S) satisfies additivity (hence also monotonicity) and preserves regularity.</a>
<a href="#1" id="1">We provided some illustrations of the flexibility of our approach using examples from [37], [30].</a>
<a href="#2" id="2">More generally, the approach has been shown to be able to capture standard finite afs and arbitrary finite combinations of finite and infinite afs, which can reasonably be regarded as covering most (if not all) situations of practical interest.</a>
<a href="#3" id="3">A related research line we are developing in parallel concerns the use of this kind of techniques to represent infinite structures in extended versions of Dungʼs framework, some initial results concerning the afra formalism (Argumentation Framework with Recursive Attacks) having been recently obtained [4].</a>
<a href="#4" id="4">We have concentrated on the expressive potential of afs, indicating that, in contrast to “naive” encodings, processes which can be dealt with efficiently in the finite setting – deciding conflict-freeness, admissibility, acceptability, verifying whether a set is a stable or complete extension as well as construction problems such as computing the characteristic function – all admit effective decision methods and algorithms for building automata accepting the corresponding sets, even when the instances being checked or the results reported are themselves infinite subsets of {a mathematical formula}X. For the case of two problems, – existence of stable extensions and determining credulous acceptance wrt preferred semantics – unlikely to be efficiently decidable in the finite context we have shown that within afs these are (at worst) semi-decidable.</a>
<a href="#5" id="5">We conclude by reviewing some topics meriting further development, a number of which are the subject of current work.</a>
<a href="#6" id="6">One such immediate area of interest concerns the efficiency with which particular procedures can be implemented (as opposed to the issue of effectiveness).</a>
<a href="#7" id="7">While some preliminary study of such questions is underway we have chosen, partly for reasons of space, not to develop this aspect in detail within the current paper.</a>
<a href="#8" id="8">We note that such questions concern two elements: the size (i.e. number of states) of automata achieving particular tasks, and the computational complexity of the problems themselves.</a>
<a href="#9" id="9">The former, referred to as state complexity in the associated literature has been widely studied{sup:25} so that tight bounds on state complexity delineating the number of states necessary and sufficient for an automaton accepting RθS or {a mathematical formula}θ(R), in terms of the state complexity of the languages R and S have been obtained for each of the principal operations θ with each of the finite automaton forms discussed.</a>
<a href="#10" id="10">It is, clearly, the case that the extent to which, say, {a mathematical formula}πa−(S), may be recognized by a “small” automaton will depend significantly not only on the state complexity of S itself, but also on the exact specification of {a mathematical formula}a∈AE(Σ).</a>
<a href="#11" id="11">As such it would seem unlikely that a completely general treatment of state complexity for {a mathematical formula}AE(Σ) (even if such is possible) will yield results of much interest since this generality is likely to overestimate state complexity for those cases that might arise in practice.</a>
<a href="#12" id="12">A rather more promising approach is to consider sub-classes of {a mathematical formula}AE(Σ) obtained by constraining the operational structures, e.g. given some finite “base language”, {a mathematical formula}B⊆Σ⁎ consider attack structures, {a mathematical formula}a̲ satisfying “{a mathematical formula}v→aw only if {a mathematical formula}v∈B or {a mathematical formula}r(|v|,|w|)” (so that {a mathematical formula}r(…) is determined through some aspect of the lengths of v and w).</a>
<a href="#13" id="13">In fact preliminary results of the authors, with {a mathematical formula}B⊆Σ2 and the constraint “{a mathematical formula}v→aw iff ({a mathematical formula}v∈B and {a mathematical formula}tl(B)=hd(w)) or ({a mathematical formula}v∈Σ⋅w)” indicate, using a careful treatment of the dfa form accepting {a mathematical formula}X that all of the cases shown to be effectively computable in Theorem 3 may be efficiently implemented (in terms of state complexity and polynomial run-time).</a>
<a href="#14" id="14">{sup:26}</a>
<a href="#15" id="15">A further topic of some interest concerns the use of our approach in finite frameworks.</a>
<a href="#16" id="16">Although it is, of course, unnecessary to resort to afs schema to describe finite {a mathematical formula}〈X,A〉 there are, however, cases where it may be advantageous to do so.</a>
<a href="#17" id="17">For example, suppose {a mathematical formula}|X|=2m for some {a mathematical formula}m∈N, then using {a mathematical formula}Σ={0,1} the set {a mathematical formula}X can be viewed as {a mathematical formula}{0,1}m a language that is accepted by a dfa with exactly {a mathematical formula}m+1 states.</a>
<a href="#18" id="18">Thus, for suitable {a mathematical formula}A⊆X×X the af, {a mathematical formula}〈X,A〉 rather than requiring a description whose size is {a mathematical formula}O(2m)+|A| could be presented by one whose size is {a mathematical formula}O(mk) for some {a mathematical formula}k∈N.</a>
<a href="#19" id="19">In cases where such compaction can be achieved, an important issue is the resulting cost of implementing standard decision procedures: an obvious concern is that, for this particular finite case, some subsets of {a mathematical formula}{0,1}m will require automata whose state complexity is {a mathematical formula}2O(m).</a>
<a href="#20" id="20">It is, however, unclear whether this behavior would be the only potential drawback, e.g. what can be said regarding the complexity of {a mathematical formula}caadm (for single, rather than sets of arguments) in such settings?</a>
<a href="#21" id="21">As a final collection of problems we note that several issues remain open concerning effective decision processes for extension-based semantics in afs.</a>
<a href="#22" id="22">In particular, although we have shown questions such as {a mathematical formula}Estab=∅ to be semi-decidable (in finitary afs), the status of its converse is open, i.e. is it the case that {a mathematical formula}Estab≠∅ is semi-decidable?</a>
<a href="#23" id="23">A positive answer would, of course, lead to an effective procedure for {a mathematical formula}existstab, while a negative answer motivates the question of identifying decidable fragments of {a mathematical formula}AE(Σ).</a>
<a href="#24" id="24">On a different side, it has to be acknowledged that afs is not an immediately usable formal tool and that the specification of each example has been crafted individually.</a>
<a href="#25" id="25">In perspective, afs can be regarded as a “low level” language which can represent the basis for the definition of higher level constructs for the description of infinite afs, accompanied by suitable methodologies for their application.</a>
<a href="#26" id="26">In fact, some recurrent structural and representation patterns can be identified in the examples considered in the paper and procedures to derive afs from logic programs could be considered, but a full investigation of these issues is left for future work.</a>
<a href="#27" id="27">In conclusion we emphasize once more that the development put forward in this paper, while establishing many cases where an effective treatment of infinite argumentation forms is realistic, provides a starting point for a wider investigation of this matter.</a>
</body>
</html>