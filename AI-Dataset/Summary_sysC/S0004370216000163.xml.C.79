<html>
<head>
<meta name="TextLength" content="SENT_NUM:14, WORD_NUM:567">
</head>
<body bgcolor="white">
<a href="#0" id="0">ComputePath expands the inconsistent states from OPEN in increasing order of priority, maintaining Invariants 1 – 3, until it discovers a minimum cost path to {a mathematical formula}sgoal.</a>
<a href="#1" id="1">We observe that when we are looking for an Ε bounded solution, we can reuse the old path cost {a mathematical formula}v(s) for an underconsistent state s (selected for expansion), as long as {a mathematical formula}g Π (s)+h(s) ≤ Ε ⋅ (v(s)+h(s)).</a>
<a href="#2" id="2">This stems from the fact that for an underconsistent state s selected for expansion, {a mathematical formula}v(s)+h(s) is a lower bound on the solution cost through s, as {a mathematical formula}v(s) holds previous shortest path cost (from {a mathematical formula}sstart) and {a mathematical formula}h(s) is a consistent heuristic.</a>
<a href="#3" id="3">If the current path to s (from {a mathematical formula}sstart) satisfies the bound on {a mathematical formula}v(s)+h(s), any state {a mathematical formula}s ′ that uses {a mathematical formula}v(s) to compute its {a mathematical formula}g(s ′ ) will never underestimate the actual solution cost by more than the Ε factor.</a>
<a href="#4" id="4">LPA* propagates this cost change until {a mathematical formula}Key(sgoal) becomes the minimum Key value in OPEN, i.e., it expands E and H before returning the previous solution as the minimum cost solution (Fig.</a>
<a href="#5" id="5">As expansion of E cannot produce a solution with cost less than 2 and {a mathematical formula}g Π (G)=4, at this point, we can truncate E and return the current path as a 2 bounded solution.</a>
<a href="#6" id="6">Now, as no other states have been truncated, {a mathematical formula}g Π (s) is computed by adding the action costs from {a mathematical formula}sstart to s following the bp pointers for each state in the path (check in line 9, Algorithm 2 is never true).Assume that the path is given by {a mathematical formula} Π (s0=sstart, … ,sk=s).</a>
<a href="#7" id="7">This optimization ensures that D* Lite does need not to alter the Key values of states that already in OPEN (i.e., no reordering required), and also that the Key values of newly generated states maintain the lower bound on the total path cost (note that, {a mathematical formula}h(slast,sstart) ≤ c ⁎ (slast,sstart)).</a>
<a href="#8" id="8">TLPA* truncates the cost propagation for an underconsistent state s (selected for expansion), if {a mathematical formula}g Π (s)+h(s) ≤ Ε ⋅ (v(s)+h(s)).</a>
<a href="#9" id="9">In ATD*, when an underconsistent state s is selected for expansion for the first time, we compute its {a mathematical formula}g Π value and check whether {a mathematical formula}g Π (s)+h(s) ≤ Ε 2 ⋅ (v(s)+h(s)), in the same manner as TLPA*.</a>
<a href="#10" id="10">Instead, we mark s as a state that can be potentially truncated (by inserting it in a list called MARKED), postpone its cost propagation, and update its position in OPEN by altering its Key value from {a mathematical formula}Key(s)=[v(s)+h(s);v(s)] to {a mathematical formula}Key(s)=[v(s)+ Ε 1 ⋅ h(s);v(s)] (Step 1).</a>
<a href="#11" id="11">If a state {a mathematical formula}s ∈ MARKED, is selected for expansion again as an underconsistent state ({a mathematical formula}v(s)<g(s)), i.e., it is selected for expansion with the inflated heuristic Key, we truncate s (Step 2).</a>
<a href="#12" id="12">InComputePath, for any state s, if the{a mathematical formula}ComputeGpi(s)routine returns a path of finite cost, i.e.,{a mathematical formula}g Π (s)< ∞ , the same path can be constructed using theObtainPathroutine if none of the back-pointers change (same asLemma 8).</a>
<a href="#13" id="13">TLPA* can truncate a subset of such states if the current path estimate ({a mathematical formula}g Π +h) is within the chosen bound of the previous total path cost ({a mathematical formula}v+h).</a>
</body>
</html>