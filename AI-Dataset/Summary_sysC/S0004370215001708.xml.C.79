<html>
<head>
<meta name="TextLength" content="SENT_NUM:31, WORD_NUM:1196">
</head>
<body bgcolor="white">
<a href="#0" id="0">The idea of the framework is to move away from the standard, in the database literature, assumption that query results be given in the form of a database object, and to allow instead two alternative representations of answers: as objects defining all other answers, or as knowledge we can deduce with certainty about all such answers.</a>
<a href="#1" id="1">In other applications, the definition of {a mathematical formula} 〚 D 〛 varies, but the notion of certain answers does not.</a>
<a href="#2" id="2">Then {a mathematical formula} 〚 D 〛 Σ consists of all such repairs, and for a given query Q one looks for consistent query answers defined as {a mathematical formula} ⋂ {Q(D ′ )|D ′ ∈ 〚 D 〛 Σ }.</a>
<a href="#3" id="3">Even worse, {a mathematical formula}(1,2) is not less informative than any of the answers {a mathematical formula}Q(D ′ ) for {a mathematical formula}D ′ ∈ 〚 D 〛 which are of the form {a mathematical formula}{(1,2),(3,n)} for different values n. Indeed, under the closed world semantics, the answer {a mathematical formula}{(1,2)} contains additional information that no tuple except {a mathematical formula}(1,2) is present.</a>
<a href="#4" id="4">The problem with returning the single tuple {a mathematical formula}(1,2) as the certain answer becomes even more pronounced if we follow the approach, pioneered by [3], that views databases as logical theories and query answering as logical implication.</a>
<a href="#5" id="5">If one has a query Q to be evaluated on an incomplete database D, one needs to represent the set{a mathematical formula} of possible answers to Q on complete databases that are represented by D. One possibility is to look for an answer A so that {a mathematical formula} 〚 A 〛 =Q( 〚 D 〛 ), i.e., A denotes exactly the answers to Q over {a mathematical formula} 〚 D 〛 .</a>
<a href="#6" id="6">When such an answer A exists for every query Q from a given class of queries, one talks about strong representation systems for that class, under the semantics {a mathematical formula} 〚 〛 , see [19], [2].</a>
<a href="#7" id="7">Free variables of a formula Φ are defined in the standard way.</a>
<a href="#8" id="8">If {a mathematical formula}x¯ is the tuple of free variables of Φ , we may indicate this explicitly by writing {a mathematical formula} Φ (x¯).</a>
<a href="#9" id="9">Note that this definition requires that both the input database D, and the answer A, be interpreted under the same semantics {a mathematical formula} 〚 〛 .</a>
<a href="#10" id="10">Computing certain answers boils down to finding certain information contained in a set of objects; in the case of query answering, in {a mathematical formula}Q( 〚 D 〛 )={Q(D ′ )|D ′ ∈ 〚 D 〛 }.</a>
<a href="#11" id="11">Thus, we need to know how to define certain information contained in a set of objects {a mathematical formula}X ⊆ D.</a>
<a href="#12" id="12">Two isomorphic databases will agree on logical formulae not mentioning constants.</a>
<a href="#13" id="13">Even if we have a logical formula mentioning constants from a finite set C, databases D and {a mathematical formula}f(D) will agree on it as long as {a mathematical formula}f(a)=a for every {a mathematical formula}a ∈ C.</a>
<a href="#14" id="14">The intuition behind the ‘ enough objects ’ condition is that for every such renaming f of elements of the active domain, {a mathematical formula}f(D) is a legitimate database, and D and {a mathematical formula}f(D) agree on formulae that only mention constants preserved by f.</a>
<a href="#15" id="15">This is just a technical condition so that we could represent a finite set {a mathematical formula}{ Φ 1, … , Φ n} of formulae by a single formula, namely their conjunction {a mathematical formula} Φ 1 ∧ … ∧ Φ n.</a>
<a href="#16" id="16">And the properties of {a mathematical formula} Δ D are again straightforward from the definition of the semantics, as they simply state it in the language of FO.</a>
<a href="#17" id="17">We look at certain information contained in sets {a mathematical formula} 〚 x 〛 and prove that, as expected, it is represented at the object level by x itself, and at the knowledge level by {a mathematical formula} Δ x, defining the semantics of x.</a>
<a href="#18" id="18">Assume that {a mathematical formula}x ≠ ⋀ 〚 x 〛 .</a>
<a href="#19" id="19">Then there is {a mathematical formula}y ⪯ ̸ x such that {a mathematical formula}y ⪯ c for each {a mathematical formula}c ∈ 〚 x 〛 .</a>
<a href="#20" id="20">Since {a mathematical formula}y ⪯ ̸ x we have {a mathematical formula} 〚 x 〛 ⊈ 〚 y 〛 , i.e., there is {a mathematical formula}c ∈ 〚 x 〛 such that {a mathematical formula}c ∉ 〚 y 〛 .</a>
<a href="#21" id="21">But since {a mathematical formula}y ⪯ c, we have {a mathematical formula} 〚 c 〛 ⊆ 〚 y 〛 , and since {a mathematical formula}c ∈ C, this implies {a mathematical formula}c ∈ 〚 y 〛 as {a mathematical formula}c ∈ 〚 c 〛 , which gives us the desired contradiction.</a>
<a href="#22" id="22">In general though, objects related by {a mathematical formula} ≈ j may not agree on all the formulae of {a mathematical formula}F (e.g., D and {a mathematical formula}D ′ do not agree on the sentence {a mathematical formula} ∃ x(x=1)) and hence there are potentially formulae in {a mathematical formula}Th( 〚 x 〛 ≈ j) which are not satisfied by x.</a>
<a href="#23" id="23">If it does not, it simply means that the semantics {a mathematical formula} 〚 〛 ′ of query answers was chosen incorrectly.</a>
<a href="#24" id="24">Certain answers to Q on an object x represent certain information in the set {a mathematical formula}Q( 〚 x 〛 )={Q(c)|c ∈ 〚 x 〛 }.</a>
<a href="#25" id="25">So the next attempt is to find a formula {a mathematical formula} Φ Q,D in some logical formalism so that{a mathematical formula} When this happens, one refers to such a logical formalism as a strong representation system (see [19], [2]), which explains why we used the name ‘ representation system ’ .</a>
<a href="#26" id="26">If the set {a mathematical formula}Q( 〚 D 〛 ) does not happen to be of the form {a mathematical formula}Mod( Φ ) for some nice formula Φ , the approach adopted in the database literature is to consider the object {a mathematical formula} ⋂ Q( 〚 D 〛 ) as the answer.</a>
<a href="#27" id="27">It seems much better to ask then, in place of (1), for an answer {a mathematical formula} Φ Q,D that is equivalent to the theory of {a mathematical formula}Q( 〚 D 〛 ), rather than defining {a mathematical formula}Q( 〚 D 〛 ) precisely.</a>
<a href="#28" id="28">Assume that there is a representation system{a mathematical formula}RS= 〈 D ′ ,F, ⊨ 〉 over the domain of query answers.</a>
<a href="#29" id="29">Since {a mathematical formula}c ⪰ x for every {a mathematical formula}c ∈ 〚 x 〛 , then {a mathematical formula}Q(x) ⪯ ′ Q(c) and {a mathematical formula}Q(c) satisfies Φ as well by the properties of representation systems, proving that {a mathematical formula} Φ ∈ Th(Q( 〚 x 〛 )).Conversely, if {a mathematical formula} Φ ∈ Th(Q( 〚 x 〛 )), consider j such that {a mathematical formula}z ≈ j ′ z ′ implies that {a mathematical formula}z,z ′ agree on Φ for every {a mathematical formula}z,z ′ (which exists by the definition of representation systems).</a>
<a href="#30" id="30">In other words, in this case the basic query evaluation {a mathematical formula}Q(x) provides us with an approximation of certain answers, since it gives us some, but perhaps not all, information that certain answers contain.</a>
</body>
</html>