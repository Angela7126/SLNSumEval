<html>
<head>
<meta name="TextLength" content="SENT_NUM:15, WORD_NUM:596">
</head>
<body bgcolor="white">
<a href="#0" id="0">Similarly, in this scenario, we can get a large number of logs as partial decomposition trees, and use them to learn the task relationships (HTN structures) and service behaviors (or action models), even when we do not have precise descriptions of all events happening during the web service composition process.</a>
<a href="#1" id="1">HTN-Learner can learn method preconditions and action models simultaneously, but requires that method structures be given as input; while HTNLearn, which extends from HTN-Learner, can learn method structures, method preconditions, and action models simultaneously from partially observed plan traces which are annotated with partial decomposition trees.</a>
<a href="#2" id="2">[19] presented an approach implemented in a development environment for constructing and maintaining a hierarchical task model from a set of annotated examples provided by domain experts, where the task model constructed did not include preconditions or effects, i.e., without methods' preconditions, actions' preconditions or actions' effects.</a>
<a href="#3" id="3">[30] and Xu and Muñoz-Avila [66] proposed eager (in the form of version spaces) and lazy learning (in the form of case-based reasoning) algorithms respectively to learn the preconditions of HTN methods, given as input the hierarchical relationships between tasks, the action models, and a complete description of the intermediate states.</a>
<a href="#4" id="4">[27] presented an algorithm, called HTN-MAKER, to learn structures by assuming that annotated tasks are given in the form of preconditions and effects (we made the same assumption in our work).</a>
<a href="#5" id="5">A Hierarchical Task Network (HTN) planning problem can be defined as a quadruple {a mathematical formula}(s0,T,M,A), where {a mathematical formula}s0 is an initial state, which is a conjunction of propositions, T is a list of tasks that need to be accomplished, M is a set of HTN methods, which specify how a high-level task can be decomposed into a totally ordered set of lower-level subtasks, and A is a set of actions, which correspond to primitive subtasks that can be directly executed [67], [20].</a>
<a href="#6" id="6">For example, a user might provide an incomplete set of tasks and methods that contain intrinsic problem structure that is not expressible in STRIPS representations and the user provides annotated tasks to fill the gaps in the HTN model.</a>
<a href="#7" id="7">Hence, while those gaps (or annotated tasks) will need to be equivalent to STRIPS representations, the overall elicited model can be more complex, i.e., including intrinsic structures and preconditions/effects representations.</a>
<a href="#8" id="8">We do this by simply scanning each partial decomposition tree in {a mathematical formula} Π part and each annotated task in {a mathematical formula}T and exploiting their relations between states and task preconditions and task effects to build {a mathematical formula}Hcand.</a>
<a href="#9" id="9">To generate a method {a mathematical formula}mk for a method structure in STR, we set {a mathematical formula}mk's parameters to be all the different parameters of the tasks in the method structure.</a>
<a href="#10" id="10">We also need to build constraints for generating {a mathematical formula}mk's preconditions.</a>
<a href="#11" id="11">We exploit a straightforward way to generate the preconditions by assuming that, if a predicate {a mathematical formula}p ∈ P frequently appears in the state where the method {a mathematical formula}mk is executed and its parameters are included in {a mathematical formula}mk, then p is one of {a mathematical formula}mk's preconditions.</a>
<a href="#12" id="12">We denote the method structure's corresponding primitive hierarchy by {a mathematical formula} 〈 t,a[i, … ,j] 〉 .</a>
<a href="#13" id="13">Specifically, for each learned action model a, we denote its corresponding ground-truth action model as {a mathematical formula}ag.</a>
<a href="#14" id="14">We define the error rate of a's preconditions as{a mathematical formula} where {a mathematical formula}allPossiblePre(a) means the set of all possible preconditions of a, i.e., the set of all predicates in P (extracted by the first step of Algorithm 1) whose parameters are included in a.</a>
</body>
</html>