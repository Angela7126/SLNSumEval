<html>
<head>
<meta name="TextLength" content="SENT_NUM:28, WORD_NUM:1208">
</head>
<body bgcolor="white">
<a href="#0" id="0">To cope with this, in the OSCAR implementation described in [74], Pollock restricts the use of the temporal projection principle to a specific form of backward reasoning: the agent is interested in the value of a property at a specific time instant t and checks whether there are reasons to believe that the property had a certain value at an instant {a mathematical formula}t0<t.</a>
<a href="#1" id="1">If this is the case, the reason can be projected, with decreased strength, from {a mathematical formula}t0 to t. However explicit representations of infinite arguments are needed to go beyond this specific form of reasoning.</a>
<a href="#2" id="2">In particular, we have to notice the arousal of a problem not occurring in the finite case: given that an argumentation framework {a mathematical formula} 〈 X,A 〉 involving infinite sets can only be given through a finite encoding {a mathematical formula} Η ( 〈 X,A 〉 ), it must be validated that an encoding {a mathematical formula} Η ( 〈 X,A 〉 ) is indeed a valid description of someaf.</a>
<a href="#3" id="3">The issues identified with so-called naive representations in the preceding section largely stem from the following fact: given that encodings of arguments, {a mathematical formula}pi ∈ X are effectively achieved for free – that is, for all natural numbers k, {a mathematical formula}pk ∈ X and no further analysis is needed – the task of describing {a mathematical formula} 〈 X,A 〉 comes down to describing the (infinite) set {a mathematical formula}A.</a>
<a href="#4" id="4">In this way we can then present very general specifications of the attack structure that are conditioned solely in terms of the specific arguments in {a mathematical formula}X.</a>
<a href="#5" id="5">Let {a mathematical formula} Σ ={ Σ 1, Σ 2, … , Σ k} be an alphabet.</a>
<a href="#6" id="6">An argument encoding over Σ is any regular language {a mathematical formula}X ⊆ Σ ⁎ ∖ { Ε }.</a>
<a href="#7" id="7">Thus a (possibly infinite) set of arguments, {a mathematical formula}X, corresponds to some regular language over a finite alphabet Σ .</a>
<a href="#8" id="8">We seek to develop formalisms by which the set of arguments (in {a mathematical formula}X) that “ attack ” in the standard sense of [37] some specified subset {a mathematical formula}S ⊆ X may be presented, i.e.</a>
<a href="#9" id="9">for defining “ suitable ” functions {a mathematical formula} Μ :2X → 2X, such that, for a given set of arguments S, {a mathematical formula} Μ (S) specifies the set of arguments attacking S, i.e.</a>
<a href="#10" id="10">The immediate problem with allowing arbitrary usage of ⋅ and ∩ concerns the fact that, for expressions such as {a mathematical formula}p ⋅ q or {a mathematical formula}p ∩ q we cannot, in general, guarantee that the mappings {a mathematical formula}p ̲ ⋅ q ̲ or {a mathematical formula}p ̲ ∩ q ̲ are additive.</a>
<a href="#11" id="11">We now have the basic elements of our formal descriptive mechanism for infinite frameworks, the idea being that the set of arguments is specified as a regular language {a mathematical formula}X ⊆ Σ ⁎ and the attack relation is specified through an attack expression a.</a>
<a href="#12" id="12">The attack expression has therefore to specify that the trailing 0 applies only to the elements of the sub-language {a mathematical formula}0 ⋅ (00) ⁎ , giving rise to the expression {a mathematical formula}(I ∩ (0 ⋅ (00) ⁎ )) ⋅ 0.</a>
<a href="#13" id="13">Similarly, the attacks from a generic {a mathematical formula}Ai to a generic {a mathematical formula}Bi can be obtained using the tl operator and properly restricting its application, giving rise to {a mathematical formula}tl(I ∩ ((00) ⋅ (00) ⁎ )).</a>
<a href="#14" id="14">The complete attack expression of {a mathematical formula}AFM is obtained by the union of the two expressions above: {a mathematical formula}aM=((I ∩ (0 ⋅ (00) ⁎ )) ⋅ 0) ∪ tl(I ∩ ((00) ⋅ (00) ⁎ )).As to {a mathematical formula}AFR, we note first that the attacks between arguments {a mathematical formula}Ai and {a mathematical formula}Bi are analogous to the case of {a mathematical formula}AFM with the difference that {a mathematical formula}Ai corresponds to {a mathematical formula}0 ⋅ (000)i − 1 and {a mathematical formula}Bi corresponds to {a mathematical formula}00 ⋅ (000)i − 1.</a>
<a href="#15" id="15">Hence, similarly to above, we obtain the expressions {a mathematical formula}(I ∩ (0 ⋅ (000) ⁎ )) ⋅ 0 and {a mathematical formula}tl(I ∩ ((00) ⋅ (000) ⁎ )).</a>
<a href="#16" id="16">As to the attacks from an argument {a mathematical formula}Ci, corresponding to {a mathematical formula}000 ⋅ (000)i − 1, to an argument {a mathematical formula}Bi corresponding to {a mathematical formula}00 ⋅ (000)i − 1 we note that they can again be represented through the addition of a trailing 0 yielding {a mathematical formula}(I ∩ (00 ⋅ (000) ⁎ )) ⋅ 0.</a>
<a href="#17" id="17">The complete attack expression of {a mathematical formula}AFR turns out to be {a mathematical formula}aR=((I ∩ (0 ⋅ (000) ⁎ )) ⋅ 0) ∪ (tl(I ∩ ((00) ⋅ (000) ⁎ ))) ∪ ((I ∩ (00 ⋅ (000) ⁎ )) ⋅ 0).</a>
<a href="#18" id="18">As a further remark, we note that the attack expression I captures the case of an argumentation framework where each argument attacks itself (and only itself) which has been shown not to be representable in the naive approach using regular languages in Section 4.</a>
<a href="#19" id="19">The expressions {a mathematical formula}a+ use the same basic elements as {a mathematical formula}AE( Σ ) plus the {a mathematical formula}rev() operator,{sup:16} which does not affect any of the desired properties.</a>
<a href="#20" id="20">The following properties, shown to be valid in the proof of Theorem 2, provide the basic elements to derive the expressions {a mathematical formula}a+ from {a mathematical formula}a ̲ .</a>
<a href="#21" id="21">Let us turn now to the specification of the additional finite attack relations {a mathematical formula}Ai,j ({a mathematical formula}i ≠ j) between subframeworks.</a>
<a href="#22" id="22">We note that the restriction to finitary frameworks (and finite subsets of {a mathematical formula}X in the second part) is needed: without this the method used in proving Theorem 4 could not be applied.</a>
<a href="#23" id="23">To conclude this section, as some of the results we provided rely on the condition that an af specification gives rise to a finitary argumentation framework, one is interested in conditions ensuring that this holds.</a>
<a href="#24" id="24">In order to provide an af specification for {a mathematical formula}AF(Q) we need first a dfa representing the infinite set of arguments {a mathematical formula}XQ and then a proper attack expression representing the relation {a mathematical formula}AQ.</a>
<a href="#25" id="25">As to the dfa representation of {a mathematical formula}XQ, it is handy to consider separately the infinite sequences corresponding to the six “ columns ” in Fig.</a>
<a href="#26" id="26">First observe that {a mathematical formula}p ̲ in these cases satisfies the additivity requirement (R1) of Definition 12 since for any {a mathematical formula}S ⊆ Σ ⁎ we have {a mathematical formula}p ̲ (S) ∈ { Σ 1, … , Σ k,S} and for each {a mathematical formula}w ∈ S, {a mathematical formula}p ̲ ({w}) ∈ { Σ 1, … , Σ k,{w}}.</a>
<a href="#27" id="27">Hence in the case {a mathematical formula}p= Σ we obtain{a mathematical formula} whereas for {a mathematical formula}p=I we have{a mathematical formula} Finally, since S is assumed regular to begin with, for each of the base case possibilities, we have {a mathematical formula}p ̲ (S) is also regular.Now inductively assume for some {a mathematical formula}k>0 and all attack expressions over Σ , q, with {a mathematical formula}size(q)<k the mapping given via {a mathematical formula}q ̲ is a reasonable attack function.</a>
</body>
</html>