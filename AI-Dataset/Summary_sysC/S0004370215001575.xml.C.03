<html>
<head>
<meta name="TextLength" content="SENT_NUM:62, WORD_NUM:1861">
</head>
<body bgcolor="white">
<a href="#0" id="0">Our program makes conjectures about relations of real number invariants of mathematical objects.</a>
<a href="#1" id="1">Conjectures in matrix theory, number theory, and graph theory are reported, together with an experiment in using conjectures to automate game play.</a>
<a href="#2" id="2">The heuristic is general and can be used to conjecture relations between real number invariants of any objects, mathematical or otherwise.</a>
<a href="#3" id="3">We include examples of conjectures in number theory, matrix theory, graph theory and the characterization of game positions.</a>
<a href="#4" id="4">Some of the number theory conjectures seem to imply the Riemann Hypothesis.</a>
<a href="#5" id="5">And some of the graph theory conjectures would advance the lower bound theory of the independence number of a graph, a widely-studied NP-hard graph invariant.</a>
<a href="#6" id="6">It was very successful — both in limiting the number of conjectures produced by earlier versions of his Graffiti program and in producing conjectures of interest to research mathematicians.</a>
<a href="#7" id="7">The first program to make conjectures leading to published mathematical research was Fajtlowicz's Graffiti program [7], [8], [9], [10], [1].</a>
<a href="#8" id="8">The Sorcerer's Apprentice Problem is how to reduce the flood of potential conjectures to a useable or scannable number — how to design a program to produce just the most “ significant ” , “ interesting ” or useful statements?</a>
<a href="#9" id="9">The program cannot make any more conjectures than the number of objects being considered (stored in the program) — so the number of generated conjectures is fundamentally limited.</a>
<a href="#10" id="10">The Graffiti program and some of its conjectures are described in Fajtlowicz's papers and in [13].</a>
<a href="#11" id="11">Fajtlowicz's Dalmatian heuristic is used to conjecture relations between real number invariants of objects.</a>
<a href="#12" id="12">The produced conjectures are based on a limited number of examples of objects of the given type.</a>
<a href="#13" id="13">Let {a mathematical formula} Α 1, … , Α k be real number invariants.</a>
<a href="#14" id="14">That is, the inequality {a mathematical formula} Α ≤ Α 1+ Α 2 can be interpreted as, “ For every object {a mathematical formula}O, {a mathematical formula} Α (O) ≤ Α 1(O)+ Α 2(O). ” A conjectured upper bound u is only added to the database of conjectures if the bound passes the following two tests.</a>
<a href="#15" id="15">The candidate conjecture {a mathematical formula} Α ≤ u is true for all of the stored objects {a mathematical formula}O1, … ,On, and</a>
<a href="#16" id="16">That is, the candidate conjecture would give a better bound for {a mathematical formula} Α (O) than any previously conjectured (upper) bound.</a>
<a href="#17" id="17">We will step through the generation of conjectured lower bounds for {a mathematical formula} Π (x), the number of primes no more than x.</a>
<a href="#18" id="18">So, ideally, we will generate lower bounds for {a mathematical formula} Π (x) where the maximum of the conjectured lower bounds applied to the object 5 is 3, while the maximum for 16 is 6.</a>
<a href="#19" id="19">Expressions formed with the unary “ add 1 ” operator are never formed as the program stops after the ninth iteration, at which point the conjectures in the conjecture store exactly predict the value of {a mathematical formula} Π (x) for all objects x in {a mathematical formula}{5,16}.</a>
<a href="#20" id="20">The considered conjecture in Iteration 1 in Table 1 is “ the sum of the digits of an integer x is no more than {a mathematical formula} Π (x) ” .</a>
<a href="#21" id="21">The next considered conjecture is “ the number of prime factors of any integer x is no more than {a mathematical formula} Π (x) ” .</a>
<a href="#22" id="22">The considered conjecture in Iteration 3 is “ the number of divisors of an integer x is no more than {a mathematical formula} Π (x) ” .</a>
<a href="#23" id="23">This is true for all of the objects and is significant as this lower bound is better than the number_prime_factors lower bound for at least one of the known objects; so number_prime_factors is added to the conjectures store.</a>
<a href="#24" id="24">The considered conjecture is “ the number of prime factors of an integer x plus the number of its divisors is no more than {a mathematical formula} Π (x) ” .</a>
<a href="#25" id="25">Some of Graffiti's best-known conjectures are the following lower bounds for the independence number Α of a graph (the maximum number of pairwise non-adjacent vertices in the graph, an NP-hard-to-compute graph invariant), and were made prior to the addition of the Dalmatian heuristic to that program.</a>
<a href="#26" id="26">Pre-Dalmatian versions of Graffiti were also used to generate some interesting number theory conjectures including, for instance, a formula for {a mathematical formula} Π (x).</a>
<a href="#27" id="27">Generate conjectures that are true for all stored objects and significant with respect to these objects and the previously stored conjectures.</a>
<a href="#28" id="28">If conjectured upper bounds (for example) for an invariant Α are being generated then a conjectured bound {a mathematical formula} Α i in the conjectures store is significant, with respect to the stored objects, if and only if there is an object {a mathematical formula}O such that {a mathematical formula} Α i(O)<min ⁡ { Α j(O):j ≠ i}, that is, if and only if, there is an object {a mathematical formula}O where the bound gives a better predicted value for {a mathematical formula} Α (O) than any other conjectured bound does.</a>
<a href="#29" id="29">The program can never make more conjectures than the number of objects it has stored: the reason is exactly because each conjecture in the conjectures store must give a better bound for at least one stored object than any other conjecture does.If there were, for instance, two stored objects and three conjectured bounds, at least one of the conjectured bounds could not possibly be significant: at best one of the conjectures could be the best bound for one of the objects and another for the second object — but the third conjecture would have no possible remaining objects for which it could give the unique best predicted value; this conjecture would have been removed as insignificant.</a>
<a href="#30" id="30">The first round of conjectures for upper bounds for the determinant (det) of a symmetric matrix are included in Table 2.</a>
<a href="#31" id="31">One further round of upper and lower bound conjectures for the absolute value of the determinant is included here.</a>
<a href="#32" id="32">The upper bound conjectures are in Table 4.</a>
<a href="#33" id="33">The lower bound conjectures for the absolute value of the determinant of a matrix are in Table 5.</a>
<a href="#34" id="34">While the determinant of a matrix is efficiently computable and an estimate may not be of any practical interest, there are other hard-to-compute invariants — for example, the independence number of a graph — where estimates generated from efficiently computable conjectured bounds may be of interest.</a>
<a href="#35" id="35">The conjecture has been verified by computer for all integers up to at least {a mathematical formula}4 ⋅ 1014[53], and there are a large number of partial results and continuing interest.</a>
<a href="#36" id="36">Clearly Goldbach's Conjecture is true if and only if {a mathematical formula}Goldbach(x)>0 for even {a mathematical formula}x>2.</a>
<a href="#37" id="37">No counterexample was found to the second conjecture and, thus, no further conjectures could be added to the list of conjectures.</a>
<a href="#38" id="38">The second run of the program produced the conjectures in Table 7.</a>
<a href="#39" id="39">Conjectures from the first run of the program are recorded in Table 8.</a>
<a href="#40" id="40">We further tested the truth of these three conjectures for all integers no more than {a mathematical formula}x=1,000,000.</a>
<a href="#41" id="41">The three invariants listed after domination_number are known upper bounds for the domination number and were eventually removed in order to try to generate better upper bound conjectures.</a>
<a href="#42" id="42">In our run generating upper bound conjectures for the domination number, the program ended up with four examples (found by this automated search for counterexamples) and the conjecture that the domination number of a graph is no more than its matching number.</a>
<a href="#43" id="43">The conjecture exactly predicted the true value of the domination number of these four graphs — and, hence, the program stopped.</a>
<a href="#44" id="44">In the next run, we removed matching_number from the list of invariants and the program generated the three conjectures in Table 11.</a>
<a href="#45" id="45">We added Hedetniemi's counterexamples as objects to the program and generated a second round of conjectures for upper bounds for the domination number of a graph; the results are in Table 13.</a>
<a href="#46" id="46">The second and third conjectures are curious as they are trivially true; but, at some point in the conjecture-making process, there must have been graphs for which these bounds gave a larger predicted domination number than the previously conjectured bounds.</a>
<a href="#47" id="47">In the previously reported experiments, no existing bounds were included in the program — and, thus, the program could make “ rediscoveries. ” Mazur later suggested including known bounds — theoretical knowledge — in the program to keep the program from making conjectures that were implied by existing theory.</a>
<a href="#48" id="48">In this way, the program only produces conjectures that are mathematically significant in a precise sense: they will give better invariant value predictions for some objects than any known bounds will.</a>
<a href="#49" id="49">The first and third conjectures in Table 16 are interesting because they, in some sense, generalize the radius lower bound for the independence number of a graph (mentioned earlier, following a conjecture of Graffiti).</a>
<a href="#50" id="50">A possible game position would either satisfy these “ winning position conjectures ” or it would not: if every conjecture were true then any winning position would satisfy all of the conjectures.</a>
<a href="#51" id="51">A sample of the generated conjectures — all the upper bound conjectures for the number of cookies on the diagonal of the game board — are recorded in Table 17.</a>
<a href="#52" id="52">These preliminary results show that a conjecture-making program based on the Dalmatian heuristic can be of use to researchers in their investigations of bounds of real number invariants of objects.</a>
<a href="#53" id="53">In this way, the program could only produce conjectures that for which there is at least one example where the produced conjecture gives a better bound than any known theorem or conjecture.</a>
<a href="#54" id="54">The generalization of the Dalmatian heuristic to the design of a program that makes conjectures about relations of properties of objects is explained below.</a>
<a href="#55" id="55">If necessary conditions are desired then the program would need to produce statements of the form, “ If an integer has property P then it has property {a mathematical formula}Qi. ”</a>
<a href="#56" id="56">That is, the statement {a mathematical formula}P ⇒ Q1 ∧ Q2 can be interpreted as, “ For every object {a mathematical formula}O, {a mathematical formula}P(O) ⇒ Q1(O) ∧ Q2(O). ” A conjectured necessary condition Q is only added to the database of conjectures if the property passes the following two tests.</a>
<a href="#57" id="57">The candidate conjecture {a mathematical formula}P ⇒ Q is true for all of the stored objects {a mathematical formula}O1, … ,On, and</a>
<a href="#58" id="58">That is, the candidate conjecture would give a better necessary condition for {a mathematical formula}P(O) than any previously conjectured necessary condition.</a>
<a href="#59" id="59">That is, the statement {a mathematical formula}Q1 ∧ Q2 ⇒ P can be interpreted as, “ For every object {a mathematical formula}O, {a mathematical formula}Q1(O) ∧ Q2(O) ⇒ P(O). ” A conjectured sufficient condition Q is only added to the database of conjectures if the property passes the Truth and Significance tests.</a>
<a href="#60" id="60">That is, the candidate conjecture would give a better sufficient condition for {a mathematical formula}P(O) than any previously conjectured sufficient condition.</a>
<a href="#61" id="61">Let {a mathematical formula}P be the set of objects that have property P. Necessary conditions for membership in {a mathematical formula}P define a super-class {a mathematical formula}N of {a mathematical formula}P. What is wanted are conjectures that make this super-class smaller and smaller.</a>
</body>
</html>