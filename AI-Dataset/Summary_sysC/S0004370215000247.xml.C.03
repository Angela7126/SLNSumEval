<html>
<head>
<meta name="TextLength" content="SENT_NUM:36, WORD_NUM:776">
</head>
<body bgcolor="white">
<a href="#0" id="0">Since we inspect HTN planning from four different perspectives, we provide a framework for each perspective.</a>
<a href="#1" id="1">The first piece of the pie is a theoretical framework for HTN planning upon which we later build two models of HTN planning.</a>
<a href="#2" id="2">We refer to a task network over {a mathematical formula}Tp as a primitive task network.</a>
<a href="#3" id="3">HTN planning problemAn HTN planning problem{a mathematical formula}P is a tuple {a mathematical formula}(Q,O,M,tn0,s0), where</a>
<a href="#4" id="4">Given an HTN planning problem {a mathematical formula}P, a solution to {a mathematical formula}P is an operator sequence executable in {a mathematical formula}s0 by decomposing {a mathematical formula}tn0.</a>
<a href="#5" id="5">Sometimes we refer to the HTN planning that uses this style as totally ordered HTN planning.</a>
<a href="#6" id="6">The HTN planning that uses this style is referenced as partially ordered HTN planning.</a>
<a href="#7" id="7">HTN planners allow tasks with variables to be inserted into a task network.</a>
<a href="#8" id="8">In some HTN planners, the phantomisation of a task is achieved by an explicit encoding in the domain knowledge.</a>
<a href="#9" id="9">Given an HTN planning problem {a mathematical formula}P, at the beginning of the search, a task decomposition is imposed on the initial task network {a mathematical formula}tn0, and the process continues by repeatedly decomposing tasks from a newly created task network until a primitive task network is produced.</a>
<a href="#10" id="10">We refer to HTN planners that search in this plan space as plan-based HTN planners, and to the model of HTN planning as plan-based HTN planning.</a>
<a href="#11" id="11">We refer to HTN planners searching in this space as state-based HTN planners, and to the model of HTN planning as state-based HTN planning.</a>
<a href="#12" id="12">Executable task networkGiven an HTN planning problem {a mathematical formula}P, {a mathematical formula}tn=(T, Φ , Ψ ) is executable in state s, if and only if it is primitive and there exists linearisation of its tasks {a mathematical formula}t1, … ,tn that is compatible with Ψ and the corresponding sequence of operators {a mathematical formula} Φ (t1), … , Φ (tn) is executable in s.</a>
<a href="#13" id="13">SolutionLet {a mathematical formula}P be an HTN planning problem.</a>
<a href="#14" id="14">Most plan-based HTN planners perform a task decomposition in a slightly different way than the general process described in Section 2.2.1.</a>
<a href="#15" id="15">A task network tn in state-based HTN planning is less expressive than the one in plan-based HTN planning.</a>
<a href="#16" id="16">SolutionLet {a mathematical formula}P be an HTN planning problem.</a>
<a href="#17" id="17">State-based HTN planners follow the task decomposition as described in Section 2.2.1, and indeed distinguish between primitive and compound tasks (Table 4).</a>
<a href="#18" id="18">In each aspect, the expressiveness of HTN planning is compared to the one of STRIPS-like planning.</a>
<a href="#19" id="19">Unfortunately, there is no common planning language for HTN planners.</a>
<a href="#20" id="20">Given an HTN planning problem {a mathematical formula}P, we define each as follows.</a>
<a href="#21" id="21">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#22" id="22">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#23" id="23">An HTN planner is sound if every plan it gives is a correct solution to {a mathematical formula}P.</a>
<a href="#24" id="24">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#25" id="25">An HTN planner is complete if it always finds a solution to {a mathematical formula}P when such a solution exists.</a>
<a href="#26" id="26">Let {a mathematical formula}P be an HTN planning problem and Π be a solution to {a mathematical formula}P. An HTN planner is said to tolerate faults from a fault set F during the execution of Π iff for each {a mathematical formula}f ∈ F, there exists a sequence of operators {a mathematical formula} Π f such that {a mathematical formula} Π f is a solution to {a mathematical formula}P.</a>
<a href="#27" id="27">Under this perspective, we deal with the following decision problem Plan-Ex: Given an HTN planning problem {a mathematical formula}P, does {a mathematical formula}P have a solution?</a>
<a href="#28" id="28">On the other hand, a totally ordered HTN planning problem can be transformed into a partially ordered HTN planning problem (that is, the latter one supports totally ordered task networks), but the converse is not true – totally ordered HTN planning does not support partially ordered task networks.</a>
<a href="#29" id="29">Once more, HTN planning is strictly more expressive than STRIPS-like planning.</a>
<a href="#30" id="30">This is because totally ordered HTN planning avoids interleaving of tasks from different compound tasks.</a>
<a href="#31" id="31">We can conclude that HTN planning is able to express a broader and more complex set of planning problems than STRIPS-like planning.</a>
<a href="#32" id="32">The result of the planning process in plan-based HTN planners is a partially ordered plan which is in compliance with the definition of flexibility.</a>
<a href="#33" id="33">Planner takes in the current HTN planning problem {a mathematical formula}P and computes a solution plan Π .</a>
<a href="#34" id="34">To that end, let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#35" id="35">That is, we choose OWL-S as a service description language upon which we define the problem of Web service composition and its corresponding HTN planning problem.</a>
</body>
</html>