<html>
<head>
<meta name="TextLength" content="SENT_NUM:11, WORD_NUM:314">
</head>
<body bgcolor="white">
<a href="#0" id="0">In contrast, as mentioned above, we consider a huge but bounded combinatorial space of algorithms, based on components taken from two dozen of the best SLS algorithms for SAT currently available, and we employ an off-the-shelf, general-purpose algorithm configuration procedure to search this space.</a>
<a href="#1" id="1">The solvers thus obtained perform substantially better than current state-of-the-art SLS-based SAT solvers on a broad range of challenging SAT instances with up to 4978 variables.</a>
<a href="#2" id="2">Existing work on algorithm synthesis is mostly focused on automatically generating algorithms that satisfy a given formal specification or that solve a specific problem from a large and diverse domain (see, e.g., [77], [57], [21]).</a>
<a href="#3" id="3">In this section, we present a high-level outline of SATenstein-LS and explain the functionality of the major building blocks used in our design.</a>
<a href="#4" id="4">We also give a detailed description of the parameters exposed by SATenstein-LS.</a>
<a href="#5" id="5">As discussed in Section 2.1, most SLS algorithms for SAT fall into one of four broad categories: GSAT-based, WalkSAT-based, dynamic local search, and G{sup:2}WSAT variants.</a>
<a href="#6" id="6">Since no recent, state-of-the-art SLS solver is GSAT-based, we constructed SATenstein-LS by drawing components from algorithms belonging to the three remaining categories.</a>
<a href="#7" id="7">As shown in the high-level algorithm outline (Procedure SATenstein-LS), SATenstein-LS is comprised of five major building blocks, B1 – B5.</a>
<a href="#8" id="8">In order to study the effectiveness of our proposed approach for algorithm design, we configured SATenstein-LS on training sets from various distributions of SAT instances and compared the performance of the SATenstein-LS solvers thus obtained against that of several existing high-performance SAT solvers on disjoint test sets.</a>
<a href="#9" id="9">However, in some cases, the original implementations of these algorithms are more efficient — on our data, by at most a factor of two on average per instance set — mostly, because SATenstein-LS's generality rules out some data structure optimizations.</a>
<a href="#10" id="10">Thus, we based all of our experimental comparisons on the original algorithm implementations, as submitted to the respective SAT Competitions.</a>
</body>
</html>