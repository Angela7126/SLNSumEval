<html>
<head>
<meta name="TextLength" content="SENT_NUM:13, WORD_NUM:547">
</head>
<body bgcolor="white">
<a href="#0" id="0">If a domain is empty in {a mathematical formula}SD ′ , the algorithm returns.</a>
<a href="#1" id="1">Pruned values are also removed from ValsIn to form {a mathematical formula}ValsIn ′ — these values are known to be in S, but the propagator tree will remove them from S. Furthermore, if only one value remains for some variable in {a mathematical formula}SD ′ , the value is added to {a mathematical formula}ValsIn ′ (otherwise the domain would be empty).</a>
<a href="#2" id="2">For this proof, we implicitly match up nodes generated by Algorithm 1 with points in the code generated by Algorithm 2.By the same argument used in Lemma 1, the Deletions generated on line 1 can also be removed from S. If applying these deletions to S leads to a domain wipe-out, then the constraint solver sets {a mathematical formula}S(x)= ∅ for all {a mathematical formula}x ∈ scope(c), and the propagator has established GAC, no matter what happens in the rest of the tree.If no domain wipe-out occurs, we progress to line 9.</a>
<a href="#3" id="3">Since the tree on the left is strictly smaller, we can appeal to the induction hypothesis that we have generated a correct GAC propagator for {a mathematical formula}S ∖ Deletions.</a>
<a href="#4" id="4">Since we know that Deletions were correctly deleted from S, we have a correct GAC propagator at this node for S.If {a mathematical formula}l ∉ S(y), the generated propagator branches right.</a>
<a href="#5" id="5">The propagator on the right is generated from the tree given by {a mathematical formula}SimpleGenTree(c,SD ′ ∖ (y,l),ValsIn ′ ) on {a mathematical formula}S ∖ Deletions.</a>
<a href="#6" id="6">Here we have {a mathematical formula}ValsIn ′ ⊆ S ∖ Deletions ⊆ SD ′ ∖ (y,l).</a>
<a href="#7" id="7">As in the previous case, the requirements of the induction hypothesis are met and we have a correct GAC propagator for S.Finally we note that the set {a mathematical formula}SD ∖ ValsIn is always reduced by at least one literal on each recursive call to Algorithm 1.</a>
<a href="#8" id="8">Therefore we know the algorithm will eventually terminate.</a>
<a href="#9" id="9">We compare eight models of LABS: Product, the model with ternary product constraints; Propagator tree, where the new 5-ary constraint has a propagator tree, and this is either compiled or executed in the VM; Table, Lighttable, MDDC and {a mathematical formula}STR2+ where the 5-ary constraint is implemented with a generic propagator using a table with 16 satisfying tuples; and Regular[17] which has 10 states and uses a ternary table constraint (representing the transition table) with 17 satisfying tuples.</a>
<a href="#10" id="10">The Propagator Tree, Table, Lighttable, MDDC, Regular and {a mathematical formula}STR2+ models search the same number of nodes as each other, and exhibit stronger propagation than Product, but their node rate is lower than Product in all cases.</a>
<a href="#11" id="11">live cells are contained within an {a mathematical formula}n×n bounding box at each time step) and period p is represented by a 3-dimensional array of Boolean variables {a mathematical formula}b[n+4,n+4,p] indexed (from 0) by position i, j and time step t. To enforce the bounding box, for each t, the rows 0, 1, {a mathematical formula}n+2 and {a mathematical formula}n+3 are set to 0.</a>
<a href="#12" id="12">That is, establishing GAC during search can take time {a mathematical formula}dn, compared to our worst case of {a mathematical formula}O(nd), or {a mathematical formula}O(n2d2) with symmetry reduction (assuming the solver can query and remove domain values in {a mathematical formula}O(1) time).</a>
</body>
</html>