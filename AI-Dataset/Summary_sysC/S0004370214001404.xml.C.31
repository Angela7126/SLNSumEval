<html>
<head>
<meta name="TextLength" content="SENT_NUM:113, WORD_NUM:2050">
</head>
<body bgcolor="white">
<a href="#0" id="0">Definition 1</a>
<a href="#1" id="1">An argumentation framework (AF) is a pair {a mathematical formula}F=(A,R) where A is a set of arguments and {a mathematical formula}R ⊆ A×A is the attack relation.</a>
<a href="#2" id="2">The pair {a mathematical formula}(a,b) ∈ R means that a attacks b.</a>
<a href="#3" id="3">We say that an argument {a mathematical formula}a ∈ A is defended (in F) by a set {a mathematical formula}S ⊆ A if, for each {a mathematical formula}b ∈ A such that {a mathematical formula}(b,a) ∈ R, there exists a {a mathematical formula}c ∈ S such that {a mathematical formula}(c,b) ∈ R.</a>
<a href="#4" id="4">A semantics for argumentation frameworks is defined as a function Σ which assigns to each AF {a mathematical formula}F=(A,R) a set {a mathematical formula} Σ (F) ⊆ 2A of extensions.</a>
<a href="#5" id="5">Definition 3</a>
<a href="#6" id="6">Let {a mathematical formula}F=(A,R) be an AF.</a>
<a href="#7" id="7">A set {a mathematical formula}S ⊆ A is conflict-free (in F), if there are no {a mathematical formula}a,b ∈ S, such that {a mathematical formula}(a,b) ∈ R.</a>
<a href="#8" id="8">{a mathematical formula}cf(F) denotes the collection of conflict-free sets of F. For a conflict-free set {a mathematical formula}S ∈ cf(F), it holds that</a>
<a href="#9" id="9">{a mathematical formula}S ∈ naive(F), if there is no {a mathematical formula}T ∈ cf(F) with {a mathematical formula}T ⊃ S;</a>
<a href="#10" id="10">{a mathematical formula}S ∈ stb(F), if {a mathematical formula}SR+=A;</a>
<a href="#11" id="11">{a mathematical formula}S ∈ adm(F), if {a mathematical formula}S ⊆ FF(S);</a>
<a href="#12" id="12">{a mathematical formula}S ∈ com(F), if {a mathematical formula}S=FF(S);</a>
<a href="#13" id="13">{a mathematical formula}S ∈ grd(F), if {a mathematical formula}S ∈ com(F) and there is no {a mathematical formula}T ∈ com(F) with {a mathematical formula}T ⊂ S;</a>
<a href="#14" id="14">{a mathematical formula}S ∈ prf(F), if {a mathematical formula}S ∈ adm(F) and there is no {a mathematical formula}T ∈ adm(F) with {a mathematical formula}S ⊂ T;</a>
<a href="#15" id="15">{a mathematical formula}S ∈ sem(F), if {a mathematical formula}S ∈ adm(F) and there is no {a mathematical formula}T ∈ adm(F) with {a mathematical formula}SR+ ⊂ TR+;</a>
<a href="#16" id="16">{a mathematical formula}S ∈ stg(F), if there is no {a mathematical formula}T ∈ cf(F), with {a mathematical formula}SR+ ⊂ TR+.</a>
<a href="#17" id="17">{a mathematical formula}L(a)=in iff for each b with {a mathematical formula}(b,a) ∈ R, {a mathematical formula}L(b)=out.</a>
<a href="#18" id="18">{a mathematical formula}L(a)=out iff there exists b with {a mathematical formula}(b,a) ∈ R, {a mathematical formula}L(b)=in.</a>
<a href="#19" id="19">Definition 5</a>
<a href="#20" id="20">Given an AF {a mathematical formula}F=(A,R).</a>
<a href="#21" id="21">The preferred labelings are those complete labelings where {a mathematical formula}Lin is ⊆ -maximal among all complete labelings.</a>
<a href="#22" id="22">Definition 6</a>
<a href="#23" id="23">Given an AF {a mathematical formula}F=(A,R), a semantics Σ and an argument {a mathematical formula}a ∈ A, then</a>
<a href="#24" id="24">{a mathematical formula}Enum Σ (F)= Σ (F)</a>
<a href="#25" id="25">{a mathematical formula}Count Σ (F)=| Σ (F)|</a>
<a href="#26" id="26">{a mathematical formula}Cred Σ (a,F)={yesif a ∈ ⋃ S ∈ Σ (F)Snootherwise</a>
<a href="#27" id="27">{a mathematical formula}Skept Σ (a,F)={yesif a ∈ ⋂ S ∈ Σ (F)Snootherwise</a>
<a href="#28" id="28">{a mathematical formula}Ver Σ (S,F)={yesif S ∈ Σ (F)nootherwise</a>
<a href="#29" id="29">Example 3</a>
<a href="#30" id="30">Consider the AF F given in Example 1.</a>
<a href="#31" id="31">For naive semantics, the reasoning problems result in {a mathematical formula}Enumnaive(F)={{a,c},{a,d},{b,d}} and {a mathematical formula}Countnaive(F)=3.</a>
<a href="#32" id="32">Furthermore, for argument a we obtain {a mathematical formula}Crednaive(a,F)=yes and {a mathematical formula}Skeptnaive(a,F)=no.</a>
<a href="#33" id="33">For preferred semantics, F has a single extension {a mathematical formula}Enumprf(F)={{a,d}}, {a mathematical formula}Countprf(F)=1, and thus credulous and skeptical acceptance coincide (e.g., {a mathematical formula}Credprf(a,F)=Skeptprf(a,F)=yes).</a>
<a href="#34" id="34">{a mathematical formula} Φ =p and {a mathematical formula}p ∈ I</a>
<a href="#35" id="35">{a mathematical formula} Φ =¬p and {a mathematical formula}p ∉ I</a>
<a href="#36" id="36">{a mathematical formula} Φ = Ψ 1 ∧ Ψ 2 and both {a mathematical formula} Ψ 1 and {a mathematical formula} Ψ 2 evaluate to true under I</a>
<a href="#37" id="37">{a mathematical formula} Φ = Ψ 1 ∨ Ψ 2 and one of {a mathematical formula} Ψ 1 and {a mathematical formula} Ψ 2 evaluates to true under I</a>
<a href="#38" id="38">{a mathematical formula} Φ = Ψ 1 → Ψ 2 and {a mathematical formula} Ψ 1 evaluates to false or {a mathematical formula} Ψ 2 evaluates to true under I</a>
<a href="#39" id="39">{a mathematical formula} Φ = ∃ p Ψ and one of {a mathematical formula} Ψ [p/ ⊤ ] and {a mathematical formula} Ψ [p/ ⊥ ] evaluates to true under I</a>
<a href="#40" id="40">{a mathematical formula} Φ = ∀ p Ψ and both {a mathematical formula} Ψ [p/ ⊤ ] and {a mathematical formula} Ψ [p/ ⊥ ] evaluate to true under I.</a>
<a href="#41" id="41">The first reduction-based approach [18], [20] we consider here uses propositional logic formulae (without quantifiers) to encode the problem of finding admissible sets.</a>
<a href="#42" id="42">Given an AF {a mathematical formula}F=(A,R), for each argument {a mathematical formula}a ∈ A a propositional variable {a mathematical formula}va is used.</a>
<a href="#43" id="43">Then, {a mathematical formula}S ⊆ A is an extension under semantics Σ iff {a mathematical formula}{va|a ∈ S} ⊨ Φ , with Φ being a propositional formula that evaluates AF F under semantics Σ (below we will present in detail how to translate AFs into formulae).</a>
<a href="#44" id="44">Formally, the correspondence between sets of extensions and models of a propositional formula can be defined as follows.</a>
<a href="#45" id="45">Definition 7</a>
<a href="#46" id="46">Let {a mathematical formula}S ⊆ 2A be a collection of sets of arguments and let {a mathematical formula}I ⊆ 2P be a collection of interpretations.</a>
<a href="#47" id="47">We say that {a mathematical formula}S and {a mathematical formula}I correspond to each other, in symbols {a mathematical formula}S ≅ I, if</a>
<a href="#48" id="48">1.</a>
<a href="#49" id="49">for each {a mathematical formula}S ∈ S, there exists an {a mathematical formula}I ∈ I, such that {a mathematical formula}{a|va ∈ I,a ∈ A}=S;</a>
<a href="#50" id="50">2.</a>
<a href="#51" id="51">for each {a mathematical formula}I ∈ I, there exists an {a mathematical formula}S ∈ S, such that {a mathematical formula}{a|va ∈ I,a ∈ A}=S; and</a>
<a href="#52" id="52">3.</a>
<a href="#53" id="53">{a mathematical formula}|S|=|I|.</a>
<a href="#54" id="54">Given an AF {a mathematical formula}F=(A,R) the following formula can be used to solve the enumeration problem of admissible semantics.</a>
<a href="#55" id="55">{a mathematical formula}</a>
<a href="#56" id="56">In short, we check whether the accepted arguments form an admissible set and whether there exists a proper superset of it which is also admissible.</a>
<a href="#57" id="57">If the former check succeeds and in the latter no such set exists, then we have found a preferred extension.</a>
<a href="#58" id="58">For an arbitrary AF {a mathematical formula}F=(A,R), its preferred extensions are in a 1-to-1 correspondence to the models of {a mathematical formula}prfA,R, i.e., {a mathematical formula}Enumprf(F) ≅ {M|M ⊨ prfA,R}.</a>
<a href="#59" id="59">Now, complete extensions are characterized by the following formula.</a>
<a href="#60" id="60">We will use L as superscript in {a mathematical formula}comA,RL to denote that this formula handles labelings instead of extensions.</a>
<a href="#61" id="61">{a mathematical formula}</a>
<a href="#62" id="62">Then, similar as in {a mathematical formula}prfA,R, the preferred extensions or their labelings can be encoded with a QBF as follows, with the quantified atoms {a mathematical formula}Av ′ ={va ′ ⊕ ,va ′ ⊖ |a ′ ∈ A ′ }.</a>
<a href="#63" id="63">{a mathematical formula}</a>
<a href="#64" id="64">Algorithm 1 decides skeptical acceptance under preferred semantics of an argument a in an AF F. The idea is to proceed from one preferred extension to the next and checking whether a is in one of the extensions.</a>
<a href="#65" id="65">This is encoded in the outer while loop, lines 2 to 11.</a>
<a href="#66" id="66">The models of formula Φ represent the remaining admissible sets in the current state of the algorithm.</a>
<a href="#67" id="67">In the beginning, Φ encodes all admissible sets of F. We start with an admissible set and iteratively extend it while making sure that a is not accepted in this admissible set.</a>
<a href="#68" id="68">This is done in the second loop (lines 3 to 5) and by adding {a mathematical formula}¬va to the query.</a>
<a href="#69" id="69">The formula {a mathematical formula} Ψ I incorporates the model I and states that a model of it must still correspond to an admissible set, but also has to be a superset of the current one, specified by I.</a>
<a href="#70" id="70">If we cannot add further arguments to the admissible set, we check whether we can extend it with having a inside, in line 6.</a>
<a href="#71" id="71">If this is the case, every preferred extension that is a superset of the current admissible set contains a.</a>
<a href="#72" id="72">Hence, we can proceed to a different admissible set not containing a.</a>
<a href="#73" id="73">In case we cannot add a to the admissible set, we have found a preferred extension without a, hereby refuting its skeptical acceptance in F. In the former case (I does not represent a preferred extension) we strengthen the main query Φ by adding {a mathematical formula} Γ I in line 7, stating that at least one argument currently not accepted in I must be accepted from now on.</a>
<a href="#74" id="74">This ensures that in future iterations we compute admissible sets that are not contained in previously found preferred extensions.</a>
<a href="#75" id="75">The formulae are defined as follows.</a>
<a href="#76" id="76">{a mathematical formula}{a mathematical formula}</a>
<a href="#77" id="77">For admissible semantics we get the following constraints.</a>
<a href="#78" id="78">{a mathematical formula}</a>
<a href="#79" id="79">We now provide fixed queries for admissible and preferred extensions in such a way that the AF F is given as an input database {a mathematical formula}F ˆ and the answer sets of the combined program {a mathematical formula} Π e(F ˆ ) are in a certain one-to-one correspondence with the respective extensions, where {a mathematical formula}e ∈ {adm,prf}.</a>
<a href="#80" id="80">1.</a>
<a href="#81" id="81">for each {a mathematical formula}S ∈ S, there exists an {a mathematical formula}I ∈ I, such that {a mathematical formula}{a|in(a) ∈ I}=S;</a>
<a href="#82" id="82">2.</a>
<a href="#83" id="83">for each {a mathematical formula}I ∈ I, there exists an {a mathematical formula}S ∈ S, such that {a mathematical formula}{a|in(a) ∈ I}=S; and</a>
<a href="#84" id="84">3.</a>
<a href="#85" id="85">{a mathematical formula}|S|=|I|.</a>
<a href="#86" id="86">For any AF {a mathematical formula}F=(A,R), the admissible sets of F correspond to the answer sets of {a mathematical formula} Π adm augmented by {a mathematical formula}F ˆ , i.e.</a>
<a href="#87" id="87">{a mathematical formula}adm(F) ≅ AS( Π adm(F ˆ )).</a>
<a href="#88" id="88">{a mathematical formula}undefeated(a) is derived if argument a is not defeated in F by the second guess T.</a>
<a href="#89" id="89">With these predicates at hand, we can now formally define the module for preferred extensions,{a mathematical formula} Then, for any AF F, the answer sets of {a mathematical formula} Π prf(F ˆ ) are in a one-to-one correspondence with the preferred extensions of F, i.e.</a>
<a href="#90" id="90">{a mathematical formula}prf(F) ≅ AS( Π prf(F ˆ )).</a>
<a href="#91" id="91">We now look at the encodings for preferred semantics which are easy to encode using the minimization statement of metasp.</a>
<a href="#92" id="92">We only need the module {a mathematical formula} Π adm and minimize the {a mathematical formula}out/1 predicate.</a>
<a href="#93" id="93">This in turn gives us the subset-maximal admissible sets which captures the definition of preferred semantics.</a>
<a href="#94" id="94">{a mathematical formula} As a result we get that for any AF F, the answer sets of {a mathematical formula} Π prf_metasp(F ˆ ) are in a one-to-one correspondence with the preferred extensions of F, i.e.</a>
<a href="#95" id="95">{a mathematical formula}prf(F) ≅ AS( Π prf_metasp(F ˆ )).</a>
<a href="#96" id="96">This algorithm iterates over all admissible sets and tests whether they are ⊆ -maximal.</a>
<a href="#97" id="97">As for each argument a the algorithm first tries to add an argument to {a mathematical formula}Lin before considering the variant without a, we can be sure that supersets are always considered first.</a>
<a href="#98" id="98">Hence, we never have to remove a labeling from the set {a mathematical formula}SL.</a>
<a href="#99" id="99">The pitfall of Algorithm 4 is the potential exponential number of admissible labelings (even for a small number of preferred extensions) which are all considered by the algorithm.</a>
<a href="#100" id="100">First, consider a game that provides, given an AF {a mathematical formula}F=(A,R) and argument {a mathematical formula}a ∈ A, a proof whether a is contained in the grounded extension of F. The game is given by the following rules of allowed moves of each player.</a>
<a href="#101" id="101">Now let us consider a game that allows us, given an AF {a mathematical formula}F=(A,R) and argument {a mathematical formula}a ∈ A, to prove whether a is contained in some preferred extension of F (or equivalently in some admissible set).</a>
<a href="#102" id="102">The following game is quite similar to the game for grounded semantics, the only difference being that Opp is not allowed to repeat its moves.</a>
<a href="#103" id="103">Restricting the legal moves of Opp makes it easier to have a winning strategy for Pro.</a>
<a href="#104" id="104">(i)</a>
<a href="#105" id="105">{a mathematical formula} ⋃ t ∈ VTXt=V</a>
<a href="#106" id="106">(ii)</a>
<a href="#107" id="107">{a mathematical formula}(vi,vj) ∈ E ⇒ ∃ t ∈ VT:{vi,vj} ⊆ Xt</a>
<a href="#108" id="108">LEAF node: Here we have {a mathematical formula}Ft=F ≥ t and thus the restricted admissible sets are just the conflict-free sets.</a>
<a href="#109" id="109">So we compute the conflict-free sets of {a mathematical formula}Ft and then build a coloring for each conflict-free set S as follows:{a mathematical formula}</a>
<a href="#110" id="110">So far we have only considered admissible semantics but the dynamic programming approach is in no way limited to problems that are in NP.</a>
<a href="#111" id="111">Harder problems, however, generally need a more complicated data structure.</a>
<a href="#112" id="112">Consider preferred semantics where, for example, deciding {a mathematical formula}Skeptprf is known to be {a mathematical formula} Π 2P-complete.</a>
</body>
</html>