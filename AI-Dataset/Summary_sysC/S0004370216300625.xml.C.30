<html>
<head>
<meta name="TextLength" content="SENT_NUM:12, WORD_NUM:397">
</head>
<body bgcolor="white">
<a href="#0" id="0">Our Automatic Construction of Parallel Portfolios (ACPP) approach uses an automatic algorithm configuration procedure to identify a set of configurations that perform well when executed in parallel.</a>
<a href="#1" id="1">Applied to two prominent SAT solvers, Lingeling and clasp, our ACPP procedure identified 8-core solvers that significantly outperformed their sequential counterparts on a diverse set of instances from the application and hard combinatorial category of the 2012 SAT Challenge.</a>
<a href="#2" id="2">We further extended our ACPP approach to produce parallel portfolio solvers consisting of several different solvers by combining their configuration spaces.</a>
<a href="#3" id="3">Applied to the component solvers of the 2012 SAT Challenge gold medal winning SAT Solver pfolioUZK, our ACPP procedures produced a significantly better-performing parallel SAT solver.</a>
<a href="#4" id="4">Given a solver with a rich design space (such as Lingeling and clasp), all our ACPP methods were able to generate 8-core parallel solvers that significantly outperformed their sequential counterparts.</a>
<a href="#5" id="5">We have thus demonstrated that our ACPP methods are able to automatically build parallel portfolio solvers, without the need for costly, hand-crafted parallel implementations.</a>
<a href="#6" id="6">However, our scalability analysis indicates that hardware restrictions lead to substantial overhead as more processor cores are used, and the scalability of our ACPP methods depends on the richness of the given sequential solver's design spaces and the existence of complementary designs within these spaces.</a>
<a href="#7" id="7">We have demonstrated that by exploiting the configuration spaces of a set of complementary solvers, even-better-performing ACPP solvers can be obtained, compared to those constructed from a single parametric SAT solver such as Lingeling (compare Table 2 and Table 6).</a>
<a href="#8" id="8">To produce such an ACPP solver, we did not need to modify our ACPP methods, but instead used conditionals in our configuration space to distinguish between the design spaces of the individual solvers.</a>
<a href="#9" id="9">Although we did not use parallel solvers with clause sharing (such as Plingeling) in our portfolio, our parHydra method was able to generate a parallel solver without clause sharing that nevertheless performed as well as pfolioUZK.</a>
<a href="#10" id="10">The first part of Table 7 summarizes the performance results for these solvers: first the sequential solvers in their default configurations (Default-SP), then the parallel solvers using clause sharing in their default configurations (Default-MP(8)+CS), and finally our ACPP solvers based on the component solvers of pfolioUZK.</a>
<a href="#11" id="11">As already discussed, the performance of the sequential pfolioUZK did not achieve state-of-the-art performance; this distinction goes to glucose for a single solver, and SATzilla for a portfolio-based algorithm selector.</a>
</body>
</html>