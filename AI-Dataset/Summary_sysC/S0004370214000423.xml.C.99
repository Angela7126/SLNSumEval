<html>
<head>
<meta name="TextLength" content="SENT_NUM:19, WORD_NUM:458">
</head>
<body bgcolor="white">
<a href="#0" id="0">Overall, the greedy propagator of AtMostNValue takes a graph G as input, calls a function F to compute independent sets in G and then filters variable domains with a set of rules {a mathematical formula}R. Therefore, we introduce the notation {a mathematical formula}AMNV 〈 G|F|R 〉 to define such a family of propagators.</a>
<a href="#1" id="1">Consequently, the greedy propagator introduced in [7] is referred to as {a mathematical formula}AMNV 〈 GI|MD|R1,2 〉 .</a>
<a href="#2" id="2">Then {a mathematical formula}GI is a complete graph, whereas there are no edges, but loops, in {a mathematical formula}GCI.</a>
<a href="#3" id="3">Consequently, {a mathematical formula} Α (GI)=1 whereas {a mathematical formula} Α (GCI)=|V|.</a>
<a href="#4" id="4">It is worth noticing that in our context, the bigger the independent set, the higher the chance to filter variable domains.</a>
<a href="#5" id="5">Thus, using {a mathematical formula}GCI is presumably better than using {a mathematical formula}GI to filter AtMostNValue when difference constraints figure in the model (Proposition 2).</a>
<a href="#6" id="6">To illustrate the interest of {a mathematical formula}GCI, we now use it on our example, with {a mathematical formula}d(z)={1,2,3}, in Fig.</a>
<a href="#7" id="7">Note also that, as long as domain union and intersection operations are defined, no assumption is made about the kind of variables in {a mathematical formula}X.</a>
<a href="#8" id="8">This means Algorithm 2 can be used to filter the AtMostNVector constraint [13], a variant of AtMostNValue which holds on continuous vector variables instead of integer variables.</a>
<a href="#9" id="9">The main difference between the two data sets is related to {a mathematical formula}z ⁎ |T|, which has an average value of {a mathematical formula}39% and {a mathematical formula}83%, respectively for Data_100 and Data_137.</a>
<a href="#10" id="10">Regarding input data only, {a mathematical formula}|S||T| is 2.2 times bigger in Data_100 than in Data_137.</a>
<a href="#11" id="11">Thus, Data_100 instances have on average more available shifts per task than Data_137, but they use a significantly smaller percentage of these shifts in optimal solutions.</a>
<a href="#12" id="12">Therefore, finding a shift set which corresponds to an optimal solution may be more difficult.</a>
<a href="#13" id="13">As a second step, we investigate the homogeneity of shifts.</a>
<a href="#14" id="14">Basically, using {a mathematical formula}GCI instead of {a mathematical formula}GI aims at reducing the number of edges to obtain larger independent sets, hence a better filtering.</a>
<a href="#15" id="15">As a first step to measure the interest of {a mathematical formula}GCI, we evaluate the ratio {a mathematical formula}|ECI||EI|.</a>
<a href="#16" id="16">It shows that MIP model fails to solve about half of instances on both data sets: It is not able to provide either lower bounds or upper bounds ({a mathematical formula}100% gap).</a>
<a href="#17" id="17">However, if the purpose is to design an effective lower bounding procedure, it may be interesting to use a much higher value of k, which may reduce the gap to optimality with a small overhead.</a>
<a href="#18" id="18">Consequently, we compare {a mathematical formula}z ̲ L with {a mathematical formula}z ̲ r for two different settings of k: 40 and 1000.</a>
</body>
</html>