<html>
<head>
<meta name="TextLength" content="SENT_NUM:9, WORD_NUM:835">
</head>
<body bgcolor="white">
<a href="#0" id="0">On the other hand, from the theoretical perspective, we note that an even more abstract approach is possible: we may alternatively define an evaluation base independently of a formula, i.e., purely based on a structure {a mathematical formula}M= 〈 S ⋆ ,W,B 〉 : any (potentially infinite) sequence of window operators {a mathematical formula} ⊞ w with {a mathematical formula}w ∈ W will eventually not produce new streams.</a>
<a href="#1" id="1">Comparing LARS to linear temporal logic, we see that the temporal operators are clearly different, The temporal operators □ and ◇ in LARS have as counterparts the pairs {a mathematical formula}G,G − 1 and {a mathematical formula}F,F − 1 respectively, which allow one to address all positions in a path; the past time operators are indispensable for evaluation inside the path.</a>
<a href="#2" id="2">By this proposition, we can reduce model checking of a LARS formula Φ on an input stream {a mathematical formula}S=(T, Υ ), to model checking an ad-hoc PLTL formula constructed from Φ , M and the specific time point {a mathematical formula}t ∈ T, on a single path {a mathematical formula} Π (M).</a>
<a href="#3" id="3">An incremental program is a triple {a mathematical formula}(B,P,Q) consisting of three program parts: B describes static knowledge; P and Q are slices that depend on a parameter t. At each step t, the program grows by a new set {a mathematical formula}P[t], while {a mathematical formula}Q[t] is considered only temporarily at t. Relying on according composition of modules, model computation can then be carried out incrementally.</a>
<a href="#4" id="4">Compared to LARS, MTL does not have general window operators (merely interval-bounded versions of the LTL operators {a mathematical formula}G, {a mathematical formula}F respectively {a mathematical formula}G − 1, {a mathematical formula}F1 are available) but features all operators of LTL respectively PLTL; notably, sliding time-based windows of LARS with universal respectively existential formula evaluation correspond to MTL window operators; i.e.,{a mathematical formula} Informally, {a mathematical formula} ⊟ [0,a] Φ (respectively {an inline-figure}) checks whether Φ holds always (respectively at least once) within a steps back from the current time point respectively state; {a mathematical formula} ⊞ [0,b] Φ (respectively {an inline-figure}) is analogous for b steps forward.</a>
<a href="#5" id="5">The data complexity of LARS formulas and LARS programs (i.e., the formula Α respectively the program P is fixed and just varying the data stream D and the time point t is varied) coincides with the one of ground LARS formulas {a mathematical formula} Α − (respectively programs {a mathematical formula}P − ), as shown in Table 1.</a>
<a href="#6" id="6">The matching lower bounds, are obtained from: (a) arbitrary polynomial-time window functions, which implies {a mathematical formula}P-hardness of MC for fixed LARS formulas (b) the data complexity of disjunctive Datalog program; from the proofs in [52], it follows that under data complexity, model checking is co-{a mathematical formula}NP-complete; deciding classical model existence is {a mathematical formula}NP-complete; and deciding answer set existence is {a mathematical formula} Σ 2p-complete.</a>
<a href="#7" id="7">To show that LARS programs can express only regular languages, we first note that any propositional LARS formula Φ in which only windows {a mathematical formula} ⊞ i,j occur is first-order expressible, i.e., that there is a monadic first-order formula {a mathematical formula} Φ Φ (x) such that for any structure {a mathematical formula}M= 〈 S,W, ∅ 〉 , {a mathematical formula}S=(T, Υ ) and {a mathematical formula}t ∈ T, we have {a mathematical formula}M,S,t ⊩ Φ iff {a mathematical formula}S ⊨ Φ (t); this formula can be built inductively, using variables to access the window range, and by taking the distance of the time point t to the start and end of S, respectively, into account.Furthermore, it is well-known that answer set existence for a logic program P can be expressed by a sentence {a mathematical formula} Ψ (P) in second-order logic, see e.g.</a>
<a href="#8" id="8">In order to make sure that this initial segment is minimal, i.e., consists only of position 0, we use a new atom {a mathematical formula}s ′ and state that {a mathematical formula}s ′ must also form an initial segment in every model I, and moreover one that is contained in the segment of s:{a mathematical formula}{a mathematical formula}{a mathematical formula} To ensure the minimality of the segment for s, we add a constraint which excludes that the segment for {a mathematical formula}s ′ is a proper subsegment:{a mathematical formula} As {a mathematical formula}s ′ occurs only in the rules (44) – (47), minimality and supportedness of answer streams (Theorem 1, Theorem 2) imply that in any answer stream I of the resulting program {a mathematical formula}PA ′ for S at t, the atom {a mathematical formula}s ′ (and thus also s) must be present at position 0 and only there.Formally, it can be shown that {a mathematical formula}PA ′ has an answer stream for {a mathematical formula}S=(T, Υ ), {a mathematical formula}T=[0,t], at t iff S correctly encodes a string {a mathematical formula} Σ 0 Σ 1 ⋯ Σ t from {a mathematical formula} Σ ⁎ and A accepts {a mathematical formula} Σ 0 Σ 1 ⋯ Σ t.</a>
</body>
</html>