<html>
<head>
<meta name="TextLength" content="SENT_NUM:49, WORD_NUM:1888">
</head>
<body bgcolor="white">
<a href="#0" id="0">Conjectures in matrix theory, number theory, and graph theory are reported, together with an experiment in using conjectures to automate game play.</a>
<a href="#1" id="1">We include examples of conjectures in number theory, matrix theory, graph theory and the characterization of game positions.</a>
<a href="#2" id="2">And some of the graph theory conjectures would advance the lower bound theory of the independence number of a graph, a widely-studied NP-hard graph invariant.</a>
<a href="#3" id="3">We have also implemented an idea, suggested to us by Barry Mazur, to include existing theorems in the program; when used in this way the program is guaranteed to produce statements that are not implied by existing mathematical knowledge.</a>
<a href="#4" id="4">Simply put, the heuristic is to produce a considered mathematical statement if it is both true — with respect to some given examples (matrices, integers, graphs, etc.</a>
<a href="#5" id="5">The Sorcerer's Apprentice Problem is how to reduce the flood of potential conjectures to a useable or scannable number — how to design a program to produce just the most “ significant ” , “ interesting ” or useful statements?</a>
<a href="#6" id="6">The program cannot make any more conjectures than the number of objects being considered (stored in the program) — so the number of generated conjectures is fundamentally limited.</a>
<a href="#7" id="7">Each conjecture must be significant with respect to at least one object — each must provide better information about a stored object than any of the other conjectures.</a>
<a href="#8" id="8">When applied to the problem of finding bounds of invariants — in cases where bounds are of pre-existing research interest — and provided with examples (objects) where existing theory does not suffice to predict the value of the invariant for the example, a program implementing the Dalmatian heuristic will produce a conjecture.</a>
<a href="#9" id="9">Fajtlowicz reports that the conjectures in [1] were based on a database of some 600 graphs; the memory available on the computers of its day were a natural limitation on the number of objects that could be used by Graffiti.</a>
<a href="#10" id="10">That is, the inequality {a mathematical formula} Α ≤ Α 1+ Α 2 can be interpreted as, “ For every object {a mathematical formula}O, {a mathematical formula} Α (O) ≤ Α 1(O)+ Α 2(O). ” A conjectured upper bound u is only added to the database of conjectures if the bound passes the following two tests.</a>
<a href="#11" id="11">By design, the truth test guarantees that the program does not know a counterexample, and the significance test guarantees that each conjectured bound is “ stronger ” (gives a better bounding value) than any other — at least for a single object known to the program.</a>
<a href="#12" id="12">The order that potential lower bounds are considered corresponds to the iteration number in Table 1.</a>
<a href="#13" id="13">Expressions formed with the unary “ add 1 ” operator are never formed as the program stops after the ninth iteration, at which point the conjectures in the conjecture store exactly predict the value of {a mathematical formula} Π (x) for all objects x in {a mathematical formula}{5,16}.</a>
<a href="#14" id="14">This is true for all of the objects and is significant as this lower bound is better than the number_prime_factors lower bound for at least one of the known objects; so number_prime_factors is added to the conjectures store.</a>
<a href="#15" id="15">At this point, for each object x, the maximum of the conjectured bounds equals the actual value of {a mathematical formula} Π (x).</a>
<a href="#16" id="16">Pre-Dalmatian versions of Graffiti were also used to generate some interesting number theory conjectures including, for instance, a formula for {a mathematical formula} Π (x).</a>
<a href="#17" id="17">Fajtlowicz generated conjectures in domains other than graph theory largely to demonstrate that the heuristics that he invented were not limited to use in graph theory but were general ( “ domain independent ” ).</a>
<a href="#18" id="18">The generated expressions are tested for being true for the provided invariant values (truth test) and can then be handed over to an internal heuristic or can just be output.</a>
<a href="#19" id="19">Generate conjectures that are true for all stored objects and significant with respect to these objects and the previously stored conjectures.</a>
<a href="#20" id="20">In this case there is no possibility of improving the current conjectures — in the sense that no other conjectures can make better predictions about the values of the existing objects — exact predictive power for all objects has been achieved.</a>
<a href="#21" id="21">If conjectured upper bounds (for example) for an invariant Α are being generated then a conjectured bound {a mathematical formula} Α i in the conjectures store is significant, with respect to the stored objects, if and only if there is an object {a mathematical formula}O such that {a mathematical formula} Α i(O)<min ⁡ { Α j(O):j ≠ i}, that is, if and only if, there is an object {a mathematical formula}O where the bound gives a better predicted value for {a mathematical formula} Α (O) than any other conjectured bound does.</a>
<a href="#22" id="22">In the case of number theory conjectures, the conjectures can easily be checked by testing the conjectures for each integer from 1 up to an arbitrary large integer.</a>
<a href="#23" id="23">The program can never make more conjectures than the number of objects it has stored: the reason is exactly because each conjecture in the conjectures store must give a better bound for at least one stored object than any other conjecture does.If there were, for instance, two stored objects and three conjectured bounds, at least one of the conjectured bounds could not possibly be significant: at best one of the conjectures could be the best bound for one of the objects and another for the second object — but the third conjecture would have no possible remaining objects for which it could give the unique best predicted value; this conjecture would have been removed as insignificant.</a>
<a href="#24" id="24">The conjecture has been verified by computer for all integers up to at least {a mathematical formula}4 ⋅ 1014[53], and there are a large number of partial results and continuing interest.</a>
<a href="#25" id="25">Starting with a single (integer) object the program generated conjectures, found counterexamples, added these to the store of objects, and repeated the process.</a>
<a href="#26" id="26">Conjectured bounds for the domination number are of theoretical interest — bounds which are functions of efficiently computable invariants are also of practical interest — these can lead to speed up of domination number computations.</a>
<a href="#27" id="27">We used McKay's program geng[61] to generate all graphs up to some (small) specified order in a loop to automatedly find counterexamples to generated conjectures and, thus, automatedly improve the produced conjectures.</a>
<a href="#28" id="28">In our run generating upper bound conjectures for the domination number, the program ended up with four examples (found by this automated search for counterexamples) and the conjecture that the domination number of a graph is no more than its matching number.</a>
<a href="#29" id="29">Stephen Hedetniemi, a co-author of the standard reference on domination [57], points out that the second of these conjectures is false for {a mathematical formula}K1 and {a mathematical formula}K2 — we had only been including graphs of order {a mathematical formula}n ≥ 3 in our automated counterexample search — and trivially true for graphs or order {a mathematical formula}n ≥ 3.</a>
<a href="#30" id="30">We added Hedetniemi's counterexamples as objects to the program and generated a second round of conjectures for upper bounds for the domination number of a graph; the results are in Table 13.</a>
<a href="#31" id="31">The second and third conjectures are curious as they are trivially true; but, at some point in the conjecture-making process, there must have been graphs for which these bounds gave a larger predicted domination number than the previously conjectured bounds.</a>
<a href="#32" id="32">In this case our goal was to generate conjectured lower bounds for the independence number which are not consequences of existing (proved) lower bounds.</a>
<a href="#33" id="33">In this way, the program only produces conjectures that are mathematically significant in a precise sense: they will give better invariant value predictions for some objects than any known bounds will.</a>
<a href="#34" id="34">The upper bound theory for the independence number is surprisingly good: there is an efficiently computable upper bound for the independence number of a graph which can give very good estimates for the true value of this invariant: this is the famous Lovász number Θ of a graph.</a>
<a href="#35" id="35">We wanted to use larger graphs as potential counterexamples and here systematic generation is impossible: there are, for instance, approximately 10{sup:65} graphs of order 25.</a>
<a href="#36" id="36">These were generated, essentially, by choosing the order of the graph and, for each pair of vertices, flipping a coin to determine whether or not to include an edge between the vertices (the theory of random graphs is large and dates back to the 1950s [71]).</a>
<a href="#37" id="37">The first and third conjectures in Table 16 are interesting because they, in some sense, generalize the radius lower bound for the independence number of a graph (mentioned earlier, following a conjecture of Graffiti).</a>
<a href="#38" id="38">Instead of systematically generating all possible small counterexamples, or choosing random examples of various size objects, it might be useful to choose examples that are extremal with respect to one of the invariants in the formula for a conjectured bound.</a>
<a href="#39" id="39">That is, the statement {a mathematical formula}Q1 ∧ Q2 ⇒ P can be interpreted as, “ For every object {a mathematical formula}O, {a mathematical formula}Q1(O) ∧ Q2(O) ⇒ P(O). ” A conjectured sufficient condition Q is only added to the database of conjectures if the property passes the Truth and Significance tests.</a>
<a href="#40" id="40">Let {a mathematical formula}P be the set of objects that have property P. Necessary conditions for membership in {a mathematical formula}P define a super-class {a mathematical formula}N of {a mathematical formula}P. What is wanted are conjectures that make this super-class smaller and smaller.</a>
<a href="#41" id="41">Similarly, sufficient conditions for membership in {a mathematical formula}P define a sub-class {a mathematical formula}S of {a mathematical formula}P. What is wanted here are conjectures that make this sub-class larger and larger.</a>
<a href="#42" id="42">So once the object, main invariant, and other invariants are specified, and one or more data examples are provided, conjectured bounds for the main invariant can be generated; and, assuming we have the values of the other invariants, these conjectures can be used to make predictions about the value of the main invariant.</a>
<a href="#43" id="43">The attraction of Sage for this project stems from the fact that it is free, that it is easy-to-use, that it has a large number of built-in invariants for a variety of mathematical objects, and that other researchers can easily use our code.</a>
<a href="#44" id="44">It provides a method conjecture that — in its most basic form — takes three arguments: a list of objects, a list of invariants and a main invariant, that is, the invariant for which one wants to find a bound.</a>
<a href="#45" id="45">The fourth line specifies objects to be a list of graphs that will be used by the program when making conjectures — in this case the list is initialized with three complete graphs.</a>
<a href="#46" id="46">The conjecture function takes the lists of invariants and objects, together with a number specifying which of the invariants in the invariants list should be used as the main invariant; in this case, 0 is input, indicating that invariants[0] — namely, Graph.size — should be used as the main invariant.</a>
<a href="#47" id="47">In fact, {a mathematical formula}2×2 matrices turned out to be too special of a subclass of matrices to lead to good conjectures — other researchers quickly found {a mathematical formula}3×3 matrices that were counterexamples to many of these.</a>
<a href="#48" id="48">In this case it will become impossible to systematically generate any interesting class, and a researcher may experiment with choosing randomly generated matrices from a chosen class.</a>
</body>
</html>