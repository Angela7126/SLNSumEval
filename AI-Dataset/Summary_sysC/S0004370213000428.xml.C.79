<html>
<head>
<meta name="TextLength" content="SENT_NUM:26, WORD_NUM:1216">
</head>
<body bgcolor="white">
<a href="#0" id="0">In Vreeswijk ʼ s abstract argumentation systems[89], [9] arguments are restricted to have a finite set of premises, but the set of arguments is possibly infinite and infinite argumentation sequences (involving either finite or infinite sets of arguments) are used as a formal tool for extension evaluation, by introducing a notion of “ limit ” for infinite argumentation sequences.</a>
<a href="#1" id="1">To cope with this, in the OSCAR implementation described in [74], Pollock restricts the use of the temporal projection principle to a specific form of backward reasoning: the agent is interested in the value of a property at a specific time instant t and checks whether there are reasons to believe that the property had a certain value at an instant {a mathematical formula}t0<t.</a>
<a href="#2" id="2">If this is the case, the reason can be projected, with decreased strength, from {a mathematical formula}t0 to t. However explicit representations of infinite arguments are needed to go beyond this specific form of reasoning.</a>
<a href="#3" id="3">{a mathematical formula}exist Σ is the decision problem whose instances, {a mathematical formula} 〈 X,A 〉 , are accepted if and only if {a mathematical formula}E Σ ( 〈 X,A 〉 ) ≠ ∅ .</a>
<a href="#4" id="4">In particular, we have to notice the arousal of a problem not occurring in the finite case: given that an argumentation framework {a mathematical formula} 〈 X,A 〉 involving infinite sets can only be given through a finite encoding {a mathematical formula} Η ( 〈 X,A 〉 ), it must be validated that an encoding {a mathematical formula} Η ( 〈 X,A 〉 ) is indeed a valid description of someaf.</a>
<a href="#5" id="5">Thus the naive encoding of a set of attacks uses a unary{sup:10} form to describe the (indices) of the source and destination arguments involved in the attack with the symbol 1 used to separate these two components (in the absence of any attack {a mathematical formula}LA= ∅ ).</a>
<a href="#6" id="6">The issues identified with so-called naive representations in the preceding section largely stem from the following fact: given that encodings of arguments, {a mathematical formula}pi ∈ X are effectively achieved for free – that is, for all natural numbers k, {a mathematical formula}pk ∈ X and no further analysis is needed – the task of describing {a mathematical formula} 〈 X,A 〉 comes down to describing the (infinite) set {a mathematical formula}A.</a>
<a href="#7" id="7">In this way we can then present very general specifications of the attack structure that are conditioned solely in terms of the specific arguments in {a mathematical formula}X.</a>
<a href="#8" id="8">Thus a (possibly infinite) set of arguments, {a mathematical formula}X, corresponds to some regular language over a finite alphabet Σ .</a>
<a href="#9" id="9">We seek to develop formalisms by which the set of arguments (in {a mathematical formula}X) that “ attack ” in the standard sense of [37] some specified subset {a mathematical formula}S ⊆ X may be presented, i.e.</a>
<a href="#10" id="10">The immediate problem with allowing arbitrary usage of ⋅ and ∩ concerns the fact that, for expressions such as {a mathematical formula}p ⋅ q or {a mathematical formula}p ∩ q we cannot, in general, guarantee that the mappings {a mathematical formula}p ̲ ⋅ q ̲ or {a mathematical formula}p ̲ ∩ q ̲ are additive.</a>
<a href="#11" id="11">We now have the basic elements of our formal descriptive mechanism for infinite frameworks, the idea being that the set of arguments is specified as a regular language {a mathematical formula}X ⊆ Σ ⁎ and the attack relation is specified through an attack expression a.</a>
<a href="#12" id="12">In fact, given an element v of {a mathematical formula}X the set T of attackers of v might be defined as {a mathematical formula}T=a ̲ ({v}).</a>
<a href="#13" id="13">The expressions {a mathematical formula}a+ use the same basic elements as {a mathematical formula}AE( Σ ) plus the {a mathematical formula}rev() operator,{sup:16} which does not affect any of the desired properties.</a>
<a href="#14" id="14">The following properties, shown to be valid in the proof of Theorem 2, provide the basic elements to derive the expressions {a mathematical formula}a+ from {a mathematical formula}a ̲ .</a>
<a href="#15" id="15">In fact this problem does not arise: any finite af{a mathematical formula} 〈 X,A 〉 can be easily described via the mechanisms proposed in this paper.</a>
<a href="#16" id="16">Let us turn now to the specification of the additional finite attack relations {a mathematical formula}Ai,j ({a mathematical formula}i ≠ j) between subframeworks.</a>
<a href="#17" id="17">One obvious choice to describe this scheme would be the set {a mathematical formula} Σ ={A,B,C} so that{a mathematical formula} It is not too hard to see, however, that it is impossible to describe the required set of attacks via some {a mathematical formula}a ∈ AE({A,B,C}): for example suppose S is an infinite regular subset of {a mathematical formula}{Ai:i ⩾ 1}.</a>
<a href="#18" id="18">Then{a mathematical formula} Now while this is a regular language for any fixed subset of {a mathematical formula}{Ai:i ⩾ 1} given that it requires determining {a mathematical formula}min{i:Ai ∈ S} it is not possible to construct a general expression allowing this minimum to be computed.</a>
<a href="#19" id="19">First of all, for a logic program P, {a mathematical formula}GP denotes the set of all ground instances of clauses in P. For each literal h, the complement of h is denoted by {a mathematical formula}h ⁎ .</a>
<a href="#20" id="20">In order to provide an af specification for {a mathematical formula}AF(Q) we need first a dfa representing the infinite set of arguments {a mathematical formula}XQ and then a proper attack expression representing the relation {a mathematical formula}AQ.</a>
<a href="#21" id="21">Notice that, in general, formal grammars provide a process for proving that {a mathematical formula}w ∈ L(G) and that there is not, necessarily, a unique sequence of derivations under which {a mathematical formula}S ⇒ G ⁎ w.</a>
<a href="#22" id="22">Hence in the case {a mathematical formula}p= Σ we obtain{a mathematical formula} whereas for {a mathematical formula}p=I we have{a mathematical formula} Finally, since S is assumed regular to begin with, for each of the base case possibilities, we have {a mathematical formula}p ̲ (S) is also regular.Now inductively assume for some {a mathematical formula}k>0 and all attack expressions over Σ , q, with {a mathematical formula}size(q)<k the mapping given via {a mathematical formula}q ̲ is a reasonable attack function.</a>
<a href="#23" id="23">{a mathematical formula}a=b ⋅ K Σ (Fact 2.3){a mathematical formula} Recall that the quotient of a language {a mathematical formula}L1 wrt {a mathematical formula}L2 (denoted {a mathematical formula}L1/L2) is{a mathematical formula} It is easily seen that for {a mathematical formula}a=b ⋅ K Σ this leads to{a mathematical formula} That is, unless {a mathematical formula}u ∈ S has the form {a mathematical formula}p ⋅ q with {a mathematical formula}q ∈ K Σ , then {a mathematical formula}a ̲ +({u})= ∅ ; for {a mathematical formula}u ∈ S which is of the required form, it is necessary to identify which arguments these (with the {a mathematical formula}K Σ component removed, i.e.</a>
<a href="#24" id="24">replacing {a mathematical formula}p ⋅ q, {a mathematical formula}q ∈ K Σ with p) attack according to the specification b.Again, this case is completed by recalling that regular languages – which S and {a mathematical formula}K Σ are by definition – are closed under the quotient operator (see Fact 4 in Appendix A) and the inductive hypothesis which ensures that {a mathematical formula}b ̲ + preserves regularity.</a>
<a href="#25" id="25">The set of arguments attacked by some {a mathematical formula}y ∈ X ∖ Π a+(S) is just {a mathematical formula} Π a+(X ∖ Π a+(S)) and, hence, any argument that does not belong to this set, i.e.</a>
</body>
</html>