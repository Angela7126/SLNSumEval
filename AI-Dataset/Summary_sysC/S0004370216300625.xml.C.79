<html>
<head>
<meta name="TextLength" content="SENT_NUM:8, WORD_NUM:405">
</head>
<body bgcolor="white">
<a href="#0" id="0">This task can be understood as falling within the programming by optimization paradigm [34] in that it involves the design of software in which many design decisions have been deliberately left open during the development process (here exposed as parameters of SAT solvers) to be made automatically later (here by means of an automated algorithm configurator) in order to obtain optimized performance for specific use cases.</a>
<a href="#1" id="1">Parallel portfolios have since made practical impact, both in cases where the allocation of computational resources to algorithms in the portfolio is static [62], [76] and where the component solvers contained in a portfolio or the resources assigned to them can change over time [24].</a>
<a href="#2" id="2">A sequential portfolio solver must somehow select component solvers (which can result in making the wrong decision), while static parallel solvers run the entire portfolio in parallel and thus achieve nearly the same performance as the portfolio's virtual best solver.</a>
<a href="#3" id="3">Following established best practices (see [40]), we performed n independent runs of AC, obtained configured solvers {a mathematical formula}c(j) with {a mathematical formula}j ∈ {1 … n} and retained the configured solver {a mathematical formula}c ˆ which achieved the best performance on instance set I according to metric m. By t we denote the overall time budget available for producing a parallel portfolio solver.</a>
<a href="#4" id="4">While the sets of n independent configurator runs in Line 2 can be performed in parallel (as in Global), the choice of the best-performing configuration {a mathematical formula}c ˆ 1:i must be made after each iteration i, introducing a modest overhead compared to the cost of the actual configuration runs.</a>
<a href="#5" id="5">In a similar vein, some results in the literature indicate that the collaboration of SAT solvers via clause sharing performs better if the solvers use similar strategies, e.g., the same solver with a fixed configuration runs several times in parallel but with different seed (cf.</a>
<a href="#6" id="6">The first part of Table 7 summarizes the performance results for these solvers: first the sequential solvers in their default configurations (Default-SP), then the parallel solvers using clause sharing in their default configurations (Default-MP(8)+CS), and finally our ACPP solvers based on the component solvers of pfolioUZK.</a>
<a href="#7" id="7">Using our extended parHydrab method and a parallel solver with clause sharing, we were able to automatically generate an ACPP solver that outperformed pfolioUZK and reached the performance level of Plingeling(aqw), which is based on considerably more advanced solving strategies than are used in the baseline portfolio from pfolioUZK.</a>
</body>
</html>