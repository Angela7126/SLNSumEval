<html>
<head>
<meta name="TextLength" content="SENT_NUM:20, WORD_NUM:867">
</head>
<body bgcolor="white">
<a href="#0" id="0">Such problems can be alleviated to some extent through using control-based and agent-based approaches that plan for reconfiguration in distributed manner based on local information available in modules.</a>
<a href="#1" id="1">However, their underlying methods must mainly concern with keeping the connectedness of the modular robot during reconfiguration steps, considering convergence to the desired shape or behavior as a result of local interaction between modules, maintaining adaptability to the environmental changes, and exhibiting robustness to module failures.</a>
<a href="#2" id="2">The most central activity of a modular robot is to change its shape or morphology.</a>
<a href="#3" id="3">Such a change is the subject of the Self-Reconfiguration Problem (SRP), which emerged in the mid-1990s in parallel with evolution of modular robots hardware design.</a>
<a href="#4" id="4">Self-Reconfiguration is the process of transforming a modular robot from an initial configuration to a desired configuration through a set of primitive and module-level actions while the total number of modules is preserved, and Self-Reconfiguration Planning is the process of planning such sequence of actions.</a>
<a href="#5" id="5">Control-based methods of self-reconfiguration must be implemented with some considerations: a main issue in generating controllers is their Convergence to the goal configuration as they are usually developed based on local interactions and communications between modules.</a>
<a href="#6" id="6">The former looks at fixed points in the cell space and measures changes of those points, while the latter treats an MRS as a system of particles, and studies the motion for each particle.Distributed Planning:It is possible to fulfill the Flow operation by parallel execution of locomotion paths planned per each individual module: for instance, the PacMan algorithm by Butler and Rus [24] can be utilized for generating surface-moving systems, and is applicable to unit-compressible systems like the ‘ Crystalline ’ module, in which paths of modules are planned in parallel using the depth-first search strategy and path conflicts are resolved in the actuation phase to let modules flow among obstacles or even climb up them (also see the Gradient-based solution method in Section 2.2.2 for more details on PacMan).</a>
<a href="#7" id="7">Fitch and Butler [48] employed distributed dynamic programming for planning an individual locomotion path for each module, where modules use local constant-time search and a module-locking scheme in order to ensure physical integrity of the robot, while following their paths toward the goal of locomotion which has been specified by a simple bounding box.Hierarchical Planning:Flow can be considered as a two-level planning problem: at the higher level gross locomotion of the modular robot's body is planned, and at the lower level detailed local movements of modules, coordination of their actions and conflict resolution issues are addressed.</a>
<a href="#8" id="8">[1] in which at the higher level a parallel GA search is used for finding the most suitable morphology that a lattice based modular robot (particularly ‘ Crystalline ’ ) must assume during its Flow among obstacles toward a goal position.</a>
<a href="#9" id="9">The genome data structure in the proposed GA contains coordinates of modules in a grid environment, and the fitness function evaluates the Euclidean distance of the robot's center of mass to the destination position.</a>
<a href="#10" id="10">Since each module runs the same copy of the GA algorithm, the population can be divided among modules so that the planning is done in decentralized manner.</a>
<a href="#11" id="11">Once the next morphology of the modular robot is determined, the lower level plans motions of modules using a PacMan-like algorithm to transform the current morphology to the target morphology identified by the higher level.Reinforcement Learning:The RL method (discussed in Section 2.3.2) can also be utilized for exhibiting flow-like motions.</a>
<a href="#12" id="12">In order to realize a particular gait in modular robots it is necessary to characterize two basic elements of controller and synchronization methods.</a>
<a href="#13" id="13">In fact, a gait is a set of cyclic actions that need a controller to tell each individual module what action must be done at each time-step.</a>
<a href="#14" id="14">On the other hand, synchronization is crucial for creating harmony between movements of modules so that discrete movements of each module lead to a continuous and smooth gait.</a>
<a href="#15" id="15">In the following, we first cover various gait controllers developed for modular robots and then study their synchronization methods.</a>
<a href="#16" id="16">Regardless of the self-assembly system type, the most common self-assembly approach is to grow the final shape from a so-called ‘ seed module ’ , which is a dedicated module that initiates a Self-assembly operation and guides the growth process by attracting other modules.</a>
<a href="#17" id="17">The final configuration is then achieved as a result of interactions not only between the seed module and other modules, but also between semi-assembled structures (interaction products) and the modules in the environment.</a>
<a href="#18" id="18">Thus, it is crucial to devise methods that control the interactions between modules (including communication, motion, and connection) according to the state of modules and towards the final configuration so that the likelihood of reaching ‘ assembly yields ’ (the desired assemblies) is maximized.</a>
<a href="#19" id="19">In that work, the paths planned by {a mathematical formula}A ⁎ between vacant lattice positions in the goal configuration and modules located off those positions are automatically rewritten into a rule set Φ in such a way that the modular robot reconfigures into a goal configuration by decentralized execution of the rules.Finite State Machines (FSM):In this method each module is equipped with an internal logic that determines its docking behavior according to the sequence of states.</a>
</body>
</html>