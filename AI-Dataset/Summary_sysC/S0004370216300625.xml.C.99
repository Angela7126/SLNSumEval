<html>
<head>
<meta name="TextLength" content="SENT_NUM:10, WORD_NUM:393">
</head>
<body bgcolor="white">
<a href="#0" id="0">This task can be understood as falling within the programming by optimization paradigm [34] in that it involves the design of software in which many design decisions have been deliberately left open during the development process (here exposed as parameters of SAT solvers) to be made automatically later (here by means of an automated algorithm configurator) in order to obtain optimized performance for specific use cases.</a>
<a href="#1" id="1">Hence, all that is required by our ACPP methods is a sequential solver whose configuration space contains complementary configurations.</a>
<a href="#2" id="2">Parallel portfolios have since made practical impact, both in cases where the allocation of computational resources to algorithms in the portfolio is static [62], [76] and where the component solvers contained in a portfolio or the resources assigned to them can change over time [24].</a>
<a href="#3" id="3">A sequential portfolio solver must somehow select component solvers (which can result in making the wrong decision), while static parallel solvers run the entire portfolio in parallel and thus achieve nearly the same performance as the portfolio's virtual best solver.</a>
<a href="#4" id="4">Following established best practices (see [40]), we performed n independent runs of AC, obtained configured solvers {a mathematical formula}c(j) with {a mathematical formula}j ∈ {1 … n} and retained the configured solver {a mathematical formula}c ˆ which achieved the best performance on instance set I according to metric m. By t we denote the overall time budget available for producing a parallel portfolio solver.</a>
<a href="#5" id="5">Specifically, if the given solver has ℓ parameters, we treat the portfolio {a mathematical formula}c1:k as a single algorithm with {a mathematical formula} ℓ ⋅ k parameters inducing a configuration space of size {a mathematical formula}|C|k, and configure it directly.</a>
<a href="#6" id="6">As noted above, we identify a single configuration as the best of n independent runs of AC.</a>
<a href="#7" id="7">This way, we combine our automatic methods with the human expert knowledge inherent in existing clause sharing mechanisms to boost performance even further.</a>
<a href="#8" id="8">To add parallel solvers as components in our ACPP approach, we consider each of them by adding multiple copies of the same solver, where each copy represents one thread of the parallel solver.</a>
<a href="#9" id="9">The first part of Table 7 summarizes the performance results for these solvers: first the sequential solvers in their default configurations (Default-SP), then the parallel solvers using clause sharing in their default configurations (Default-MP(8)+CS), and finally our ACPP solvers based on the component solvers of pfolioUZK.</a>
</body>
</html>