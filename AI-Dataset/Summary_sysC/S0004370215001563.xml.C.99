<html>
<head>
<meta name="TextLength" content="SENT_NUM:14, WORD_NUM:848">
</head>
<body bgcolor="white">
<a href="#0" id="0">A key point is that, in synthesizing a plan for a particular transition, one needs to take into account that the resulting state of the domain must not only satisfy the corresponding achievement goal assertion, but also must allow for the existence of plans for each possible next transition, and this must hold again after such plans, and so on.</a>
<a href="#1" id="1">By combining declarative and procedural approaches to behavior specification, together with automatic synthesis techniques, the agent planning program approach has the potential to provide convenient and powerful specification of behavior in complex scenarios.</a>
<a href="#2" id="2">{a mathematical formula} Δ ⊆ V× Φ (P)× Φ (P)× Φ (P)×V is the transition relation of {a mathematical formula}P, where {a mathematical formula} Φ (P) stands for the set of all boolean formulas built from the set of propositions P. A transition {a mathematical formula} 〈 v, Γ , Ψ , Φ ,v ′ 〉 ∈ Δ — also {a mathematical formula} 〈 v, 〈 Γ , Ψ , Φ 〉 ,v ′ 〉 ∈ Δ or {a mathematical formula}v → Γ : Ψ , Φ v ′ in {a mathematical formula}P for legibility — is used to denote that whenever the guard Γ holds (in the domain), the agent planning program {a mathematical formula}P may legally move from state v to state {a mathematical formula}v ′ by “ achieving Φ while maintaining Ψ . ” □</a>
<a href="#3" id="3">The idea is that when the planning program and the domain are in states v and s (initially {a mathematical formula}v0 and {a mathematical formula}s0), respectively, the agent is allowed to pursue any enabled (i.e., whose guard holds true in s) planning program transition {a mathematical formula}v → Γ : Ψ , Φ v ′ in {a mathematical formula}P. However, being declarative assertions, such transition are not directly executable and actual realizations are required for them.</a>
<a href="#4" id="4">As a result of the nondeterminism of drive, after executing the first action, the tank level can be either low or full.</a>
<a href="#5" id="5">Consequently, after the plan is executed (walk is not affected by the fuel level), the domain can be in two possible states, i.e., either {a mathematical formula}{MyLoc(dept),CarLoc(lot),Fuel(full)} or {a mathematical formula}{MyLoc(dept),CarLoc(lot),Fuel(low)}.</a>
<a href="#6" id="6">Thus, in order to realize the planning program, a (HT-) plan must be defined for each of such states.</a>
<a href="#7" id="7">In the rest of this section, for technical convenience, an action is represented as a triple {a mathematical formula} 〈 Pre,Eff+,Eff − 〉 where Pre is a set of propositions representing the action preconditions, and {a mathematical formula}Eff+/ − is a set of propositions representing the action positive/negative effects.</a>
<a href="#8" id="8">Like in classical planning [46], under the closed world assumption, a state is specified by a set of propositions, an action {a mathematical formula}a= 〈 Pre,Eff+,Eff − 〉 is said to be executable in a domain state s if {a mathematical formula}Pre ⊆ s, and the domain state {a mathematical formula}s ′ obtained by executing a in state s is {a mathematical formula}s ∖ Eff − ∪ Eff+.</a>
<a href="#9" id="9">Starting from an open configuration (called open pair in the algorithm) {a mathematical formula} 〈 s,v 〉 , where s is a domain state and v is a planning program state (initially {a mathematical formula}s=s0 and {a mathematical formula}v=v0), for each transition d outgoing from v such that the guard of d holds in s, {a mathematical formula}RealizePlanProg constructs a plan Π realizing d from s. Then, the algorithm progresses the states of {a mathematical formula}D and {a mathematical formula}P (according to {a mathematical formula} Π (s) and d, respectively), possibly generating a new open pair {a mathematical formula} 〈 s ′ ,v ′ 〉 to process similarly.</a>
<a href="#10" id="10">It is worth noting that for planning program structures including loops, even when sets {a mathematical formula}ST and {a mathematical formula}AT are empty, the planning problems with PESs that are solved during the execution of {a mathematical formula}RealizePlanProg are interdependent in the sense that the solution of a planning problem associated with a transition incoming to a {a mathematical formula}P-state v takes into account the solution of the planning problems associated with the transition(s) outgoing from v, as it should (preferably) enable the reuse of the plans already computed for the outgoing transitions (this is the purpose of PESs).</a>
<a href="#11" id="11">The number of not interdependent planning problems is always (at most) the number of program states, i.e., the number of planning problems with an empty set of PESs that are constructed during the execution of {a mathematical formula}RealizePlanProg.</a>
<a href="#12" id="12">Therefore, the average number of solved interdependent planning problems can be derived by subtracting the number of program states from the data in Table 3.</a>
<a href="#13" id="13">Since the usage of {a mathematical formula}Tabu(v) in subroutine {a mathematical formula}Plan prevents the generation of any plan reaching an end state {a mathematical formula}s ∈ Tabu(v), {a mathematical formula}s ′ ∉ Tabu(v), and {a mathematical formula}Plan can generate a valid plan for every solvable planning problem in the input domain ({a mathematical formula}Plan is complete), {a mathematical formula}Plan cannot generate failure when it realizes transition d from {a mathematical formula} 〈 s0,v0 〉 (lines 10 – 11 of {a mathematical formula}RealizePlanProg).</a>
</body>
</html>