<html>
<head>
<meta name="TextLength" content="SENT_NUM:13, WORD_NUM:635">
</head>
<body bgcolor="white">
<a href="#0" id="0">It is well known that, for sufficiently large m, {a mathematical formula}hm delivers perfect goal distance estimates: simply set m to the number of state variables, reasoning over all relevant conjunctions.</a>
<a href="#1" id="1">We find that the success of our techniques depends on the extent of three structural properties of the input planning task: conflict identification, the ability of forward search to quickly find conflicts and thus enable the learning in the first place; effective learning, the ability to recognize dead-ends with small conjunction sets C; and generalization, the ability of {a mathematical formula}uC to detect states {a mathematical formula}s ′ it was not refined on.</a>
<a href="#2" id="2">For unsolvable benchmarks, we also evaluate the usefulness of the learned conjunction sets C as unsolvability certificates – a role they are suited to in principle, given they are efficiently verifiable (polynomial time in {a mathematical formula}|C|), while potentially exponentially smaller than the state space itself.</a>
<a href="#3" id="3">This is not mandatory in theory – the dead-end detection power of the learned clauses is dominated by that of {a mathematical formula}uC – but can be useful in practice, as it can reduce the number of calls to {a mathematical formula}uC and hence the runtime overhead.</a>
<a href="#4" id="4">To identify the clause Φ , we minimize the inverse state {a mathematical formula}F ∖ s – the set of facts false in s – to obtain a minimal reason for {a mathematical formula}uC(s)= ∞ .</a>
<a href="#5" id="5">In the present case, the refinement algorithm – precisely, “ neighbors refinement ” which will be explained in Section 5.2 – extends C by a single atomic conjunction, {a mathematical formula}c={t(l2),f(1)}.</a>
<a href="#6" id="6">The only difference to the standard algorithms then lies in the dead-end pruning, (a) via {a mathematical formula}u(s) at node expansion time, (b) via {a mathematical formula}u(s ′ ) at node generation time, and (c) via a call to the {a mathematical formula}CheckAndLearn() procedure after state expansion.</a>
<a href="#7" id="7">In what follows, like in Equation (1) we use {a mathematical formula}hC(s,G) to denote the {a mathematical formula}hC value of subgoal fact set G, i.e., the approximated cost, given the {a mathematical formula}hC relaxation of achieving G from s. Correspondingly, we use {a mathematical formula}h ⁎ (s,G) to denote the real cost of achieving G from s. The {a mathematical formula}hC recursion path on a current subgoal G is cut off by identifying a small conjunction {a mathematical formula}x ⊆ G that cannot be achieved with action sequences of length at most {a mathematical formula}hC(s,G).</a>
<a href="#8" id="8">In other words, we aim at obtaining a minimal reason for {a mathematical formula}uC(s)= ∞ (similarly as done for failed “ obligations ” in property-directed reachability [14]).</a>
<a href="#9" id="9">Omitting implementation details, we essentially store the dynamic programming table (an index from atomic conjunctions into {a mathematical formula}{0, ∞ }) of the previous iteration, identify the table cells changing from ∞ to 0 due to the inclusion of p, and propagate these changes.</a>
<a href="#10" id="10">For ordering children nodes in DFS, we focus on an ordering by smaller value of the delete relaxation heuristic {a mathematical formula}hFF[41], which turns out to be beneficial for both, finding plans and (to a lesser degree) proving unsolvability.</a>
<a href="#11" id="11">Observe that the only reason for this is generalization, i.e., refinements of {a mathematical formula}uC on states s leading to pruning on states other than s. Without generalization, the search spaces would be identical, including tie-breaking.</a>
<a href="#12" id="12">Consider now part (B) of Table 3, which shows data supporting a performance analysis with respect to the three prerequisites for online learning to work well: (1) conflict identification, i.e., the ability of forward search to find conflicts and thus enable the learning in the first place; (2) effective learning, i.e., the ability of recognizing dead-ends with small conjunction sets C; (3) strong generalization, i.e., the ability of {a mathematical formula}uC to detect states {a mathematical formula}s ′ it was not trained on.</a>
</body>
</html>