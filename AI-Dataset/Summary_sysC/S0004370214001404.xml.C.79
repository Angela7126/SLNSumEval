<html>
<head>
<meta name="TextLength" content="SENT_NUM:52, WORD_NUM:2071">
</head>
<body bgcolor="white">
<a href="#0" id="0">We will first discuss the theoretical underpinnings of this approach and then continue with an introduction to the CEGARTIX system [21] and the ArgSemSAT system [22], which both rely on iterative calls to SAT solvers for argumentation semantics of high complexity (i.e., being located on the second level of the polynomial hierarchy).</a>
<a href="#1" id="1">The figure is complete in the sense that if there is no arrow from semantics Σ to semantics Τ , then there is some AF F such that {a mathematical formula} Σ (F) ⊈ Τ (F).</a>
<a href="#2" id="2">For all semantics Σ we introduced here, except stable semantics, it holds that for any AF F we have {a mathematical formula} Σ (F) ≠ ∅ .</a>
<a href="#3" id="3">Finally, we also consider the problem {a mathematical formula}Ver Σ (S,F) of verifying a given extension, i.e., testing whether a given set S is a Σ -extension of F. This problem typically occurs as a subroutine of a reasoning procedure.</a>
<a href="#4" id="4">For preferred semantics, F has a single extension {a mathematical formula}Enumprf(F)={{a,d}}, {a mathematical formula}Countprf(F)=1, and thus credulous and skeptical acceptance coincide (e.g., {a mathematical formula}Credprf(a,F)=Skeptprf(a,F)=yes).</a>
<a href="#5" id="5">The class {a mathematical formula} Σ 2P=NPNP thus denotes the set of problems which can be decided by a non-deterministic polynomial time algorithm that has (unrestricted) access to an NP-oracle.</a>
<a href="#6" id="6">From a computational point of view, we assure that this reduction is efficiently computable, i.e., achievable in polynomial time, and that the answer for the original problem instance can be immediately obtained from the answer to the new problem instance.</a>
<a href="#7" id="7">The basis of propositional logic is a set of propositional variables {a mathematical formula}P, to which we also refer to as atoms.</a>
<a href="#8" id="8">The first conjunction in (1) ensures that the resulting set of arguments is conflict-free, that is, whenever we accept an argument a (i.e., {a mathematical formula}va evaluates to true under a model), all its attackers cannot be selected any further.</a>
<a href="#9" id="9">Likewise, we define a renaming for the attack relation as {a mathematical formula}R ′ ={(a ′ ,b ′ )|(a,b) ∈ R}.</a>
<a href="#10" id="10">For two variables we have four different cases, which correspond to the four truth values: {a mathematical formula}{p ⊕ ,p ⊖ } ⊆ I is interpreted as assigning inconsistent to p, true (resp.</a>
<a href="#11" id="11">For an AF {a mathematical formula}F=(A,R) the following notion of correspondence holds: Let the set of atoms evaluated to true under the four-valued interpretation be {a mathematical formula}Mt={p|p ⊕ ∈ M,p ⊖ ∉ M}, then {a mathematical formula}Enumprf(F) ≅ {Mt|M ⊨ prfA,RL}.</a>
<a href="#12" id="12">Utilizing the expressive power of quantifiers and the labeling approach, the authors of [19] also encode a range of other semantics, for instance semi-stable reasoning, where one can apply the same idea as outlined above, but instead of maximizing the arguments that are in, the arguments that are labeled undecided are minimized.</a>
<a href="#13" id="13">This is, for instance, the case with skeptical acceptance under preferred semantics where the corresponding decision problem is {a mathematical formula} Π 2P complete.</a>
<a href="#14" id="14">skeptical acceptance of an argument under preferred semantics one requires in general an exponential number of calls to the SAT solver (under standard complexity theoretic assumptions).</a>
<a href="#15" id="15">The formula {a mathematical formula} Ψ I incorporates the model I and states that a model of it must still correspond to an admissible set, but also has to be a superset of the current one, specified by I.</a>
<a href="#16" id="16">In case we cannot add a to the admissible set, we have found a preferred extension without a, hereby refuting its skeptical acceptance in F. In the former case (I does not represent a preferred extension) we strengthen the main query Φ by adding {a mathematical formula} Γ I in line 7, stating that at least one argument currently not accepted in I must be accepted from now on.</a>
<a href="#17" id="17">The condition of the first loop is satisfied as there exist the admissible sets ∅ , {a mathematical formula}{a}, {a mathematical formula}{d} and {a mathematical formula}{a,d} in F. The algorithm now non-deterministically selects one of the admissible sets.</a>
<a href="#18" id="18">The second while loop then creates a subset maximal admissible set (excluding b) in two iterations, say first adding a and then d. As {a mathematical formula}{a,d} is now subset maximal, the second loop terminates.</a>
<a href="#19" id="19">If the inner while loop terminates, then the corresponding preferred labeling/extension is added to the solution set {a mathematical formula}S. In line 8 we exclude smaller complete labelings from subsequent iterations.</a>
<a href="#20" id="20">For example, solutions that correspond to conflict-free sets can be obtained by defining a constraint for each pair of arguments a and b with {a mathematical formula}(a,b) ∈ R, where the two variables may not be set to 1 at the same time.</a>
<a href="#21" id="21">Thus, for preferred semantics, the authors in [28] propose an approach that iteratively computes admissible/complete extensions and adds constraints to exclude certain sets, such that one finally obtains the preferred extensions.</a>
<a href="#22" id="22">We fix a countable set {a mathematical formula}U of (domain) elements, also called constants, and suppose a total order < over the domain elements.</a>
<a href="#23" id="23">Besides disjunctive and normal programs, we consider here the class of optimization programs, i.e., normal programs which additionally contain #minimize statements{a mathematical formula} where {a mathematical formula}li is a literal, {a mathematical formula}wi an integer weight and {a mathematical formula}Ji an integer priority level.</a>
<a href="#24" id="24">{a mathematical formula}Gr( Π ) is the set of rules r Τ obtained by applying, to each rule {a mathematical formula}r ∈ Π , all possible substitutions Τ from the variables in r to elements of {a mathematical formula}U Π .</a>
<a href="#25" id="25">For a program Π , we denote the set of its answer sets by {a mathematical formula}AS( Π ).</a>
<a href="#26" id="26">Then, M is a collection of relations of the form {a mathematical formula} ⊆ Jw for priority levels J and weights w. A standard answer set (i.e., not taking the minimize statements into account) Y of Π dominates a standard answer set X of Π w.r.t.</a>
<a href="#27" id="27">For an AF {a mathematical formula}F=(A,R), we define{a mathematical formula} We have to guess candidates for the selected type of extensions and then check whether a guessed candidate satisfies the corresponding conditions, where default negation is an appropriate concept to formulate such a guess within a query.</a>
<a href="#28" id="28">To compute the preferred extensions of an argumentation framework, we will use the saturation technique as follows: Having computed an admissible set S (characterized via predicates {a mathematical formula}in( ⋅ ) and {a mathematical formula}out( ⋅ ) using encoding {a mathematical formula} Π adm(F ˆ )), we perform a second guess with new predicates, say {a mathematical formula}inN( ⋅ ) and {a mathematical formula}outN( ⋅ ), to represent a guess {a mathematical formula}T ⊃ S.</a>
<a href="#29" id="29">In order to check whether the first guess characterizes a preferred extension, we have to ensure that no guess of the second form (i.e., via {a mathematical formula}inN( ⋅ ) and {a mathematical formula}outN( ⋅ )) characterizes an admissible set.</a>
<a href="#30" id="30">Let us for the moment also assume that predicates eq (rule (22)) and {a mathematical formula}undefeated( ⋅ ) (rule (24)) are defined (we give the additional rules for those predicates below in the modules {a mathematical formula} Π eq and {a mathematical formula} Π undefeated) and provide the following information:</a>
<a href="#31" id="31">In other words, we have not derived fail if {a mathematical formula}T ⊃ S and T is admissible in F. By definition, S then cannot be a preferred extension of F.</a>
<a href="#32" id="32">Basically, these predicates would be easy to define, but as we have seen in the discussion above, default negation plays a central role in the saturation technique (recall the functioning of {a mathematical formula} ← notfail).</a>
<a href="#33" id="33">With these predicates at hand, we can now formally define the module for preferred extensions,{a mathematical formula} Then, for any AF F, the answer sets of {a mathematical formula} Π prf(F ˆ ) are in a one-to-one correspondence with the preferred extensions of F, i.e.</a>
<a href="#34" id="34">Usually, when one uses an ASP program, like {a mathematical formula} Π prf for preferred semantics, for an AF F, the ASP solver returns all answer sets of the program which correspond to all preferred extensions of F. For credulous or skeptical acceptance, one uses the respective reasoning problems of the ASP solver, which are sometimes referred to as brave or cautious reasoning.</a>
<a href="#35" id="35">In [98] MCSes are applied to solve reasoning problems for semi-stable semantics by encoding the range of a set as satisfied clauses, and techniques for computing backbones are utilized to enhance the efficiency of the algorithms.</a>
<a href="#36" id="36">Here, one receives a system of equations where each argument is represented by a distinct variable with a domain of real numbers in the interval {a mathematical formula}[0,1].</a>
<a href="#37" id="37">This strategy prevents the algorithm from considering all the (relatively small) admissible sets as candidates for preferred extension like other algorithms do (compare Algorithm 4).</a>
<a href="#38" id="38">When applying the algorithm to an AF {a mathematical formula}F=(A,R), it first initializes the labeling {a mathematical formula}L such that each argument is labeled with in, i.e., {a mathematical formula}Lin=A, and the set {a mathematical formula}SL of candidate solutions only contains the labeling {a mathematical formula}( ∅ , ∅ ,A), corresponding to the empty set.</a>
<a href="#39" id="39">Instead, it exploits the observation that a complete labeling {a mathematical formula}L is a preferred labeling iff there is no subset S of {a mathematical formula}Lundec such that the set {a mathematical formula}Lin ∪ S is admissible.</a>
<a href="#40" id="40">Secondly, in [36] the authors provide a smart traversal of the search space such that one can avoid deleting sets from {a mathematical formula}SL, i.e., in each step one can decide whether the current candidate is preferred or not, by only using previously computed preferred labelings (see Algorithm 4).</a>
<a href="#41" id="41">Here we have only considered the case of preferred semantics, but for most of the semantics labeling-based algorithms have been proposed in the literature: an algorithm for grounded semantics is given in [35]; an algorithm for admissible labelings can be easily obtained from Algorithm 4 (by dropping the ⊆ -maximality test in line 14); for complete semantics one can adapt Algorithm 3; for stable semantics, see [35]; algorithms for semi-stable and stage semantics can be found in [104], [106], [35].</a>
<a href="#42" id="42">Now let us consider a game that allows us, given an AF {a mathematical formula}F=(A,R) and argument {a mathematical formula}a ∈ A, to prove whether a is contained in some preferred extension of F (or equivalently in some admissible set).</a>
<a href="#43" id="43">Thus, we define an {a mathematical formula}X>t-restricted admissible set S for a sub-framework {a mathematical formula}F ≥ t such that first S has to be conflict-free and second it has to defend itself against the arguments in {a mathematical formula}X>t ∖ S.</a>
<a href="#44" id="44">So the {a mathematical formula}X>t-restricted admissible sets for a sub-framework {a mathematical formula}F ≥ t are all the sets that might become admissible in a framework {a mathematical formula}F ≥ t ′ for some node {a mathematical formula}t ′ above in the tree decomposition.</a>
<a href="#45" id="45">We define so-called colorings that allow us to store information of relationships between arguments in {a mathematical formula}X ≥ t solely by assigning colors to arguments in {a mathematical formula}Xt.</a>
<a href="#46" id="46">Given a coloring C for node t, we define the extensions of C, {a mathematical formula}et(C), as the collection of {a mathematical formula}X>t-restricted admissible sets S for {a mathematical formula}F ≥ t that satisfy the following conditions for each {a mathematical formula}a ∈ Xt:{a mathematical formula} If {a mathematical formula}et(C) ≠ ∅ , C is called a valid coloring for t.</a>
<a href="#47" id="47">In each node we use our data structure of colorings and compute all valid colorings C for every node t. As shown in [112], there exists a one-to-one mapping between the extensions of C, {a mathematical formula}et(C), and the {a mathematical formula}X>t-restricted admissible sets for {a mathematical formula}F ≥ t.</a>
<a href="#48" id="48">Based on the definition of the join operator their combination results in a coloring C with {a mathematical formula}C(b)=out and {a mathematical formula}C(c)=out which represents one {a mathematical formula}X>t2 (or {a mathematical formula}{a,d,e})-restricted admissible set for {a mathematical formula}F ≥ t2, namely {a mathematical formula}{a,d}.</a>
<a href="#49" id="49">It is sufficient to calculate the number of {a mathematical formula}X>t-restricted admissible sets that are represented by the respective coloring immediately during the bottom-up traversal.</a>
<a href="#50" id="50">Credulous acceptance of an argument x can be decided by storing an additional flag together with each coloring: In case {a mathematical formula}C(x) for a coloring C is set to in, C is marked.</a>
<a href="#51" id="51">As preferred extensions are subset-maximal admissible sets in order to guarantee subset maximality one can use pairs {a mathematical formula}(C, Γ ) as a data structure within a node t instead of colorings.</a>
</body>
</html>