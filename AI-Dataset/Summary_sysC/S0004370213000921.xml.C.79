<html>
<head>
<meta name="TextLength" content="SENT_NUM:14, WORD_NUM:561">
</head>
<body bgcolor="white">
<a href="#0" id="0">In the greedy mode, the pickVar functions prefer variables whose flips can decrease the number of falsified clauses (or the total weight of falsified clauses in clause weighting SLS algorithms); in the diversification mode, they tend to better explore the search space and avoid local optima, usually using randomized strategies and exploiting diversification properties of variables such as age and flip count to pick a variable for this aim.</a>
<a href="#1" id="1">Generally, for a formula F, we use {a mathematical formula}cost(F, Α ) to denote the number of falsified clauses under an assignment Α .</a>
<a href="#2" id="2">In dynamic local search algorithms which use clause weighting techniques, however, {a mathematical formula}cost(F, Α ) denotes the total weight of all falsified clauses under an assignment Α .</a>
<a href="#3" id="3">Based on the CC strategy, it is natural to define the concept of configuration changed decreasing variables, which are considered to be good candidate variables for flipping and should be preferable than other variables.</a>
<a href="#4" id="4">To implement the CC strategy, we employ an array confChange, whose element is an indicator for a variable — {a mathematical formula}confChange(x)=1 means the configuration of variable x has been changed since the last time x was flipped; and {a mathematical formula}confChange(x)=0 on the contrary.</a>
<a href="#5" id="5">More importantly, we propose a new variable property called subscore, and utilize it to break ties in CCApaws, resulting in the algorithm CCAsubscore, which proves very efficient for random k-SAT with {a mathematical formula}k>3.</a>
<a href="#6" id="6">To demonstrate the detailed performance of CCASat on random k-SAT instances with various k ({a mathematical formula}k=3,4,5,6,7), we report in Table 13 the number of solved instances for each solver on each k-SAT.</a>
<a href="#7" id="7">A recent local search solver called FrwCB can solve random 3-SAT instances at {a mathematical formula}r=4.2 with up to 4 million variables within reasonable time, but its performance on those with ratio 4.267 is worse than that of CCASat [30].</a>
<a href="#8" id="8">The Survey Propagation (SP) algorithm [7], which is extremely good at solving random 3-SAT instances, can solve random 3-SAT instances at {a mathematical formula}r=4.2 with up to 10 million variables [35], but it fails to converge on those with ratio up to 4.267, or before that [7].</a>
<a href="#9" id="9">In this case, the configuration for x is considered changed ({a mathematical formula}confChange(x)=1) according to our implementation, but it is not really changed since the true value of all x ʼ s neighbors are the same as the last time when x was flipped.</a>
<a href="#10" id="10">In this naive implementation, the CC strategy needs {a mathematical formula}O( Δ (F)) for both storing and checking the configuration for a variable.</a>
<a href="#11" id="11">Therefore, the worst complexity per step for the CC strategy under the naive implementation (which needs to check the configuration for the candidate variables and store the configuration for the flipped variable) is {a mathematical formula}O( Δ (F)n)+O( Δ (F))=O( Δ (F)n).</a>
<a href="#12" id="12">For the approximate implementation in this work, in each step, the algorithm first scans the CCDVar stack to remove those variables that are no longer CCD; then it updates the confChange values for the flipping variable x and each {a mathematical formula}y ∈ N(x), and also adds those variables that become CCD from among {a mathematical formula}N(x) into the CCDVar stack.</a>
<a href="#13" id="13">According to the above proposition, in order to make a random 3-SAT formula be evaluated true, at least half of the clauses ({a mathematical formula}(2 − 32)m=m2) should be critical, i.e., having only one true literal.</a>
</body>
</html>