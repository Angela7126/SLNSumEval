<html>
<head>
<meta name="TextLength" content="SENT_NUM:14, WORD_NUM:647">
</head>
<body bgcolor="white">
<a href="#0" id="0">Semantic Based Regularization [6] is a framework for integrating logic constraints within kernel machines, by turning them into real-valued constraints using appropriate transformations (T-norms).</a>
<a href="#1" id="1">The resulting optimization problem is no longer convex in general, and they suggest a stepwise approach adding constraints in an incremental fashion, in order to solve progressively more complex problems.</a>
<a href="#2" id="2">This is actually the main focus of these approaches, and the reason why they are less suitable for solving the latter problem when the search space becomes strongly disconnected.</a>
<a href="#3" id="3">As with most structured-output approaches over which it builds, LMT is currently limited to the task of finding an optimal configuration, which in a probabilistic setting corresponds to generating the most probable explanation.</a>
<a href="#4" id="4">Overall, for the scope of this paper, it is important to highlight the fact that OMT solvers are available which, thanks to the underlying SAT and SMT technologies, can handle problems with a large number of hybrid variables (in the order of thousands, at least for the {a mathematical formula}LRA theory).</a>
<a href="#5" id="5">To this extent, we notice that the underlying theories and {a mathematical formula}T-solvers provide the meaning and the reasoning capabilities for specific predicates and function symbols (e.g., the {a mathematical formula}LRA-specific symbols “ ≥ ” and “ + ” , or the {a mathematical formula}AR-specific symbols “ read(...) ” , “ write(...) ” ) that would otherwise be very difficult to describe, or to reason over, with logic-based automated reasoning tools — e.g., traditional first-order theorem provers cannot handle arithmetical reasoning efficiently — or with arithmetical ones — e.g., DLP, ILP, MILP, LGDP tools [41], [42], [43] or CLP tools [44], [45], [46] do not handle symbolic theory-reasoning on theories like {a mathematical formula}EUF or {a mathematical formula}AR.</a>
<a href="#6" id="6">First, the problem involves a mixture of numerical variables (coordinates, sizes of block 2) and Boolean variables, along with hard rules that control the feasible space of the optimization procedure (conditions (i) and (ii)), and costs — or soft rules — which control the shape of the optimization landscape.</a>
<a href="#7" id="7">Similarly, we refer to the cost of a rational-valued constraint {a mathematical formula} Φ k as {a mathematical formula}ck(I,O) ∈ Q.</a>
<a href="#8" id="8">The feature space representation of an object {a mathematical formula}(I,O) is given by the feature vector{a mathematical formula} Ψ (I,O), which is a function of the constraints.</a>
<a href="#9" id="9">Each soft constraint {a mathematical formula} Φ k has an associated finite weight {a mathematical formula}wk ∈ Q (to be learned from the data), while hard constraints have no associated weight.</a>
<a href="#10" id="10">Learning can be expressed as the problem of finding the weights w that minimize the per-instance error {a mathematical formula} Ξ i and the model complexity [23]:{a mathematical formula} Here the constraints require that the compatibility between any input {a mathematical formula}Ii and its corresponding correct output {a mathematical formula}Oi is always higher than that with all wrong outputs {a mathematical formula}O ′ by a margin, with {a mathematical formula} Ξ i playing the role of per-instance violations.</a>
<a href="#11" id="11">The CP algorithm is generic, meaning that it can be adapted to any structured prediction problem as long as it is provided with: (i) a joint feature space representation Ψ of input – output pairs (and consequently a compatibility function f); (ii) an oracle to perform inference, i.e.</a>
<a href="#12" id="12">In order to encode the set of constraints {a mathematical formula}{ Φ k} that underlie both the learning and the inference problems, it is convenient to first introduce a background knowledge of predicates expressing facts about the relative positioning of blocks.</a>
<a href="#13" id="13">The hard constraints represent the fact that the output O should be a valid block within the bounding box (all the constraints {a mathematical formula} Φ k are implicitly conjoined):{a mathematical formula} Then we require the output block O to “ touch ” the input block I:{a mathematical formula} Note that whenever this rule is satisfied, both conditions (i) and (ii) of the toy example hold, i.e.</a>
</body>
</html>