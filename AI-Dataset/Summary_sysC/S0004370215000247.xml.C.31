<html>
<head>
<meta name="TextLength" content="SENT_NUM:36, WORD_NUM:789">
</head>
<body bgcolor="white">
<a href="#0" id="0">Constraints in Ψ specify restrictions over T that must be satisfied during the planning process and by the solution.</a>
<a href="#1" id="1">We refer to a task network over {a mathematical formula}Tp as a primitive task network.</a>
<a href="#2" id="2">The set of all task networks over {a mathematical formula}Tn is denoted as TN.</a>
<a href="#3" id="3">{a mathematical formula}tn0 is an initial task network,</a>
<a href="#4" id="4">Definition 5</a>
<a href="#5" id="5">We draw the formalism of plan-based HTN planning upon the work of Geier and Pascal [40].</a>
<a href="#6" id="6">With respect to Definition 2 of the theoretical framework, we complement a task network as follows.</a>
<a href="#7" id="7">Task networkA task network tn is a triple {a mathematical formula}(T, Φ , Ψ ), where</a>
<a href="#8" id="8">Definition 7</a>
<a href="#9" id="9">Executable task networkGiven an HTN planning problem {a mathematical formula}P, {a mathematical formula}tn=(T, Φ , Ψ ) is executable in state s, if and only if it is primitive and there exists linearisation of its tasks {a mathematical formula}t1, … ,tn that is compatible with Ψ and the corresponding sequence of operators {a mathematical formula} Φ (t1), … , Φ (tn) is executable in s.</a>
<a href="#10" id="10">Definition 8</a>
<a href="#11" id="11">SolutionLet {a mathematical formula}P be an HTN planning problem.</a>
<a href="#12" id="12">A task network {a mathematical formula}tns is a solution to {a mathematical formula}P, if and only if {a mathematical formula}tns is executable in {a mathematical formula}s0, and {a mathematical formula}tn0 → D ⁎ tns for {a mathematical formula}tns being a solution to {a mathematical formula}P.</a>
<a href="#13" id="13">Definition 13</a>
<a href="#14" id="14">SolutionLet {a mathematical formula}P be an HTN planning problem.</a>
<a href="#15" id="15">t is primitive and applicable in {a mathematical formula}s0 and the sequence {a mathematical formula}o2, … ,on is a solution to {a mathematical formula}P in which the task network is {a mathematical formula}tn0 ∖ {o1} and the state is {a mathematical formula}s0[o1]; or</a>
<a href="#16" id="16">t is compound and there is a task decomposition in {a mathematical formula}s0 such that the sequence {a mathematical formula}o1, … ,on is a solution to {a mathematical formula}P in which {a mathematical formula}tn0 → Dtn ′ .</a>
<a href="#17" id="17">HTN planning assumes an initial task network {a mathematical formula}tn0 to be accomplished as an objective for {a mathematical formula}P. In its simplest form, {a mathematical formula}tn0 does not allow to specify conditions to be satisfied in some intermediate state during or in the final state of the execution of the solution to {a mathematical formula}P. Extended goals enable to express a planning objective in a way that its satisfaction could be on a part, on the whole trajectory of the solution, or in the final state.</a>
<a href="#18" id="18">In classical planning, this is usually achieved through the use of temporal modal operators.</a>
<a href="#19" id="19">Solution flexibility defines the ordering of operators in the solution to a planning problem.</a>
<a href="#20" id="20">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#21" id="21">The solution to {a mathematical formula}P is flexible if it is partially ordered.</a>
<a href="#22" id="22">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#23" id="23">An HTN planner is sound if every plan it gives is a correct solution to {a mathematical formula}P.</a>
<a href="#24" id="24">Let {a mathematical formula}P be an HTN planning problem.</a>
<a href="#25" id="25">An HTN planner is complete if it always finds a solution to {a mathematical formula}P when such a solution exists.</a>
<a href="#26" id="26">Let {a mathematical formula}P be an HTN planning problem, {a mathematical formula} Π =o1, … ,on be the solution to {a mathematical formula}P, where {a mathematical formula}s0[ Π ]=sn.</a>
<a href="#27" id="27">Let {a mathematical formula} Π e be the partially executed part of Π , and {a mathematical formula} Π r the remaining part still to be executed.</a>
<a href="#28" id="28">The execution of Π is in a correct state s iff {a mathematical formula}s[ Π r]=sn.</a>
<a href="#29" id="29">Let {a mathematical formula}P be an HTN planning problem and Π be a solution to {a mathematical formula}P. An HTN planner is said to tolerate faults from a fault set F during the execution of Π iff for each {a mathematical formula}f ∈ F, there exists a sequence of operators {a mathematical formula} Π f such that {a mathematical formula} Π f is a solution to {a mathematical formula}P.</a>
<a href="#30" id="30">Planner takes in the current HTN planning problem {a mathematical formula}P and computes a solution plan Π .</a>
<a href="#31" id="31">Repair and Replanning takes f and tries to repair the current plan.</a>
<a href="#32" id="32">If the component is able to do so, it sends the repaired plan for execution, otherwise it may ask a user for help, and if that does not work, it asks the planner to re-plan given a modified HTN planning problem {a mathematical formula}P ′ .</a>
<a href="#33" id="33">{a mathematical formula}Q,O,M are generated by an OWL-S to HTN translation for the OWL-S process models K,</a>
<a href="#34" id="34">{a mathematical formula}tn0 is generated by an OWL-S to HTN translation for the OWL-S process C, and</a>
<a href="#35" id="35">each {a mathematical formula}ti is a primitive task that corresponds to an atomic process {a mathematical formula}pi defined by some OWL-S to HTN translation.</a>
</body>
</html>