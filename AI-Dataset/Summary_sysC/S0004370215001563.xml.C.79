<html>
<head>
<meta name="TextLength" content="SENT_NUM:10, WORD_NUM:808">
</head>
<body bgcolor="white">
<a href="#0" id="0">{a mathematical formula} Δ ⊆ V× Φ (P)× Φ (P)× Φ (P)×V is the transition relation of {a mathematical formula}P, where {a mathematical formula} Φ (P) stands for the set of all boolean formulas built from the set of propositions P. A transition {a mathematical formula} 〈 v, Γ , Ψ , Φ ,v ′ 〉 ∈ Δ — also {a mathematical formula} 〈 v, 〈 Γ , Ψ , Φ 〉 ,v ′ 〉 ∈ Δ or {a mathematical formula}v → Γ : Ψ , Φ v ′ in {a mathematical formula}P for legibility — is used to denote that whenever the guard Γ holds (in the domain), the agent planning program {a mathematical formula}P may legally move from state v to state {a mathematical formula}v ′ by “ achieving Φ while maintaining Ψ . ” □</a>
<a href="#1" id="1">The idea is that when the planning program and the domain are in states v and s (initially {a mathematical formula}v0 and {a mathematical formula}s0), respectively, the agent is allowed to pursue any enabled (i.e., whose guard holds true in s) planning program transition {a mathematical formula}v → Γ : Ψ , Φ v ′ in {a mathematical formula}P. However, being declarative assertions, such transition are not directly executable and actual realizations are required for them.</a>
<a href="#2" id="2">Like in classical planning [46], under the closed world assumption, a state is specified by a set of propositions, an action {a mathematical formula}a= 〈 Pre,Eff+,Eff − 〉 is said to be executable in a domain state s if {a mathematical formula}Pre ⊆ s, and the domain state {a mathematical formula}s ′ obtained by executing a in state s is {a mathematical formula}s ∖ Eff − ∪ Eff+.</a>
<a href="#3" id="3">Starting from an open configuration (called open pair in the algorithm) {a mathematical formula} 〈 s,v 〉 , where s is a domain state and v is a planning program state (initially {a mathematical formula}s=s0 and {a mathematical formula}v=v0), for each transition d outgoing from v such that the guard of d holds in s, {a mathematical formula}RealizePlanProg constructs a plan Π realizing d from s. Then, the algorithm progresses the states of {a mathematical formula}D and {a mathematical formula}P (according to {a mathematical formula} Π (s) and d, respectively), possibly generating a new open pair {a mathematical formula} 〈 s ′ ,v ′ 〉 to process similarly.</a>
<a href="#4" id="4">The algorithm terminates when no more open pairs are left, or it is the case that no realization can be found, i.e., for at least a transition {a mathematical formula}d= 〈 v0, 〈 Γ , Ψ , Φ 〉 ,v 〉 outgoing from the initial planning program state {a mathematical formula}v0, and such that Γ holds in the initial domain state {a mathematical formula}s0, there exists no plan Π constructed from {a mathematical formula}s0 such that Π maintains Ψ , {a mathematical formula}last( Π (s0)) ⊨ Φ and {a mathematical formula}last( Π (s0)) is in the set of domain states from which a transition outgoing from v can be realized.</a>
<a href="#5" id="5">It is worth noting that for planning program structures including loops, even when sets {a mathematical formula}ST and {a mathematical formula}AT are empty, the planning problems with PESs that are solved during the execution of {a mathematical formula}RealizePlanProg are interdependent in the sense that the solution of a planning problem associated with a transition incoming to a {a mathematical formula}P-state v takes into account the solution of the planning problems associated with the transition(s) outgoing from v, as it should (preferably) enable the reuse of the plans already computed for the outgoing transitions (this is the purpose of PESs).</a>
<a href="#6" id="6">The number of not interdependent planning problems is always (at most) the number of program states, i.e., the number of planning problems with an empty set of PESs that are constructed during the execution of {a mathematical formula}RealizePlanProg.</a>
<a href="#7" id="7">Since plan adaptation can be especially useful when the program structure forms several cycles and the domain instance is large (i.e., when solving the planning problems can be quite hard), for this experiment we considered the planning programs in benchmark {a mathematical formula}ML2 − 12, which are planning programs with a structure forming a complete directed graph.</a>
<a href="#8" id="8">the (current) planning program state {a mathematical formula}W[v] ∈ W ∩ V, which always exists and is unique due to definition of {a mathematical formula} Ρ e (recall that {a mathematical formula}XV=V);</a>
<a href="#9" id="9">Since the usage of {a mathematical formula}Tabu(v) in subroutine {a mathematical formula}Plan prevents the generation of any plan reaching an end state {a mathematical formula}s ∈ Tabu(v), {a mathematical formula}s ′ ∉ Tabu(v), and {a mathematical formula}Plan can generate a valid plan for every solvable planning problem in the input domain ({a mathematical formula}Plan is complete), {a mathematical formula}Plan cannot generate failure when it realizes transition d from {a mathematical formula} 〈 s0,v0 〉 (lines 10 – 11 of {a mathematical formula}RealizePlanProg).</a>
</body>
</html>