<html>
<head>
<meta name="TextLength" content="SENT_NUM:61, WORD_NUM:2060">
</head>
<body bgcolor="white">
<a href="#0" id="0">We will first discuss the theoretical underpinnings of this approach and then continue with an introduction to the CEGARTIX system [21] and the ArgSemSAT system [22], which both rely on iterative calls to SAT solvers for argumentation semantics of high complexity (i.e., being located on the second level of the polynomial hierarchy).</a>
<a href="#1" id="1">The figure is complete in the sense that if there is no arrow from semantics Σ to semantics Τ , then there is some AF F such that {a mathematical formula} Σ (F) ⊈ Τ (F).</a>
<a href="#2" id="2">For all semantics Σ we introduced here, except stable semantics, it holds that for any AF F we have {a mathematical formula} Σ (F) ≠ ∅ .</a>
<a href="#3" id="3">Finally, we also consider the problem {a mathematical formula}Ver Σ (S,F) of verifying a given extension, i.e., testing whether a given set S is a Σ -extension of F. This problem typically occurs as a subroutine of a reasoning procedure.</a>
<a href="#4" id="4">For preferred semantics, F has a single extension {a mathematical formula}Enumprf(F)={{a,d}}, {a mathematical formula}Countprf(F)=1, and thus credulous and skeptical acceptance coincide (e.g., {a mathematical formula}Credprf(a,F)=Skeptprf(a,F)=yes).</a>
<a href="#5" id="5">Next, let us turn to the complexity of reasoning in abstract argumentation frameworks.</a>
<a href="#6" id="6">In this section we will discuss reduction-based approaches in abstract argumentation.</a>
<a href="#7" id="7">As implied by the name, these methods reduce or translate a reasoning problem to another, typically to another formalism.</a>
<a href="#8" id="8">From a computational point of view, we assure that this reduction is efficiently computable, i.e., achievable in polynomial time, and that the answer for the original problem instance can be immediately obtained from the answer to the new problem instance.</a>
<a href="#9" id="9">The first conjunction in (1) ensures that the resulting set of arguments is conflict-free, that is, whenever we accept an argument a (i.e., {a mathematical formula}va evaluates to true under a model), all its attackers cannot be selected any further.</a>
<a href="#10" id="10">For two variables we have four different cases, which correspond to the four truth values: {a mathematical formula}{p ⊕ ,p ⊖ } ⊆ I is interpreted as assigning inconsistent to p, true (resp.</a>
<a href="#11" id="11">Utilizing the expressive power of quantifiers and the labeling approach, the authors of [19] also encode a range of other semantics, for instance semi-stable reasoning, where one can apply the same idea as outlined above, but instead of maximizing the arguments that are in, the arguments that are labeled undecided are minimized.</a>
<a href="#12" id="12">This is, for instance, the case with skeptical acceptance under preferred semantics where the corresponding decision problem is {a mathematical formula} Π 2P complete.</a>
<a href="#13" id="13">skeptical acceptance of an argument under preferred semantics one requires in general an exponential number of calls to the SAT solver (under standard complexity theoretic assumptions).</a>
<a href="#14" id="14">In case we cannot add a to the admissible set, we have found a preferred extension without a, hereby refuting its skeptical acceptance in F. In the former case (I does not represent a preferred extension) we strengthen the main query Φ by adding {a mathematical formula} Γ I in line 7, stating that at least one argument currently not accepted in I must be accepted from now on.</a>
<a href="#15" id="15">The condition of the first loop is satisfied as there exist the admissible sets ∅ , {a mathematical formula}{a}, {a mathematical formula}{d} and {a mathematical formula}{a,d} in F. The algorithm now non-deterministically selects one of the admissible sets.</a>
<a href="#16" id="16">For example, solutions that correspond to conflict-free sets can be obtained by defining a constraint for each pair of arguments a and b with {a mathematical formula}(a,b) ∈ R, where the two variables may not be set to 1 at the same time.</a>
<a href="#17" id="17">We fix a countable set {a mathematical formula}U of (domain) elements, also called constants, and suppose a total order < over the domain elements.</a>
<a href="#18" id="18">Besides disjunctive and normal programs, we consider here the class of optimization programs, i.e., normal programs which additionally contain #minimize statements{a mathematical formula} where {a mathematical formula}li is a literal, {a mathematical formula}wi an integer weight and {a mathematical formula}Ji an integer priority level.</a>
<a href="#19" id="19">Then, M is a collection of relations of the form {a mathematical formula} ⊆ Jw for priority levels J and weights w. A standard answer set (i.e., not taking the minimize statements into account) Y of Π dominates a standard answer set X of Π w.r.t.</a>
<a href="#20" id="20">For an AF {a mathematical formula}F=(A,R), we define{a mathematical formula} We have to guess candidates for the selected type of extensions and then check whether a guessed candidate satisfies the corresponding conditions, where default negation is an appropriate concept to formulate such a guess within a query.</a>
<a href="#21" id="21">To compute the preferred extensions of an argumentation framework, we will use the saturation technique as follows: Having computed an admissible set S (characterized via predicates {a mathematical formula}in( ⋅ ) and {a mathematical formula}out( ⋅ ) using encoding {a mathematical formula} Π adm(F ˆ )), we perform a second guess with new predicates, say {a mathematical formula}inN( ⋅ ) and {a mathematical formula}outN( ⋅ ), to represent a guess {a mathematical formula}T ⊃ S.</a>
<a href="#22" id="22">In order to check whether the first guess characterizes a preferred extension, we have to ensure that no guess of the second form (i.e., via {a mathematical formula}inN( ⋅ ) and {a mathematical formula}outN( ⋅ )) characterizes an admissible set.</a>
<a href="#23" id="23">Let us for the moment also assume that predicates eq (rule (22)) and {a mathematical formula}undefeated( ⋅ ) (rule (24)) are defined (we give the additional rules for those predicates below in the modules {a mathematical formula} Π eq and {a mathematical formula} Π undefeated) and provide the following information:</a>
<a href="#24" id="24">Basically, these predicates would be easy to define, but as we have seen in the discussion above, default negation plays a central role in the saturation technique (recall the functioning of {a mathematical formula} ← notfail).</a>
<a href="#25" id="25">We therefore have to find encodings which suitably define the required predicates only with a limited use of negation.</a>
<a href="#26" id="26">This in turn gives us the subset-maximal admissible sets which captures the definition of preferred semantics.</a>
<a href="#27" id="27">{a mathematical formula} As a result we get that for any AF F, the answer sets of {a mathematical formula} Π prf_metasp(F ˆ ) are in a one-to-one correspondence with the preferred extensions of F, i.e.</a>
<a href="#28" id="28">{a mathematical formula}prf(F) ≅ AS( Π prf_metasp(F ˆ )).</a>
<a href="#29" id="29">As with other reduction-based approaches, the types of reasoning available depend on the ASP solver.</a>
<a href="#30" id="30">Usually, when one uses an ASP program, like {a mathematical formula} Π prf for preferred semantics, for an AF F, the ASP solver returns all answer sets of the program which correspond to all preferred extensions of F. For credulous or skeptical acceptance, one uses the respective reasoning problems of the ASP solver, which are sometimes referred to as brave or cautious reasoning.</a>
<a href="#31" id="31">Here, one receives a system of equations where each argument is represented by a distinct variable with a domain of real numbers in the interval {a mathematical formula}[0,1].</a>
<a href="#32" id="32">When applying the algorithm to an AF {a mathematical formula}F=(A,R), it first initializes the labeling {a mathematical formula}L such that each argument is labeled with in, i.e., {a mathematical formula}Lin=A, and the set {a mathematical formula}SL of candidate solutions only contains the labeling {a mathematical formula}( ∅ , ∅ ,A), corresponding to the empty set.</a>
<a href="#33" id="33">The preferred labeling {a mathematical formula} 〈 {b},{a,c}, ∅ 〉 will be produced by two branches of the algorithm, by the branch choosing a in the first step (and assign out to a) and then choosing c in the second step (and assigning out as well), but also by the branch selecting c first and then a in the second step.</a>
<a href="#34" id="34">As such duplicates are indeed a waste of computational resources, this is a weak point.</a>
<a href="#35" id="35">This part ensures the ⊆ -maximality of the labelings in {a mathematical formula}SL.</a>
<a href="#36" id="36">As the set {a mathematical formula}SL can be of exponential size (even if the number of preferred labelings is small) testing whether a new candidate is ⊆ -maximal and updating the set {a mathematical formula}SL is costly.</a>
<a href="#37" id="37">Hence, alternative approaches to deal with ⊆ -maximality have been proposed.</a>
<a href="#38" id="38">Secondly, in [36] the authors provide a smart traversal of the search space such that one can avoid deleting sets from {a mathematical formula}SL, i.e., in each step one can decide whether the current candidate is preferred or not, by only using previously computed preferred labelings (see Algorithm 4).</a>
<a href="#39" id="39">Here we have only considered the case of preferred semantics, but for most of the semantics labeling-based algorithms have been proposed in the literature: an algorithm for grounded semantics is given in [35]; an algorithm for admissible labelings can be easily obtained from Algorithm 4 (by dropping the ⊆ -maximality test in line 14); for complete semantics one can adapt Algorithm 3; for stable semantics, see [35]; algorithms for semi-stable and stage semantics can be found in [104], [106], [35].</a>
<a href="#40" id="40">Now let us consider a game that allows us, given an AF {a mathematical formula}F=(A,R) and argument {a mathematical formula}a ∈ A, to prove whether a is contained in some preferred extension of F (or equivalently in some admissible set).</a>
<a href="#41" id="41">We distinguish between attacks from arguments in {a mathematical formula}X>t and {a mathematical formula}Xt.</a>
<a href="#42" id="42">While attacks from arguments {a mathematical formula}Xt might be counter attacked by arguments appearing later, i.e., somewhere above in the tree decomposition, this cannot happen for arguments in {a mathematical formula}X>t.</a>
<a href="#43" id="43">Thus, we define an {a mathematical formula}X>t-restricted admissible set S for a sub-framework {a mathematical formula}F ≥ t such that first S has to be conflict-free and second it has to defend itself against the arguments in {a mathematical formula}X>t ∖ S.</a>
<a href="#44" id="44">So the {a mathematical formula}X>t-restricted admissible sets for a sub-framework {a mathematical formula}F ≥ t are all the sets that might become admissible in a framework {a mathematical formula}F ≥ t ′ for some node {a mathematical formula}t ′ above in the tree decomposition.</a>
<a href="#45" id="45">Given a coloring C for node t, we define the extensions of C, {a mathematical formula}et(C), as the collection of {a mathematical formula}X>t-restricted admissible sets S for {a mathematical formula}F ≥ t that satisfy the following conditions for each {a mathematical formula}a ∈ Xt:{a mathematical formula} If {a mathematical formula}et(C) ≠ ∅ , C is called a valid coloring for t.</a>
<a href="#46" id="46">In each node we use our data structure of colorings and compute all valid colorings C for every node t. As shown in [112], there exists a one-to-one mapping between the extensions of C, {a mathematical formula}et(C), and the {a mathematical formula}X>t-restricted admissible sets for {a mathematical formula}F ≥ t.</a>
<a href="#47" id="47">Moreover, we assume that the root node r has an empty bag of arguments.</a>
<a href="#48" id="48">Hence, by computing the valid colorings C for r we obtain the {a mathematical formula}X>r-restricted admissible sets for {a mathematical formula}F ≥ r.</a>
<a href="#49" id="49">As {a mathematical formula}X>r=A these correspond to the admissible sets for our original AF instance.</a>
<a href="#50" id="50">In order to achieve tractability we have to compute valid colorings in bottom-up order without explicit computation of the corresponding restricted admissible sets {a mathematical formula}et(C).</a>
<a href="#51" id="51">Hence, we define operations for the computation of valid colorings which are applied recursively on the colorings computed at the child node(s).</a>
<a href="#52" id="52">We build two colorings {a mathematical formula}C+a and {a mathematical formula}C+ ˙ a for t as described below.</a>
<a href="#53" id="53">The first is always valid while the second is only valid if {a mathematical formula}[C+ ˙ a]in is conflict-free.</a>
<a href="#54" id="54">{a mathematical formula}{a mathematical formula}</a>
<a href="#55" id="55">In an introduction node we add a new argument to the framework.</a>
<a href="#56" id="56">So for each extension we get two new candidates, one where we leave the argument a outside the extension (case {a mathematical formula}C+a) and one where we add a to the extension (case {a mathematical formula}C+ ˙ a).</a>
<a href="#57" id="57">Based on the definition of the join operator their combination results in a coloring C with {a mathematical formula}C(b)=out and {a mathematical formula}C(c)=out which represents one {a mathematical formula}X>t2 (or {a mathematical formula}{a,d,e})-restricted admissible set for {a mathematical formula}F ≥ t2, namely {a mathematical formula}{a,d}.</a>
<a href="#58" id="58">It is sufficient to calculate the number of {a mathematical formula}X>t-restricted admissible sets that are represented by the respective coloring immediately during the bottom-up traversal.</a>
<a href="#59" id="59">We only give a rough outline of the ideas to extend the above algorithm for preferred semantics, for details the interested reader is referred to [40].</a>
<a href="#60" id="60">As preferred extensions are subset-maximal admissible sets in order to guarantee subset maximality one can use pairs {a mathematical formula}(C, Γ ) as a data structure within a node t instead of colorings.</a>
</body>
</html>