<html>
<head>
<meta name="TextLength" content="SENT_NUM:32, WORD_NUM:666">
</head>
<body bgcolor="white">
<a href="#0" id="0">Definition 2</a>
<a href="#1" id="1">An integrity constraint is any formula {a mathematical formula}ic ∈ LPS.</a>
<a href="#2" id="2">Definition 3</a>
<a href="#3" id="3">Given an integrity constraint {a mathematical formula}ic ∈ LPS, an aggregation procedure {a mathematical formula}F:DN → D is called collectively rational (CR) with respect to ic, if for all rational profiles {a mathematical formula}B ∈ Mod(ic)N we have that {a mathematical formula}F(B) ∈ Mod(ic).</a>
<a href="#4" id="4">Definition 5</a>
<a href="#5" id="5">Given a language {a mathematical formula}L ⊆ LPS, call {a mathematical formula}CR[L] the class of aggregation procedures that lift all {a mathematical formula}ic ∈ L:{a mathematical formula}</a>
<a href="#6" id="6">Definition 6</a>
<a href="#7" id="7">An aggregation procedure F satisfies a set of axioms AX wrt.</a>
<a href="#8" id="8">a language {a mathematical formula}L ⊆ LPS, if F satisfies the axioms in AX on {a mathematical formula}Mod(ic)N for all constraints {a mathematical formula}ic ∈ L.</a>
<a href="#9" id="9">This defines the following class:{a mathematical formula}</a>
<a href="#10" id="10">Let {a mathematical formula}L be a language.</a>
<a href="#11" id="11">Define {a mathematical formula}L ∧ to be the closure of {a mathematical formula}L under conjunction, i.e., the set of finite conjunctions of formulas in {a mathematical formula}L. We now prove that the class of collectively rational procedures is invariant under closing the language under conjunction, i.e., that the set of collectively rational procedures for {a mathematical formula}L and for {a mathematical formula}L ∧ coincide:</a>
<a href="#12" id="12">Definition 8</a>
<a href="#13" id="13">Given a class of aggregation procedures {a mathematical formula}G ⊆ F, call {a mathematical formula}LF[G] the set of integrity constraints that are lifted by all {a mathematical formula}F ∈ G:{a mathematical formula}</a>
<a href="#14" id="14">Once a language for integrity constraints is fixed, e.g., by means of a syntactic restriction on the integrity constraints, we may be interested in the problem of how to guarantee collective rationality with respect to all the integrity constraints that can be expressed in the given language.</a>
<a href="#15" id="15">The aim of this section is to explore the relationship between the two definitions of classes of aggregation procedures introduced in Section 3: collectively rational procedures on one side, and procedures defined by axiomatic requirements on the other.</a>
<a href="#16" id="16">In particular, we look for results of the following form:{a mathematical formula} for languages {a mathematical formula}L and axioms AX.</a>
<a href="#17" id="17">We call such findings characterisation results: they provide necessary and sufficient axiomatic conditions for an aggregation procedure to be collectively rational with respect to a language for integrity constraints.</a>
<a href="#18" id="18">Given the importance of collective rationality in many classical studies of aggregation and for a number of practical applications, such results are central to our study.</a>
<a href="#19" id="19">With an analogous proof we can obtain a characterisation result involving the axiom of domain-neutrality.</a>
<a href="#20" id="20">Recall that a procedure is domain-neutral if it symmetric with respect to any two issues.</a>
<a href="#21" id="21">An XOR formula is a bi-implication of one negative and one positive literal.</a>
<a href="#22" id="22">Call {a mathematical formula}LXOR the language for integrity constraints generated from {a mathematical formula}{pj ↔ ¬pk|pj,pk ∈ PS}.</a>
<a href="#23" id="23">Results such as the one proved in the previous section cannot be proved for other important axioms, for which it is not possible to obtain a characterisation result.</a>
<a href="#24" id="24">In this section we prove a negative result for the axioms of independence, anonymity and both formulations of monotonicity.</a>
<a href="#25" id="25">We first prove the following proposition.</a>
<a href="#26" id="26">Recall that {a mathematical formula}LF[G] is the set of integrity constraints lifted by all the aggregation procedures in {a mathematical formula}G, and let {a mathematical formula}L ⊤ , ⊥ be the language for integrity constraints generated by {a mathematical formula}{ ⊤ , ⊥ }.</a>
<a href="#27" id="27">We now want to turn these results into characterisation results in the line of those proved in Section 4.</a>
<a href="#28" id="28">We first have to define languages of clauses from our definition of clauses of a limited size.</a>
<a href="#29" id="29">Let {a mathematical formula}k-pclauses and {a mathematical formula}k-nclauses denote, respectively, the language for integrity constraints generated from positive (negative) clauses of size ≤ k.</a>
<a href="#30" id="30">Denote by {a mathematical formula}QRe(qj) the set of quota rules such that all quotas {a mathematical formula}qj for {a mathematical formula}j ∈ I satisfy the equation in the subscript.</a>
<a href="#31" id="31">The function {a mathematical formula} ⌈ x ⌉ is defined as the smallest integer greater than or equal than x.</a>
</body>
</html>