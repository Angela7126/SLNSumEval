<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370213000957</url><title>Approximating operators and semantics for abstract dialectical frameworks</title><authors>Hannes Strass</authors><abstract>We provide a systematic in-depth study of the semantics of abstract dialectical frameworks (ADFs), a recent generalisation of Dungʼs abstract argumentation frameworks. This is done by associating with an ADF its characteristic one-step consequence operator and defining various semantics for ADFs as different fixpoints of this operator. We first show that several existing semantical notions are faithfully captured by our definition, then proceed to define new ADF semantics and show that they are proper generalisations of existing argumentation semantics from the literature. Most remarkably, this operator-based approach allows us to compare ADFs to related nonmonotonic formalisms like Dung argumentation frameworks and propositional logic programs. We use polynomial, faithful and modular translations to relate the formalisms, and our results show that both abstract argumentation frameworks and abstract dialectical frameworks are at most as expressive as propositional normal logic programs.</abstract><keywords>Abstract dialectical frameworks;Abstract argumentation frameworks;Logic programming;Fixpoint semantics;Approximations;Nonmonotonic reasoning</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>In recent years, abstract argumentation frameworks (AFs) [14] have become increasingly popular in the artificial intelligence community. An AF can be seen as a directed graph where the nodes are arguments whose internal structure is abstracted away, and where the edges encode a notion of attack between arguments. Part of the reason for the interest in AFs may be that in spite of their conceptual simplicity, there exist many different semantics with different properties in terms of characterisation, existence and uniqueness. Notwithstanding their success, their expressive capabilities are somewhat limited, as has been recognised many times in the literature: often it is inadequate to model argumentation scenarios having as only means of expression arguments attacking each other. There have been several proposals towards generalising AFs. To cite only a few examples, Prakken and Sartor [34] add priorities amongst arguments that are constructed from prioritised logic programming rules; Nielsen and Parsons [30] introduced attacks from sets of arguments; Cayrol and Lagasquie-Schiex [9] presented bipolar argumentation frameworks, in which arguments can also support each other; and Modgil [28] proposed attacks on attacks with the aim of reasoning about preferences on the object level.</paragraph><paragraph>As a general way to overcome the restrictions of Dungʼs AFs while staying on the abstract level, Brewka and Woltran [3] introduced abstract dialectical frameworks (ADFs). Just like AFs, these ADFs treat arguments (called statements there) as abstract, atomic entities whose contents are not further analysed. But instead of expressing for an argument only its attackers, ADFs associate with each statement an acceptance condition that determines the acceptance status of a statement given the acceptance status of its parent statements. These parents are the statements which have a say on whether the statement in question can or must (not) be accepted. In this way, AFs are recovered in the language of ADFs by specifying for each statement the acceptance condition “accept if and only if none of the attackers is accepted.”</paragraph><paragraph>The abstract nature of Dungʼs AFs makes them well-suited as a target language for translations from more expressive formalisms. To be more precise, it is common to use expressive languages to model more concrete (argumentation) scenarios, and to provide these original expressive languages with semantics by translating them into Dung AFs [8], [44], [33], [40]. However, Caminada and Amgoud [8] observed that it is not always immediately clear how such translations into AFs should be defined, even for a fairly simple source formalism. A major problem that they encountered were unintended conclusions that indirectly led to inconsistency. In the same paper, Caminada and Amgoud also proposed solutions to these problems, where during translation additional precautions have to be taken to avoid undesired anomalies. Let us explain in more detail what this means in general for abstractions among knowledge representation (KR) languages.</paragraph><paragraph>First of all, by an abstraction we mean a translation between languages that may disregard some information. Instantiating an abstract language is then the process of translating a more concrete, more expressive language into the abstract, less expressive language. This entails that there is no dichotomy “knowledge representation language vs. abstraction formalism” – any KR language abstracts to a greater or lesser extent, and can thus be used for abstraction purposes. Whether any specific language is to be used for direct, concrete representation or for abstraction of another language depends entirely on the application domain at hand.</paragraph><paragraph>Naturally, we are interested in those abstractions that preserve the meaning of translated language elements in some sense. As an example, consider the language {a mathematical formula}{yes,no}. It is very simple and can abstract from any decision problem whatsoever. Furthermore it is trivial to devise an intuitively correct semantics for it. But to faithfully instantiate this language to a particular decision problem – say, the satisfiability problem of propositional logic –, the problem must be solved during translation, for otherwise the abstraction would not be meaningful at all. At the other end of the spectrum, for any language {a mathematical formula}L, an “abstraction” is provided by {a mathematical formula}L itself. In contrast to the two-element target language {a mathematical formula}{yes,no}, using {a mathematical formula}L as target language makes it trivial to translate {a mathematical formula}L into the abstraction, but the target language does in fact not abstract at all and devising a semantics for the abstraction is as hard as devising a semantics for the original language.</paragraph><paragraph>Thus abstraction proper should indeed disregard some information, but not too much of it. In the example above, the fact that the language {a mathematical formula}{yes,no} can abstract away from any decision problem is no argument for its usefulness as an abstraction formalism, since its expressive power is clearly too poor to model real problems (meaning problems that are syntactically different from their solutions). Consequently the expressiveness of a language is important when using it as a target language for abstraction. More specifically, a suitable target language for abstraction must be expressive enough to model important problem aspects, while being sufficiently abstract to ignore irrelevant details.</paragraph><paragraph>So to be able to use a formalism for abstraction, we obviously need a clear picture of its capabilities as a KR language, especially its expressive power in comparison to other languages, and about the properties of its semantics. It is the main objective of this paper to provide this information for abstract dialectical frameworks. For this purpose, we technically view ADFs as KR languages – but of course our work has ramifications for ADFs as abstraction formalisms. In the same way as there is no single intended semantics for argumentation frameworks, there is also no single perfect formalism for abstraction. But to be able to make an informed choice, it is of great importance to understand the inherent relationships between different available options. Our results will facilitate this choice and be an aid to anyone wishing to abstract from concrete argumentation languages; especially, our results will help them decide if they want to translate into AFs or into ADFs.</paragraph><paragraph>But why, after all, should there be a choice to be made between AFs and ADFs? Here, the additional expressiveness of ADFs in comparison to AFs comes into play. As we will see throughout the paper, the well-known distinction between supported and stable models from logic programming is present in ADFs but is missing in AFs. In a different disguise, this same distinction also materialises as Moore expansions vs. Reiter extensions in nonmonotonic logics [12]. To summarise it in a nutshell, there are basically two ways in which the major nonmonotonic KR formalisms deal with cyclic positive dependencies between pieces of knowledge. To explain what such cyclic support dependencies are and why they can be problematic, let us look at a study from the literature where researchers applied several logic-based knowledge representation techniques in a medium-sized practical application.</paragraph><paragraph>Nogueira et al. [32] describe a declarative rule-based system that controls some of the functions of a space shuttle. More specifically, the system operates the space shuttleʼs reaction control system, whose primary responsibility is to manoeuvre the shuttle through space. Part of the rule-based specification represents the plumbing system of this reaction control system. The plumbing system consists of a collection of tanks, jets and pipe junctions, which are connected through pipes. The flow of fluids through pipes is controlled by valves. The purpose of the plumbing system is to deliver fuel and oxidiser from tanks to the jets needed to perform a manoeuvre. The structure of the plumbing system is described by a directed graph whose nodes are tanks, jets and pipe junctions, and whose edges are labelled by valves. The description of the plumbing system should predict how the positions of valves affect the pressure of tanks, jets and junctions. For tanks themselves, the pressure resulting from pressurising certain (other) tanks is easy to specify. For all other nodes in the graph the definition is recursive: roughly, any non-tank node is pressurised by a tank if the node is connected by an open valve to a node which is pressurised by the tank. Nogueira et al. [32] explicitly recognise that modelling this is non-trivial because the connection graph of the plumbing system can contain cycles. That is, there may be nodes in the graph that are mutually connected to each other, and accurately modelling this is not straightforward:</paragraph><paragraph label="Example 1.1">But of course, causality dictates that the two nodes cannot simply pressurise each other without an external cause (that is, through an open valve). A reasoner that predicts “both nodes are pressurised” as possible successor state of the state “both nodes are not pressurised” when no relevant valve has been opened in between is obviously not of great assistance – only more so if it offers the cyclic explanation “one node is pressurised because the other is.” So the knowledge engineers that specify and use the system should be aware that the supported model semantics does not accurately reflect causality in this domain.On the other hand, the set ∅ is the only stable model of the logic program, showing that the stable model semantics correctly deals with the issue at hand. And indeed, Nogueira et al. [32] explicitly remarked that the ability of answer set programming to express and to reason with recursion allowed them to use a concise definition of pressure.</paragraph><paragraph>Such issues with cyclic support dependencies not only occur in logic programs, but also in default logic and autoepistemic logic:</paragraph><list><list-item label="•">Cyclic support is allowed by supported semantics for logic programs (which is equivalent to the Clark completion [10]) and in expansions of autoepistemic logic [29].</list-item><list-item label="•">Cyclic support is disallowed by stable semantics for logic programs [20] and in extensions of default logic [35].{sup:1}</list-item></list><paragraph> The fact that this distinction is not present in AFs means that anyone translating their modelling language into AFs has to take care of the issue of cyclic support themselves and thus has to solve part of the problem by hardwiring it into the translation. (Just like a decision problem has to be solved when it is “translated” into the language {a mathematical formula}{yes,no}.) When ADFs are used as a target language, ADF semantics will simply take care of cyclic supports, thereby considerably simplifying the translation.</paragraph><paragraph>Generally speaking, it is at the heart of an abstraction to remove information; it is at the heart of a good abstraction to remove irrelevant information. If some removed information afterwards turns out to have been relevant, it either has to be (however costly) recomputed or is simply lost. And if the target language cannot natively express some concept, then information about this concept is bound to get lost. An example, again, is the support relation between atoms in a logic program, which is hardly translated into an AF and easily translated into an ADF as this paper will show.</paragraph><paragraph>More concrete empirical evidence for the usefulness of abstract dialectical frameworks has already been provided in the literature. For one, Brewka and Gordon [2] translated argument evaluation structures of the Carneades framework [21] into ADFs.{sup:2} It is especially remarkable that their work allowed cyclic dependencies among arguments, which was previously not possible in Carneades. Meanwhile, Van Gijzel and Prakken [40] also translated Carneades into AFs via ASPIC+ [33]. They can deal with cycles, but even with cycles there is only one unique stable, preferred, complete, grounded extension. Thus the semantic richness of abstract argumentation is not used, and more importantly the user cannot choose whether they want to accept or reject positive cyclic dependencies between arguments. In contrast, in the ADF approach of Brewka and Gordon [2], the user can choose whether support cycles should be accepted or rejected, by choosing models or stable models as intended ADF semantics. For another, we [37] have shown how ADFs can be used to provide an argumentation-based semantics for the defeasible theories of Caminada and Amgoud [8]. Our translated ADFs treat the problematic examples from the literature [8], [44] in the right way, and we proved that the translated frameworks satisfy the rationality postulates proposed by Caminada and Amgoud [8]. The translation is efficiently computable, since it involves only a quadratic blowup and creates a number of arguments that is linear in the size of the defeasible theory. Furthermore, the frameworks can detect cyclic supports amongst literals via ADFsʼ stable semantics.</paragraph><paragraph>To summarise, our main arguments for using abstract dialectical frameworks as abstraction language are the following conclusions of this paper:</paragraph><list><list-item label="•">ADFs are at least as expressive as AFs, and thus can represent all important problem aspects that AFs can represent. On top of that, ADFs offer a built-in treatment of positive cyclic dependencies which is derived from decades of research into nonmonotonic knowledge representation languages.</list-item><list-item label="•">ADFs are at most as expressive as normal logic programs, and therefore still sufficiently simple to be suited as an abstraction formalism.</list-item><list-item label="•">ADFs provide all of Dungʼs standard semantics for AFs, so there is no loss in semantical richness. On the contrary, each of the standard AF semantics (stable, preferred, complete, grounded) has at least two ADF generalisations.</list-item></list><paragraph>To go about our main task of analysing the expressiveness of abstract dialectical frameworks, we do not have to start from scratch. Brewka and Woltran [3] already showed that ADFs are at least as general as AFs and also provided a (non-modular) translation from normal logic programs to ADFs that preserves stable models. However, the exact location of ADFs in the realm of nonmonotonic knowledge representation formalisms remained unclear. Later, Brewka et al. [4] were able to give a polynomial translation from ADFs into AFs, suggesting on complexity-theoretical grounds that ADFs are not substantially more expressive than AFs. That translation is technically remarkable since it works irrespective of the specific chosen representation of acceptance conditions, provided the chosen representation is reasonable in a complexity-theoretic sense. However, the translation depends on the particular ADF semantics that is used: one does not simply translate ADFs into AFs with a fixed translation and then gets nice correspondences between the ADF and AF semantics (which is exactly how it works the other way around). Rather, to faithfully map ADFs into AFs one has to decide for a semantics beforehand and then apply a semantics-specific translation. Furthermore, the translation introduced by Brewka et al. [4] for the stable semantics is again not modular, so when something is added to the input ADF, one cannot simply add the translation of the addendum, but has to retranslate the whole updated ADF. In contrast, as we will show, there are translations from AFs and ADFs into normal logic programs (LPs) which are modular, polynomial (in fact linear) and faithful with respect to a whole range of semantics.</paragraph><paragraph>These and similar results provide us with a more fine-grained view on the location of AFs and ADFs in the bigger picture of nonmonotonic knowledge representation languages. Technically, we achieve this by a principled and uniform reconstruction of the semantics of abstract dialectical frameworks by embedding them into the approximation operator framework of Denecker, Marek and Truszczyński (henceforth DMT) [11], [12]. In seminal work, DMT developed a powerful algebraic framework in which the semantics of logic programs, default logic and autoepistemic logic can be treated in an entirely uniform and purely algebraic way. The approach works by defining operators, and then their fixpoints according to an abstract and principled method. In this paper, we extend their work by adding abstract dialectical frameworks (and by corollary abstract argumentation frameworks) to their approach.</paragraph><paragraph>We do this by defining the so-called characteristic operator of an ADF and then deriving new operators following abstract principles [11]. For the special case of a Dung argumentation framework, for instance, the characteristic ADF operator fully captures Dungʼs characteristic function of the AF. Our investigation generalises the most important semantics known from abstract argumentation to the case of ADFs and relates them to the respective logic programming semantics. It will turn out that when generalising AF semantics, there are typically two different possibilities for generalisations: a “supported” and a “stable” version of the respective semantics. Brewka and Woltran [3] already recognised this in the case of stable extensions for argumentation frameworks: stable AF extensions can be generalised to ADFs in two ways, namely to models and stable models for ADFs.</paragraph><paragraph>In addition to our usage of operators to clarify the relation of different semantics for single formalisms, we will employ another technique to illuminate the relationship between different formalisms. This role will be played by investigating polynomial, faithful, modular (PFM) translations between languages as has been done by Gottlob [22] and Janhunen [25] for the relationship between nonmonotonic logics. In our case, we even need a stronger kind of translation: “faithful” usually refers to a translation mapping models of one specific semantics of the source formalism to models of another specific semantics for the target formalism. In our case, faithful refers to the translation providing a perfect alignment with respect to any fixpoint semantics or at least a range of fixpoint semantics. Of course, this requires all of the involved semantics to be defined for both source and target formalism, which is however the case for our operator-based approach.</paragraph><paragraph>The picture that emerges from our work sheds new light on the underlying connections between the major nonmonotonic knowledge representation formalisms, since we study AFs, ADFs and logic programs all in a unified semantical framework. In particular, it conclusively shows that Dungʼs abstract argumentation frameworks can be seen as special cases of propositional normal logic programs. Now all normal logic programs are default theories, which are in turn theories of autoepistemic logic [12]. Thus as a byproduct, our work yields generalisations of argumentation semantics for a general lattice-based setting, from which the existing semantics for logic programming and argumentation can be derived as special cases. Among the semantics generalised are conflict-free and admissible sets, and naive, stage, preferred and semi-stable semantics. As a corollary and another new contribution, this also defines these semantics for default logic and autoepistemic logic [12]. This is a considerable improvement upon a result by Dung [14], who already argued for a preferred semantics for default logic, but only defined it through a translation to infinite argumentation frameworks. We show that our generalisations of argumentation semantics are well-defined by showing that well-known relationships between the semantics generalise accordingly: for example, any preferred ADF model is also complete.</paragraph><paragraph>In the last part of the paper, we instantiate the general ADF-based operator to the special case of AFs and present new semantical correspondence results between argumentation frameworks and their translated logic programs: preferred and semi-stable extensions correspond one-to-one to M-stable and L-stable models [36], respectively. Additionally, we show that our lattice-theoretical account of argumentation yields easier proofs for existing results in this area. As our final result, we prove equivalence (in four-valued Belnap logic) of two different translations from AFs to logic programs: a folklore translation from the literature (we call it the standard translation) that encodes attack by negation as failure, and the original translation of Dung [14], where attack and defeat of arguments is explicitly recorded.</paragraph><paragraph label="Structure of the paper">We next recall the necessary background, that is to say, the relevant aspects of the DMT lattice-theoretic framework [11], [13], logic programming and argumentation – in particular Dung-style argumentation frameworks and their generalisation to ADFs. Afterwards, we define the characteristic operator of an abstract dialectical framework, whose fixpoints then serve to define ADF semantics in a novel way. The operator will also be used to determine the relationship between propositional normal logic programs and abstract dialectical frameworks: we prove that ADFs can be faithfully and modularly mapped into LPs. We finally show the importance of our general results by illuminating the ramifications for the special case of Dung frameworks. Specifically, we prove several new semantical correspondence results for argumentation and logic programming, and finally prove the equivalence of two different translations from argumentation frameworks into logic programs.</paragraph></section><section label="2"><section-title>Background</section-title><paragraph>Let us first recall some basic concepts from lattice theory. A complete lattice is a partially ordered set {a mathematical formula}(L,⊑) where every subset of L has a least upper and a greatest lower bound. In particular, a complete lattice has a least and a greatest element. An operator {a mathematical formula}O:L→L is monotone if for all {a mathematical formula}x⊑y we find {a mathematical formula}O(x)⊑O(y); it is antimonotone if for all {a mathematical formula}x⊑y we find {a mathematical formula}O(y)⊑O(x). An {a mathematical formula}x∈L is a fixpoint of O if {a mathematical formula}O(x)=x; an {a mathematical formula}x∈L is a prefixpoint of O if {a mathematical formula}O(x)⊑x and a postfixpoint of O if {a mathematical formula}x⊑O(x). Due to a fundamental result by Tarski and Knaster, for any monotone operator O on a complete lattice, the set of its fixpoints forms a complete lattice itself [38]. In particular, its least fixpoint {a mathematical formula}lfp(O) exists; additionally, the least prefixpoint of O is also its least fixpoint.</paragraph><section label="2.1">The algebraic framework of Denecker et al. [11]<paragraph>Building upon the fundamental result by Tarski and Knaster, Denecker et al. [11] introduce the important concept of an approximation of an operator. In the study of semantics of nonmonotonic knowledge representation formalisms, elements of lattices represent objects of interest. Operators on lattices transform such objects into others according to the contents of some knowledge base. Consequently, fixpoints of such operators are then objects that cannot be updated any more – informally speaking, the knowledge base can neither add information to a fixpoint nor remove information from it.</paragraph><paragraph>To study fixpoints of operators O, DMT study fixpoints of their approximating operators{a mathematical formula}O.{sup:3} When O operates on a set L, its approximation {a mathematical formula}O operates on pairs {a mathematical formula}(x,y)∈L2 where {a mathematical formula}L2 denotes {a mathematical formula}L×L. Such a pair can be seen as representing a set of lattice elements by providing a lower bound x and an upper bound y. Consequently, the pair {a mathematical formula}(x,y) approximates all {a mathematical formula}z∈L such that {a mathematical formula}x⊑z⊑y. Of special interest are consistent pairs – those where {a mathematical formula}x⊑y, that is, the set of approximated elements is nonempty. A pair {a mathematical formula}(x,y) with {a mathematical formula}x=y is called exact – it “approximates” a single element of the original lattice.{sup:4}</paragraph><paragraph>There are two natural orderings on approximating pairs: first, the information ordering{a mathematical formula}⩽i, that intuitively orders pairs according to their information content. Formally, for {a mathematical formula}x1,x2,y1,y2∈L define {a mathematical formula}(x1,y1)⩽i(x2,y2) iff {a mathematical formula}x1⊑x2 and {a mathematical formula}y2⊑y1. This ordering leads to a complete lattice {a mathematical formula}(L2,⩽i), the product of L with itself, its bilattice. For example, the pair {a mathematical formula}(⊥,⊤) consisting of ⊑-least ⊥ and ⊑-greatest lattice element ⊤ approximates all lattice elements and thus contains no information – it is the least element of the bilattice {a mathematical formula}(L2,⩽i); exact pairs {a mathematical formula}(x,x) are those that are maximally informative while still being consistent. The second natural ordering is the truth ordering{a mathematical formula}⩽t, which orders elements of the bilattice according to their degree of truth. Formally, for {a mathematical formula}x1,x2,y1,y2∈L it is defined by {a mathematical formula}(x1,y1)⩽t(x2,y2) iff {a mathematical formula}x1⊑x2 and {a mathematical formula}y1⊑y2. The pair {a mathematical formula}(⊥,⊥) is the least element of {a mathematical formula}⩽t – in a truth-based setting, it assigns the truth value false to all elements of L; the pair {a mathematical formula}(⊤,⊤) consequently is the {a mathematical formula}⩽t-greatest element – here, all elements of L are assigned value true.</paragraph><paragraph>To define an approximation operator {a mathematical formula}O:L2→L2, one essentially has to define two functions: a function {a mathematical formula}O′:L2→L that yields a new lower bound (first component) for a given pair; and a function {a mathematical formula}O″:L2→L that yields a new upper bound (second component) for a given pair. Accordingly, the overall approximation is then given by {a mathematical formula}O(x,y)=(O′(x,y),O″(x,y)) for {a mathematical formula}(x,y)∈L2. Conversely, in case {a mathematical formula}O is considered given, the notations {a mathematical formula}O′(x,y) and {a mathematical formula}O″(x,y) are read as the projection of {a mathematical formula}O(x,y) to the first and second component, respectively.</paragraph><paragraph>Denecker et al. [11] identify an important subclass of operators on bilattices, namely those that are symmetric, that is, for which {a mathematical formula}O′(x,y)=O″(y,x). For these, {a mathematical formula}O(x,y)=(O′(x,y),O′(y,x)), and to define {a mathematical formula}O it suffices to specify {a mathematical formula}O′. An operator is approximating if it is symmetric and {a mathematical formula}⩽i-monotone. For an antimonotone operator O, its canonical approximation{a mathematical formula}O is given by {a mathematical formula}O′(x,y)=(O(y),O(x)).</paragraph><paragraph>The main contribution of Denecker et al. [11] was the association of the stable operator{a mathematical formula}SO to an approximating operator {a mathematical formula}O. Below, the expression {a mathematical formula}O′(⋅,y):L→L denotes the operator given by {a mathematical formula}x↦O′(x,y) for {a mathematical formula}x∈L.</paragraph><paragraph label="Definition 2.1">For a complete lattice {a mathematical formula}(L,⊑) and an approximating operator {a mathematical formula}O:L2→L2, define the</paragraph><list><list-item label="•">complete stable operator for{a mathematical formula}O as {a mathematical formula}cO:L→L by {a mathematical formula}cO(y)=deflfp(O′(⋅,y));</list-item><list-item label="•">stable operator for{a mathematical formula}O as {a mathematical formula}SO:L2→L2 by {a mathematical formula}SO(x,y)=def(cO(y),cO(x)).</list-item></list><paragraph>This general, lattice-theoretic definition by DMT yields a uniform treatment of the standard semantics of the major nonmonotonic knowledge representation formalisms – logic programming, default logic and autoepistemic logic [12].</paragraph><paragraph label="Definition 2.2">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O:L2→L2 be an approximating operator. Furthermore, let {a mathematical formula}x,y∈L with {a mathematical formula}x⊑y. Define the following semantical notions for {a mathematical formula}O:{a mathematical formula}</paragraph><paragraph>It is clear that each two-valued supported/stable model is a three-valued supported/stable model; furthermore the Kripke–Kleene semantics of an operator is a three-valued supported model and the well-founded semantics is a three-valued stable model. Also, each three-valued/two-valued stable model is a three-valued/two-valued supported model, which is easily seen: if {a mathematical formula}(x,y) is a three-valued stable model, we have {a mathematical formula}(x,y)=SO(x,y). Now {a mathematical formula}(x,y)=SO(x,y)=(cO(y),cO(x))=(lfp(O′(⋅,y)),lfp(O′(⋅,x))) implies {a mathematical formula}x=O′(x,y) and {a mathematical formula}y=O′(y,x), whence {a mathematical formula}(x,y)=(O′(x,y),O′(y,x))=O(x,y) and {a mathematical formula}(x,y) is a three-valued supported model. This holds in particular if {a mathematical formula}x=y, and each two-valued stable model is a two-valued supported model.</paragraph><paragraph label="Ultimate approximations">In subsequent work, Denecker et al. [13] presented a general, abstract way to define the most precise approximation of a given operator O in a lattice {a mathematical formula}(L,⊑). Most precise here refers to a generalisation of {a mathematical formula}⩽i to operators, where for {a mathematical formula}O1,O2:L2→L2, they define {a mathematical formula}O1⩽iO2 iff for all {a mathematical formula}x⊑y∈L it holds that {a mathematical formula}O1(x,y)⩽iO2(x,y). For consistent pairs {a mathematical formula}(x,y) of the bilattice {a mathematical formula}(L2,⩽i), they show that the most precise – called the ultimate – approximation of O is given by {a mathematical formula}UO(x,y)=def(UO′(x,y),UO″(x,y)) with{a mathematical formula}{a mathematical formula} Note that the ultimate approximation works only for consistent pairs and is not symmetric. Still, this definition is remarkable since previously, approximating operators {a mathematical formula}O for lattice operators O had to be devised by hand rather than automatically derived. We next illustrate the workings of the operator-based framework for the case of logic programming.</paragraph></section><section label="2.2"><section-title>Logic programming</section-title><paragraph>For technical convenience, we use definitions along the lines of Fitting [18], whose fixpoint-theoretic approach to logic programming was extended by Denecker et al. [11]. For a nonempty set A – the signature, or set of atoms –, define {a mathematical formula}notA=def{nota|a∈A} and the set of literals over A as {a mathematical formula}Lit(A)=defA∪notA. A logic program rule over A is then of the form {a mathematical formula}a←M where {a mathematical formula}a∈A and {a mathematical formula}M⊆Lit(A). The rule can be read as logical consequence, “a is true if all literals in M are true.” We denote by {a mathematical formula}M+=defM∩A and {a mathematical formula}M−=def{a∈A|nota∈M} the positive and negative body atoms, respectively. A rule is definite if {a mathematical formula}M−=∅. For singleton {a mathematical formula}M={m} we denote the rule just by {a mathematical formula}a←m. A logic program (LP) Π over A is a set of logic program rules over A, and it is definite if all rules in it are definite.</paragraph><paragraph>The perhaps most prominent example for an operator is the one-step consequence operator {a mathematical formula}TΠ associated with a definite logic program Π[18]. For a signature A, it operates on subsets of A and assigns to a set of atoms S those atoms which are implied by S according to the rules in Π. The underlying lattice is therefore {a mathematical formula}(2A,⊆) consisting of the set of Aʼs subsets ordered by ⊆.</paragraph><paragraph label="Definition 2.3">This operator was later generalised to four-valued Belnap logic [18] and can be recast in a bilattice-based setting as follows. A pair {a mathematical formula}(X,Y)∈2A×2A can be read as a four-valued assignment by evaluating all atoms in {a mathematical formula}X∩Y as true, those in {a mathematical formula}A∖(X∪Y) as false, the ones in {a mathematical formula}Y∖X as undefined and the atoms in {a mathematical formula}X∖Y as inconsistent. For a logic program Π over A, define an (approximating) operator {a mathematical formula}TΠ:2A×2A→2A×2A as follows: for {a mathematical formula}X,Y⊆A,{a mathematical formula}{a mathematical formula} Roughly, to construct a new lower bound, the operator {a mathematical formula}TΠ′ returns all those atoms for which a rule exists whose positive body is implied by the current lower bound and whose negative body does not share an atom with the current upper bound. This first of all means that the operator allows to infer an atom via a program rule if – according to the input estimate – the positive body is true and the negative body is false. The fixpoints of {a mathematical formula}TΠ are the four-valued supported models of Π; its consistent fixpoints are the three-valued supported models of Π. The two-valued supported models of Π are computed by the abovementioned operator {a mathematical formula}TΠ, that – in this setting – is defined by {a mathematical formula}TΠ(M)=TΠ′(M,M)[11].</paragraph><paragraph>The abstract principles of Denecker et al. [11] outlined above also yield the corresponding stable operator {a mathematical formula}STΠ. This operator in turn immediately yields the Gelfond–Lifschitz operator {a mathematical formula}GLΠ(M)=STΠ′(M,M) for computing two-valued stable models of Π. The stable operator {a mathematical formula}STΠ also gives rise to the well-founded model of Π, which is the least fixpoint of {a mathematical formula}STΠ. Additionally, three-valued stable models are the consistent fixpoints of {a mathematical formula}STΠ. These are further refined into two additional semantics: M-stable models are three-valued stable models {a mathematical formula}(X,Y) where X is ⊆-maximal – M-stable is for “maximal stable” [36]; L-stable models are three-valued stable models {a mathematical formula}(X,Y) where {a mathematical formula}Y∖X is ⊆-minimal – L-stable is for “least undefined” [36]. It is clear that these same maximisation/minimisation criteria can be applied to consistent fixpoints of {a mathematical formula}TΠ – the three-valued supported models. This leads to M-supported models and L-supported models. In a table much like the one from Definition 2.2, this looks thus:{a mathematical formula} It follows that each two-valued supported/stable model is an L-supported/L-stable model is an M-supported/M-stable model is a three-valued supported/stable model.</paragraph><paragraph>As an example, consider the logic program {a mathematical formula}π1={a←∅,b←a}. It is a definite LP, thus we can iterate its two-valued one-step consequence operator {a mathematical formula}Tπ1 on the empty set, the least element of the relevant lattice: we have {a mathematical formula}Tπ1(∅)={a} and {a mathematical formula}Tπ1({a})={a,b}=Tπ1({a,b}) as a fixpoint and thus the least (two-valued supported) model of program {a mathematical formula}π1. Now we add another rule to this program and set {a mathematical formula}π2=defπ1∪{c←{b,notd}}, a logic program over {a mathematical formula}A={a,b,c,d} that is not definite. To compute its well-founded model, we iterate the associated stable four-valued one-step consequence operator {a mathematical formula}STπ2 on the least element {a mathematical formula}(∅,A) of the relevant bilattice. We see that {a mathematical formula}STπ2(∅,A)=({a},{a,b,c}): intuitively, a is added to the lower bound since its body is satisfied, d is removed from the upper bound because there is no program rule to derive d. Applying {a mathematical formula}STπ2 again leads to the pair {a mathematical formula}({a,b,c},{a,b,c}) which is an exact fixpoint and thus the only two-valued stable model of {a mathematical formula}π2.</paragraph></section><section label="2.3"><section-title>Abstract argumentation frameworks</section-title><paragraph>Dung [14] introduced a way to study the fundamental mechanisms that humans use in argumentation. His argumentation frameworks (AFs) Θ are pairs {a mathematical formula}(A,R) where A is a set and {a mathematical formula}R⊆A×A. The intended reading of an AF Θ is that the elements of A are arguments whose internal structure is abstracted away. The only information about the arguments is given by the relation R encoding a notion of attack: for {a mathematical formula}a,b∈A a pair {a mathematical formula}(a,b)∈R expresses that argument a attacks argument b in some sense. This seemingly lightweight formalism allows for a rich semantical theory, whose most important notions we subsequently recall.</paragraph><paragraph>The purpose of semantics for argumentation frameworks is to determine sets of arguments which are acceptable according to various standards. As an intuitive example, a set of arguments could be accepted if it is internally consistent and can defend itself against attacks from the outside. More formally, a set {a mathematical formula}S⊆A of arguments is conflict-free iff there are no {a mathematical formula}a,b∈S with {a mathematical formula}(a,b)∈R. For an argument {a mathematical formula}a∈A, the set of its attackers is {a mathematical formula}AttackersΘ(a)=def{b∈A|(b,a)∈R}. An AF is finitary iff {a mathematical formula}AttackersΘ(a) is finite for all {a mathematical formula}a∈A. For {a mathematical formula}S⊆A, the set of arguments it attacks is {a mathematical formula}AttackedΘ(S)=def{b∈A|(a,b)∈R for some a∈S}. Finally, for {a mathematical formula}S⊆A and {a mathematical formula}a∈A, the set S defends a iff {a mathematical formula}AttackersΘ(a)⊆AttackedΘ(S), that is, all attackers of a are attacked by S.</paragraph><paragraph>The major semantics for argumentation frameworks can be formulated using two operators that Dung [14] already studied. The first is the characteristic function of an AF {a mathematical formula}Θ=(A,R): for {a mathematical formula}S⊆A, define {a mathematical formula}FΘ(S)=def{a∈A|S defends a}. This operator {a mathematical formula}FΘ is ⊆-monotone and therefore has a least fixpoint in the lattice {a mathematical formula}(2A,⊆). This least fixpoint of {a mathematical formula}FΘ is defined as the grounded extension of Θ. The second relevant operator {a mathematical formula}UΘ takes as input a set S of arguments, and returns the arguments which are not attacked by any argument in S (U is for “unattacked”) – formally {a mathematical formula}UΘ(S)=defA∖AttackedΘ(S). It is an antimonotone operator, and its fixpoints are the stable extensions of Θ. Additionally, {a mathematical formula}UΘ can characterise conflict-freeness: a set {a mathematical formula}S⊆A is conflict-free iff {a mathematical formula}S⊆UΘ(S). Further semantics are defined as follows. A set {a mathematical formula}E⊆A is a complete extension iff it is a conflict-free fixpoint of {a mathematical formula}FΘ. More generally, a set {a mathematical formula}S⊆A is admissible iff S is conflict-free and {a mathematical formula}S⊆FΘ(S). Finally, preferred extensions are ⊆-maximal complete extensions; and semi-stable extensions are those complete extensions E where the set {a mathematical formula}E∪AttackedΘ(E) (the range of the extension E) is ⊆-maximal. The same maximisation criteria that lead from admissible sets to preferred and semi-stable extensions can also be applied to conflict-free sets: a naive extension of an AF is a ⊆-maximal conflict-free set; a stage extension of an AF is a conflict-free set with ⊆-maximal range. For two argumentation frameworks {a mathematical formula}Θ1=(A1,R1) and {a mathematical formula}Θ2=(A2,R2), their union is defined as {a mathematical formula}Θ1∪Θ2=def(A1∪A2,R1∪R2).</paragraph><paragraph>As an example, let the argumentation framework {a mathematical formula}θ=(A,R) be given by {a mathematical formula}A={a,b,c,d} and {a mathematical formula}R={(a,b),(c,d),(d,c)}. It is depicted by the following directed graph:{a mathematical formula} Its grounded extension is the set {a mathematical formula}G={a}; it possesses two stable extensions, {a mathematical formula}E1={a,c} and {a mathematical formula}E2={a,d}. The three sets {a mathematical formula}G,E1,E2 form the only complete extensions of θ.</paragraph></section><section label="2.4"><section-title>Abstract dialectical frameworks</section-title><paragraph>Brewka and Woltran [3] introduced abstract dialectical frameworks as a powerful generalisation of abstract argumentation frameworks that are able to capture not only attack and support, but also more general notions such as joint attack and joint support.</paragraph><paragraph label="Definition 2.4">An abstract dialectical framework (ADF) is a triple {a mathematical formula}Ξ=(S,L,C) where</paragraph><list><list-item label="•">S is a set of statements,</list-item><list-item label="•">{a mathematical formula}L⊆S×S is a set of links, where {a mathematical formula}par(s)=def{r∈S|(r,s)∈L},</list-item><list-item label="•">{a mathematical formula}C={Cs}s∈S is a set of total functions {a mathematical formula}Cs:2par(s)→{in,out}.</list-item></list><paragraph>Intuitively, the function {a mathematical formula}Cs for a statement s determines the acceptance status of s, which naturally depends on the status of its parent nodes {a mathematical formula}par(s). Alternatively, any such function {a mathematical formula}Cs can be represented by the set of all parent subsets leading to acceptance, {a mathematical formula}Csin=def{M⊆par(s)|Cs(M)=in}. We will use both representations in this paper and indicate the alternative one by writing an ADF as {a mathematical formula}(S,L,Cin).</paragraph><paragraph>Many more specific representations of acceptance conditions are possible, Brewka and Woltran [3] even introduce two of these additional representations: For one, an acceptance condition {a mathematical formula}Ca can be described via a propositional formula {a mathematical formula}φa over the vocabulary {a mathematical formula}par(a), which is straightforward to use whenever each statement has only finitely many relevant parents. The understanding there is that {a mathematical formula}Cain is given by the two-valued models of {a mathematical formula}φa, where an interpretation is identified with the set of atoms that are evaluated to true. For another, Brewka and Woltran [3] also demonstrated how assigning weights to links and combining these weights with proof standards can give rise to acceptance conditions.</paragraph><paragraph label="Example 2.1">The following is a simple ADF: {a mathematical formula}D=(S,L,Cin) with statements {a mathematical formula}S={a,b,c,d}, links {a mathematical formula}L={(a,c),(b,b),(b,c),(b,d)} and acceptance functions given by {a mathematical formula}Cain={∅}, {a mathematical formula}Cbin={{b}}, {a mathematical formula}Ccin={{a,b}} and {a mathematical formula}Cdin={∅}. These acceptance functions can intuitively be interpreted as follows:</paragraph><list><list-item label="•">Statement a has no parents, {a mathematical formula}par(a)=∅, thus {a mathematical formula}2par(a)={∅}. The acceptance function specifies that {a mathematical formula}∅↦in, whence a is always in.</list-item><list-item label="•">Statement b is its own parent. According to its acceptance function, it is in only if it is in. Statement b is thus (cyclicly) self-supporting.</list-item><list-item label="•">Statement c has parents {a mathematical formula}par(c)={a,b}. They jointly support c, as is witnessed by {a mathematical formula}Ccin={par(c)}. Note that joint support here indeed means that the support only becomes effective if both parents are in.</list-item><list-item label="•">Statement d is attacked by its only parent b.</list-item></list><paragraph>Brewka and Woltran [3] introduced several semantical notions for ADFs. For an ADF {a mathematical formula}Ξ=(S,L,Cin), a set {a mathematical formula}M⊆S is conflict-free iff for all {a mathematical formula}s∈M we have {a mathematical formula}M∩par(s)∈Csin. A set {a mathematical formula}M⊆S is a model for Ξ iff for each {a mathematical formula}s∈S we have {a mathematical formula}s∈M iff {a mathematical formula}M∩par(s)∈Csin.</paragraph><paragraph label="Example 2.1">ContinuedA conflict in a set of statements intuitively means that there is either an attack within the set or a lack of support for some statement. The running example ADF D has the following conflict-free sets:{a mathematical formula} This is easy to understand: from all subsets of {a mathematical formula}S={a,b,c,d}, we have to remove those that (1) contain both b and d, since b attacks d; or (2) contain c without containing both a and b, because c depends on joint support of a and b. The remaining ones above are conflict-free.The two models of D are {a mathematical formula}M1={a,b,c} and {a mathematical formula}M2={a,d}. Intuitively, a is always in and thus contained in both models. For the self-supporting b, the model semantics has a choice whether or not to accept it, and this choice determines the two models. In {a mathematical formula}M1, statement b is accepted along with a, their joint support of c becomes relevant and c is also accepted. (Statement d is not accepted by {a mathematical formula}M1 since b is accepted and attacks d.) In {a mathematical formula}M2, statement b is not accepted whence c is not accepted due to a lack of support; statement d behaves like an AF argument and so is accepted because its only attacker b is not accepted.</paragraph><paragraph>Some semantics were only defined for a subclass of ADFs called bipolar. Intuitively, in bipolar ADFs (BADFs) each link is supporting or attacking (or both); that is, there is nothing such as joint support or attack and the like. Formally, a link {a mathematical formula}(r,s)∈L is supporting in Ξ iff for all {a mathematical formula}R⊆par(s), we have that {a mathematical formula}R∈Csin implies {a mathematical formula}R∪{r}∈Csin; symmetrically, a link {a mathematical formula}(r,s)∈L is attacking in Ξ iff for all {a mathematical formula}R⊆par(s), we have that {a mathematical formula}R∪{r}∈Csin implies {a mathematical formula}R∈Csin. An ADF {a mathematical formula}Ξ=(S,L,C) is bipolar iff all links in L are supporting or attacking; we use {a mathematical formula}L+ to denote all supporting and {a mathematical formula}L− to denote all attacking links of L in Ξ. A model M of a bipolar ADF Ξ is a BW-stable model of Ξ iff it is the least model of the reduced ADF {a mathematical formula}ΞM defined as {a mathematical formula}ΞM=(SM,LM,CM) with</paragraph><list><list-item label="•">{a mathematical formula}SM=S∩M (nodes are restricted to those in the model),</list-item><list-item label="•">{a mathematical formula}LM={(r,s)|r,s∈SM,(r,s)∈L+} (links are restricted to supporting links among nodes in the model) and</list-item><list-item label="•">for each {a mathematical formula}s∈SM and {a mathematical formula}B⊆SM, we set {a mathematical formula}CsM(B)=in iff {a mathematical formula}Cs(B)=in (likewise the acceptance functions are restricted to the remaining parent nodes).</list-item></list><paragraph> Stable models then serve to define further notions; but first let us define how to remove a set R of statements from an ADF {a mathematical formula}Ξ=(S,L,Cin) as follows: {a mathematical formula}Ξ−R=def(S′,L′,C′), where</paragraph><list><list-item label="•">{a mathematical formula}S′=S∖R (the nodes in R are removed),</list-item><list-item label="•">{a mathematical formula}L′=L∩(S′×S′) (links are restricted to the remaining nodes) and</list-item><list-item label="•">{a mathematical formula}C′={{B∩S′|B∈Csin}}s∈S′ (likewise, acceptance conditions are restricted to the remaining parents).</list-item></list><paragraph>For a bipolar ADF {a mathematical formula}Ξ=(S,L,C), a set {a mathematical formula}M⊆S is BW-admissible in Ξ iff there is some {a mathematical formula}R⊆S with</paragraph><list><list-item label="•">{a mathematical formula}L−∩(R×M)=∅ (there are no attacks from R to M) and</list-item><list-item label="•">M is a stable model of {a mathematical formula}Ξ−R.</list-item></list><paragraph> A set {a mathematical formula}M⊆S is a BW-preferred model of Ξ iff it is ⊆-maximal among the sets BW-admissible in Ξ. Finally, Brewka and Woltran [3] also generalise the grounded semantics: for {a mathematical formula}Ξ=(S,L,C) they define a monotone operator {a mathematical formula}ΓΞ:2S×2S→2S×2S by {a mathematical formula}(X,Y)↦(ΓΞ′(X,Y),ΓΞ″(X,Y)), where{sup:5}{a mathematical formula}{a mathematical formula} The {a mathematical formula}⩽i-least fixpoint of {a mathematical formula}ΓΞ gives rise to the BW-well-founded model of Ξ.</paragraph><paragraph label="Example 2.1">ContinuedThe {a mathematical formula}⩽i-least fixpoint of {a mathematical formula}ΓD is the pair {a mathematical formula}({a},{a,b,c,d}), therefore the BW-well-founded model of D is the set {a mathematical formula}{a}. Intuitively, statement a is in there because it is always in. Statement b is not contained in the BW-well-founded model since it is only self-supporting. Statement c is not contained because it needs joint support by a and b, of which b is missing. For d, it cannot be guaranteed that its attacker b is necessarily out, since it is still contained in the upper bound of {a mathematical formula}ΓDʼs least fixpoint.</paragraph><paragraph label="Proposition 2.1">It is clear that ADFs are a generalisation of AFs: for an argumentation framework {a mathematical formula}Θ=(A,R), its associated abstract dialectical framework is {a mathematical formula}Ξ(Θ)=(A,R,Cin), where {a mathematical formula}Cain={∅} for each {a mathematical formula}a∈A. But this is not just syntactical; Brewka and Woltran [3] showed that their semantical notions for ADFs are generalisations of Dungʼs respective AF notions: Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}Ξ(Θ)=(A,R,Cin)its associated abstract dialectical framework. The following are in one-to-one correspondence:</paragraph><list><list-item label="1.">the grounded extension of Θ and the BW-well-founded model of{a mathematical formula}Ξ(Θ);</list-item><list-item label="2.">conflict-free sets of Θ and conflict-free sets of{a mathematical formula}Ξ(Θ);</list-item><list-item label="3.">stable extensions of Θ and models of{a mathematical formula}Ξ(Θ);</list-item><list-item label="4.">stable extensions of Θ and BW-stable models of{a mathematical formula}Ξ(Θ);</list-item><list-item label="5.">preferred extensions of Θ and BW-preferred models of{a mathematical formula}Ξ(Θ).</list-item></list><paragraph label="Proof">Propositions 3, 1, 7 and 12 of [3].  □</paragraph><paragraph>It is especially notable that models and stable models coincide for AF-based ADFs, a fact that we will illuminate further and for which we will provide an intuitive explanation.</paragraph></section></section><section label="3"><section-title>Approximating semantics of abstract dialectical frameworks</section-title><paragraph>Abstract dialectical frameworks are nonmonotonic knowledge representation formalisms. As such, they allow to express knowledge and provide formal semantics for such expressions. In this respect, nonmonotonic means that extending a knowledge base (that is, an ADF) may invalidate conclusions drawn from it. One approach to define semantics for knowledge bases is the one championed by van Emden, Kowalski and others: there, a revision operator is associated with a knowledge base [18]. The operator revises interpretations for the knowledge base K in the sense that the revision of an interpretation is somehow “more in accord” with the knowledge contained in K. Extending the metaphor, fixpoints of the revision operator then correspond to models since they exactly “hit the spot” in that they represent stationary interpretations that cannot be revised further. In this section, we will apply this operator-based approach to semantics to abstract dialectical frameworks.</paragraph><paragraph>From the definition of a model of an ADF by Brewka and Woltran [3], it is straightforward to devise a two-valued one-step consequence operator for a given ADF: given a two-valued interpretation, we evaluate the acceptance condition of each statement; the resulting evaluation determines the revised interpretation. To generalise this to an approximating operator, we generalise the evaluation from the two-valued {a mathematical formula}{in,out} to four-valued Belnap logic.</paragraph><section label="3.1"><section-title>The characteristic operator of an ADF</section-title><paragraph>For an abstract dialectical framework {a mathematical formula}Ξ=(S,L,Cin), four-valued interpretations can be represented by pairs {a mathematical formula}(X,Y) with {a mathematical formula}X,Y⊆S. Such pairs can equivalently be interpreted as approximations to two-valued interpretations where X represents a lower bound and Y an upper bound of the approximation. Given such an approximating pair {a mathematical formula}(X,Y) and an ADF Ξ, to revise the pair we do the following for each statement {a mathematical formula}s∈S: we check if there is some subset B of the parents of s (which are exactly the statements that determine the acceptance status of s) such that (1) all statements in B being in causes s to be in; (2) all statements in B are indeed in according to the conservative estimate X; (3) the remaining parents of s are indeed out, that is, not contained in the liberal estimate Y. The definition below, the most important definition of the paper, makes this formally precise.</paragraph><paragraph label="Definition 3.1">Let {a mathematical formula}Ξ=(S,L,Cin) be an abstract dialectical framework. Define an operator {a mathematical formula}GΞ:2S×2S→2S×2S by{a mathematical formula}{a mathematical formula}</paragraph><paragraph>The last condition {a mathematical formula}(par(s)∖B)∩Y=∅ can be equivalently reformulated as {a mathematical formula}par(s)∖B⊆S∖Y. By {a mathematical formula}B⊆X this means that all parents of s which are not in must be out – there must not be undecided parents of s.</paragraph><paragraph label="Proof">A two-valued immediate consequence operator for ADFs (the equivalent of logic programsʼ two-valued van Emden–Kowalski operator {a mathematical formula}TΠ) is now given by {a mathematical formula}GΞ(X)=defGΞ′(X,X). The next lemma about this two-valued operator relates to ADF models and will prove useful on various occasions. For any abstract dialectical framework{a mathematical formula}Ξ=(S,L,C),{a mathematical formula}s∈Sand{a mathematical formula}X⊆Swe have{a mathematical formula}s∈GΞ(X)iff{a mathematical formula}X∩par(s)∈Csin.{a mathematical formula}</paragraph><paragraph>Our definition of the approximating operator of an ADF immediately defines quite a number of semantics for ADFs, among them all the semantics of Definition 2.2. In the following, we will show how some of the standard operator-based semantics coincide with existing ADF semantics. Operator-based semantics without a corresponding ADF semantics accordingly define new semantical notions for abstract dialectical frameworks, for example three-valued stable models. Similarly, there are ADF semantics which have no operator-based counterpart – BW-stable, BW-admissible and BW-preferred –, we will provide alternative, operator-based definitions for these semantics.</paragraph><paragraph>But first, we do the obviously necessary and show that {a mathematical formula}GΞ is indeed an approximating operator. From Definition 3.1 it is immediate that {a mathematical formula}GΞ is symmetric. It is easy to prove that the operator is also {a mathematical formula}⩽i-monotone.</paragraph><paragraph label="Proof">For any ADF{a mathematical formula}Ξ=(S,L,C), the operator{a mathematical formula}GΞis{a mathematical formula}⩽i-monotone.Let {a mathematical formula}(X1,Y1)⩽i(X2,Y2), that is, {a mathematical formula}X1⊆X2 and {a mathematical formula}Y2⊆Y1. We have to show {a mathematical formula}GΞ(X1,Y1)⩽iGΞ(X2,Y2), that is, (1) {a mathematical formula}GΞ′(X1,Y1)⊆GΞ′(X2,Y2) and (2) {a mathematical formula}GΞ′(Y2,X2)⊆GΞ′(Y1,X1).</paragraph><list><list-item label="1.">Let {a mathematical formula}s∈GΞ′(X1,Y1). Then there is an {a mathematical formula}M∈Csin with {a mathematical formula}M⊆X1 and {a mathematical formula}(par(s)∖M)∩Y1=∅. Now {a mathematical formula}M⊆X1⊆X2; furthermore {a mathematical formula}Y2⊆Y1 implies {a mathematical formula}(par(s)∖M)∩Y2=∅, whence {a mathematical formula}s∈GΞ′(X2,Y2).</list-item><list-item label="2.">Analogous. □</list-item></list><paragraph>Hence the fixpoints of this operator form a complete lattice [38]. From {a mathematical formula}GΞ being approximating it follows that it maps consistent pairs to consistent pairs [11, Proposition 14]; in particular its least fixpoint is consistent. Finally, we can construct its associated stable operator {a mathematical formula}SGΞ as defined by Denecker et al. [11]. We will now use our newly defined approximating ADF operator to systematically reconstruct semantical notions for abstract dialectical frameworks.</paragraph><section label="3.1.1"><section-title>Conflict-free sets</section-title><paragraph>First of all, we find a nice characterisation of conflict-freeness: a set M is conflict-free for an ADF Ξ iff application of the two-valued immediate consequence operator {a mathematical formula}GΞ leads to a superset of M, that is, M is a postfixpoint of {a mathematical formula}GΞ. Intuitively speaking, each statement that is contained in a conflict-free set M has a reason to be contained in M.</paragraph><paragraph label="Proof">For any abstract dialectical framework{a mathematical formula}Ξ=(S,L,C), a set{a mathematical formula}M⊆Sis conflict-free for Ξ iff{a mathematical formula}M⊆GΞ(M).{a mathematical formula}</paragraph><paragraph>Notice that this characterisation only uses conflict-free sets and is thus inherently two-valued. We will later generalise “conflict-free” to three-valued interpretations represented by consistent pairs.</paragraph></section><section label="3.1.2"><section-title>Model semantics</section-title><paragraph label="Proof">Much in accordance with logic programming, a model of an ADF is simply a two-valued fixpoint of its associated consequence operator: For any abstract dialectical framework{a mathematical formula}Ξ=(S,L,C), a set{a mathematical formula}M⊆Sis a model of Ξ iff{a mathematical formula}GΞ(M,M)=(M,M).{a mathematical formula}</paragraph><paragraph>Since the correspondence with logic programming is striking, we will use the more specific term “two-valued supported model” from now on.</paragraph></section><section label="3.1.3"><section-title>Stable model semantics</section-title><paragraph>Motivated by the same notion of logic programming, Brewka and Woltran [3] defined stable models for bipolar ADFs. When we compare their definition to the general operator-based notion of two-valued stable models, we have to acknowledge a slight mismatch.</paragraph><paragraph label="Example 3.1">Consider the following (bipolar) ADF {a mathematical formula}ξ=(S,L,C) with components {a mathematical formula}S={a,b}, {a mathematical formula}L={(a,a),(a,b),(b,b)} and {a mathematical formula}Cain={{a}} and {a mathematical formula}Cbin={∅,{a},{b}}. In words, a supports itself while a and b jointly attack b. The set {a mathematical formula}M={b} is a BW-stable model of ξ: The reduct {a mathematical formula}ξM is given by the triple {a mathematical formula}({b},∅,{Cb′in}) with {a mathematical formula}Cb′in={∅}, an ADF where b is always in. (The link {a mathematical formula}(b,b) is not in the reduct because it is attacking in ξ.) However, the operator {a mathematical formula}Gξ does not have a two-valued stable model: when trying to reconstruct the upper bound {a mathematical formula}{b}, we get {a mathematical formula}Gξ′(∅,{b})=∅ since b attacks itself and thus its containment in the upper bound prevents its inclusion in the new lower bound, as witnessed by {a mathematical formula}par(b)∩{b}={b}≠∅. (Interestingly, this example also shows that M-stable models are not necessarily M-supported: ξ has the single M-stable model {a mathematical formula}(∅,{b}) and the two M-supported models {a mathematical formula}({a},{a,b}) and {a mathematical formula}({b},{b}).)</paragraph><paragraph>So while there are ADFs with BW-stable models which are not two-valued stable models of the ADFʼs approximating operator, we can establish an inclusion relation for the converse direction: any operator-based two-valued stable model of an ADF is also a BW-stable model of the ADF. To show this, we first need a lemma that relates the operators {a mathematical formula}GΞ′(⋅,M) and {a mathematical formula}GΞM whenever M is a model of Ξ.</paragraph><paragraph label="Proof">Let{a mathematical formula}Ξ=(S,L,C)be a bipolar ADF and{a mathematical formula}(M,M)be a two-valued supported model for Ξ. For any{a mathematical formula}X⊆Mwe find{a mathematical formula}GΞ′(X,M)⊆GΞM(X).Recall that the reduct of Ξ with M is defined by {a mathematical formula}ΞM=(M,LM,CM) with reduced links {a mathematical formula}LM={(r,s)|r,s∈M,(r,s)∈L+} and for each {a mathematical formula}s∈M and {a mathematical formula}B⊆M, we have {a mathematical formula}CsM(B)=in iff {a mathematical formula}Cs(B)=in. Now for each {a mathematical formula}s∈S denote by {a mathematical formula}Ps the parent nodes of s with respect to L and for {a mathematical formula}s∈M by {a mathematical formula}PsM the parent nodes of s with respect to {a mathematical formula}LM. It follows that {a mathematical formula}PsM=(M∩Ps)∖{r∈Ps|(r,s)∉L+}.Let {a mathematical formula}s∈GΞ′(X,M). (Observe that {a mathematical formula}X⊆M means {a mathematical formula}GΞ′(X,M)⊆GΞ′(M,M)=M and thus {a mathematical formula}s∈M.) Then there is a {a mathematical formula}B⊆Ps with {a mathematical formula}Cs(B)=in, {a mathematical formula}B⊆X and {a mathematical formula}(Ps∖B)∩M=∅. Now {a mathematical formula}PsM⊆Ps and {a mathematical formula}X⊆M yield {a mathematical formula}(PsM∖B)∩X=∅, whence {a mathematical formula}X∩PsM⊆B. Define {a mathematical formula}B′=B∖{r∈Ps|(r,s)∉L+}. By definition {a mathematical formula}B′⊆PsM, whence by {a mathematical formula}B′⊆B⊆X we get {a mathematical formula}B′⊆X∩PsM. Since all the removed parents r were attackers (Ξ is bipolar), we still have {a mathematical formula}Cs(B′)=in. Now all links from {a mathematical formula}PsM to s are supporting and thus still {a mathematical formula}Cs(X∩PsM)=in. Hence {a mathematical formula}Cs(X∩PsM)=CsM(X∩PsM)=in and {a mathematical formula}s∈GΞM(X).  □</paragraph><paragraph>This shows that {a mathematical formula}GΞM – the two-valued operator associated to the reduced ADF {a mathematical formula}ΞM – is in some sense “complete” with respect to the result of {a mathematical formula}GΞ′(⋅,M) – the operator for checking whether M is a two-valued stable model of Ξ. The next lemma will show that this “completeness” carries over to the least fixpoints of these operators.</paragraph><paragraph label="Proof">Let{a mathematical formula}Ξ=(S,L,C)be a bipolar ADF and{a mathematical formula}(M,M)be a two-valued supported model for Ξ. If M is the least fixpoint of{a mathematical formula}GΞ′(⋅,M), then it is the least fixpoint of{a mathematical formula}GΞM.We use the notation from the proof of Lemma 3.5. Let {a mathematical formula}s∈M and observe that we have {a mathematical formula}Cs(M∩Ps)=in since M is a model of Ξ. By the definition of the reduct, we get {a mathematical formula}PsM=(M∩Ps)∖{r∈Ps|(r,s)∉L+}. Since Ξ is bipolar, any link from {a mathematical formula}(M∩Ps)∖PsM is attacking and thus {a mathematical formula}Cs(PsM)=in.</paragraph><list><list-item label="•">M is a fixpoint of {a mathematical formula}GΞM:{a mathematical formula}</list-item><list-item label="•">M is the least fixpoint of {a mathematical formula}GΞM: Let {a mathematical formula}X⊆M be a fixpoint of {a mathematical formula}GΞM. By Lemma 3.5, {a mathematical formula}GΞ′(X,M)⊆GΞM(X)=X and X is a prefixpoint of {a mathematical formula}GΞ′(⋅,M). Since M is the least fixpoint and thus also the least prefixpoint of {a mathematical formula}GΞ′(⋅,M), we get {a mathematical formula}M⊆X.  □</list-item></list><paragraph>Using the lemma, it is easy to show that the set of BW-stable models contains all operator-based two-valued stable models.</paragraph><paragraph label="Proof">Let{a mathematical formula}Ξ=(S,L,C)bipolar abstract dialectical framework and{a mathematical formula}M⊆S. If{a mathematical formula}(M,M)is a two-valued stable model of Ξ, then M is a BW-stable model of Ξ.Let {a mathematical formula}SGΞ(M,M)=(M,M). By definition {a mathematical formula}M=cGΞ(M)=lfp(GΞ′(⋅,M)), that is, M is the least fixpoint of {a mathematical formula}GΞ′(⋅,M). By Lemma 3.6, M is the least fixpoint of {a mathematical formula}GΞM. Therefore, M is the least model of {a mathematical formula}ΞM (and a model of Ξ), thus it is a BW-stable model of Ξ.  □</paragraph><paragraph>The mismatch noticed in Example 3.1 does not depend on our definition of the four-valued approximating operator: the ADF presented there also does not allow for ultimate two-valued stable models, although the model notion of Brewka and Woltran [3] is perfectly captured by the two-valued one-step ADF consequence operator, which also gives rise to ADFʼs ultimate family of semantics. Put another way, if we take the model notion from Brewka and Woltran [3] and apply to it the transformations of Denecker et al. [13], we arrive at an ultimate stable model semantics which is demonstrably different from BW-stable models.</paragraph><paragraph>Thus at the current point, we have two different stable model semantics at our disposal – operator-based two-valued stable models and BW-stable models. The following example shows that the BW-stable semantics admits too many models, since there are ADFs which admit for BW-stable models where one is a proper subset of another.</paragraph><paragraph label="Example 3.2">Consider the following (bipolar) ADF {a mathematical formula}ξ=(S,L,C) with components {a mathematical formula}S={a,b}, {a mathematical formula}L={(a,b),(b,b)} and {a mathematical formula}Cain={∅} and {a mathematical formula}Cbin={∅,{b},{a,b}}. In words, a is always in and attacks b, which however can support itself. The ADF ξ has two BW-stable models, {a mathematical formula}M1={a} and {a mathematical formula}M2={a,b}: The reduct of ξ with {a mathematical formula}M1 is given by {a mathematical formula}ξM1=({a},∅,CM1) with {a mathematical formula}CaM1={∅}, thus its least model is {a mathematical formula}{a}=M1. For the second BW-stable model {a mathematical formula}M2={a,b}, the reduct of ξ with {a mathematical formula}M2 is given by {a mathematical formula}ξM2=(S,{(b,b)},CM2) with {a mathematical formula}CaM2={∅} and {a mathematical formula}CbM2={∅,{b}}. (Note that the link {a mathematical formula}(b,b) is both supporting and attacking, thus in fact irrelevant.) It is easy to see that {a mathematical formula}{a,b}=M2 is the least model of this ADF. In contrast, the approximating operator {a mathematical formula}Gξ associated with ξ admits only the single two-valued stable model {a mathematical formula}({a},{a}).</paragraph><paragraph>The problem with this example is that the ADF ξ allows for the BW-stable model {a mathematical formula}M2 in which statement b cyclicly supports itself. This violates the intuitive requirement of stable semantics that whatever it takes to be true must have a non-cyclic justification. Furthermore, in logic programming, two distinct stable models of normal logic programs cannot be in a subset-relationship; likewise in Reiterʼs default logic, two distinct extensions of a default theory cannot be in a subset-relationship. With our operator-based definition of two-valued stable models for ADFs, this property comes for free:</paragraph><paragraph label="Proof">Let{a mathematical formula}(L,⊑)be a complete lattice and{a mathematical formula}Oan approximating operator on the bilattice{a mathematical formula}(L2,⩽i). For any{a mathematical formula}x,y∈Lwith{a mathematical formula}SO(x,x)=(x,x)and{a mathematical formula}SO(y,y)=(y,y), we have that{a mathematical formula}x⊑yimplies{a mathematical formula}x=y.Let {a mathematical formula}x,y∈L with {a mathematical formula}SO(x,x)=(x,x), {a mathematical formula}SO(y,y)=(y,y) and {a mathematical formula}x⊑y. Since {a mathematical formula}O is antimonotone in the second component, we have {a mathematical formula}O(x,y)⊑O(x,x)=x and x is a prefixpoint of {a mathematical formula}O(⋅,y). Now y is the least prefixpoint of {a mathematical formula}O(⋅,y) and thus {a mathematical formula}y⊑x.  □</paragraph><paragraph>Together with Example 3.2, this result means that there is no approximating operator for which Definition 2.1 can reconstruct BW-stable models. However, our operator-based definition of two-valued stable models easily gives rise to an equivalent reduct-based definition of the same concept: in operator terms, M is a two-valued stable model of {a mathematical formula}GΞ iff M is the least fixpoint of the operator {a mathematical formula}GΞ′(⋅,M). To define a reduct, we have to find the ADF associated to this consequence operator defined for {a mathematical formula}X⊆S by{a mathematical formula} Our new operator-inspired reduct now just has to mimic the way the operator enforces the upper bound M. This is achieved by the definition below, which notably works for all ADFs, bipolar or not.</paragraph><paragraph label="Definition 3.2">Let {a mathematical formula}Ξ=(S,L,Cin) be an abstract dialectical framework. A set {a mathematical formula}M⊆S is a stable model of Ξ iff it is the unique least model of the reduced ADF {a mathematical formula}ΞM=(S,L,CMin) with{a mathematical formula}</paragraph><paragraph>Intuitively, the reduct only changes the acceptance functions of statements such that accepting parent configurations that rely on some statement from M being out are discarded (since the statements in M are by virtue in). If the reduced ADF has a unique least model, and this least model coincides with M, then M is a stable model of the original ADF. It is easy to show that this new reduct-based definition of a stable model coincides with our operator-based definition of two-valued stable models.</paragraph><paragraph label="Proof">Let{a mathematical formula}Ξ=(S,L,Cin)be an abstract dialectical framework and{a mathematical formula}M⊆S.{a mathematical formula}(M,M)is a two-valued stable model of{a mathematical formula}GΞiff M is a stable model of Ξ.First observe that we find the two-valued consequence operator of the reduct {a mathematical formula}ΞM given for any {a mathematical formula}X⊆S by{a mathematical formula} Hence {a mathematical formula}X⊆M implies {a mathematical formula}GΞM(X)=GΞ′(X,M) and the two operators {a mathematical formula}GΞM and {a mathematical formula}GΞ′(⋅,M) coincide on all subsets of M. In particular, M is the least fixpoint of {a mathematical formula}GΞ′(⋅,M) iff M is the least fixpoint of {a mathematical formula}GΞM. (The least fixpoint of {a mathematical formula}GΞ′(⋅,M) always exists since the operator is monotone in {a mathematical formula}(2S,⊆).) Now{a mathematical formula}</paragraph><paragraph label="Example 3.3">Let us reconsider the problematic ADF from Example 3.2, that is, {a mathematical formula}ξ=(S,L,C) with components {a mathematical formula}S={a,b}, {a mathematical formula}L={(a,b),(b,b)} and {a mathematical formula}Cain={∅} and {a mathematical formula}Cbin={∅,{b},{a,b}}.The (new) reduct of ξ with {a mathematical formula}M2={a,b} is given by {a mathematical formula}ξM2=(S,L,CM2) with {a mathematical formula}CM2,ain={∅} and {a mathematical formula}CM2,bin={{a,b}}. It is easy to see that {a mathematical formula}{a}≠M2 is the least model of this ADF and {a mathematical formula}M2 is not a stable model of ξ.The (new) reduct of ξ with {a mathematical formula}M1={a} is given by {a mathematical formula}ξM1=(S,L,CM1in) with {a mathematical formula}CM1,ain={∅} and {a mathematical formula}CM1,bin={{a,b}}. Its least model is {a mathematical formula}{a}=M1 and {a mathematical formula}M1 is thus a stable model of ξ, just as expected.</paragraph></section><section label="3.1.4"><section-title>Admissible sets</section-title><paragraph label="Example 3.4">For the generalisation of admissibility provided by Brewka and Woltran [3], the picture is not quite as clear. Firstly, for the special case of Dung argumentation frameworks, any stable extension of an AF is admissible. So we should naturally expect that all ADF generalisations of stable AF extensions are also (the ADF generalisation of) admissible; more specifically, since for AF-based ADFs we have that stable extensions coincide with two-valued supported models of the ADF, for an ADF generalisation of admissibility we should expect that all two-valued supported models of the ADF are also admissible. But this is not the case for the generalisation of admissibility of Brewka and Woltran [3]. Recall that a set M is BW-admissible iff there exists an {a mathematical formula}R⊆S such that M is a stable model of {a mathematical formula}Ξ−R. Consider the simplest abstract dialectical framework with a self-supporting cycle between two arguments, {a mathematical formula}ξ=(S,L,C) with {a mathematical formula}S={a,b}, {a mathematical formula}L={(a,b),(b,a)} and {a mathematical formula}Cain={{b}}, {a mathematical formula}Cbin={{a}}. In other words, the links between a and b are both supporting. Hence the set {a mathematical formula}{a,b} is a (two-valued supported) model of ξ, but it is not BW-admissible: {a mathematical formula}{a,b} is not a stable model of ξ or any subframework of ξ.</paragraph><paragraph label="Example 3.5">It might seem that BW-admissibility is just too restrictive and could be fixed by weakening the definition. One possibility may be to replace “stable” in the definition of BW-admissibility by “supported.” But, as the following example shows, already the current, stable-based definition of BW-admissibility considers too many sets to be admissible. Consider the (bipolar) ADF {a mathematical formula}ξ=(S,L,C) with statements {a mathematical formula}S={a,b,c,d}, links {a mathematical formula}L={(b,a),(c,a),(d,c)} and acceptance conditions {a mathematical formula}Cain={∅,{b},{c}}, {a mathematical formula}Cbin={∅}, {a mathematical formula}Ccin={{d}} and {a mathematical formula}Cdin={∅}. In words, there is a joint attack of b and c on a – a is out if both b and c are in, and a is in otherwise. Statements b and d are always in, and c is in if d is. This ADF ξ has the BW-admissible set {a mathematical formula}M={a,b}: Taking {a mathematical formula}R={d}, we see that there are no attacks from R to M. Furthermore, the ADF {a mathematical formula}ξ−R=ξ′=(S′,L′,C′) is given by {a mathematical formula}S′={a,b,c}, {a mathematical formula}L′={(b,a),(c,a)} and {a mathematical formula}Ca′={∅,{b},{c}}, {a mathematical formula}Cb′={∅} and {a mathematical formula}Cc′={}. This ADF {a mathematical formula}ξ′ has the stable model {a mathematical formula}{a,b}, which is easily verified when looking at the reduct {a mathematical formula}ξ′M=({a,b},∅,C′M) where {a mathematical formula}Ca′M=Cb′M={∅}. So in a sense, the set {a mathematical formula}{a,b} being admissible depends on the removal of {a mathematical formula}{d}, in which case the only support of c is removed and the joint attack on a cannot happen. But d is by definition of its acceptance condition always in, so no reasonable semantics could ever label it out, and consequently the condition upon which BW-admissibility of {a mathematical formula}{a,b} hinges can never become true.{sup:6}</paragraph><paragraph>There is an alternative characterisation of admissibility which satisfies all of our abovementioned criteria. That is, all two-valued supported models of an ADF are admissible in our new sense; and for the ADF from Example 3.5, the undesired BW-admissible set from above is not admissible according to this new definition. As a much more important property, it is defined for all ADFs and not only bipolar ones. It is also a generalisation of AF admissibility, as will be shown in Section 4.</paragraph><paragraph>Intuitively, we require that an admissible pair is first of all consistent and satisfies a further criterion: for any statement that is labelled with either in or out, the pair must provide sufficient justification for this choice. For a pair {a mathematical formula}(M,N), this means that any statement that is labelled in (contained in M) must indeed be accepted by this pair; conversely, any statement that is labelled out (not contained in N) must indeed be rejected by the pair. Acceptance and rejection is expressed using the approximating operator, so for {a mathematical formula}(M,N) we require {a mathematical formula}M⊆GΞ′(M,N) (justified lower bound) and {a mathematical formula}GΞ″(M,N)⊆N (justified upper bound). This combination is easily expressed using the information ordering.</paragraph><paragraph label="Definition 3.3">For any ADF {a mathematical formula}Ξ=(S,L,C), a consistent pair {a mathematical formula}(M,N) is admissible in Ξ iff {a mathematical formula}(M,N)⩽iGΞ(M,N).</paragraph><paragraph>It is clear that the lower bound of an admissible pair {a mathematical formula}(M,N) is a conflict-free set since {a mathematical formula}M⊆GΞ′(M,N)⊆GΞ′(M,M)=GΞ(M). Since for any two-valued supported model M we have {a mathematical formula}(M,M)=GΞ(M,M) it is also immediate that all two-valued supported models of an ADF are (three-valued supported models and in turn) admissible pairs. Interestingly, {a mathematical formula}⩽i-postfixpoints of operators {a mathematical formula}O were also important for Denecker et al. [13] – they called them {a mathematical formula}O-reliable pairs.</paragraph></section><section label="3.1.5"><section-title>Preferred semantics</section-title><paragraph>In principle, there could be different ways to define the preferred semantics for ADFs: (1) the argumentation way of taking all model candidates that are maximally admissible; (2) the logic-programming way of maximising over three-valued supported models. It is clear that any preferred pair derived according to (2) is also preferred in the sense of (1) since any three-valued supported model is admissible. But – as we will show next – the converse also holds, so it is inessential which of these two definitions we pick. This even holds for any approximating operator on a complete lattice, as is shown by the theorem below; in AF-speak, it expresses the operator generalisation of “all preferred extensions are complete.”</paragraph><paragraph label="Proof">Let{a mathematical formula}(L,⊑)be a complete lattice and{a mathematical formula}Obe an approximating operator on{a mathematical formula}(L2,⩽i). Any{a mathematical formula}⩽i-maximal admissible pair for{a mathematical formula}Ois a three-valued supported model for{a mathematical formula}O.Let {a mathematical formula}(x,y) be an {a mathematical formula}⩽i-maximal admissible pair, that is, {a mathematical formula}(x,y)⩽iO(x,y) and there is no admissible pair {a mathematical formula}(xˆ,yˆ) with {a mathematical formula}(x,y)&lt;i(xˆ,yˆ). We have to show {a mathematical formula}O(x,y)=(x,y), so assume to the contrary that {a mathematical formula}O(x,y)⩽̸i(x,y), that is, {a mathematical formula}(x,y)&lt;iO(x,y). Since {a mathematical formula}O is approximating, it is in particular {a mathematical formula}⩽i-monotone and from {a mathematical formula}(x,y)⩽iO(x,y) we can infer {a mathematical formula}O(x,y)⩽iO(O(x,y)). Thus {a mathematical formula}O(x,y) is itself admissible and {a mathematical formula}(x,y)&lt;iO(x,y), in contradiction to {a mathematical formula}(x,y) being {a mathematical formula}⩽i-maximal admissible.  □</paragraph><paragraph>As an immediate consequence, we have the result that all maximal admissible ADF models are three-valued supported (as we will see, “complete”) models.</paragraph><paragraph label="Corollary 3.11">Let Ξ be an abstract dialectical framework. Any{a mathematical formula}⩽i-maximal admissible pair is a three-valued supported model.</paragraph><paragraph>This leads to the generalisation of AF preferred semantics for abstract dialectical frameworks (including non-bipolar ones): they are simply M-supported models of {a mathematical formula}GΞ, that is, {a mathematical formula}⩽i-maximal fixpoints of {a mathematical formula}GΞ. Since supported and stable semantics coincide for argumentation frameworks, another suitable candidate for generalising preferred semantics is the M-stable semantics for ADFs, that is, {a mathematical formula}⩽i-maximal fixpoints of {a mathematical formula}SGΞ.</paragraph><paragraph label="Well-founded semantics">In order to generalise the grounded semantics from AFs to ADFs, Brewka and Woltran [3] introduced – for an ADF {a mathematical formula}Ξ=(S,L,C) – the operator {a mathematical formula}ΓΞ on the bilattice {a mathematical formula}(2S×2S,⩽i). Motivated by naming conventions from logic programming, they decided to call (the lower bound of) the least fixpoint of {a mathematical formula}ΓΞ the “well-founded model” of an ADF. As our next result shows, their intuition of defining the operator was on the spot – they defined the most precise approximation of the two-valued ADF consequence operator {a mathematical formula}GΞ.{sup:7}</paragraph><paragraph label="Proof">For any abstract dialectical framework Ξ, the operator{a mathematical formula}ΓΞis the ultimate approximation of{a mathematical formula}GΞ.Recall that for {a mathematical formula}Ξ=(S,L,C) the operator {a mathematical formula}ΓΞ:2S×2S→2S×2S is given by {a mathematical formula}(X,Y)↦(ΓΞ′(X,Y),ΓΞ″(X,Y)), where{a mathematical formula}{a mathematical formula} Now by [13, Theorem 5.6], for {a mathematical formula}X⊆Y⊆S, the ultimate approximation {a mathematical formula}UΞ of the operator {a mathematical formula}GΞ is characterised by {a mathematical formula}UΞ(X,Y)=(UΞ′(X,Y),UΞ″(X,Y)) with{a mathematical formula}{a mathematical formula} By Lemma 3.1, we know that for any {a mathematical formula}s∈S and {a mathematical formula}Z⊆S we find {a mathematical formula}Z∩par(s)∈Csin iff {a mathematical formula}s∈GΞ(Z), which leads to the equalities{a mathematical formula} and, likewise for the upper bound,{a mathematical formula} which proves the claim.  □</paragraph><paragraph>This lemma immediately entails that what Brewka and Woltran [3] called “well-founded” is what DMT call the ultimate Kripke–Kleene semantics.</paragraph><paragraph label="Corollary 3.13">For any ADF Ξ, its BW-well-founded semantics coincides with its ultimate Kripke–Kleene semantics.</paragraph><paragraph>The well-founded semantics of Ξ in the usual sense (the least fixpoint of the stable operator {a mathematical formula}SGΞ) hence may differ from the BW-well-founded semantics.</paragraph><paragraph label="Example 2.1">ContinuedRecall that the ultimate Kripke–Kleene semantics of D is given by the pair {a mathematical formula}({a},{a,b,c,d}) (the least model of the operator {a mathematical formula}UD=ΓD). The well-founded semantics of D in the logic-programming sense is given by the pair {a mathematical formula}({a,d},{a,d}). Since this pair is exact, it also represents the unique two-valued stable model of D. (Recall that {a mathematical formula}M2={a,d} is the supported model of D where the self-support of b was rejected.)</paragraph><paragraph>We have seen how the characteristic operator of an ADF can be used to redefine several existing ADF semantics. The remaining operator-based semantics that we did not yet talk about therefore present new semantics for ADFs. Among them, we generalised complete AF extensions to ADFs (three-valued supported/stable models) which will be explored in more detail in the AF section.</paragraph></section></section><section label="3.2"><section-title>From ADFs to logic programs</section-title><paragraph>We now use the four-valued one-step ADF consequence operator to determine the relationship between ADFs and logic programs. As it turns out, there is a straightforward polynomial and modular translation from ADFs to logic programs which is additionally faithful with respect to all operator-based semantics. The translation creates logic program rules for each statement of a given ADF Ξ. The body of a rule for statement s is satisfied whenever for some {a mathematical formula}M⊆par(s), the statements in M are in and the remaining parents are out.</paragraph><paragraph label="Definition 3.4">Let {a mathematical formula}Ξ=(S,L,Cin) be an ADF. Define its standard logic program as follows.{a mathematical formula}</paragraph><paragraph label="Example 2.1">ContinuedThe standard logic program {a mathematical formula}Π(D) of our running example ADF D is given by{a mathematical formula}</paragraph><paragraph>As another illustrative example, we look at the ADF where we observed a mismatch between BW-stable models and operator-based two-valued stable models.</paragraph><paragraph label="Example 3.6">The ADF ξ from Example 3.1 is translated into the logic program consisting of the following rules:{a mathematical formula} This somewhat obviates why there is no two-valued stable model for ξ: the only candidate for deriving b in some reduct program is the last rule, which however circularly requires b itself.</paragraph><paragraph>The next lemma shows that the term “standard logic program” is well-chosen, since the translation is faithful with respect to all operator-based semantics: the associated approximating operators of an ADF and its standard logic program are identical. The term {a mathematical formula}B¯ below denotes the complement of B with respect to the parents of s, that is, {a mathematical formula}B¯=par(s)∖B.</paragraph><paragraph label="Proof">For any ADF{a mathematical formula}Ξ=(S,L,Cin), we find that{a mathematical formula}GΞ=TΠ(Ξ).Let {a mathematical formula}X,Y⊆S. We show {a mathematical formula}GΞ′(X,Y)=TΠ(Ξ)′(X,Y).{a mathematical formula}</paragraph><paragraph label="Theorem 3.15">This result yields immediate correspondence of all operator-based semantics of an ADF Ξ with the respective semantics of its standard logic program {a mathematical formula}Π(Ξ). Let{a mathematical formula}Ξ=(S,L,Cin)be an abstract dialectical framework and{a mathematical formula}Π(Ξ)its standard logic program. Then Ξ and{a mathematical formula}Π(Ξ)coincide on all semantics based on their approximation operators.</paragraph><paragraph>In particular, {a mathematical formula}GΞ=TΠ(Ξ) and an ADF and its standard logic program also agree on all semantics derived from the ultimate approximation of their two-valued operators. These results obviate that propositional normal logic programs are at least as expressive as abstract dialectical frameworks in a very strong sense: there exists a single translation that preserves models in a whole type of semantics. Furthermore, the translation can be computed in polynomial time and is modular with respect to statements.</paragraph><paragraph label="Example 3.7">More precisely, let {a mathematical formula}Ξ1=(S1,L1,C1in) and {a mathematical formula}Ξ2=(S2,L2,C2in) be ADFs such that {a mathematical formula}S1∩S2=∅. Then the union of the two ADFs is defined as {a mathematical formula}Ξ1∪Ξ2=def(S1∪S2,L1∪L2,C1in∪C2in). For such pairs of ADFs we indeed observe that the translation is modular: {a mathematical formula}Π(Ξ1∪Ξ2)=Π(Ξ1)∪Π(Ξ2). But it is not straightforward to define the union of two ADFs when they share statements: Consider the ADFs {a mathematical formula}ξ1=(S1,L1,C1in) with {a mathematical formula}S1={a,b}, {a mathematical formula}L1={(b,a)}, {a mathematical formula}C1,ain={{b}} and {a mathematical formula}C1,bin={∅} (in words, b is always in and supports a); and {a mathematical formula}ξ2=(S2,L2,C2in) with {a mathematical formula}S2={a,c}, {a mathematical formula}L2={(c,a)}, {a mathematical formula}C2,ain={{c}} and {a mathematical formula}C2,cin={∅} (in words, c is always in and supports a). In both frameworks, the common statement a is supported by a statement which is always in. Consequently, a is always in for every model of every semantics in both ADFs. However, the union of the acceptance functionsʼ characteristic sets is {a mathematical formula}C1,ain∪C2,ain={{b},{c}}, and thus in the union ADF, statement a is always out since both parents are always in. The undesired result in this case is that a is always accepted in the two constituent ADFs but not accepted in their union, although this union should be expected to exhibit some kind of disjunctive acceptance with respect to its constituents. (For comparison, note that {a mathematical formula}Π(ξ1)={a←b,b←∅} and {a mathematical formula}Π(ξ2)={a←c,c←∅}, whence a is contained in the single (two-valued) stable model {a mathematical formula}{a,b,c} of {a mathematical formula}Π(ξ1)∪Π(ξ2).)</paragraph><paragraph>Of course, the example above would work if we represented acceptance conditions by formulas {a mathematical formula}φ1,a=b and {a mathematical formula}φ2,a=c: then in the union of the two ADFs the acceptance formula is given by the disjunction {a mathematical formula}φ1,a∨φ2,a=b∨c which has the desired set of models {a mathematical formula}{{b},{c},{b,c}}. However, this is dependent on the specific chosen representation of acceptance conditions, namely propositional formulas. For the general case of overlapping sets of statements and an abstract stance with regard to the representation of acceptance conditions, it seems that a more sophisticated procedure for ADF merging is required. This makes it hard to assess a more general type of modularity concerning translations from ADF into logic programs.</paragraph></section><section label="3.3"><section-title>From logic programs to ADFs</section-title><paragraph>To translate ADFs into logic programs, we essentially had to take the acceptance formulas, transform them into disjunctive normal form and write an LP rule for each disjunct. To translate logic programs into ADFs, this process is reversed: to devise an acceptance function for statement s, we take the disjunction of all bodies (read as conjunctions of literals) of rules with head s.</paragraph><paragraph label="Definition 3.5">(See Brewka and Woltran [3].) Let Π be a normal logic program over a set A of atoms. Define an ADF {a mathematical formula}Ξ(Π)=(A,L,Cin) as follows.</paragraph><list><list-item label="•">{a mathematical formula}L=def{(b,a)|a←M∈Π,b∈M+∪M−}.</list-item><list-item label="•">For {a mathematical formula}a∈A, set {a mathematical formula}Cain=def{B⊆par(a)|a←M∈Π,M+⊆B,M−∩B=∅}.</list-item></list><paragraph>Alternatively, we could define the acceptance condition of each {a mathematical formula}a∈A by{a mathematical formula}</paragraph><paragraph>Although straightforward, the translation is obviously not modular, since all logic program rules with head a are needed to devise the acceptance condition for statement a. Furthermore, the translation is not faithful with respect to three-valued semantics defined by the approximating operator {a mathematical formula}GΞ.</paragraph><paragraph label="Example 3.8">Lost in translationConsider the following two logic programs over the signature {a mathematical formula}A={a,b,c} that have a common subprogram {a mathematical formula}π={c←∅,b←notb}:</paragraph><list><list-item label="1.">{a mathematical formula}π1=π∪{a←b,a←c}.</list-item><list-item label="2.">{a mathematical formula}π2=π∪{a←{b,notc},a←{c,notb},a←{b,c}}.</list-item></list><paragraph>However, the translation is faithful for two-valued supported semantics, as we will show next. Technically, this is proved by establishing a correspondence between the two-valued one-step consequence operators {a mathematical formula}TΠ for a logic program Π and {a mathematical formula}GΞ(Π) for the logic programʼs ADF {a mathematical formula}Ξ(Π) in the following lemma.</paragraph><paragraph label="Proof">For any normal logic program Π, we have{a mathematical formula}TΠ=GΞ(Π).Abbreviate {a mathematical formula}Ξ(Π)=Ξ, let A be the signature of Π and let {a mathematical formula}X,Y⊆A. We show something slightly more general than {a mathematical formula}GΞ(X)=GΞ′(X,X)=TΠ′(X,X)=TΠ(X).</paragraph><list><list-item label="1.">{a mathematical formula}GΞ′(X,Y)⊆TΠ′(X,Y): Let {a mathematical formula}a∈GΞ′(X,Y). Then there is a {a mathematical formula}B∈Cain with {a mathematical formula}B⊆X and {a mathematical formula}B¯∩Y=∅. By definition of {a mathematical formula}Ξ(Π), there is a {a mathematical formula}B⊆par(a) and a rule {a mathematical formula}a←M∈Π with {a mathematical formula}M+⊆B and {a mathematical formula}M−∩B=∅. We have to show that {a mathematical formula}M+⊆X (this is immediate) and {a mathematical formula}M−∩Y=∅. Assume to the contrary that there is a {a mathematical formula}b∈M−∩Y. Then {a mathematical formula}M−∩B=∅ implies {a mathematical formula}b∉B. Similarly, {a mathematical formula}B¯∩Y=∅ implies that {a mathematical formula}b∉B¯. Thus {a mathematical formula}b∉B∪B¯=par(a), which is a contradiction to {a mathematical formula}b∈M−, {a mathematical formula}a←M∈Π and the definition of {a mathematical formula}Ξ(Π).</list-item><list-item label="2.">{a mathematical formula}TΠ′(X,X)⊆GΞ′(X,X): Let {a mathematical formula}a∈TΠ′(X,X). Then there is a rule {a mathematical formula}a←M∈Π with {a mathematical formula}M+⊆X and {a mathematical formula}M−∩X=∅. Define {a mathematical formula}B=defpar(a)∩X. We have to show that {a mathematical formula}B∈Cain, {a mathematical formula}B⊆X (obvious) and {a mathematical formula}B¯∩X=∅. For the last item, we have that {a mathematical formula}B¯=par(a)∖B=par(a)∖(par(a)∩X)=par(a)∖X, whence {a mathematical formula}B¯∩X=∅. Finally, {a mathematical formula}a←M∈Π means {a mathematical formula}M+⊆par(a) and together with {a mathematical formula}M+⊆X we get {a mathematical formula}M+⊆B=par(a)∩X. Since {a mathematical formula}B⊆X, we have {a mathematical formula}M−∩B=∅. By definition {a mathematical formula}B⊆par(a) and thus {a mathematical formula}B∈Cain.  □</list-item></list><paragraph>From the proof we can read off that Π can derive anything that {a mathematical formula}Ξ(Π) can derive, for any three-valued pair; in the converse direction, this only works for two-valued pairs. As an immediate consequence, we get correspondence of two-valued supported models.</paragraph><paragraph label="Corollary 3.17">Let Π be a normal logic program over a set A of atoms and{a mathematical formula}Ξ=Ξ(Π)be its associated abstract dialectical framework. For any set{a mathematical formula}X⊆A,{a mathematical formula}</paragraph><paragraph>As another consequence of the proof of Lemma 3.16, we can also show that LP-based ADFs are sound with respect to two-valued stable models of the LP, that is, any stable model of {a mathematical formula}Ξ(Π) is a stable model of Π.</paragraph><paragraph label="Proof">Let Π be a normal logic program over a set A of atoms and{a mathematical formula}Ξ=Ξ(Π)be its associated abstract dialectical framework. For any set{a mathematical formula}X⊆A,{a mathematical formula}Let {a mathematical formula}SGΞ(X,X)=(X,X). Then X is the least fixpoint of {a mathematical formula}GΞ′(⋅,X) and in particular {a mathematical formula}GΞ′(X,X)=X. Now by Lemma 3.16 above, we get {a mathematical formula}TΠ′(X,X)=X and X is a fixpoint of {a mathematical formula}TΠ′(⋅,X). It remains to show that X is the least fixpoint of {a mathematical formula}TΠ′(⋅,X). Let Y be a prefixpoint of {a mathematical formula}TΠ′(⋅,X), that is, {a mathematical formula}TΠ′(Y,X)⊆Y. By Item 1 in the proof of Lemma 3.16 we have {a mathematical formula}GΞ′(Y,X)⊆TΠ′(Y,X), whence {a mathematical formula}GΞ′(Y,X)⊆Y and Y is a prefixpoint of {a mathematical formula}GΞ′(⋅,X). Since X is the least fixpoint of {a mathematical formula}GΞ′(⋅,X) and thus also its least prefixpoint, we get {a mathematical formula}X⊆Y and thus X is the least (pre)fixpoint of {a mathematical formula}TΠ′(⋅,X).  □</paragraph><paragraph label="Example 3.9">The converse of the lemma does not hold: Let {a mathematical formula}π={a←∅,a←a}. This program has the two-valued stable model {a mathematical formula}{a}. Its resulting ADF is {a mathematical formula}ξ=Ξ(π)=({a},{(a,a)},{Cain}) with {a mathematical formula}Cain={∅,{a}}. Interestingly, the link {a mathematical formula}(a,a) is both supporting and attacking – that is, it contains no information. When trying to reconstruct the (LP) stable model {a mathematical formula}{a}, we observe that {a mathematical formula}Gξ′(∅,{a})=∅ and {a mathematical formula}{a} is not a (ADF) stable model for ξ.</paragraph><paragraph>As much more interesting consequence of Lemma 3.16, it follows that the ultimate approximations of {a mathematical formula}TΠ and {a mathematical formula}GΞ(Π) are identical, thus Π and {a mathematical formula}Ξ(Π) also coincide on all ultimate semantics, including ultimate stable models. This means that whatever “goes missing” in the translation from Π to {a mathematical formula}Ξ(Π) can be recovered by the construction of the ultimate approximation. This should however be taken with a grain of salt, since the ultimate versions of approximation semantics are generally accompanied by higher computational costs [13]. So while information thrown away through translation can be recovered, it seems much more economic to keep the information during translation instead of paying for a subsequent reconstruction.</paragraph></section></section><section label="4"><section-title>A special case: Argumentation frameworks</section-title><paragraph>In this section we look at the subset of ADFs which corresponds to AFs. Recall that for AFs, the original lattice of interest {a mathematical formula}(2A,⊆) considers sets of arguments and the subset relation. The corresponding bilattice {a mathematical formula}(2A×2A,⩽i) is concerned with pairs of sets of arguments and ordered by the information ordering. The elements of this bilattice generalise three-valued labellings [6] to the four-valued case: for a pair {a mathematical formula}(S,P), the arguments in {a mathematical formula}S∩P are in, those in {a mathematical formula}S∪P¯ are out, those in {a mathematical formula}P∖S are undecided and those in {a mathematical formula}S∖P get the new label inconsistent. Consistent pairs (those {a mathematical formula}(S,P) with {a mathematical formula}S⊆P) obviously are three-valued labellings, where exactly all arguments in S are in.</paragraph><paragraph>As our first observation, we note that the approximating operator that Definition 3.1 assigns to the ADF of an AF Θ is also a special case of an operator: it is the canonical approximation of {a mathematical formula}UΘ, the operator assigning to a set S of arguments all the arguments from A which are not attacked by S.</paragraph><paragraph label="Proof">For any argumentation framework{a mathematical formula}Θ=(A,R)and sets{a mathematical formula}X,Y⊆A, we have{a mathematical formula}GΞ(Θ)(X,Y)=(UΘ(Y),UΘ(X)).We have to show {a mathematical formula}GΞ(Θ)′(X,Y)=UΘ(Y). Recall that {a mathematical formula}Ξ(Θ)=(A,R,Cin), where {a mathematical formula}Cain={∅} for each {a mathematical formula}a∈A. Thus for any argument {a mathematical formula}a∈A, we find that {a mathematical formula}par(a)=AttackersΘ(a). Now{a mathematical formula}</paragraph><paragraph label="Proof">In the remainder, we will denote the four-valued approximation operator of an argumentation framework Θ by {a mathematical formula}FΘ; we formally define {a mathematical formula}FΘ′=defGΞ(Θ)′. It follows by definition that the characteristic operator {a mathematical formula}FΘ of an AF is its own stable operator: For any argumentation framework Θ, we have{a mathematical formula}SFΘ=FΘ.Let {a mathematical formula}Θ=(A,R) and {a mathematical formula}X,Y⊆A. We have to show {a mathematical formula}SFΘ′(X,Y)=FΘ′(X,Y). Now {a mathematical formula}SFΘ′(X,Y)=lfp(FΘ′(⋅,Y))=lfp(UΘ(Y))=UΘ(Y)=FΘ′(X,Y).  □</paragraph><paragraph>This means informally that (in a sense) there are fewer semantics for Dung frameworks than there are for ADFs, logic programming, default logic and autoepistemic logic. Translated into logic programming language, we have that in Dung-style argumentation, supported and stable models coincide, and well-founded semantics equals Kripke–Kleene semantics. Put in different terms of default and autoepistemic logics: for argumentation frameworks, Moore expansions and Reiter extensions coincide!</paragraph><paragraph>In principle, this collapsing picture could be due to a mistake in our definition of the characteristic operator. In the following section, it will become clear that this is not the case and the characteristic operator of an argumentation framework is well-designed: we show next how the major semantics of argumentation frameworks can be redefined in terms of fixpoints of the characteristic operator.</paragraph><section label="4.1"><section-title>Fixpoint semantics for abstract argumentation frameworks</section-title><paragraph>As a first illustration of universality of the characteristic operator of an AF, we recapitulate a result that is well-known in the argumentation community: the operator {a mathematical formula}UΘ (which is at the heart of {a mathematical formula}FΘ) can emulate the characteristic function {a mathematical formula}FΘ of an argumentation framework: {a mathematical formula}FΘ is the same as twofold application of {a mathematical formula}UΘ.</paragraph><paragraph label="Lemma 4.3">(See[14, Lemma 45].) For any AF Θ, we have{a mathematical formula}FΘ=UΘ2.</paragraph><paragraph>For our operator {a mathematical formula}FΘ, this means that for any {a mathematical formula}X,Y⊆A we have{a mathematical formula}</paragraph><paragraph>There are several works in the literature that redefine argumentation semantics in terms of (pre-/post-)fixpoints of the two operators {a mathematical formula}FΘ and {a mathematical formula}UΘ[1], [23]. Since the two operators are closely related and the characteristic approximating operator {a mathematical formula}FΘ can express them both, we can reconstruct argumentation semantics based entirely on this single operator.</paragraph><paragraph label="Proposition 4.4">We begin with the simplest semantics: recall that for {a mathematical formula}Θ=(A,R) a set E of arguments is a stable extension iff {a mathematical formula}E=UΘ(E), so the following is immediate. Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}E⊆A. Then E is a stable extension of Θ iff{a mathematical formula}FΘ(E,E)=(E,E).</paragraph><paragraph label="Proof">It is almost as easy to characterise the class of complete extensions: Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}E⊆A. Then E is a complete extension of Θ iff for some{a mathematical formula}E′⊆Athe pair{a mathematical formula}(E,E′)is a consistent fixpoint of{a mathematical formula}FΘ.{a mathematical formula}</paragraph><paragraph label="Corollary 4.6">As an easy corollary, we get the grounded semantics as the {a mathematical formula}⩽i-least fixpoint of the characteristic operator. This fixpoint exists since {a mathematical formula}FΘ is {a mathematical formula}⩽i-monotone. Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}E⊆A. Then E is the grounded extension of Θ iff for some{a mathematical formula}E′⊆Athe pair{a mathematical formula}(E,E′)is the{a mathematical formula}⩽i-least fixpoint of{a mathematical formula}FΘ.</paragraph><paragraph>In the sequel, we use the term “complete extension” for the set E and the pair {a mathematical formula}(E,E′) interchangeably. It follows by definition that preferred extensions are exactly those consistent fixpoints where E is ⊆-maximal – the M-supported models of {a mathematical formula}FΘ.</paragraph><paragraph label="Proposition 4.7">Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}E⊆A. Then E is a preferred extension of Θ iff for some{a mathematical formula}E′⊆Athe pair{a mathematical formula}(E,E′)is a consistent fixpoint of{a mathematical formula}FΘwhere E is ⊆-maximal.</paragraph><paragraph>Alternatively, we can say that for a consistent pair {a mathematical formula}(E,E′) the lower bound E is a preferred extension if and only if the pair is M-supported/M-stable for {a mathematical formula}FΘ. This immediately yields a “preferred” semantics for default logic, which is an improvement upon a result by Dung [14, Theorem 43], who defined preferred semantics for default logic only through a translation to infinite AFs.</paragraph><paragraph label="Proof">Semi-stable extensions are those complete ones where the set of arguments in the upper but not in the lower bound (the undecided arguments) is minimal – L-supported/L-stable models. Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}E⊆A. Then E is a semi-stable extension of Θ iff for some{a mathematical formula}E′⊆Athe pair{a mathematical formula}(E,E′)is a consistent fixpoint of{a mathematical formula}FΘwhere{a mathematical formula}E′∖Eis ⊆-minimal.{a mathematical formula}E∪AttackedΘ(E) is ⊆-maximal iff {a mathematical formula}E∪E′¯ is ⊆-maximal iff {a mathematical formula}E∪E′¯¯ is ⊆-minimal iff {a mathematical formula}E¯∩E′ is ⊆-minimal iff {a mathematical formula}E′∖E is ⊆-minimal.  □</paragraph><paragraph>Finally, we show that the ADF version of “admissible” (Definition 3.3) is a proper generalisation of the respective AF notion. This is easily shown using the respective associated approximating operators.</paragraph><paragraph label="Proof">Let{a mathematical formula}Θ=(A,R)be an argumentation framework and{a mathematical formula}X⊆A. Then X is an admissible set for Θ iff{a mathematical formula}(X,UΘ(X))is an admissible pair for{a mathematical formula}FΘ.Abbreviate {a mathematical formula}Y=defUΘ(X). We have the following equivalences:{a mathematical formula}</paragraph><paragraph>Jakobovits and Vermeir [24] introduced four-valued labellings for argumentation frameworks. Using indicators for acceptance (+) and rejection (−), they define the labels {a mathematical formula}in={+}, {a mathematical formula}out={−}, {a mathematical formula}undec={+,−} and {a mathematical formula}irrelevant=∅. It is possible to adapt our intuition behind pairs {a mathematical formula}(X,Y) of sets of arguments in the sense that those in {a mathematical formula}X∖Y are irrelevant (instead of inconsistent); in this case, their labels can be seen as indicating which of the two possible statuses + and − are still considered possible for the argument in question. Under this assumption, it is straightforward to adapt the definitions of [24] to our setting. To this end, we first recall their original definition of four-valued labellings.</paragraph><paragraph label="Definition 4.1">(See [24, Definition 3.1].) Let {a mathematical formula}Θ=(A,R) be an AF. A JV-labelling is a function {a mathematical formula}l:A→2{+,−} such that for all {a mathematical formula}a∈A:</paragraph><list><list-item label="1.">If {a mathematical formula}−∈l(a), then there is a {a mathematical formula}b∈A with {a mathematical formula}(b,a)∈R and {a mathematical formula}+∈l(b).</list-item><list-item label="2.">If {a mathematical formula}+∈l(a), then {a mathematical formula}(b,a)∈R implies {a mathematical formula}−∈l(b).</list-item><list-item label="3.">If {a mathematical formula}+∈l(a), then {a mathematical formula}(a,c)∈R implies {a mathematical formula}−∈l(c).</list-item></list><paragraph>It is easy to establish a correspondence between pairs {a mathematical formula}(X,Y) and functions {a mathematical formula}l:A→2{+,−}. It only remains to reformulate the three conditions in terms of AF operators, which results in the proposition below.</paragraph><paragraph label="Proposition 4.10">Let{a mathematical formula}Θ=(A,R)be an AF and{a mathematical formula}X,Y⊆A.</paragraph><list><list-item label="(A)">The pair{a mathematical formula}(X,Y)corresponds to a JV-labelling iff{a mathematical formula}X=FΘ′(X,Y)and{a mathematical formula}Y⊆FΘ″(X,Y).</list-item><list-item label="(B)">The pair{a mathematical formula}(X,Y)is consistent iff its corresponding JV-labelling is total.</list-item></list><paragraph label="Proof"><list><list-item label="(A)">Define {a mathematical formula}l:A→2{+,−} such that it maps as follows: {a mathematical formula}X∩Y↦{+}, {a mathematical formula}A∖(X∪Y)↦{−}, {a mathematical formula}Y∖X↦{+,−} and {a mathematical formula}X∖Y↦∅. We first observe that for any argument {a mathematical formula}a∈A, we have {a mathematical formula}−∈l(a) iff {a mathematical formula}a∉X, and {a mathematical formula}+∈l(a) iff {a mathematical formula}a∈Y. The conditions of Definition 4.1 are now readily formulated thus:</list-item><list-item label="(B)">{a mathematical formula}(X,Y) is consistent iff {a mathematical formula}X⊆Y iff {a mathematical formula}X∖Y=∅ iff {a mathematical formula}{a∈A|l(a)=∅}=∅ iff l is total.  □</list-item></list></paragraph><paragraph>Using the truth and information orderings, pairs {a mathematical formula}(X,Y) that correspond to JV-labellings could be characterised by {a mathematical formula}(X,Y)⩽tFΘ(X,Y) and {a mathematical formula}FΘ(X,Y)⩽i(X,Y). While this may suggest a possible intuitive reading of such pairs, we have to be cautious as the intuitions underlying these orderings are slightly different. Anyway, when applying the revision operator {a mathematical formula}FΘ, the result must be “at least as true” and “at most as informative” as the input pair.</paragraph><paragraph>We have seen how all of the semantical notions for AFs considered in this paper can be recast in terms of the approximating operator of an AF, as fixpoints or pre-/postfixpoints with respect to the information ordering {a mathematical formula}⩽i and truth ordering {a mathematical formula}⩽t. This tells us that operators associated with an argumentation framework are useful tools to study the semantics of the AF. This technique of associating operators with a knowledge base and then studying the operators to study the knowledge base is successfully and widely used in logic programming. In the next section, we will see that this enables us to elegantly build a bridge from abstract argumentation to logic programming via the approximation operators associated with the respective objects of study.</paragraph></section><section label="4.2"><section-title>From argumentation frameworks to logic programs</section-title><paragraph>There are different translations from AFs into LPs in the literature: the one we call the standard translation, and the one devised by Dung [14] to demonstrate how logic programs could be used to implement abstract argumentation. We consider each of the translations in turn and lastly show that they produce equivalent logic programs.</paragraph><section label="4.2.1"><section-title>Standard translation</section-title><paragraph>The translation we refine below was introduced as “well-known” in Gabbay and dʼAvila Garcez [19, Example 1.2]. They do not provide a definition or motivation for that translation, but our subsequent results will show that the intuition behind it is sound and the name “standard translation” is justified. The standard logic program resulting from an AF uses the set of arguments as its underlying signature. A rule is created for each argument a, and the rule basically says “a is accepted if none of its attackers is accepted.”</paragraph><paragraph>Since AFs are in particular ADFs, the standard logic program of an AF Θ is given by {a mathematical formula}Π(Ξ(Θ)), that is, translating the AF Θ into an ADF {a mathematical formula}Ξ(Θ) and that further into the standard LP of the ADF. For AFs {a mathematical formula}Θ=(A,R), the definition of its standard logic program can be simplified to the following:{a mathematical formula}Note that the positive body is empty in general since there is no notion of support in classical Dung-style AFs. Also, the negative bodies of the rules are finite if and only if the framework is finitary.</paragraph><paragraph>It should be noted that the standard translation from AFs to LPs is not modular, since the LP rule for an atom a depends on all attackers of a. This might seem paradoxical at first, since the standard translation from ADFs to LPs is modular with respect to statements. But recall that the union of two ADFs is defined whenever the two have disjoint statements, so for AFs with disjoint sets of arguments the standard translation is again modular with respect to arguments.</paragraph><paragraph label="Corollary 4.11">It is immediate from Lemma 3.14 that the associated operators of AFs Θ and their translated logic program {a mathematical formula}Π(Θ) are the same. For any argumentation framework Θ, we have{a mathematical formula}FΘ=TΠ(Θ).</paragraph><paragraph label="Lemma 4.12">Now we know from Lemma 4.2 that the approximation operator of any AF Θ is its own stable operator – in symbols {a mathematical formula}FΘ=SFΘ. Combining these two results about {a mathematical formula}FΘ leads to the following lemma, which nicely pictures the special role of argumentation frameworks in the realm of nonmonotonic reasoning formalisms. For any AF Θ, we have{a mathematical formula}TΠ(Θ)=FΘ=SFΘ=STΠ(Θ).</paragraph><paragraph label="Theorem 4.13">Since the consequence operator of a logic program yields its Kripke–Kleene and well-founded models as well as its two-valued and three-valued supported and stable models, this lemma immediately gives rise to several important coincidence results, accumulated in the first main result of this section below. Its first and last items are obvious. The second item contains the conclusion of Wu et al. [43, Theorem 17] (they did not look at supported semantics), while the third and fourth items imply new results that solve open problems posed there. Let Θ be an AF. The following are identical:</paragraph><list><list-item label="1.">the grounded extension of Θ, the Kripke–Kleene model of{a mathematical formula}Π(Θ)and the well-founded model of{a mathematical formula}Π(Θ);</list-item><list-item label="2.">complete extensions of Θ, three-valued supported models of{a mathematical formula}Π(Θ)and three-valued stable models of{a mathematical formula}Π(Θ);</list-item><list-item label="3.">preferred extensions of Θ, M-supported models of{a mathematical formula}Π(Θ)and M-stable models of{a mathematical formula}Π(Θ);</list-item><list-item label="4.">semi-stable extensions of Θ, L-supported models of{a mathematical formula}Π(Θ)and L-stable models of{a mathematical formula}Π(Θ);</list-item><list-item label="5.">stable extensions of Θ, two-valued supported models of{a mathematical formula}Π(Θ)and two-valued stable models of{a mathematical formula}Π(Θ).</list-item></list><paragraph label="Proof">The first item is obvious, since they are the least fixpoint of the same operator; the rest follows from Lemma 4.12 and Proposition 4.5, Proposition 4.7, Proposition 4.8, Proposition 4.4.  □</paragraph><paragraph>As witnessed by Lemma 3.14, for the standard translation the correspondence between AFs and LPs is immediate. We will next consider a different translation where this correspondence is less obvious, albeit still present. Most importantly, that translation will be modular for all argumentation frameworks.</paragraph></section><section label="4.2.2"><section-title>Dungʼs translation</section-title><paragraph label="Definition 4.2">Dung duplicates the arguments, thereby explicitly keeping track of their being in or out: for {a mathematical formula}a∈A, a new propositional variable −a expresses defeat of a by some counterargument. Note that this translation is modular with respect to both arguments and attacks, and furthermore rule bodies are always finite.{sup:9}Let {a mathematical formula}Θ=(A,R) be an argumentation framework. Define {a mathematical formula}−A=def{−a|a∈A}, {a mathematical formula}A±=defA∪−A and a logic program over {a mathematical formula}A± as follows.{a mathematical formula}</paragraph><paragraph>Intuitively, an argument a is accepted (signified by atom a) unless it is defeated (signified by atom −a). An argument is defeated if it is attacked by an accepted argument.</paragraph><paragraph>We show next that the four-valued one-step consequence operator for the logic program resulting from Dungʼs translation essentially does the same as the characteristic operator of the original argumentation framework. It only needs twice as many steps due to the syntactical duplication of arguments.</paragraph><paragraph label="Definition 4.3">To show this result, we need the technical notion of coherence: in words, a pair is coherent if it respects the intuition of −a for {a mathematical formula}a∈A, in the sense that a is true iff −a is false and vice versa. A pair {a mathematical formula}(S,P) of sets of arguments can be extended to matching pairs {a mathematical formula}(S⁎,P⁎) of logic program atoms over {a mathematical formula}A± in a straightforward way. Let A be a set of arguments and {a mathematical formula}S⁎,P⁎⊆A±. The pair {a mathematical formula}(S⁎,P⁎) is coherent iff for all {a mathematical formula}a∈A, we find {a mathematical formula}a∈S⁎ iff {a mathematical formula}−a∉P⁎ and {a mathematical formula}a∈P⁎ iff {a mathematical formula}−a∉S⁎. For {a mathematical formula}S,P⊆A, define {a mathematical formula}co(S,P)=def(S∪−P¯,P∪−S¯).{sup:10}</paragraph><paragraph>Observe that {a mathematical formula}−X¯={−a|a∉X}, so it is clear that the pair {a mathematical formula}co(S,P) is coherent. What the function does, intuitively, is simple: if a is not in the upper bound P, that is, cannot become true any more, then it can be considered false, which is expressed by adding −a to the lower bound; likewise, if a is not in the lower bound S, that is, is not yet considered true, then its falsity must be considered an option, which leads to −a being added to the upper bound. These manipulations are entirely syntactic and do not mention attacks.</paragraph><paragraph label="Proof">We are now ready to show that for an AF {a mathematical formula}Θ=(A,R), its standard translation {a mathematical formula}Π(Θ) and Dung translation {a mathematical formula}ΠD(Θ) have the same four-valued supported models with respect to the original signature A. Technically, we show that the fixpoints of their four-valued one-step consequence operators coincide. Let{a mathematical formula}Θ=(A,R)be an argumentation framework with standard translation Π and Dung translation{a mathematical formula}ΠDand let{a mathematical formula}S,P⊆A.{a mathematical formula}We first observe that for any {a mathematical formula}X,Y⊆A and {a mathematical formula}a∈A, by definition of {a mathematical formula}ΠD we have {a mathematical formula}a∈TΠD′(X,Y) iff {a mathematical formula}−a∉Y and {a mathematical formula}−a∈TΠD′(X,Y) iff {a mathematical formula}a∉UΘ(X), whence {a mathematical formula}TΠD′(X,Y)={a|−a∉Y}∪−UΘ(X)¯ and {a mathematical formula}TΠD′(X,−Y¯)=Y∪−UΘ(X)¯. Now{a mathematical formula}</paragraph><paragraph>Furthermore, coherent pairs are also the only fixpoints of {a mathematical formula}TΠD.</paragraph><paragraph label="Proof">Let{a mathematical formula}Θ=(A,R)be an AF,{a mathematical formula}ΠDbe its Dung translation over{a mathematical formula}A±and let{a mathematical formula}S⁎,P⁎⊆A±. If{a mathematical formula}TΠD(S⁎,P⁎)=(S⁎,P⁎), then{a mathematical formula}(S⁎,P⁎)is coherent.Let {a mathematical formula}TΠD(S⁎,P⁎)=(S⁎,P⁎). Now {a mathematical formula}S⁎={a|−a∉P⁎}∪−UΘ(S⁎)¯ and {a mathematical formula}P⁎={a|−a∉S⁎}∪−UΘ(P⁎)¯. For {a mathematical formula}a∈A, it immediately follows that {a mathematical formula}a∈S⁎ iff {a mathematical formula}−a∉P⁎ and {a mathematical formula}a∈P⁎ iff {a mathematical formula}−a∉S⁎, thus {a mathematical formula}(S⁎,P⁎) is coherent.  □</paragraph><paragraph>Hence for any semantics derived from the operator {a mathematical formula}TΠD which is only “interested” in atoms from A, the choice between standard translation and Dung translation is semantically inessential. We remark that Dungʼs translation has the advantage of producing a logic program where each rule has a finite body.</paragraph><paragraph label="Theorem 4.16">Theorem 4.14 and Proposition 4.15 immediately yield the same nice correspondence picture from the standard translation (Theorem 4.13) for Dungʼs translation. The first and last items below are again obvious for our setting, parts of them were also proved by Dung [14, Theorem 62]. Correspondence results 2, 3 and 4 are completely new. Let{a mathematical formula}Θ=(A,R)be an argumentation framework. The following are in one-to-one correspondence:</paragraph><list><list-item label="1.">the grounded extension of Θ, the Kripke–Kleene model of{a mathematical formula}ΠD(Θ)and the well-founded model of{a mathematical formula}ΠD(Θ);</list-item><list-item label="2.">complete extensions of Θ, three-valued supported models of{a mathematical formula}ΠD(Θ)and three-valued stable models of{a mathematical formula}ΠD(Θ);</list-item><list-item label="3.">preferred extensions of Θ, M-supported models of{a mathematical formula}ΠD(Θ)and M-stable models of{a mathematical formula}ΠD(Θ);</list-item><list-item label="4.">semi-stable extensions of Θ, L-supported models of{a mathematical formula}ΠD(Θ)and L-stable models of{a mathematical formula}ΠD(Θ);</list-item><list-item label="5.">stable extensions of Θ, two-valued supported models of{a mathematical formula}ΠD(Θ)and two-valued stable models of{a mathematical formula}ΠD(Θ).</list-item></list><paragraph label="Proof">Follows from Theorem 4.14, Proposition 4.15 and Proposition 4.5, Proposition 4.7, Proposition 4.8, Proposition 4.4.  □</paragraph><paragraph>This theorem conclusively shows that Dungʼs modular translation from AFs to LPs is faithful with respect to all operator-based semantics. We infer that propositional normal logic programs are at least as expressive as abstract argumentation frameworks.</paragraph></section></section><section label="4.3"><section-title>From logic programs to argumentation frameworks</section-title><paragraph>For ADFs, we have seen how the standard translation into logic programs could straightforwardly be reversed into a translation from normal logic programs to ADFs that was sound with respect to both two-valued supported and stable model semantics. In the case of AFs, however, things are different.</paragraph><paragraph>Dung [14] defined two semantics-independent translations from normal logic programs into argumentation frameworks. When restricted to propositional programs, his first translation (Section 4.3.2) is polynomial and faithful with respect to two-valued supported models and the Kripke–Kleene semantics, but not modular. Furthermore it is not faithful with respect to two-valued stable models: the logic program {a mathematical formula}{a←a} has the only two-valued stable model ∅, but its associated argumentation framework{sup:11}{a mathematical formula}({a,¬a},{(a,¬a),(¬a,a)}) has two stable extensions (corresponding to the logic programʼs two-valued supported models). For Dungʼs second translation (Section 4.3.1), the size of the resulting argumentation framework may – in the worst case – be at least exponential in the number of atoms in the vocabulary of the logic program.</paragraph><paragraph>Although it is certainly possible to devise polynomial, semantics-dependent translations from logic programs into argumentation frameworks (as a start, consider translating a logic program into an ADF to which in turn the translation from Brewka et al. [4] is applied), we consider it unlikely that any such translation is polynomial, faithful and modular. In particular, it is highly unlikely that a polynomial and modular translation is faithful with respect to both supported and stable semantics, as these two semantics are not equal in general but coincide for abstract argumentation frameworks.</paragraph></section></section><section label="5"><section-title>General semantics for approximating operators</section-title><paragraph>We have seen how the characteristic operator of an ADF can be used to redefine the existing ADF semantics. In addition, this introduced the admissible, preferred and stable semantics for all ADFs – they were previously only defined for bipolar ADFs. We have also seen that an ADF Ξ and its standard logic program {a mathematical formula}Π(Ξ) correspond on all semantics which are defined for both ADFs and LPs. Finally, we have seen how the characteristic operator of Dung-style argumentation frameworks (given by AF-based ADFs) allows to redefine AF semantics for operators. This allows us to easily transfer definitions of semantics from abstract argumentation to abstract dialectical frameworks, logic programming and beyond – to the general case of approximating operators.</paragraph><section label="5.1"><section-title>Admissible</section-title><paragraph>In Dung argumentation frameworks, a set of arguments is admissible if it is conflict-free and defends itself against all attacks. For abstract dialectical frameworks, we have seen in Definition 3.3 and Proposition 4.9 that a suitable ADF generalisation of AF admissibility is given by consistent pairs that are postfixpoints with respect to the information ordering {a mathematical formula}⩽i. These pairs have the property that applying the revision operator increases (or preserves) their information content. For the sake of completeness we have included the following formal definition.</paragraph><paragraph label="Definition 5.1">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O an approximating operator on the bilattice {a mathematical formula}(L2,⩽i). A consistent pair {a mathematical formula}(x,y)∈L2 is admissible for{a mathematical formula}O iff {a mathematical formula}(x,y)⩽iO(x,y).</paragraph><paragraph>Denecker et al. [13] already took special note of admissible pairs and called them {a mathematical formula}O-reliable. They point out that {a mathematical formula}O-reliable pairs – consistent pairs whose {a mathematical formula}O-revisions are at least as accurate – are especially useful for studying fixpoints of O, the original operator that {a mathematical formula}O approximates. In particular, the {a mathematical formula}⩽i-least element {a mathematical formula}(⊥,⊤) is {a mathematical formula}O-reliable; iterating {a mathematical formula}O on it leads to the Kripke–Kleene semantics, which provides a more precise approximation to all fixpoints of the approximated operator O.</paragraph></section><section label="5.2"><section-title>Semi-stable</section-title><paragraph>Theorem 4.13 and Proposition 4.8 immediately yield a definition of L-stable/semi-stable semantics for default and autoepistemic logics. Complete semantics for the two are given by consistent fixpoints (those {a mathematical formula}(x,y) with {a mathematical formula}x⊑y) of an approximating operator. To generalise semi-stable to operators we simply have to generalise the minimality criterion of L-stable models for logic programming. Since this involves algebraic operations on lattice elements, we have to make some more restricting assumptions on the underlying lattice.</paragraph><paragraph>In the sequel, for a complete lattice {a mathematical formula}(L,⊑) with join ⊔ and meet ⊓, we assume the existence of a function {a mathematical formula}⋅−1:L→L such that for any {a mathematical formula}x,y∈L,</paragraph><list><list-item label="•">{a mathematical formula}(x−1)−1=x ({a mathematical formula}⋅−1 is involutive),</list-item><list-item label="•">{a mathematical formula}(x⊔y)−1=x−1⊓y−1 and {a mathematical formula}(x⊓y)−1=x−1⊔y−1 (de Morganʼs laws).</list-item></list><paragraph> In the special cases we have seen so far, the role of this “negation” is played by set complement with respect to the underlying vocabulary.</paragraph><paragraph label="Definition 5.2">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O an approximating operator on its corresponding bilattice {a mathematical formula}(L2,⩽i). A consistent pair {a mathematical formula}(x,y) is L-supported iff it is a fixpoint of {a mathematical formula}O and {a mathematical formula}y⊓x−1 is ⊑-minimal. A consistent pair {a mathematical formula}(x,y) is L-stable iff it is a fixpoint of {a mathematical formula}SO and {a mathematical formula}y⊓x−1 is ⊑-minimal.</paragraph><paragraph>For the special case of argumentation, these general definitions of L-supported and L-stable reduce to a consistent fixpoint {a mathematical formula}(S,P) of {a mathematical formula}FΘ=SFΘ such that {a mathematical formula}P∩S¯=P∖S (the set of undecided arguments) is ⊆-minimal – a semi-stable extension.</paragraph></section><section label="5.3"><section-title>Conflict-free</section-title><paragraph>In classical abstract argumentation, a set of arguments is conflict-free if there are no attacks amongst its members. For abstract dialectical frameworks, a set of statements is conflict-free if each statement – informally speaking – has a reason to be in the set. This reason for one entails absence of any attackers as well as presence of supporters in case the statementʼs acceptance conditions so requires.</paragraph><paragraph>To generalise this notion to three-valued pairs {a mathematical formula}(X,Y), we require two things:</paragraph><list><list-item label="•">any in statement (in X) must have a reason not to be out, and</list-item><list-item label="•">any out statement (not in Y) must have a reason to be out.</list-item></list><paragraph>Notice the asymmetry, which resurfaces in the following operator-based definition. For a consistent pair to be conflict-free, we stipulate that applying the approximating operator improves the upper bound of the pair.</paragraph><paragraph label="Definition 5.3">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O an approximating operator on the bilattice {a mathematical formula}(L2,⩽i). A consistent pair {a mathematical formula}(x,y)∈L2 is conflict-free for{a mathematical formula}O iff {a mathematical formula}x⊑O″(x,y)⊑y.</paragraph><paragraph>Let us illustrate this notion on a standard example AF. It shows that conflict-free pairs allow to set arguments to undec that attack in arguments.</paragraph><paragraph label="Example 5.1">Odd cycleConsider an attack cycle between three arguments, the AF {a mathematical formula}θ=({a,b,c},{(a,b),(b,c),(c,a)}). Its conflict-free pairs are given by{a mathematical formula} Notice that the single admissible pair {a mathematical formula}(∅,{a,b,c}) is among the conflict-free pairs.</paragraph><paragraph>It is not hard to show that any admissible pair is conflict-free.</paragraph><paragraph label="Proof">Let{a mathematical formula}(L,⊑)be a complete lattice and{a mathematical formula}Oan approximating operator on the bilattice{a mathematical formula}(L2,⩽i). Any consistent pair{a mathematical formula}(x,y)∈L2that is admissible for{a mathematical formula}Ois also conflict-free for{a mathematical formula}O.The pair {a mathematical formula}(x,y) is admissible if and only if {a mathematical formula}x⊑O′(x,y) and {a mathematical formula}O″(x,y)⊑y. Since {a mathematical formula}O′(⋅,y) is ⊑-monotone and {a mathematical formula}O′(x,⋅) is ⊑-antimonotone, we obtain the following picture:{a mathematical formula} In particular, {a mathematical formula}x⊑O″(x,y)=O′(y,x)⊑y and {a mathematical formula}(x,y) is conflict-free.  □</paragraph><paragraph>Let us again take note of the asymmetry in the definition of conflict-free pairs. If admissible pairs ensure that during revision, both lower and upper bounds are improved, why should conflict-free pairs be defined such that only the upper bound must improve? Why not improve the lower bound? Another possibility to define conflict-free pairs would have been to say a pair {a mathematical formula}(x,y) is conflict-free for an operator {a mathematical formula}O iff {a mathematical formula}x⊑O′(x,y)⊑y. In AF terms, this alternative notion allows to set arguments to undec that are attacked by in arguments.</paragraph><paragraph label="Example 5.1">ContinuedIn the odd attack cycle between three arguments, the alternative conflict-free pairs (improving the lower bound) are{a mathematical formula}</paragraph><paragraph>Unfortunately, this possible alternative version of conflict-freeness is not a suitable generalisation of the set-based AF notion, since there are argumentation frameworks with conflict-free sets that are not the lower bound of any such pair.</paragraph><paragraph label="Example 5.2">Consider the argumentation framework {a mathematical formula}θ=({a,b},{(a,b)}) where a attacks b. The set {a mathematical formula}X={b} is conflict-free. Assume to the contrary that there is a {a mathematical formula}Y⊆A such that {a mathematical formula}X⊆Uθ(Y)⊆Y. It follows that {a mathematical formula}b∈Uθ(Y), that is, Y does not attack b. Thus Y does not contain a and {a mathematical formula}Y⊆{b}=X. From {a mathematical formula}X⊆Y we conclude {a mathematical formula}X=Y={b}. But we find that {a mathematical formula}Uθ(Y)={a,b}⊈Y. Contradiction.</paragraph><paragraph>We want to stress that these two different generalisations of conflict-free sets are not an artefact of using approximating operators. Rather, they occur in the step from two-valued to three-valued semantics. As opposed to the alternative, the version requiring improvement of the upper bound generalises conflict-free sets.</paragraph><paragraph label="Proof">Let{a mathematical formula}Θ=(A,R)be an AF and{a mathematical formula}X⊆A. X is conflict-free iff{a mathematical formula}(X,UΘ(X))is a conflict-free pair.{a mathematical formula}</paragraph><paragraph>Indeed, this notion of conflict-free pairs for AFs coincides with Caminadaʼs definition of conflict-free labellings [7].</paragraph><paragraph label="Proposition 5.3">For any AF{a mathematical formula}Θ=(A,R)and{a mathematical formula}X⊆Y⊆A, the pair{a mathematical formula}(X,Y)is conflict-free iff the labelling{a mathematical formula}l:A→{in,out,undec}with{a mathematical formula}X↦in,{a mathematical formula}Y∖X↦undec,{a mathematical formula}A∖Y↦outis conflict-free in the sense of[7, Definition 3].</paragraph></section><section label="5.4"><section-title>Naive</section-title><paragraph>It is clear that conflict-free pairs are amenable to the usual maximisation criteria that lead from admissible to preferred and semi-stable semantics. We begin with naive semantics, which for AFs are just ⊆-maximal conflict-free sets.</paragraph><paragraph label="Definition 5.4">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O an approximating operator on its corresponding bilattice {a mathematical formula}(L2,⩽i). A consistent pair {a mathematical formula}(x,y)∈L2 is an M-conflict-free pair for{a mathematical formula}O iff it is {a mathematical formula}⩽i-maximal among the conflict-free pairs for {a mathematical formula}O.</paragraph><paragraph>We keep our uniform naming conventions for recording maximisation criteria. It is straightforward that this definition generalises naive semantics.</paragraph><paragraph label="Proof">Let{a mathematical formula}Θ=(A,R)be an AF. A set{a mathematical formula}X⊆Ais a naive extension of Θ iff the pair{a mathematical formula}(X,UΘ(X))is an M-conflict-free pair of Θ.First note that for any {a mathematical formula}X⊆A, the set {a mathematical formula}UΘ(X) is fixed. Furthermore {a mathematical formula}UΘ is a ⊆-antimonotone operator and thus {a mathematical formula}X⊆Y iff {a mathematical formula}(X,UΘ(X))⩽i(Y,UΘ(Y)). Consequently for maximisation there is no difference whether we ⊆-maximise the set X or we {a mathematical formula}⩽i-maximise the pair {a mathematical formula}(X,UΘ(X)). It follows that{a mathematical formula}</paragraph></section><section label="5.5"><section-title>Stage</section-title><paragraph label="Proof">Verheij [41] defined the notion argumentation stage for an argumentation framework, in turn based on three-valued status assignments. Such an assignment represents not only the arguments that are accepted (as extensions do), but also those which are not accepted. (Hence each assignment gives rise to a unique extension, but not necessarily vice versa.) An argumentation stage is a three-valued status assignment to arguments with the restriction that the arguments that are not accepted must be exactly the ones that have an attacker that is accepted. It follows that the set of arguments which are accepted in an argumentation stage (its associated extension) is conflict-free. It is easy to find out how (argumentation) stages can be captured in our setting: Let{a mathematical formula}Θ=(A,R)be an argumentation framework. A consistent pair{a mathematical formula}(X,Y)is an argumentation stage iff{a mathematical formula}Y=UΘ(X).{a mathematical formula}(X,Y) is a stage iff {a mathematical formula}A∖Y=AttackedΘ(X) iff {a mathematical formula}Y=UΘ(X).  □</paragraph><paragraph>While an argumentation stage is always a conflict-free pair, and any conflict-free set gives rise to an argumentation stage (and thus to a conflict-free pair), there are conflict-free pairs which are not argumentation stages. (Consider Example 5.2 and the pair {a mathematical formula}({a},{a,b}).) Still, we can apply the range maximisation criterion to conflict-free pairs in order to generalise stage extension semantics.</paragraph><paragraph label="Definition 5.5">Let {a mathematical formula}(L,⊑) be a complete lattice and {a mathematical formula}O an approximating operator on its corresponding bilattice {a mathematical formula}(L2,⩽i). A consistent pair {a mathematical formula}(x,y)∈L2 is an L-conflict-free pair for{a mathematical formula}O iff {a mathematical formula}y⊓x−1 is ⊑-minimal among the conflict-free pairs for {a mathematical formula}O.</paragraph><paragraph>For AFs, L-conflict-free pairs coincide with stage extensions.</paragraph><paragraph label="Proof">Let{a mathematical formula}Θ=(A,R)be an AF. A set{a mathematical formula}X⊆Ais a stage extension of Θ iff the pair{a mathematical formula}(X,UΘ(X))is an L-stage pair of{a mathematical formula}FΘ.{a mathematical formula}</paragraph><paragraph>When trying to define two-valued conflict-free pairs we end up with pairs {a mathematical formula}(x,x) where {a mathematical formula}x⊑O″(x,x)=O′(x,x)⊑x, that is, two-valued supported models.</paragraph></section></section><section label="6"><section-title>Conclusion</section-title><paragraph>We embedded abstract dialectical frameworks into Denecker et al.ʼs lattice-theoretical formalism for the abstract study of nonmonotonic logical languages. This provides useful insights into the relationship of abstract argumentation frameworks and abstract dialectical frameworks with other nonmonotonic knowledge representation formalisms.</paragraph><paragraph>In this last section, we will provide a concise overview over the results of our investigation. First, for reference and as a completion of the table in Definition 2.2, we review the definitions of operator-based semantics in Table 1.</paragraph><paragraph>Fig. 1 then depicts the relationship between the different semantical notions explored in this paper. If a semantics σ is seen as a function assigning to a knowledge base κ a set of models, then a partial order on semantics is given by {a mathematical formula}σ1⩽σ2 iff {a mathematical formula}σ1(κ)⊆σ2(κ) for all κ. In the figure, an arrow from {a mathematical formula}σ1 to {a mathematical formula}σ2 expresses {a mathematical formula}σ1⩽σ2 – in words, all {a mathematical formula}σ1-models are also {a mathematical formula}σ2-models.</paragraph><paragraph>Next, Table 2 shows the correspondences between different argumentation semantics and operator-based semantics. The operator-based semantics lead to new semantics for default logic and autoepistemic logics via their respective consequence operators [12]. A discussion of these semantics is however out of the scope of this paper.</paragraph><paragraph>Finally, Fig. 2 on p. 68 shows the location of abstract dialectical frameworks with respect to different approaches in the area of nonmonotonic reasoning. We use a very strong notion of one formalism being at least as expressive as another: the existence of a polynomial and modular translation that is faithful with respect to all operator-based semantics. Such results existed previously for the translation from logic programs into default theories of Marek and Truszczyński [27], and the translation from default logic into autoepistemic logic of Konolige [26] – for details see Denecker et al. [11]. In this paper, we added argumentation frameworks and abstract dialectical frameworks to the picture.</paragraph><paragraph label="Related work">In general, we are not aware of any works that address the relationship of abstract dialectical frameworks with other nonmonotonic knowledge representation formalisms, attempt a principled reconstruction of ADF semantics or generalise argumentation semantics to an abstract operator-based setting.</paragraph><paragraph label="Future work">As we observed in Example 3.7, it is not entirely clear how to define the union of two ADFs that share statements. Although for specific representations of acceptance conditions such a union should be straightforward to define, we want to devote some future work into abstracting from specific representations and develop a general method for combining ADFs.Corollary 3.13 has shown that Brewka and Woltran [3] defined not only the notion of an ADF model, but also the ultimate three-valued approximation of this notion. In recent related work, Brewka et al. [5] introduced several new ultimate semantics for abstract dialectical frameworks. In future research we will compare the different semantics defined by their work and in this paper. Furthermore, Denecker et al. [13] study several other ultimate semantics. It is an important aspect of future work to investigate these ultimate semantics in detail and to compare them with the ones investigated here and by Brewka et al. [5].We remarked on several occasions throughout the paper that we defined new semantics for default and autoepistemic logics (admissible, preferred, semi-stable, stage). We plan to study these semantics in greater detail, especially their strengths and weaknesses in comparison to the standard semantics of these two nonmonotonic KR formalisms. Additionally, in the same way we defined several semantics for normal logic programs (conflict-free, admissible, naive, stage). In order to determine whether these semantics are new, it might be a good starting point to compare them to the semantics discussed by Eiter et al. [16]. Finally, it is of course in order to perform an analysis of the computational complexity of the newly introduced ADF semantics.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>The author wishes to thank Gerhard Brewka, Stefan Ellmauthaler and Johannes Peter Wallner for useful discussions and providing several (counter-)examples. He is also grateful to several anonymous referees for providing valuable feedback. This work was partially supported by DFG under project BR-1817/7-1.</paragraph></acknowledgements><references><reference label="[1]"><authors>Philippe Besnard,Sylvie Doutre</authors><title>Characterization of semantics for argument systems</title><host>Didier DuboisChristopher A. WeltyMary-Anne WilliamsProceedings of the Ninth International Conference on Principles of Knowledge Representation and ReasoningKR2004(2004)AAAI Press pp.183-193</host></reference><reference label="[2]"><authors>Gerhard Brewka,Thomas F. Gordon</authors><title>Carneades and abstract dialectical frameworks: a reconstruction</title><host>Computational Models of Argument: Proceedings of COMMA 2010Frontiers in Artificial Intelligence and Applicationsvol. 216 (September 2010)IOS Press pp.3-12</host></reference><reference label="[3]"><authors>Gerhard Brewka,Stefan Woltran</authors><title>Abstract dialectical frameworks</title><host>Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning (KR)(2010) pp.102-111</host></reference><reference label="[4]"><authors>Gerhard Brewka,Paul E. Dunne,Stefan Woltran</authors><title>Relating the semantics of abstract dialectical frameworks and standard AFs</title><host>Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence(2011) pp.780-785</host></reference><reference label="[5]"><authors>Gerhard Brewka,Stefan Ellmauthaler,Hannes Strass,Johannes Peter Wallner,Stefan Woltran</authors><title>Abstract dialectical frameworks revisited</title><host>Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence(August 2013)AAAI Press pp.803-809</host></reference><reference label="[6]"><authors>Martin Caminada</authors><title>On the issue of reinstatement in argumentation</title><host>Proceedings of the Tenth European Conference on Logics in Artificial IntelligenceLecture Notes in Computer Sciencevol. 4160 (September 2006)Springer pp.111-123</host></reference><reference label="[7]"><authors>Martin Caminada</authors><title>An algorithm for stage semantics</title><host>Computational Models of Argument: Proceedings of COMMA 2010(2010) pp.147-158</host></reference><reference label="[8]"><authors>Martin Caminada,Leila Amgoud</authors><title>On the evaluation of argumentation formalisms</title><host>Artif. Intell.171 (5–6)(2007) pp.286-310</host></reference><reference label="[9]"><authors>Claudette Cayrol,Marie-Christine Lagasquie-Schiex</authors><title>Bipolar abstract argumentation systems</title><host>Guillermo SimariIyad RahwanArgumentation in Artificial Intelligence(2009)Springer pp.65-84</host></reference><reference label="[10]"><authors>Keith L. Clark</authors><title>Negation as failure</title><host>Hervé GallaireJack MinkerLogic and Data Bases(1978)Plenum Press pp.293-322</host></reference><reference label="[11]"><authors>Marc Denecker,Victor Marek,Miroslaw Truszczyński</authors><title>Approximations, stable operators, well-founded fixpoints and applications in nonmonotonic reasoning</title><host>Logic-Based Artificial Intelligence(2000)Kluwer Academic Publishers pp.127-144</host></reference><reference label="[12]"><authors>Marc Denecker,V. Wiktor Marek,Miroslaw Truszczyński</authors><title>Uniform semantic treatment of default and autoepistemic logics</title><host>Artif. Intell.143 (1)(2003) pp.79-122</host></reference><reference label="[13]"><authors>Marc Denecker,Victor W. Marek,Miroslaw Truszczyński</authors><title>Ultimate approximation and its application in nonmonotonic knowledge representation systems</title><host>Inf. Comput.192 (1)(2004) pp.84-121</host></reference><reference label="[14]"><authors>Phan,Minh Dung</authors><title>On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games</title><host>Artif. Intell.77 (1995) pp.321-358</host></reference><reference label="[15]"><authors>Uwe Egly,Sarah Alice Gaggl,Stefan Woltran</authors><title>Answer-set programming encodings for argumentation frameworks</title><host>Argument Comput.1 (2)(2010) pp.147-177</host></reference><reference label="[16]"><authors>Thomas Eiter,Michael Fink,João Moura</authors><title>Paracoherent answer set programming</title><host>Proceedings of the Twelfth International Conference on Principles of Knowledge Representation and Reasoning(May 2010)</host></reference><reference label="[17]"><authors>Stefan Ellmauthaler,Johannes Peter Wallner</authors><title>Evaluating abstract dialectical frameworks with ASP</title><host>Computational Models of Argument: Proceedings of COMMA 2012(2012) pp.505-506</host></reference><reference label="[18]"><authors>Melvin Fitting</authors><title>Fixpoint semantics for logic programming: a survey</title><host>Theor. Comput. Sci.278 (1–2)(2002) pp.25-51</host></reference><reference label="[19]"><authors>Dov M. Gabbay,Artur S. dʼAvila Garcez</authors><title>Logical modes of attack in argumentation networks</title><host>Stud. Log.93 (2–3)(2009) pp.199-230</host></reference><reference label="[20]"><authors>Michael Gelfond,Vladimir Lifschitz</authors><title>The stable model semantics for logic programming</title><host>Proceedings of the International Conference on Logic ProgrammingICLP(1988)The MIT Press pp.1070-1080</host></reference><reference label="[21]"><authors>Thomas F. Gordon,Henry Prakken,Douglas Walton</authors><title>The Carneades model of argument and burden of proof</title><host>Artif. Intell.171 (10–15)(2007) pp.875-896</host></reference><reference label="[22]"><authors>Georg Gottlob</authors><title>Translating default logic into standard autoepistemic logic</title><host>J. ACM42 (4)(1995) pp.711-740</host></reference><reference label="[23]"><authors>Davide Grossi</authors><title>Fixpoints and iterated updates in abstract argumentation</title><host>Proceedings of the Thirteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR)(2012)AAAI Press pp.65-74</host></reference><reference label="[24]"><authors>Hadassa Jakobovits,Dirk Vermeir</authors><title>Robust semantics for argumentation frameworks</title><host>J. Log. Comput.9 (2)(1999) pp.215-261</host></reference><reference label="[25]"><authors>Tomi Janhunen</authors><title>On the intertranslatability of non-monotonic logics</title><host>Ann. Math. Artif. Intell.27 (1–4)(1999) pp.79-128</host></reference><reference label="[26]"><authors>Kurt Konolige</authors><title>On the relation between default and autoepistemic logic</title><host>Artif. Intell.35 (3)(1988) pp.343-382</host></reference><reference label="[27]"><authors>V. Wiktor Marek,Miroslaw Truszczyński</authors><title>Stable semantics for logic programs and default theories</title><host>North American Conference on Logic Programming(1989)The MIT Press pp.243-256</host></reference><reference label="[28]"><authors>Sanjay Modgil</authors><title>Reasoning about preferences in argumentation frameworks</title><host>Artif. Intell.173 (9–10)(2009) pp.901-934</host></reference><reference label="[29]"><authors>Robert Moore</authors><title>Semantical considerations of nonmonotonic logic</title><host>Artif. Intell.25 (1)(1985) pp.75-94</host></reference><reference label="[30]"><authors>Søren H. Nielsen,Simon Parsons</authors><title>A generalization of Dungʼs abstract framework for argumentation: Arguing with sets of attacking arguments</title><host>Argumentation in Multi-Agent SystemsLNCSvol. 4766 (2006)Springer pp.54-73</host></reference><reference label="[31]"><authors>Juan Carlos Nieves,Mauricio Osorio,Claudia Zepeda</authors><title>A schema for generating relevant logic programming semantics and its applications in argumentation theory</title><host>Fundam. Inform.106 (2–4)(2011) pp.295-319</host></reference><reference label="[32]"><authors>Monica Nogueira,Marcello Balduccini,Michael Gelfond,Richard Watson,Matthew Barry</authors><title>An A-Prolog decision support system for the Space Shuttle</title><host>Alessandro ProvettiTran Cao SonAnswer Set Programming(2001)</host></reference><reference label="[33]"><authors>Henry Prakken</authors><title>An abstract framework for argumentation with structured arguments</title><host>Argument Comput.1 (2)(2010) pp.93-124</host></reference><reference label="[34]"><authors>Henry Prakken,Giovanni Sartor</authors><title>A system for defeasible argumentation, with defeasible priorities</title><host>Artificial Intelligence TodayLNAI (1999)Springer-VerlagBerlin Heidelberg pp.365-379</host></reference><reference label="[35]"><authors>Raymond Reiter</authors><title>A logic for default reasoning</title><host>Artif. Intell.13 (1980) pp.81-132</host></reference><reference label="[36]"><authors>Domenico Saccà,Carlo Zaniolo</authors><title>Deterministic and non-deterministic stable models</title><host>J. Log. Comput.7 (5)(1997) pp.555-579</host></reference><reference label="[37]"><authors>Hannes Strass</authors><title>Instantiating knowledge bases in Abstract Dialectical Frameworks</title><host>Proceedings of the Fourteenth International Workshop on Computational Logic in Multi-Agent SystemsCLIMA XIVLNCSvol. 8143 (September 2013)Springer pp.86-101</host></reference><reference label="[38]"><authors>Alfred Tarski</authors><title>A lattice-theoretical fixpoint theorem and its applications</title><host>Pac. J. Math.5 (2)(1955) pp.285-309</host></reference><reference label="[39]"><authors>Francesca Toni,Marek Sergot</authors><title>Argumentation and answer set programming</title><host>M. BalducciniT. SonLogic Programming, Knowledge Representation, and Nonmonotonic Reasoning: Essays in Honor of Michael GelfondLNAIvol. 6565 (2011)Springer pp.164-180</host></reference><reference label="[40]"><authors>Bas Van Gijzel,Henry Prakken</authors><title>Relating Carneades with abstract argumentation</title><host>Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence, vol. 2(2011)AAAI Press pp.1113-1119</host></reference><reference label="[41]"><authors>Bart Verheij</authors><title>Two approaches to dialectical argumentation: admissible sets and argumentation stages</title><host>J.-J.Ch. MeyerL.C. van der GaagProceedings of the Eighth Dutch Conference on Artificial IntelligenceNAICʼ96(1996) pp.357-368</host></reference><reference label="[42]"><authors>Toshiko Wakaki,Katsumi Nitta</authors><title>Computing argumentation semantics in answer set programming</title><host>Proceedings of the Annual Conference of Japanese Society for Artificial Intelligence (JSAI)(2008) pp.254-269</host></reference><reference label="[43]"><authors>Yining Wu,Martin Caminada,Dov M. Gabbay</authors><title>Complete extensions in argumentation coincide with 3-valued stable models in logic programming</title><host>Stud. Log.93 (2–3)(2009) pp.383-403</host></reference><reference label="[44]"><authors>Adam Wyner,Trevor Bench-Capon,Paul Dunne</authors><title>Instantiating knowledge bases in abstract argumentation frameworks</title><host>Proceedings of the AAAI Fall Symposium – The Uses of Computational Argumentation(2009)</host></reference></references><footnote><note-para label="1">But this is not inherent to these formalisms – both strong expansions for autoepistemic logic that reject cyclic support, and weak extensions for default logic that accept cyclic support can be defined [12].</note-para><note-para label="2">Note that in their approach, an ADF statement corresponds to an argument evaluation structure of Carneades and is hence on the same abstraction level.</note-para><note-para label="3">The approximation of an operator O is typographically indicated by a calligraphic {a mathematical formula}O.</note-para><note-para label="4">Denecker et al. [11] call such pairs “complete,” we however use that term for argumentation in a different meaning and want to avoid confusion.</note-para><note-para label="5">The representation of the operator and the lattice it operates on given by Brewka and Woltran [3] is slightly different: both representations use pairs of sets of statements to describe the current acceptance status of statements. Their pairs explicitly represent the statements that are in in the first component and the ones that are out in the second component. Since our second component explicitly represents the statements that are not out, we adjusted the definition of the operator {a mathematical formula}ΓΞ″ for computing the second component.</note-para><note-para label="6">Incidentally, {a mathematical formula}{a,b} is also a BW-preferred model which does not contain the BW-well-founded model {a mathematical formula}{b,c,d}. Since the grounded AF extension is always contained in any preferred AF extension, Example 3.5 also hints at another unexpected (non-)relation between the generalised ADF semantics of Brewka and Woltran [3].</note-para><note-para label="7">According to personal communication this was conjectured by Mirosław Truszczyński.</note-para><note-para label="9">Dungʼs original translation is slightly different; he uses a first-order signature and logic program atoms with variables [14]. Definition 4.2 above is merely a syntactical variant that already incorporates ground instantiation.</note-para><note-para label="10">The notation is entirely unambiguous since for any {a mathematical formula}S⊆A we have {a mathematical formula}−S¯=−S¯.</note-para><note-para label="11">Actually, applying the translation yields an argumentation framework that looks slightly more complicated: {a mathematical formula}({({a},a),({¬a},¬a)},{(({a},a),({¬a},¬a)),(({¬a},¬a),({a},a))}). We chose to simplify notation for the sake of readability.</note-para></footnote></root>