<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S000437021500082X</url><title>Transferring knowledge as heuristics in reinforcement learning: A case-based approach</title><authors>Reinaldo A.C. Bianchi,Luiz A. Celiberto,Paulo E. Santos,Jackson P. Matsuura,Ramon Lopez de Mantaras</authors><abstract>The goal of this paper is to propose and analyse a transfer learning meta-algorithm that allows the implementation of distinct methods using heuristics to accelerate a Reinforcement Learning procedure in one domain (the target) that are obtained from another (simpler) domain (the source domain). This meta-algorithm works in three stages: first, it uses a Reinforcement Learning step to learn a task on the source domain, storing the knowledge thus obtained in a case base; second, it does an unsupervised mapping of the source-domain actions to the target-domain actions; and, third, the case base obtained in the first stage is used as heuristics to speed up the learning process in the target domain. A set of empirical evaluations were conducted in two target domains: the 3D mountain car (using a learned case base from a 2D simulation) and stability learning for a humanoid robot in the Robocup 3D Soccer Simulator (that uses knowledge learned from the Acrobot domain). The results attest that our transfer learning algorithm outperforms recent heuristically-accelerated reinforcement learning and transfer learning algorithms.</abstract><keywords>Case-based reasoning;Reinforcement learning;Transfer learning</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Reinforcement learning (RL) is a field of machine learning whose aim is to maximise the total amount of reward an agent receives while interacting with its environment [1]. This interaction occurs by means of exploring the state space by trial-and-error actions on the environment, leading to a process whose convergence is often slow (or infeasible) on complex tasks [2], [3].</paragraph><paragraph>The current scientific literature presents distinct ways of accelerating the computational process involved in Reinforcement Learning (RL) through the use of various methods, such as composition of functions [4], human feedback [5], [6], imitation [7], and reward shaping [8]. The use of heuristics to this end has been pursued in [9], in order to speed up the action selection procedure during the learning process. Heuristics were also obtained from previously learned policies within a Case-Based Reasoning approach [10]. In fact, the (re)use of heuristics from a base of cases naturally leads to the Transfer Learning (TL) framework in machine learning [2], whose goal is to develop methods that allow the transfer of knowledge obtained in one domain to another [11].</paragraph><paragraph>Transfer learning is an important tool to speed up RL algorithms since, in RL, small changes on a problem configuration usually require complete new training. Within a Transfer Learning context, this complete re-training can be simplified, as the knowledge acquired in a previous situation can be re-used as heuristics, accelerating the learning procedure in the new situation.</paragraph><paragraph>A very informative definition of transfer learning is given in [11]: given a source domain ({a mathematical formula}Ds) with its related task ({a mathematical formula}Ts), and a target domain ({a mathematical formula}Dt) with its related task ({a mathematical formula}Tt), transfer learning aims to improve the performance of learning the task's predictive function at the target domain, using the knowledge obtained on learning the predictive function in {a mathematical formula}Ds and {a mathematical formula}Ts, for {a mathematical formula}Ds≠Dt or {a mathematical formula}Ts≠Tt. Also, according to Pan and Yang [11], transfer learning algorithms can be characterised by (1) which information is transfered; (2) how it is transfered; and, (3) when it is transfered. The first characteristic refers to what part of knowledge is chosen to be transfered, in RL it could be the rewards or the policy, for instance. The second feature is related to the algorithms used to transfer the knowledge from one domain to the other, which should take into account task mappings; and the third feature specifies in which situations the knowledge should be transfered.</paragraph><paragraph>This paper investigates the strengths of a transfer learning meta-algorithm, called L3, that provides a framework that allows the implementation of different algorithms using heuristics to accelerate a Reinforcement Learning procedure in one domain (target), that are obtained from another, simpler, domain (source). The L3 meta-algorithm works in 3 stages: first, it uses an RL algorithm to learn how to perform one task, storing the solution for this problem as a case in a case base; in the second stage, it maps actions of the source domain to actions of the target domain; and, in the last stage, it uses the stored cases as heuristics to speed up the Reinforcement Learning process in the target domain. By using a case base as part of the transfer learning procedure, L3 falls within the class of case-based transfer learning algorithms, discussed in [12]. A preliminary investigation on this meta-algorithm was presented in [13], where an L3 instance based on the Q-Learning algorithm was described. The present paper extends our previous work in three ways: first, this work introduces a new L3 algorithm based on the SARSA(λ) algorithm; second, the proposed algorithms are evaluated on more domains than those described in [13]; and, third, we show that the L3 framework is robust under the transference of negative information.</paragraph><paragraph>The theoretical background, that supports this work, is presented in Section 3, that also presents the evolution of methods that use heuristics to accelerate RL. The L3 meta-algorithm, that is built upon this theoretical background, is described in Section 4, and Section 5 presents the empirical results of applying L3 in two distinct domains: the 3D mountain car and stability learning for a humanoid robot in the Robocup 3D Soccer Simulator. The results show that L3 outperforms several algorithms, including Q-Learning, used as baseline algorithm, and two state-of-the-art transfer learning algorithms.</paragraph></section><section label="2"><section-title>Related work</section-title><paragraph>The field of transfer learning can be seen as the consolidation of a set of techniques proposed over the past years [11], such as life-long learning [14], knowledge (or inductive) transfer [15], metalearning [16], among others. There are also closely related techniques, such as multi-task learning [17], imitation learning [18] and human advice [19]. The goal of multi-task learning is to learn multiple tasks simultaneously, using common features in the pool of (distinct) tasks to accelerate the learning process of each of the tasks individually; in contrast, transfer learning focus on accelerating the learning rate of one target task only, given the knowledge obtained from learning a previous task. Imitation learning aims at speeding up the learning process of a task by using the knowledge obtained from the observation of another agent solving the same task, whereas transfer learning concentrates on the transference of the knowledge obtained by a single agent on solving distinct (but related) tasks [2]. Similarly to imitation learning, human advice integrates knowledge provided by a human agent in the machine learning loop, which is an issue outside the interest of current methods in transfer learning.</paragraph><paragraph>In a broader sense, transfer learning may be placed within the abstraction in artificial intelligence umbrella, as abstractions in AI usually relate a ground problem with a more abstract one (not necessarily a more abstract version of the same problem), according to [20]. In fact, Saitta and Zucker [20, p. 54] point out that a comprehensive theory of abstraction should provide “the framework to support the transfer of techniques between different domains”.</paragraph><paragraph>The application of Transfer Learning within Reinforcement Learning tasks was first proposed in [4], where an algorithm was defined that exploits strong features obtained from RL on one task in order to compose functions in a case base that is used on the solution of a new task. More recent work on transferring cases for RL includes [21], which propose a technique for abstracting reusable cases from RL, enabling the transfer of acquired knowledge to other instances of the same problem. A method that abstracts the intention of an actor on solving a task, turning it into a case base for RL is proposed in [22]. Focusing on policy reuse, Fernández and Veloso [23] propose a method that uses previously learned policies as a probabilistic bias that guides the exploration/exploitation process. The principles of knowledge transfer were applied to general game learning in [24], whereby the knowledge obtained in learning one particular game is generalised to be used in other games. The problem of transferring policies across continuous domains was tackled in [25] by means of a model minimisation strategy for mapping state-action pairs. In contrast to previous work, which were mostly based on model-free methods, Taylor et al. [26] propose a transfer-learning method for a model-based reinforcement learning algorithm for continuous state space. The problem of finding the appropriate potential function for accelerating the task performance of the target domain is defined as a supervised regression problem in [27]. In this regression problem the goal is to select the features that are most relevant to the potential function by means of the features' influence on the prediction of the cross-task value. A more complete survey of transfer learning in reinforcement learning, up till 2009, is presented in [2].</paragraph><paragraph>It is evident in the literature of transfer learning in RL that most of the early approaches typically use hand-coded inter-task mapping for transferring knowledge from one domain to another [28]. More recently, there has been an increasing number of work reporting successful experiments on learning inter-task mapping. The work proposed by Taylor [29] was perhaps the first approach to automate the process of inter-task mappings in TL, where actions with similar effects (in the target and source domains) were associated to allow the transference of knowledge across the domains. In fact, Taylor [29] explores the use of inter-task mappings with various possibilities of features to transfer, such as Value-function, Q-value, Policy and rules representing the source-task policy learned. This work also proposes the “Modeling Approximated State Transitions by Exploiting Regression” (MASTER) algorithm, that automatically learns a mapping between source and target tasks using an agent's experience.</paragraph><paragraph>In [30] the correspondence between state spaces of the tasks is accomplished assuming an underlying subspace (called the common-task subspace) that relates the source and target tasks. The inter-task mapping is then autonomously determined by a function approximation technique. The common task subspace, however, is determined manually. Relaxing the need for a hand-coded subspace, Ammar et al. [28] propose a supervised method for learning the inter-task mapping by using sparse coding with a similarity measure. The use of multiple inter-task mappings in transfer learning is investigated in [31] for both model-free and model-based RL. In this work, in order to avoid negative mappings, the authors propose a method for selecting the most relevant mappings. A hybrid approach implementing model-free and model-based learning for transferring models of potential-based, reward shaping functions is proposed in [32], whereby the transition and reward functions of the source task are obtained by cascade neural networks. A value-function approximation (the Cerebral Model Articulation Controller, CMAC [33]) is used to find the value of a state, given the neighbouring state values. In the target task this algorithm generates simulations from the source task that are used in an RL step; finally, the target and source models are queried for a new state, the algorithm then chooses which model (either target or source) to use, selecting that with the least prediction error for that state.</paragraph><paragraph>The meta-algorithm proposed in this paper falls into the category of methods whose inter-task mapping is automatically learned. For this reason, the algorithms proposed in [32] and in [29] (mentioned above) are used in the present paper for comparison purposes, as described in Section 5.</paragraph><paragraph>In contrast to other work in this area, as we shall see further in this paper, in L3 the knowledge is transferred across domains in terms of heuristics that are stored as a case base to be used to accelerate reinforcement learning in the target domains. This allows the learning process to recover from negative (or imprecise) transfers.</paragraph><paragraph>The next section presents the theoretical background of this work, tracing the evolution of the use of heuristics to speed up RL.</paragraph></section><section label="3"><section-title>Background</section-title><paragraph>The task of an RL agent is to learn an optimal policy {a mathematical formula}π⁎:S→A that maps the current state s into a desirable action a to be performed in s[34]. In RL, the policy π should be learned through trial-and-error interactions of the agent with its environment. This problem is usually formulated as a discrete time, finite state, finite action Markov Decision Process (MDP), where the learner's environment is modelled as a 4-tuple {a mathematical formula}〈S,A,T,R〉, in which: {a mathematical formula}S is a finite set of states; {a mathematical formula}A is a finite set of actions that the agent can perform; {a mathematical formula}T:S×A→Π(S) is a state transition function, where {a mathematical formula}Π(S) is a probability distribution over {a mathematical formula}S; and, {a mathematical formula}R:S×A→R: is a reward function [35].</paragraph><paragraph>Within the set of RL algorithms, Q-learning [36] obtains an optimal policy {a mathematical formula}π⁎ when the model ({a mathematical formula}T and {a mathematical formula}R) is not known in advance. This is done by using the following update rule:{a mathematical formula} where s is the current state; a is the action performed in s; r is the reward received; {a mathematical formula}s′ is the new state obtained by executing action a in state s; α is the learning rate ({a mathematical formula}α=1/(1+visits(s,a))), and γ is a discount factor ({a mathematical formula}0≤γ&lt;1). The term {a mathematical formula}visits(s,a) is the total number of times this state-action pair has been visited up to, and including, the current iteration.</paragraph><paragraph>The SARSA algorithm [37] is a modification of Q-learning that updates the policy based on actions taken during the interaction with the environment – this kind of learning is known as on-policy. The SARSA learning rule does not include the maximisation that exists in the Q-learning rule, and can be represented by Equation (2) below:{a mathematical formula} where all the variables are defined in the same way as in Equation (1).</paragraph><paragraph>The SARSA algorithm outperforms Q-learning when the use of exploration occasionally results in a large negative reward, learning to avoid “dangerous areas” on the learning space.</paragraph><paragraph>The Heuristically Accelerated Reinforcement Learning (HARL) is a class of algorithms [9] that solves the RL problem by making explicit use of a heuristic function {a mathematical formula}H:S×A→R to influence the choice of actions during the learning process. The heuristic function is used only in the action-choice rule; it defines which action {a mathematical formula}at must be executed when the agent is in a state {a mathematical formula}st. The action-choice rule used in HARL is a modification of the standard ϵ-Greedy rule used in Reinforcement Learning, but with the heuristic function included:{a mathematical formula} where: {a mathematical formula}H:S×A→R is the heuristic function, which influences the action choice. The subscript t indicates that the heuristic function can be non-stationary; ξ is a real variable used to weigh the influence of the heuristic function; q is a random value with uniform probability in {a mathematical formula}[0,1] and ϵ ({a mathematical formula}0≤ϵ≤1) is the parameter that defines the exploration/exploitation trade-off: the greater the value of p, the smaller is the probability of a random choice; {a mathematical formula}arandom is a random action selected from the set of possible actions in the state {a mathematical formula}st.</paragraph><paragraph>As a general rule, the value of the heuristic {a mathematical formula}Ht(st,at) used in the HARL must be higher than the variation among {a mathematical formula}Qˆ(st,at) for a similar {a mathematical formula}st∈S (so that it can influence the choice of actions) and it must be as low as possible in order to minimise the error. There are several possibilities to compute {a mathematical formula}Ht(st,at), from using a large value that is lower than {a mathematical formula}rn/(1−γ), where {a mathematical formula}rn is the negative reward the agent receives in each time step (see [38] for a discussion on this value), to using a small value that depends on the instant values of the value function approximation, that can be defined as:{a mathematical formula} where η is a small real value and {a mathematical formula}πH(st) is the action suggested by the heuristic H.</paragraph><paragraph>Bianchi et al. [38] showed that as the heuristic is used only in the choice of the action to be taken, this algorithm differs from the original RL algorithm only in the way the exploration is carried out. The only convergence condition of the RL algorithm that could be affected by the exploration made in the HARL is the necessity of infinite visitation to each pair state-action. One option to validate this condition is to recede the influence of the heuristics with time, by multiplying ξ by a decay factor. Other options is to use other visitation strategies, such as intercalating steps where the algorithm makes alternate use of the heuristics and exploration steps, or using the heuristics only during a period of time, smaller than the total learning time for RL algorithm. Thus the formal results obtained for RL algorithms remain valid for HARL.</paragraph><paragraph>HAQL was the first HARL algorithm implemented [39]. It extends the Q-Learning algorithm by using the heuristic function to influence the action choice. HAQL has been used in a variety of domains such as autonomous mobile robot navigation [9], RoboCup 2D Simulation [40], Multi-Robot Task Allocation (MRTA) applied in the RoboCup Small Size League [41]; it was also extended to deal with multiagent problems [42]. The HAQL algorithm is shown in Algorithm 1.</paragraph><paragraph>The use of heuristics in the SARSA algorithm was recently proposed by Bianchi et al. [38]. In the same paper, the authors also expand the number of HARL algorithms by proposing the Heuristically Accelerated Q(λ), HA-SARSA(λ) and HA-TD(λ), the first algorithms that used both heuristics and eligibility traces.</paragraph><paragraph>The HAQL algorithm was extended in [43] to allow the retrieval and reuse of heuristics from a case base. In this algorithm, called CB-HAQL (see Algorithm 2), steps were added before the action selection is made in order to compute the similarity of the cases with the current state and the cost of adaptation.</paragraph><paragraph>A case is retrieved if the similarity between the new problem and a case in the case base is above a certain threshold. To compute the similarity, several functions can be used. For example, the distance between the attributes of the new problem and the problem in the case base can be computed using a distance metric such as the Manhattan distance, the Euclidean distance or the Gaussian distance. The problem of finding a good similarity function for a domain is well known in the literature of Case Based Reasoning, with several works dedicated to it [44], [45].</paragraph><paragraph>The case definition used in the HAQL algorithm (and inherited by the work presented in this paper) was that proposed by Ros et al. [46], which is composed of three parts: (1) the problem description (P), which corresponds to the situation in which the case can be used; (2) the solution description, which is composed by the sequence of actions that each agent must perform to solve the problem; and, (3) the case scope that defines the applicability boundaries of the cases.</paragraph><paragraph>After a case is retrieved, the heuristic (with the sequence of actions suggested by the case selected) is computed using Equation (4). This heuristic is used for an amount of time proportional to the number of actions of the retrieved case. After this time interval, a new case can be retrieved.</paragraph><paragraph>Although only the CB-HAQL has been proposed before, we can infer that there is a class of algorithms of this kind, that extends all HARL algorithms by using cases as heuristics. We will call this class of algorithms CB-HARL, and any algorithm of this new class will differ from the one presented in Algorithm 2 only by the basic RL algorithm used. For example, the CB-HASARSA differs from the CB-HAQL only in the line 12, where the update rule used is Equation (2) instead of Equation (1).</paragraph></section><section label="4"><section-title>Transferring a case base of heuristics: the L3 meta-algorithm</section-title><paragraph>In this work we investigate one extension of CB-HARL algorithms towards transferring cases between learning agents across distinct domains. This extension has been defined within the L3 meta-algorithm (Algorithm 3), which works in three stages: first, the algorithm learns how to perform a task in the source domain, storing the optimal policy for this problem as a case base; second, it maps actions from the source domain to actions in the target domain; and third, it uses the case base learned in the first stage as heuristics in a CB-HARL algorithm. The L3 processing stages are detailed as follows.</paragraph><paragraph>Stage 1: In the case base construction phase, an RL algorithm (such as Q-learning or SARSA) is used to compute the optimal policy for the source domain. A case base is then built from the learned policy, with a pre-defined number of cases. Similar to the model proposed in [46], each case is described by a 3-tuple: {a mathematical formula}case=(P,A,R), where: P is the description of the problem, containing all relevant information of the agent state; A is an action that solves the problem; and, R is the expected return for performing the action, which indicates the quality of the action stored in this case. There are several ways by which the case-base can be built from the learned policy, such as:</paragraph><list><list-item label="•">select N cases by random sampling the state set and finding the best action for that state;</list-item><list-item label="•">Select N cases by random sampling the action-state set and excluding the cases that contains the worst actions for the state chosen;</list-item><list-item label="•">Select N cases that have the best Q value.</list-item></list><paragraph>These cases will be explored in the experiments below.</paragraph><paragraph>Stage 2: In the action-mapping stage, a Neural Network maps the actions between the source task and the target task. In this network, the input nodes correspond to the set of possible actions in the target domain, and the output nodes correspond to the set of actions of the source domain. In order to learn the network weights, a set of random actions is executed in both domains. If the observed results of the two actions are similar (for example, both actions lead to an increase in the x speed of a robot), the weight that links this pair of actions is increased. If the results of the two actions are different, the weight of the connection is decreased. In this way, this neural network learns the relationship between the consequences of actions in both domains.</paragraph><paragraph>This scheme can be formalised as a single layer, forward-feed, unsupervised neural network using the Hebbian learning rule, where the input and output vectors are in bipolar form (−1 or 1). The Hebbian rule (or Hebbian law) was proposed by Hebb [47], and it can be paraphrased as “cells that fire together wire together; cells that fire out of sync, loose their link”.{sup:5} The main idea of this learning rule is that the weights that connect two neurons should be increased when their outputs are similar, and decreased when they are dissimilar. This rule allows the construction of unsupervised neural networks, since it facilitates the input of training pairs that are not known a priori. It differs from some of the better known learning rules, such as the Delta Learning rule of the Backpropagation Algorithm [49], since the target output is not necessary for the learning process to be successful.</paragraph><paragraph>The Hebbian learning rule can be defined by the following equation:{a mathematical formula} where α is the learning rate, {a mathematical formula}xi is the input and {a mathematical formula}yj is the output neuron.</paragraph><paragraph>In this work, as the main goal of the neural network is to learn the relationship between the consequences of the actions in two different domains, the values of {a mathematical formula}xi and {a mathematical formula}yj used during the learning phase are the action consequences, that is, the changes in the domains due to the action executions. Algorithm 4 details the action-map learning process.</paragraph><paragraph>After the learning phase, the trained neural network is used to map the actions from one domain to the other. As the proposed neural network is single layer, forward feed, the output of one neuron depends on the weighted sum of the input neurons:{a mathematical formula} where x is the input vector defining the target domain action, {a mathematical formula}sumj is the weighted sum and {a mathematical formula}β0 is the neuron bias. The output of the neural network is given by applying a binary activation function, Heaviside step function, to the output of all neurons:{a mathematical formula}</paragraph><paragraph>The result of this computation is a table that describes the relationship between the actions of both domains.</paragraph><paragraph>The benefits of this mapping approach is that it is simple, fast and effective. However, this requires that the state mapping is given so that the neural network could be applied. Future work shall consider developing a mapping procedure capable of both, mapping states and actions autonomously.</paragraph><paragraph>Stage 3: In the final stage, the previously stored case base is used in a CB-HARL algorithm to speed up task learning in the target domain.</paragraph><paragraph>Case retrieval (in this context) is driven by a similarity measure between the new problem and the data in the case base. Inspired in the case retrieval method proposed in [46], in this work we use a similarity function to compute the similarity between the new problem and the stored case base:{a mathematical formula} where {a mathematical formula}Aic is the value of the attribute i in the description of the case, {a mathematical formula}Aip is its value in the new problem, and {a mathematical formula}dist(a,b) is the distance between objects a and b. As described in Section 3, the distance between the attributes of the new problem and the problem in the case base can be computed using a distance metric such as the Manhattan distance, the Euclidean distance or the Gaussian distance. To retrieve a case, the similarity between all the cases in the case base and the new problem are computed, and the case that is most similar to the new problem is retrieved.</paragraph><paragraph>After a case is retrieved, a heuristic is computed using Equation (4) and the action suggested by the case is selected and executed. If the case base does not contain a case that can be used in the current situation (i.e., the similarity between all the cases in the case base and the current situation is below a pre-defined threshold), the CB-HARL algorithm behaves as the original RL algorithm implemented in it.</paragraph><paragraph>Using the L3 framework, two algorithms were implemented in this work:</paragraph><list><list-item label="•">L3-Q, which is based on the CB-HAQL, and was previously proposed by Celiberto et al. [13], and</list-item><list-item label="•">L3-SARSA(λ), which extends the SARSA(λ) algorithm to include the use of cases as heuristics in the action selection.</list-item></list></section><section label="5"><section-title>Results and evaluation</section-title><paragraph>In this section we present experiments where two L3 algorithms, L3-Q and L3-SARSA(λ), are applied in two domains: one which is a traditional benchmark in Reinforcement Learning, the Mountain Car Problem; and a more recent control problem, the Stabilisation of a Humanoid Robot. The first experiment shows how a control strategy can be mapped and transferred between similar domains and the last experiment shows a more complex transfer procedure. Our claim here is that L3 outperforms its non-transfer learning version, and also state-of-the-art transfer learning algorithms.</paragraph><paragraph>In [2] several performance metrics for transfer learning were proposed. Although each one of these metrics have known drawbacks, and others can be proposed, these five metrics are becoming a standard in the transfer learning community. The metrics are:</paragraph><list><list-item label="1.">Jumpstart: the initial improvement of the performance of an agent in the target task, given by the transfer;</list-item><list-item label="2.">Asymptotic performance: the final learned performance of the agent in the target task;</list-item><list-item label="3.">Total reward: the total reward earned by the agent;</list-item><list-item label="4.">Transfer ratio: the ratio between the total reward received by an agent that used the transfer and the one received by an agent that does not use transfer learning;</list-item><list-item label="5.">Time to threshold: the time taken by an agent to achieve a pre-defined level of performance.</list-item></list><paragraph>These metrics were used in the experiments below to provide more information for comparing the algorithms in a multi-dimensional evaluation procedure.</paragraph><paragraph>Student's t-Test [50] was also used in this work as a statistical test to verify the hypothesis that L3 speeds up the learning process. According to Nehmzow [51], if two different control programs produce two distinct means of a particular result, the t-Test can be used to decide whether there is a significant difference between these two means. The greater the value of T, the more significantly different are the results.</paragraph><paragraph>In order to show that the L3 meta-algorithm improves the learning rate of the system, we compare the obtained results with those obtained with other RL, HARL and TL algorithms.</paragraph><section label="5.1"><section-title>Experiment 1: mountain car problem</section-title><paragraph>In this experiment we tested how cases acquired in the 2D mountain car problem [52] can be transferred and used to speed up the learning in the 3D mountain car problem [53].</paragraph><paragraph>In the mountain car problem, a car that is located at the bottom of a valley is moved backward and forward until it reaches the top of a hill. The goal of the learning agent is to generalise across continuous state variables in order to learn how to drive the car up to the goal state.</paragraph><paragraph>In the 2D mountain car problem two continuous variables describe the agent's state: the horizontal position (x) restricted to the range {a mathematical formula}[−1.2,0.6] and the velocity ({a mathematical formula}x˙) restricted to the range {a mathematical formula}[−0.07,0.07]. The agent may select one of the following three actions on each step:{a mathematical formula} which change the velocity by −0.0007, 0, and 0.0007 respectively. The car reaches the top of the hill when its horizontal position is greater than 0.5. The system dynamics is given by Equations (9) below:{a mathematical formula}</paragraph><paragraph>The 3D mountain car is similar to its 2D version, whereas the former is defined over a surface rather than on a curve [29] (as shown in Fig. 1). The state is composed of four continuous state variables: x, {a mathematical formula}x˙, y, {a mathematical formula}y˙. The positions and velocities have ranges of {a mathematical formula}[−1.2,0.6] and {a mathematical formula}[−0.07,0.07], respectively. The agent can select from five actions at each time step: {a mathematical formula}{neutral,west,east,south,north}. The actions west and east modify {a mathematical formula}x˙ by −0.0007 and +0.0007 respectively, while south and north modify {a mathematical formula}y˙ by −0.0007 and +0.0007 respectively.</paragraph><paragraph>The 2D Mountain Car implementation used in this work is that described in [1] and it is available for download at [54]. This simulator implements a Gradient-Descent SARSA(λ) algorithm, using a CMAC function approximator with 9 by 9 tilings.</paragraph><paragraph>In the present experiment we modified the 2D Mountain Car simulator to test the results of using Q-Learning, Q(λ), SARSA, and SARSA(λ) algorithms. All of these four algorithms reached the same optimal policy. However, best results were achieved by SARSA(λ) with the parameters proposed in [1], which were: {a mathematical formula}α=0,5, the exploration/ exploitation rate =0.0, {a mathematical formula}γ=1.0. The reward is −1 on every time step until the car reaches the goal position, ending one episode.</paragraph><paragraph>In order to acquire the case base to be used by the L3-SARSA(λ) algorithm, SARSA(λ) was used to learn the 2D mountain car problem during 200 episodes (each episode ends either after 10.000 steps or when the agent finds the goal state). As observed in [1], this simulator could learn a near optimal policy within 100 episodes. In this work we tested with a different number of episodes, verifying that within 200 episodes learning stabilises ({a mathematical formula}Qˆ(s′,a′)−Qˆ(s,a)∼0).</paragraph><paragraph>Case acquisition begins after the learning stabilises. Each case contains the state, position and velocity, (P), the action taken (A) and the expected return (R). For instance, an acquired case has the following form: {a mathematical formula}〈P=(−1.036143,0.013455);A=right;R=−79.531860〉.</paragraph><paragraph>There are several ways in which the case base acquisition can be accomplished. We tested the following four possibilities:</paragraph><list><list-item label="•">Select N cases by random sampling the state set and finding the best action for that state. To do this, we define the position and speed using a random number generator, then we find the action that maximises this state ({a mathematical formula}argmax(Q)), and its Q value, saving this data as a case. In this way, the case base is built using the best actions for the 2D problem, for a uniformly distributed set of states.</list-item><list-item label="•">Select N cases by random sampling the action-state set. During this sampling process, if a case contains the worst action for that state (i.e., the one with the lowest Q value), this case is discarded. In this way, the case base is built using actions that are not the worst for the 2D problem.</list-item><list-item label="•">Select N cases that have the best Q value. To do this, we sample {a mathematical formula}N⁎1000 times the state set, finding the best action and its Q value for a sampled state. Then, only the N cases with the highest values of Q are selected to be included in the case base. By doing this, we built a case-base with the N best state-action pairs.</list-item><list-item label="•">For comparison purposes, we also built a set with the N worst cases, obtained analogously to the first possibility cited above, but using {a mathematical formula}argmin(Q) instead of {a mathematical formula}argmax(Q).</list-item></list><paragraph>The random number generator used to acquire the case base is the Mersenne Twist Random Generator [55]. This is the most widely used pseudorandom number generator up to date.</paragraph><paragraph>In order to use a case in the target domain, an action mapping between the two domains is needed. As described in Section 4, this mapping is made using an unsupervised neural network using the Hebbian learning rule, where the input and output vectors are in bipolar form (−1 or 1) and the activation function of the output nodes is the Heaviside step function. The network has a five-neuron input layer (one neuron for each of the 5 actions in the target domain) and three neurons in the output layer (one for each of the actions in the source domain).</paragraph><paragraph>In this experiment, the consequences of each action are measured as the variation of the car's speed in each dimension. To do this we compute, for all dimensions in both domains, the variations as given by:{a mathematical formula} where {a mathematical formula}oldVelocityd is updated at the end of each iteration, and d is the dimension.</paragraph><paragraph>As the actions in the 3D Mountain Car domain are only applied in one dimension (e.g. the action south changes the speed only in the y direction), in order to use the action's effects to train the neural network, the dimension in which the action is applied has to be defined. This is accomplished by selecting the greatest value of the variations in the x and y axis computed for this domain. Note that z is a function of x and y.</paragraph><paragraph>The 3D Mountain Car implementation used in this work is based on the one described in [31], and that is available for download at [56]. The parameters used in the neural networks were: {a mathematical formula}learning rate=0.9, {a mathematical formula}Bias=0.01 and 100,000 iterations were used. The bias was used because there are changes in the velocity when using the neutral action due to the gravity force that acts on the car. The bias eliminate these effects on the mapping. One problem with this mapping is that it cannot map the neutral action, as it does not have any direct consequence on the target and source domains. But it can be inferred, as it is the action that has the lowest weights in the neural network connections, and that is not mapped to any other action on the source domain.</paragraph><paragraph>Table 1 shows the results of the automatic action-mapping executed in the second stage of the L3 algorithm. Note that the actions that accelerate the car towards the goal were mapped together, as well as the actions that accelerate the car away from the goal. The neutral action is inferred as the one that did not have any effect on the target domain.</paragraph><paragraph>The last task is now to transfer the cases to the target domain. As mentioned above, the 3D Mountain Car experiments were conducted using the simulator provided by Sutton and Barto [1], with the implementation of the Mountain Car 3D provided by Partalas [56]. The simulator was modified to introduce the L3-SARSA(λ) algorithm, with the addition of the case retrieval procedure and the use of the heuristic function.</paragraph><paragraph>To implement the case retrieval procedure, for each action selected, Equation (8) was used to compute the similarity between the current state of the car and each case in the case base. As the source task has only two attributes (horizontal position x and velocity {a mathematical formula}x˙) in the case base, and the problem has four attributes (x, {a mathematical formula}x˙, y, {a mathematical formula}y˙), we used Equation (8) to find the most similar case between each degree of freedom of the 3D problem and the 2D problem, and computed the similarity of a case as the minimum value between these two results, as stated in Equation (11):{a mathematical formula} where {a mathematical formula}dist(a,b)=|a−b| is the Manhattan Distance between two points.</paragraph><paragraph>The heuristic used in the L3-SARSA(λ) was computed using Equation (4), where {a mathematical formula}st is the current state and {a mathematical formula}at is equivalent to {a mathematical formula}ac, which is the action suggested by the most similar case in the case base. To compare both actions, {a mathematical formula}at must be mapped to the source domain using the learned mapping function {a mathematical formula}map:At→As, which maps actions from the target domain into actions in the source domain. Equation (4) can be rewritten as:{a mathematical formula}</paragraph><paragraph>Thirty training sessions (each of which contained 1000 episodes) were executed for four algorithms in the 3D domain: SARSA(λ), HA-SARSA(λ), L3-SARSA(λ) and the TiMRLA Value-Addition algorithm (described in Fachantidis et al. [31]). For comparison purposes we also include the results obtained by Taylor's MASTER Algorithm, published in [29, Chapter 7].</paragraph><paragraph>The last two are state-of-the art transfer learning algorithms that were selected for comparison purposes (as mentioned in Section 2).</paragraph><paragraph>The heuristic used in HA-SARSA(λ) was defined by a simple rule: if the velocity is negative, use a negative thrust, i.e., decrease the velocity by 0.0007. This heuristic can be expressed by:{a mathematical formula} where {a mathematical formula}x˙t and {a mathematical formula}y˙t are elements of the state {a mathematical formula}st.</paragraph><paragraph>The TiMRLA Value-Addition algorithm described in [31] was executed using the software provided by the authors (available in [57]). The case base used in L3-SARSA(λ) was the one that contains N cases selected by random sampling the state set and finding the best action for that state, because this is the case base that produced the best results for the transfer.{sup:6} The parameters used in the experiments were the same over all trials: the learning rate {a mathematical formula}α=0.2, the exploration/exploitation rate {a mathematical formula}ϵ=0.0, {a mathematical formula}λ=0.95, {a mathematical formula}γ=1.0. The parameter used to create the heuristics in L3 is {a mathematical formula}η=1 and the parameter that weights the influence of the heuristic {a mathematical formula}ξ=1, with a decay of {a mathematical formula}10−4 at the end of each episode. Values in the Q table were randomly initiated. Fig. 2 shows the learning curves obtained, where it can be noted that L3-SARSA(λ) outperforms all other algorithms until episode 600; after that the performances of the algorithms converge. The curves for L3-SARSA(λ) and Taylor's MASTER algorithm are shown in Fig. 3.</paragraph><paragraph>For the experiments reported in this section, the value of the module of T (of the t-Student test) was computed for each episode using the data presented in Fig. 2. The dashed line indicates the 99% confidence limit, i.e. results above the line are different and the probability for this statement to be erroneous is 1%. The results in Fig. 4 show that L3-SARSA(λ) performs clearly better than SARSA(λ) until the 750th episode, HA-SARSA(λ) until the 450th episode with a level of confidence greater than 99%. It also outperforms the TiMRLA Value-Addition algorithm until the 450th episode. After that the performances of all algorithms are equivalent, as expected.</paragraph><paragraph>The results of the comparison between L3-SARSA(λ) and Taylor's MASTER algorithm (Fig. 3) shows that L3 outperforms MASTER in the initial episodes. After the 20th episode, the errorbars on MASTER's results are very large, making the value of T drop below the 99% limit in which there is confidence that the algorithms are different. The asymptotic values of the MASTER algorithm are higher than L3-SARSA(λ), but they are still within the limit in which it can be said that the performances are the same.</paragraph><paragraph>Table 2, Table 3 show the values of Jumpstart, Asymptotic Performance, Total Reward, Transfer Ratio and Time To Threshold metrics for the algorithms executed in this experiment. These tables show that L3-SARSA(λ) outperforms the other algorithms. The closest results to those obtained by L3-SARSA were obtained on Asymptotic Performance of the MASTER algorithm. In fact, MASTER has a higher mean value of the Asymptotic Performance (and a higher Total Reward as a consequence) than those of L3-SARSA, however the t-Student test shows that results from MASTER and L3-SARSA are not statistically distinct.</paragraph><paragraph>In order to decide which case base should be used in the transfer, from the three possibilities acquired (as mentioned above), we compared the results of using each case base with the L3-SARSA(λ) algorithm in the target domain. The results, presented in Fig. 5, show that the best case base is the one that selects N cases by random sampling the state set, finding the best action for that state. For this experiment, the value of the module of T (of the t-Student test) was computed for each episode using the data represented in Fig. 5. The results are similar to the ones in Fig. 4 and show that L3-SARSA(λ), using the cases with the best actions from random sampling of the state set, outperforms all the other case bases until the 600th episode, when they reach the same performance level, with a level of confidence greater than 99%. The error bars were not added in Fig. 5 in order to enhance visibility of the curves, they have the same size of those shown in Fig. 2.</paragraph><paragraph>The behaviour of L3-SARSA(λ) with respect to negative transfer was also investigated in this work. A negative transfer is a situation when the transfer degrades the learning agent's performance. This can be caused by problems related to the knowledge acquisition phase in the source task or to eventual incorrect mappings between the tasks.</paragraph><paragraph>A negative transfer was provided to L3-SARSA(λ) from a case base constructed with the N worst cases (as shown in Fig. 6). In order to compare the performance of our algorithm against other TL algorithms in this context, we used the TiMRLA Value-Addition algorithm with negative information obtained by inverting the values of the transfered data. The results of the negative transfer for both L3-SARSA(λ) and TiMRLA Value-Addition algorithm are shown in Fig. 6.</paragraph><paragraph>In this figure it can be seen that the negative transfer in L3-SARSA(λ) degrades the algorithm's performance until the 100th episode, after that point it learns at a fast pace, converging to the solution earlier than SARSA(λ). This behaviour is due to the fact that, as the case base contains the worst actions, at the beginning of the learning trial our algorithm only makes bad choices. But, as the case base is used as an heuristic, the SARSA(λ) algorithm learns that the actions suggested by the heuristics are misleading, and that they should not be executed. So, at this point (around the 200th episode), it begins to learn which is the best action to be performed, already knowing which are the worst actions (and not selecting any of the latter). In contrast, the TiMRLA Value-Addition algorithm with a negative transfer (shown in Fig. 6) had a very poor asymptotic performance, much lower than L3-SARSA(λ) with negative transfer and the traditional SARSA(λ) algorithm.</paragraph><paragraph>In Section 3, we stated that the convergence of the HARL algorithms depends on the infinite visitation to each pair state-action condition, and that this condition can be considered valid for these algorithms by reducing the influence of the heuristics over time in a number of manners: by multiplying ξ by a decay factor; by multiplying η by a decaying factor; or by using the heuristics only during a period of time, shorter than the total learning time for RL algorithm.</paragraph><paragraph>Fig. 7 shows that the results of the negative transfer when using L3-SARSA(λ) depends on the value of the η and ξ parameters and their decay (Fig. 7a and b), and in the number of episodes that the heuristic is used (Fig. 7c). Bianchi et al. [58] showed that using a fixed value for η and ξ, the algorithm takes longer to ignore the negative transfer. Multiplying ξ by a decay value at the end of each episode reduces the influence of the heuristics over time. If this value is too high, the algorithm takes longer to ignore the misleading heuristics. On the other hand, if this value is too low, the algorithm ignores the heuristics too soon, which makes it behave as the traditional SARSA(λ) algorithm. The same effect happens when the heuristic is used only until a certain episode (Fig. 7c). The results presented here corroborates the results presented in [58].</paragraph><paragraph>This experiment was coded in {a mathematical formula}C++, compiled with GNU {a mathematical formula}g++, and executed on a Virtual Machine running Linux Ubuntu 14 LTS, virtualised using VM-Ware Player, and running on a MacPro running Mac OS X 10.6, 2,66 GHz Intel Xeon processor and 12 Gb of RAM memory.{sup:7} The time needed by each part of this experiment to be executed is presented in Table 4 (where the learning time of L3-SARSA(λ) was divided into its constituting parts). It can be seen that the time to acquire the case base, and to map the source and target domains is negligible in comparison to the time needed to learn the target task. It is not possible to compare these results with the TiMRLA, because the software provided by the authors uses the deprecated RL-Glue Library [59], which makes its running time much slower than the other algorithms.</paragraph></section><section label="5.2"><section-title>Experiment 2: humanoid robot stabilisation</section-title><paragraph>In this experiment we investigate the transfer of cases acquired in the Acrobot domain [1] to accelerate stability learning for a humanoid robot in the Robocup 3D Soccer Simulator domain.</paragraph><paragraph>The Acrobot is a two-link pendulum operating in a vertical plane. The first joint of this actuator is passive, whereas a motor is mounted at the second joint (between the links) to provide a torque input. This system has four continuous state variables: the two joint positions, {a mathematical formula}θ1 and {a mathematical formula}θ2, and the two joint velocities {a mathematical formula}θ1˙ and {a mathematical formula}θ2˙. The goal is to swing the endpoint of the pendulum above its base by an amount equal to the equilibrium position ({a mathematical formula}θ1=(π/2),θ2=0), starting from the initial state {a mathematical formula}θ1=θ2=0. There are three possible actions in this system: positive torque, negative torque, and no torque.</paragraph><paragraph>The RoboCup 3D Simulated Soccer [60] is a realistic simulator that allows the development of control techniques for humanoid robots. The current robot model used in the simulator is based on the Nao Robot by Aldebaran Robotics, which is a humanoid with 22 degrees of freedom, 57 cm high and weighing around 4.5 kg. Nao is equipped with various sensors and effectors, some of them, reproduced in the simulator, are: angle sensors in each joint, a gyroscope, an accelerometer and a force sensor which provides information about the force applied upon the sole of each of the robot's feet.</paragraph><paragraph>In this experiment only three of the Nao's joints were used: Hip Pitch, Knee Pitch, and Foot Pitch (with left and right joint having the same position). All the other joints of the robot were kept in a stationary position. At each time step, the robot could use one of the following seven actions: {a mathematical formula}+0.5∘Hip Pitch, {a mathematical formula}+0.5∘Knee Pitch, {a mathematical formula}+0.5∘Foot Pitch, {a mathematical formula}−0.5∘Hip Pitch, {a mathematical formula}−0.5∘Knee Pitch, {a mathematical formula}−0.5∘Foot Pitch or no action. The robot starts a trial at a random position close to the equilibrium (i.e., the body leaning forward or backward in angles between −20 and 20 degrees in the foot joint). Informally, looking at the humanoid's left side a movement that makes the robot to lean forward is an anti-clockwise rotation of the robot's joints, which is a positive rotation (negative is defined on an analogous way).</paragraph><paragraph>In the first stage of L3-Q, Q-learning is applied in the Acrobot domain over 10,000 episodes (each episode ending either after 20.000 steps or when the agent finds the goal state). The case base acquisition starts when learning stabilises (i.e., when {a mathematical formula}Qˆ(s′,a′)−Qˆ(s,a)∼0) which happens near the 9000th episode. From that point, 500 cases are acquired by randomly sampling the action-state set. During this sampling, cases containing actions with the lowest Q value for that state (the worst one) were discarded. In the second stage of L3-Q, the actions between the two domains are connected. This procedure mapped Acrobot's {a mathematical formula}θ1 angle with the movement of Nao's ankle (foot pitch) and Acrobot's {a mathematical formula}θ2 angle with the movement of Nao's knee. Then, the forward-feed perceptron neural network described in Section 4 is used, with input nodes corresponding to the seven actions used in the Robocup 3D Simulator (the set of possible actions in the target domain), and output nodes corresponding to the three possible actions in the Acrobot domain (the set of actions of the source domain). Table 5 shows the results of this automatic action-mapping.</paragraph><paragraph>At the last stage of the L3-Q algorithm, the case base is used in the CB-HAQL algorithm to learn Nao's equilibrium position. The features used to compute the distance between a case and the problem are the joint angles (assumed as states in both domains). In this experiment, the distance function is defined as the Gaussian distance between attributes of the source domain and target domain:{a mathematical formula} where {a mathematical formula}τx,τy are the radius of the scope around the object. The Gaussian distance is used because the larger the distance between two points, the lower is the similarity between them. Also, the {a mathematical formula}τx,τy parameters are used as thresholds that define a maximum distance allowed for two points to have some degree of similarity, if the distance is greater than a limit, for two object's a and b, then {a mathematical formula}Sim(a,b)=0.</paragraph><paragraph>To verify that L3-Q improves the learning rate, the L3 learning curves are compared with those of Q-learning and the HAQL. This comparison was accomplished over thirty training sessions for each of the three algorithms, each of these sessions consists of 400 episodes of 120 seconds each. The same parameters were used throughout these experiments, as follows: {a mathematical formula}α=0.25, {a mathematical formula}γ=0.9, exploration/exploitation rate =0.1 and the Q table was initialised with zeroes. HAQL and L3-Q use {a mathematical formula}η=1 and {a mathematical formula}ξ=1, and reward of −1 on all steps which do not lead to the goal. The goal state is rewarded with +1. The heuristic used in the HAQL algorithm was defined using a simple rule: if the Nao is leaning forward, move the HIP angle {a mathematical formula}−0.5∘, if it is leaning backward, move the HIP angle {a mathematical formula}+0.5∘.</paragraph><paragraph>This is computed using the equation below:{a mathematical formula}</paragraph><paragraph>The results obtained are presented in Fig. 8, which shows the number of times per episode taken by the agent to reach the goal. It can be seen that L3-Q outperforms both Q-learning and HAQL in the initial learning phase; while the three algorithms converge to similar performance results in later episodes, as expected. The results of applying the Student's t-Test are presented in Fig. 9, where we can see that the performance obtained for L3-Q is statistically distinct from the performances of Q-learning up to the 350th episode and for HAQL up to the 50th episode, with a level of confidence greater than 1%. After that, the results are statistically indistinguishable.</paragraph><paragraph>One issue worth discussing in this experiment is the selection of the robot's joint whose transfer would be more effective. To transfer the learning from Acrobot to the humanoid robot three different joints could be used: the feet joint, the knee joint or the hip joint. In order to verify in which of these the transfer would produce the best results, we repeated the experiment transferring the learning each time to a different joint. The results of this comparison, presented in Fig. 10, show that the best transfer occurs at the hip joint. The t-Test applied on this problem (Fig. 11) shows that the use of L3-Q at the Hip joint is better than its application at the robot's feet up till the 100th episode, and that it was better than L3-Q applied to the robot's Knee only at the beginning of the learning trial. Future work shall address an automatic way of finding the best joint to be used in such cases.</paragraph></section></section><section label="6"><section-title>Discussion</section-title><paragraph>In the meta-algorithm L3, an element of the case base is used in the action selection rule to guide the search in the new domain, in the same way a heuristic is used in an informed search procedure. At the beginning of each learning episode, RL operates as a blind search method. As such, knowledge can be used to lift RL from a blind search style to an informed search procedure.</paragraph><paragraph>Experimental results (described in Section 5) were obtained for two instances of L3 (L3-Q and L3-SARSA(λ)) over two distinct domains, in order to confirm the generality of the method proposed. The experiments verified the initial claim that L3 outperforms its non transfer-learning versions, and also state-of-the-art transfer learning algorithms. The results show that L3 outperforms traditional RL algorithms, such as Q-Learning and SARSA(λ), HARL algorithms such as the HAQL and HA-SARSA(λ), and TL algorithms such as Taylor's MASTER [29] and TiMRLA Value-Addition algorithms [32]. It is worth pointing out that, in contrast to L3, HAQL and HA-SARSA(λ) presuppose user-defined domain knowledge. The fact that the L3 algorithms outperform other heuristically accelerated reinforcement learning (HARL) algorithms lets us conclude that learning the optimal policy of a similar task to be used as a heuristic in another domain is better than using a tailor-made heuristic based on expert knowledge.</paragraph><paragraph>L3 was compared with other state-of-the-art transfer learning algorithms: L3 was compared with the TiMRLA Value-Addition algorithm transfer learning algorithm [32] and Taylor's MASTER algorithm [29] on the Mountain Car experiment (Section 5.1). We did not find any competing algorithm in the literature to compare the Humanoid Robot Stabilisation experiment (presented in Section 5.2), which was a domain included in this paper to illustrate the generality of the algorithm proposed.</paragraph><paragraph>In this paper we compared L3 with HAQL but not with its case-base counterpart, CB-HAQL. In order to compare with CB-HAQL a tailor-made case base would have to be built. Not only this is a tedious process, but the results obtained would be very similar to those obtained with HAQL, since a tailor-made case base would be constructed using some pre-defined heuristics.</paragraph><paragraph>To the best of our knowledge, L3 is the only class of TL algorithms for Reinforcement Learning to date that uses the knowledge obtained in one domain as heuristics in another. This characteristic makes L3 robust to negative transfers: if the cases acquired in the source domain are not useful in the target domain, assuming them as heuristics will not speed up the learning procedure but, in the worst case (when every case in the case base is not applicable to the target domain), L3 will be as efficient as the original RL algorithm that it is based. In other words, if the case base contains no useful (or even misleading) information for the target domain, the agent is still able to learn the optimal policy for the domain using the RL component of the algorithm. As the value of the heuristic defined in Equation (4) is bounded, after a finite number of learning iterations, the correct value of the value function in that state will be learned.</paragraph><paragraph>The effect of negative transfer on L3 was presented in Fig. 6, that show the learning curves for L3 when it was given (as transferred knowledge from the source domain) a set with the N worst cases, obtained by random sampling the state set and selecting the worst action for that state.</paragraph><paragraph>Fig. 6 shows that L3 with negative transfer (curve L3-argmin) had the lowest jumpstart and could not learn anything until the 200th episode, after that it presented the best asymptotic performance and the best time to threshold, in contrast to the other cases analysed. This was due to the fact that the negative transfer delayed the algorithm initially (as expected), but after a number of learning iterations, the algorithm ignored the negative heuristics and avoided the states previously generated by these heuristics in later episodes. In other words, the learning curve of L3-argmin was steeper than the others because L3 learned to avoid bad states, from having to deal with the negative transference of knowledge in earlier episodes.</paragraph><paragraph>This verifies our hypothesis that L3 is robust to negative transfers due to its reliance on the transference of heuristics between domains. However, we were incapable of exactly bounding the finite number of learning iterations needed for L3 to recover from negative transfers. This is an open issue to be addressed in future work.</paragraph></section><section label="7"><section-title>Conclusion and open issues</section-title><paragraph>In this paper we investigated the performance of a new class of algorithms, called L3, which uses a case base to transfer knowledge as heuristics between domains. Two algorithms of this class were investigated: L3-Q, based on Q-Learning, and L3-SARSA(λ), based on the gradient descent SARSA(λ). The transference of heuristics across domains makes L3 robust to negative transfers, which is the major contribution of these algorithms to the state of the art of transfer learning in reinforcement learning. In order to show the generality of L3, this algorithm was applied to benchmark domains in RL whose results show that L3 outperforms Q-Learning (which is traditionally used as baseline algorithm), a Heuristically Accelerated RL algorithm and two state-of-the-art transfer learning algorithms.</paragraph><paragraph>However, L3 was not capable of mapping actions between domains in which there is a one-to-many possibility of mappings, and vice-versa. This issue shall be considered in future research. Future work shall also consider further possible relevance measures for case selection, other than the reward received. A possible candidate for such measure could be the probability assigned to a possible case to be used. In general, the more a case is used in the source domain, the more relevant it is. Whether or not the use of these cases in the target domain results in a better performance than that reported in this paper is an issued to be investigated.</paragraph><paragraph>In our experiments, cases are single step: they represent a single action to be taken in a state. However, we believe that this approach could easily be made more general, in the sense that sequences of actions can also be stored in the case base and used as heuristics. Experiments to validate this hypothesis are a matter for future work.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>Luiz Celiberto Jr. and Reinaldo Bianchi acknowledge the support of FAPESP (grants 2012/14010-5 and 2011/19280-8). Paulo E. Santos acknowledges support from FAPESP (grant 2012/04089-3) and CNPq (grant PQ2 – 303331/2011-9). Ramon Lopez de Mantaras acknowledges the support of the Generalitat de Catalunya grant 2014-SGR-118.</paragraph></acknowledgements><references><reference label="[1]"><authors>R.S. Sutton,A.G. Barto</authors><title>Reinforcement Learning: An Introduction</title><host>(1998)MIT PressCambridge, MA</host></reference><reference label="[2]"><authors>M.E. Taylor,P. Stone</authors><title>Transfer learning for reinforcement learning domains: a survey</title><host>J. Mach. Learn. Res.10 (1)(2009) pp.1633-1685</host></reference><reference label="[3]"><authors>M.E. Taylor,P. Stone</authors><title>An introduction to inter-task transfer for reinforcement learning</title><host>AI Mag.32 (1)(2011) pp.15-34</host></reference><reference label="[4]"><authors>C. Drummond</authors><title>Accelerating reinforcement learning by composing solutions of automatically identified subtasks</title><host>J. Artif. Intell. Res.16 (2002) pp.59-104</host></reference><reference label="[5]"><authors>W.B. Knox,P. Stone</authors><title>Combining manual feedback with subsequent MDP reward signals for reinforcement learning</title><host>Proc. of 9th Int. Conf. on Autonomous Agents and Multiagent SystemsAAMAS 2010(2010) pp.5-12</host></reference><reference label="[6]">W.B. Knox,P. StoneReinforcement learning from simultaneous human and MDP rewardAAMAS '12Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systemsvol. 1 (2012)International Foundation for Autonomous Agents and Multiagent SystemsRichland, SC0-9817381-1-7 pp.475-482ISBN 978-0-9817381-1-6</reference><reference label="[7]"><authors>B. Price,C. Boutilier</authors><title>Accelerating reinforcement learning through implicit imitation</title><host>J. Artif. Intell. Res.19 (2003) pp.569-629</host></reference><reference label="[8]"><authors>G. Konidaris,A. Barto</authors><title>Autonomous shaping: knowledge transfer in reinforcement learning</title><host>Proceedings of the 23rd International Conference on Machine Learning(2006) pp.489-496</host></reference><reference label="[9]"><authors>R.A.C. Bianchi,C.H.C. Ribeiro,A.H.R. Costa</authors><title>Accelerating autonomous learning by using heuristic selection of actions</title><host>J. Heuristics1381-123114 (2)(2008) pp.135-168</host></reference><reference label="[10]"><authors>R.A.C. Bianchi,R. Ros,R. Lopez de Mantaras</authors><title>Improving reinforcement learning by using case based heuristics</title><host>L. McGintyD.C. WilsonCase-Based Reasoning Research and Development, 8th International Conference on Case-Based ReasoningICCBR 2009, Seattle, WA, USA, July 20–23, 2009Lecture Notes in Computer Sciencevol. 5650 (2009)Springer978-3-642-02997-4 pp.75-89</host></reference><reference label="[11]"><authors>S.J. Pan,Q. Yang</authors><title>A survey on transfer learning</title><host>IEEE Trans. Knowl. Data Eng.1041-434722 (10)(2010) pp.1345-1359</host></reference><reference label="[12]"><authors>M. Klenk,D.W. Aha,M. Molineaux</authors><title>The case for case-based transfer learning</title><host>AI Mag.32 (1)(2011) pp.54-69</host></reference><reference label="[13]"><authors>L.A. CelibertoJr.,J.P. Matsuura,R. Lopez de Mantaras,R.A.C. Bianchi</authors><title>Using cases as heuristics in reinforcement learning: a transfer learning application</title><host>Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence, vol. 2IJCAI'11(2011)AAAI Press pp.1211-1217</host></reference><reference label="[14]"><authors>S. Thrun</authors><title>Explanation-Based Neural Network Learning: A Lifelong Learning Approach</title><host>(1996)Kluwer Academic PublishersBoston, MA</host></reference><reference label="[15]"><authors>A. Niculescu-Mizil,R. Caruana</authors><title>Inductive transfer for Bayesian network structure learning</title><host>Unsupervised and Transfer Learning – Workshop Held at ICML 2011Bellevue, Washington, USA, July 2, 2011(2012) pp.167-180</host></reference><reference label="[16]"><authors>C. Lemke,M. Budka,B. Gabrys</authors><title>Metalearning: a survey of trends and technologies</title><host>Artif. Intell. Rev.0269-2821 (2013) pp.1-14</host></reference><reference label="[17]"><authors>R. Caruana</authors><title>Multitask learning</title><host>Mach. Learn.0885-612528 (1)(1997) pp.41-75</host></reference><reference label="[18]"><authors>B.D. Argall,S. Chernova,M. Veloso,B. Browning</authors><title>A survey of robot learning from demonstration</title><host>Robot. Auton. Syst.57 (5)(2009) pp.469-483</host></reference><reference label="[19]"><authors>S. Griffith,K. Subramanian,J. Scholz,C.L. Isbell,A.L. Thomaz</authors><title>Policy shaping: integrating human feedback with reinforcement learning</title><host>C.J.C. BurgesL. BottouZ. GhahramaniK.Q. WeinbergerNIPS(2013) pp.2625-2633</host></reference><reference label="[20]"><authors>L. Saitta,J.-D. Zucker</authors><title>Abstraction in Artificial Intelligence and Complex Systems</title><host>(2013)Springer Publishing Company, Incorporated9781461470519</host></reference><reference label="[21]">A. von Hessling,A.K. GoelAbstracting reusable cases from reinforcement learningS. Brüninghaus6th International Conference on Case-Based ReasoningICCBR 2005, Chicago, IL, USA, August 23–26, 2005(2005)Workshop Proceedings</reference><reference label="[22]"><authors>D.W. Aha,M. Molineaux,G. Sukthankar</authors><title>Case-based reasoning in transfer learning</title><host>Proceedings of the 8th International Conference on Case-Based Reasoning: Case-Based Reasoning Research and DevelopmentICCBR '09(2009)Springer-VerlagBerlin, Heidelberg978-3-642-02997-4 pp.29-44</host></reference><reference label="[23]"><authors>F. Fernández,M. Veloso</authors><title>Probabilistic policy reuse in a reinforcement learning agent</title><host>Proceedings of the Fifth International Joint Conference on Autonomous Agents and Multiagent SystemsAAMAS '06(2006)ACMNew York, NY, USA1-59593-303-4 pp.720-727</host></reference><reference label="[24]"><authors>B. Banerjee,P. Stone</authors><title>General game learning using knowledge transfer</title><host>The 20th International Joint Conference on Artificial Intelligence(2007) pp.672-677</host></reference><reference label="[25]"><authors>V. Soni,S. Singh</authors><title>Using homomorphisms to transfer options across continuous reinforcement learning domains</title><host>Proceedings of the 21st National Conference on Artificial Intelligencevol. 1 (2006)AAAI Press978-1-57735-281-5 pp.494-499</host></reference><reference label="[26]"><authors>M.E. Taylor,N.K. Jong,P. Stone</authors><title>Transferring instances for model-based reinforcement learning</title><host>Machine Learning and Knowledge Discovery in DatabasesLecture Notes in Artificial Intelligencevol. 5212 (2008) pp.488-505</host></reference><reference label="[27]"><authors>M. Snel,S. Whiteson</authors><title>Multi-task reinforcement learning: shaping and feature selection</title><host>Proceedings of the 9th European Conference on Recent Advances in Reinforcement LearningEWRL'11(2012)Springer-VerlagBerlin, Heidelberg pp.237-248</host></reference><reference label="[28]"><authors>H.B. Ammar,K. Tuyls,M.E. Taylor,K. Driessens,G. Weiss</authors><title>Reinforcement learning transfer via sparse coding</title><host>AAMAS '12Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systemsvol. 1 (2012)International Foundation for Autonomous Agents and Multiagent SystemsRichland, SC pp.383-390</host></reference><reference label="[29]">M.E. TaylorAutonomous inter-task transfer in reinforcement learning domainsPh.D. thesis<host>(2008)University of Texas at AustinAustin, TX, USA</host></reference><reference label="[30]"><authors>H.B. Ammar,M.E. Taylor</authors><title>Reinforcement learning transfer via common subspaces</title><host>Proceedings of the 11th International Conference on Adaptive and Learning AgentsALA'11(2012)Springer-VerlagBerlin, Heidelberg pp.21-36</host></reference><reference label="[31]"><authors>A. Fachantidis,I. Partalas,M.E. Taylor,I. Vlahavas</authors><title>Transfer learning via multiple inter-task mappings</title><host>Proceedings of the 9th European Conference on Recent Advances in Reinforcement LearningEWRL'11(2012)Springer-VerlagBerlin, Heidelberg pp.225-236</host></reference><reference label="[32]"><authors>A. Fachantidis,I. Partalas,G. Tsoumakas,I. Vlahavas</authors><title>Transferring task models in reinforcement learning agents</title><host>Neurocomputing0925-2312107 (2013) pp.23-32</host></reference><reference label="[33]"><authors>J.S. Albus</authors><title>A new approach to manipulator control: the Cerebellar Model Articulation Controller (CMAC)</title><host>Trans. ASME G, J. Dyn. Syst. Meas. Control97 (3)(1975) pp.220-227</host></reference><reference label="[34]"><authors>M.L. Littman,C. Szepesvári</authors><title>A generalized reinforcement learning model: convergence and applications</title><host>Proceedings of the 13th International Conference on Machine LearningICML'96(1996) pp.310-318</host></reference><reference label="[35]"><authors>L.P. Kaelbling,M.L. Littman,A.W. Moore</authors><title>Reinforcement learning: a survey</title><host>J. Artif. Intell. Res.4 (1996) pp.237-285</host></reference><reference label="[36]">C.J.C.H. WatkinsLearning from delayed rewardsPh.D. thesis<host>(1989)University of Cambridge</host></reference><reference label="[37]">G. Rummery,M. NiranjanOn-line Q-learning using connectionist systemsTechnical report CUED/F-INFENG/TR 166<host>(1994)Cambridge University, Engineering Department</host></reference><reference label="[38]"><authors>R.A.C. Bianchi,C.H.C. Ribeiro,A.H.R. Costa</authors><title>Heuristically accelerated reinforcement learning: theoretical and experimental results</title><host>L.D. RaedtC. BessièreD. DuboisP. DohertyP. FrasconiF. HeintzP.J.F. Lucas20th European Conference on Artificial Intelligence. Including Prestigious Applications of Artificial Intelligence (PAIS-2012) System Demonstrations TrackECAI 2012, Montpellier, France, August 27–31, 2012Front. Artif. Intell. Appl.vol. 242 (2012)IOS Press978-1-61499-097-0 pp.169-174</host></reference><reference label="[39]"><authors>R.A.C. Bianchi,C.H.C. Ribeiro,A.H.R. Costa</authors><title>Heuristically accelerated Q-learning: a new approach to speed up reinforcement learning</title><host>Lect. Notes Artif. Intell.3171 (2004) pp.245-254</host></reference><reference label="[40]"><authors>L.A. Celiberto,C.H.C. Ribeiro,A.H.R. Costa,R.A.C. Bianchi</authors><title>Heuristic reinforcement learning applied to RoboCup simulation agents</title><host>U. VisserF. RibeiroT. OhashiF. DellaertRoboCupLecture Notes in Computer Sciencevol. 5001 (2007)Springer978-3-540-68846-4 pp.220-227</host></reference><reference label="[41]"><authors>J.A. Gurzoni,F. Tonidandel,R.A.C. Bianchi</authors><title>Market-based dynamic task allocation using heuristically accelerated reinforcement learning</title><host>L. AntunesH.S. PintoEPIALecture Notes in Computer Sciencevol. 7026 (2011)Springer978-3-642-24768-2 pp.365-376</host></reference><reference label="[42]"><authors>R.A.C. Bianchi,C.H.C. Ribeiro,A.H.R. Costa</authors><title>Heuristic selection of actions in multiagent reinforcement learning</title><host>M.M. VelosoIJCAI(2007) pp.690-695</host></reference><reference label="[43]"><authors>R.A.C. Bianchi,R. Lopez de Mantaras</authors><title>Case-based multiagent reinforcement learning: cases as heuristics for selection of actions</title><host>Proceedings of the 2010 Conference on ECAI 2010: 19th European Conference on Artificial Intelligence(2010)IOS PressAmsterdam, The Netherlands978-1-60750-605-8 pp.355-360</host></reference><reference label="[44]"><authors>H.-D. Burkhard</authors><title>Similarity and distance in case based reasoning</title><host>Fundam. Inform.0169-296847 (3–4)(2001) pp.201-215</host></reference><reference label="[45]"><authors>G.R. Finnie,Z. Sun</authors><title>Similarity and metrics in case-based reasoning</title><host>Int. J. Intell. Syst.17 (3)(2002) pp.273-287</host></reference><reference label="[46]"><authors>R. Ros,J.L. Arcos,R. Lopez de Mantaras,M. Veloso</authors><title>A case-based approach for coordinated action selection in robot soccer</title><host>Artif. Intell.0004-3702173 (9–10)(2009) pp.1014-1039</host></reference><reference label="[47]"><authors>D.O. Hebb</authors><title>The Organization of Behavior: A Neuropsychological Theory</title><host>(1949)WileyNew York0-8058-4300-0</host></reference><reference label="[48]"><authors>N. Doidge</authors><title>The Brain That Changes Itself</title><host>(2007)Viking Press</host></reference><reference label="[49]"><authors>D.E. Rumelhart,G.E. Hinton,R.J. Williams</authors><title>Learning representations by back-propagating errors</title><host>Nature323 (6088)(1986) pp.533-536</host></reference><reference label="[50]"><authors>M.R. Spiegel</authors><title>Statistics</title><host>(1998)McGraw-Hill</host></reference><reference label="[51]"><authors>U. Nehmzow</authors><title>Scientific Methods in Mobile Robotics: Quantitative Analysis of Agent Behaviour</title><host>(2006)Springer-Verlag London LimitedLondon1846280192</host></reference><reference label="[52]"><authors>A. Moore</authors><title>Variable resolution dynamic programming: efficiently learning action maps in multivariate real-valued state-spaces</title><host>L. BirnbaumG. CollinsMachine Learning: Proceedings of the Eighth International ConferenceMorgan Kaufmann, San Francisco, CA(1991) pp.333-337</host></reference><reference label="[53]"><authors>M.E. Taylor,G. Kuhlmann,P. Stone</authors><title>Autonomous transfer for reinforcement learning</title><host>L. PadghamD.C. ParkesJ.P. MüllerS. Parsons7th International Joint Conference on Autonomous Agents and Multiagent Systems, vol. 1AAMAS 2008, Estoril, Portugal, May 12–16, 2008(2008)IFAAMAS978-0-9817381-0-9 pp.283-290</host></reference><reference label="[54]">R.S. Sutton, Mountain car software, http://webdocs.cs.ualberta.ca/~sutton/MountainCar/MountainCar.html, 2000, last accessed 20/11/2014.</reference><reference label="[55]"><authors>M. Matsumoto,T. Nishimura</authors><title>Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator</title><host>ACM Trans. Model. Comput. Simul.1049-33018 (1)(1998) pp.3-30</host></reference><reference label="[56]">I. Partalas, Mountain car 3D CPP in RL library, http://library.rl-community.org/wiki/Mountain_Car_3D_(CPP), last accessed 20/11/2014, 2014.</reference><reference label="[57]">I. Partalas, The value-addition algorithm for mountain car, http://mlkd.csd.auth.gr/transfer-learning.html, last accessed 20/11/2014, 2014.</reference><reference label="[58]"><authors>R.A.C. Bianchi,M. Martins,C.H.C. Ribeiro,A.H.R. Costa</authors><title>Heuristically-accelerated multiagent reinforcement learning, cybernetics</title><host>IEEE Trans. Cybern.2168-226744 (2)(2014) pp.252-265</host></reference><reference label="[59]"><authors>B. Tanner,A. White</authors><title>RL-glue: language-independent software for reinforcement-learning experiments</title><host>J. Mach. Learn. Res.10 (2009) pp.2133-2136</host></reference><reference label="[60]"><authors>J. Boedecker,K. Dorer,M. Rollmann,Y. Xu,F. Xue,M. Buchta,H. Vatankhah</authors><title>SimSpark Users's Manual</title><host>(2010)RoboCup Federation</host></reference></references><footnote><note-para label="5">This mnemonic sentence is attributed to Carla Shatz at Stanford University [48].</note-para><note-para label="6">A comparison between the case bases are shown at the end of this section (cf. Fig. 5).</note-para><note-para label="7">This virtual machine, and all the software needed to run this experiment, is available at http://fei.edu.br/~rbianchi/software.</note-para></footnote></root>