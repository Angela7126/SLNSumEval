<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370216000151</url><title>Parameterised verification for multi-agent systems</title><authors>Panagiotis Kouvaros,Alessio Lomuscio</authors><abstract>We study the problem of verifying role-based multi-agent systems, where the number of components cannot be determined at design time. We give a semantics that captures parameterised, generic multi-agent systems and identify three notable classes that represent different ways in which the agents may interact among themselves and with the environment. While the verification problem is undecidable in general we put forward cutoff procedures for the classes identified. The methodology is based on the existence of a notion of simulation between the templates for the agents and the template for the environment in the system. We show that the cutoff identification procedures as well as the general algorithms that we propose are sound; for one class we show the decidability of the verification problem and present a complete cutoff procedure. We report experimental results obtained on MCMAS-P, a novel model checker implementing the parameterised model checking methodologies here devised.</abstract><keywords>Multi-agent systems;Validation;Parameterised verification;Cutoffs</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>With the development and deployment of autonomous agents and multi-agent systems (MAS) in diverse applications such as robot-based search-and-rescue [1], web-services [2], personal negotiation assistants [3], a growing need has emerged to develop powerful and versatile methodologies for the validation and verification of MAS. Model checking [4] is a leading logic-based technique for the verification of systems that has emerged in the past twenty years. Model checking enables us to check whether a model {a mathematical formula}MS representing a system S, satisfies a formula {a mathematical formula}ϕP encoding a specification P.</paragraph><paragraph>While plain reactive systems [5] are typically specified by means of reachability or purely temporal statements, autonomous agents are typically specified by means of high level properties inspired from AI. As a consequence, in the case of MAS the specification {a mathematical formula}ϕP is typically given in agent-based logics, such as epistemic logic [6], BDI [7], Desires-Goal-Intention [8], and ATL [9]. Over the past ten years a number of techniques have been put forward for the efficient model checking of MAS against agent-based specifications including binary decision diagrams [10], [11], abstraction [12], partial order reduction [13], bounded model checking [14], parallel model checking [15], thereby making it possible to verify systems with large state spaces. Yet, since the number of states is exponential in the number of agents in the system, systems of many agents typically remain intractable.</paragraph><paragraph>A further difficulty consists on the fact that some agent-based protocols, such as auctions, do not specify how many agents may be present at runtime. By model checking we may be able to verify a system for a given number of agents. But this does not enable us to draw any conclusion as to whether the specification would still hold should more agents be present. Intuitively, additional agents may possibly interfere with the system in unpredicted ways resulting in the specification to be violated. Yet, our practical experience (e.g., networking and security protocols) tells us that some, albeit not all, protocols are correct irrespective of the number of components. Any technique that enables us to verify specifications independently of the number of agents present would clearly be beneficial in validating a wide range of MAS.</paragraph><paragraph>Cutoffs have been studied in the formal analysis of systems to try to address this, often in the context of networking protocols [16], [17]. A cutoff for a specification is the number of components that need to be analysed to be able to draw general conclusions that hold irrespective of the number of components in a system. Since the problem in its generality is undecidable [18], sound but incomplete methods have been put forward [17], [19], [20] that impose restrictions on the systems and the properties to be studied. However, as we discuss below the current literature does not address the needs of MAS, or AI systems in general, as they are tailored to temporal specifications only and they often rely on specific semantics that abstract from the particular way in which agents may interact.</paragraph><paragraph>The aim of this paper is to present a technique for the automatic verification of MAS populated by arbitrarily many agents adhering to different roles. In particular we isolate three classes of MAS for which we show that cutoffs can be given when certain sufficient conditions are met. We illustrate the semantic classes correspond to different ways in which the agents may interact among themselves and with the environment. In addition to exploring the theoretical side of the problem we also present an implementation based on ideas here presented and discuss the experimental results obtained.</paragraph><section label="1.1"><section-title>Parameterised model checking</section-title><paragraph>The traditional model checking problem [4] concerns establishing whether a specification {a mathematical formula}ϕP representing a property P holds on a finite model {a mathematical formula}MS built from a finite number of components implementing the system S, or {a mathematical formula}MS⊨ϕP. In the traditional approach the behaviours of all the components are specified beforehand; the model {a mathematical formula}MS resulting from their synchronisation is then constructed and the property {a mathematical formula}ϕP is then checked.</paragraph><paragraph>While the traditional model checking problem establishes whether a particular system satisfies a given specification, the parameterised model checking problem (PMCP) is concerned with establishing whether any system composed of any number of agents following a certain behavioural template satisfies a given specification. Clearly any attempt to reduce the parameterised model checking problem to the standard model checking problem would entail checking an infinite number of models, i.e., all possible systems built from any number of agents. Given the number of agents is not bounded it would also imply checking models of unbounded size.</paragraph><paragraph>In traditional computer science the PMCP can potentially be used to verify specific networking protocols and a wide range of distributed algorithms. In MAS and AI in general, techniques for the PMCP could in principle be used to establish properties of a wide and diverse range of systems ranging from robotic swarms to e-commerce applications where the number of agents is not known at design time.</paragraph><paragraph>In the general setting the PMCP is undecidable [18]. However, given its importance, it is of interest to develop sound but incomplete techniques to solve it. The PMCP is typically formulated in a finitary, abstract way by giving a template for the agents in the system, a template for the environment, and the formula to be verified. By providing the parameter n specifying the actual number of agents in the system, we can then construct a concrete system upon which the standard model checking problem can be solved. A way to limit the generality of the problem is to restrict the systems considered. For example, we may consider a specific topology, e.g., rings, when analysing network protocols for an unbounded number of hosts. In this paper we follow a different approach. We do not impose many constraints in terms of how the agents may behave, but we are constrain their interaction.</paragraph></section><section label="1.2"><section-title>Related work</section-title><paragraph>In the past 10 years several methods have been put forward for verifying MAS by means of symbolic model checking. Most techniques support epistemic specifications [13], [14], [21], [22], [23], [24]; others target deontic specifications [25], [26], or specifications expressing strategic abilities [27], [28]. The resulting performance differs depending on a number of assumptions; symbolic checkers such as MCK[10], MCMAS[11] and VerICS[29] are all capable of handling state-spaces of the region of 10{sup:15} and beyond.</paragraph><paragraph>While these techniques have received considerable attention, they all suffer from a key limitation in that they only deal with closed MAS where the number of components is known at design time. This makes it impossible to verify MAS where the number of agents is not known at design time.</paragraph><paragraph>Verification of systems with an arbitrarily large number of components has been investigated, however, in the context of reactive systems where the problem has been shown to be undecidable in general [18]. The techniques put forward typically assume a number of restrictions either on the systems or in the specifications considered so that either soundness or decidability can be retained. The approaches can be classified into abstraction techniques, network invariant techniques, regular model checking, and cutoff techniques.</paragraph><paragraph>Abstraction techniques [30], [31], [32], [33], [34], [35], [36], [37] rely on the analysis of a single finite state abstract system encoding all possible concrete systems. Typically these methods require manual guidance for obtaining the abstract mapping. Further, they are often incomplete: if a certain specification is falsified in the abstract model, then it does not necessarily follow that there is a concrete system falsifying the specification. Among these techniques we identify counter abstraction and environment abstraction.</paragraph><paragraph>Counter abstraction techniques generate abstract states that reflect the number of participants in each local state. A seminal work in this context defined the abstract model in terms of a Petri Net [32]. An automata-theoretic procedure was defined to check single-indexed LTL properties for systems communicating via CSS actions. The procedure runs in time doubly exponential in the size of the template process and the specification. A forward reachability procedure that extends the covering graph for Petri Nets was proposed in [37]. The procedure was shown to be incomplete for broadcast protocols [35]. In contrast, a backward reachability algorithm which is complete for upwards-closed sets of states was discussed in [35]. By building on these ideas a forward bounded reachability analysis that sequentially generates a set of increasingly refined abstractions was devised [36]. In another line, counter abstractions were refined to saturate binary counters [30]. This gives a finite abstract model which is used to check asynchronous parameterised systems against liveliness properties. The method was shown to be sound but incomplete. Similarly, the counters were also saturated in [34] to check synchronous systems against LTL properties [34]. Although in the asynchronous case the proposed framework becomes undecidable, the synchronous case is decidable via a procedure identifying spurious counterexamples that may occur in the counter-abstracted model.</paragraph><paragraph>Environment abstraction combines counter abstraction with predicate abstraction by keeping track of the number of participants which satisfy a certain predicate. The technique was applied to the analysis of Lamport's bakery algorithm and Szymanski's algorithm [31]. Soundness of the technique was showed [33].</paragraph><paragraph>Network invariant techniques [38], [39], [40] are induction-based methods that reduce the parameterised model checking problem to model checking a finite state system. They identify a network invariant capturing a system's behaviour that is independent of the number of agents; i.e., the invariant is present in any concrete system. It follows that a property is satisfied by the parameterised system if it is satisfied by the network invariant. Methodologies for computing network invariants as well as sufficient criteria for their existence have been given [38], [41]. While these works depend on manual guidance, heuristics have been used to generate the invariants automatically [40], [39].</paragraph><paragraph>Infinite state model checking techniques have also been applied to parameterised systems via regular model checking [42], [43], [44], [45]. In regular model checking the states are represented by words and the transition relation on the set of states is represented by finite state transducers. The fundamental difficulty with this approach is the computation of the transitive closure of the transducers. This often leads to incomplete techniques and expensive automata-theoretic constructions. To improve their efficiency several methodologies have been developed including widening[43], [45] and acceleration[42], [44].</paragraph><paragraph>Approaches based on cutoffs [16], [17], [19], [20], [46], [47], [48], [49], [50] aim to identify an integer called cutoff, expressing the number of components that is sufficient to consider when evaluating a given specification. The identification may either be dynamic or static. Dynamic cutoffs are identified on-the-fly during the verification procedure. While they were first introduced for the analysis of reachability properties in Petri Nets [47], similar ideas have been used to analyse systems with linear or tree-like topologies [19]. Static cutoffs are identified by an explicit cutoff procedure before the actual verification commences. Techniques based on static cutoffs can typically analyse richer specifications, such as those built on {a mathematical formula}LTL∖X[16], [17], [50], [20] or {a mathematical formula}CTL⁎∖X[46], [48], [49].</paragraph><paragraph>While the research discussed above is related to the problem addressed here, our work is fundamentally different in several respects. Firstly, we address multi-agent systems where the patterns of interaction do not depend on a particular network topology. Secondly, we support epistemic specifications and not just temporal ones.</paragraph><paragraph>The parameterised interleaved interpreted systems (PIIS) model we introduce generalises the model of broadcast protocols [37], whose PMCP has been analysed in terms of {a mathematical formula}LTL∖X properties, LTL properties, regular and ω-regular properties [35], [37], [51]. The PMCP was shown to be decidable for regular properties in [35]. The decidability result instantiates the backward reachability procedure[52] to the context of broadcast protocols. The procedure only supports safety properties. The PMCP was shown to be undecidable for {a mathematical formula}LTL∖X properties in [51], and thus for LTL and ω-regular properties, and decidable for ω-regular properties under the restriction of initialisable templates[51]. Although the restriction on initialisable templates, i.e., every state of the template has a transition to the initial state, has been proven useful in the analysis of cache coherence protocols [51], the aim of this paper is to model general MAS not adhering to this constraint.</paragraph><paragraph>Closely related to the techniques developed in this paper are also the cutoff techniques previously put forward for linear time and computation tree logic [16], [17], [20], [46], [48], [49]. Cutoff results for linear time properties [17], [20], [46], [48] are not easily transferable to our context since the branching nature of the knowledge modality requires a stronger notion of simulation. In some cases, however, notions of stuttering simulations previously defined in the context of {a mathematical formula}CTL⁎[16], [49] can be extended to include knowledge as well, as we show Section 3.4. However, while existing work focuses on particular topologies, here we address a more general setup.</paragraph><paragraph>Previous work by the authors. In our earlier work we have begun addressing parameterised verification for MAS [53], [54]. However, [53] makes strong assumptions on the semantics thereby forcing all agents to evolve in the same way following synchronisation with the environment. This was to some extent overcome in [54], where further patterns of synchronisation where studied. The technique here presented, however, is considerably more general. Most importantly, the notion of role, left as an open problem in [54], is introduced and the semantics reformulated in this way. The extended semantics enables us to explore and present results for systems composed of different classes of agents performing different behaviours. Through the notion of role, agents may interact among themselves in ways that were not previously possible, e.g., an agent of one role can interact with an agent of another role, thereby largely surpassing the expressive power of our initial studies. The implementation we present here also notably extends the one previously presented in that it allows for the declaration of several templates representing the roles of the agents in the system.</paragraph></section><section label="1.3"><section-title>Scheme of the paper</section-title><paragraph>The rest of the paper is organised as follows. In Section 2 we recall the semantics of interleaved interpreted systems, and we put forward PIIS as an abstract semantics for MAS on which the parameterised model checking problem can be defined. In particular we give the definitions for the agent templates for a given role, the environment template and we identify five types of interactions that the agents and the environment can engage in. We then proceed to define three special classes of PIIS, each representing different synchronisation patterns for the agents in the system. In Section 3 we introduce our specification language which consists of an indexed version of a temporal-epistemic logic. Here we adopt a limited form of quantification over the agents to account for the unbounded number of agents in the system, but we remove the next state temporal operator to avoid undecidability. The section continues with some key theoretical observations regarding the notions of stuttering simulations that can be defined on these systems and an exploration on the extent to which these preserve logical satisfaction. This enables us to formally define the PMCP and the notion of cutoffs on the semantics in Section 4.</paragraph><paragraph>Sections 5, 6 and 7 include the main theoretical results of the paper. We study each of the classes identified in Section 2 and give cutoff results for them. By means of these results the PMCP for a class of PIIS can be solved by model checking all systems up to the cutoff. Given the cutoffs are typically low natural numbers these results provide algorithms for the effective verification of various classes of MAS. Each respective class is exemplified via a concrete example showing the applicability of the results.</paragraph><paragraph>Section 8 reports an implementation that we built realising the techniques described in Sections 5 Verifying, 6 Verifying, 7 Verifying. Specifically the section introduces MCMAS-P, a parameterised version of MCMAS, an open-source model checker for the verification of MAS. As we explain, MCMAS-P conducts an iterative check on the existence of certain simulations that guarantee, by the methods of Sections 5 Verifying, 6 Verifying, 7 Verifying, that a cutoff exists. If this can be shown, the checker performs plain model checking on corresponding concrete systems in line with the requirements of the theory developed. We report the experimental results obtained.</paragraph><paragraph>We conclude in Section 9, where we discuss possible future work.</paragraph></section></section><section label="2"><section-title>Parameterised systems with multiple roles</section-title><paragraph>Interpreted systems are a standard semantics for describing multi-agent systems [6]. They provide a natural setup to interpret specifications in a variety of languages including temporal-epistemic logic and alternating temporal logic [6]. Interleaved Interpreted Systems (IIS) are a class of interpreted systems constraining the interleaved evolution of the agents' actions [13]. Here we extend IIS to reason about temporal-epistemic properties in an unbounded MAS setting. To do this, we define parameterised IIS to give a generic description of a MAS irrespective of the number of agents present. This will enable us to define three important classes of parameterised IIS that exhibit attractive properties towards verification. We then proceed to define an indexed temporal-epistemic logic to express properties in the unbounded system. This is followed by the formal definition of the PMCP and the notion of cutoff. We show that cutoffs do not exist in general, thereby paving the road to the subclasses' analysis in the following sections.</paragraph><section label="2.1"><section-title>Interleaved interpreted systems</section-title><paragraph>We begin by assuming a MAS composed of n agents {a mathematical formula}A={1,…,n} acting in an environment E. The environment is treated as a special agent allowing us to consider a MAS as composed of the set {a mathematical formula}A∪{E} of agents. Each agent {a mathematical formula}i∈A∪{E} is described by a nonempty set of local states {a mathematical formula}Li, a unique initial local state {a mathematical formula}ιi∈Li, and a nonempty set of actions {a mathematical formula}Acti. Actions are performed in compliance with a protocol {a mathematical formula}Pi:Li→Acti governing which actions can be performed at a given local state. The evolution of an agent i's local states is specified by a transition function {a mathematical formula}ti:Li×Acti→Li returning the next local state given the agent's (current) local state and action.</paragraph><paragraph>A “null” action {a mathematical formula}ϵi is assumed to be a member of any set {a mathematical formula}Acti. It is assumed that for every state {a mathematical formula}li∈Li we have that: (i) {a mathematical formula}ϵi∈Pi(li) (i.e., the null action is enabled at every local state); (ii) {a mathematical formula}ti(li,ϵi)=li (i.e., an agent stutters in its current local state whenever it performs the null action).</paragraph><paragraph label="Definition 2.1">Interleaved interpreted systemAn interleaved interpreted system is a tuple {a mathematical formula}IIS=〈{Li,ιi,Acti,Pi,ti}i∈A∪{E},V〉, where {a mathematical formula}V:L1×…×Ln×LE→P(AP) is a valuation function for a set AP of atomic propositions.</paragraph><paragraph>A global state{a mathematical formula}g=(l1,…,ln,lE) is a tuple of local states for all the agents in the system; it describes the system at a particular instant of time. Given a global state {a mathematical formula}g=(l1,…,ln,lE) and an agent i, we write {a mathematical formula}lsi(g) to denote the local state {a mathematical formula}lsi(g)=li of agent i in g. The system's global states evolve over time in compliance with the agents' local protocols and local evolution functions, thereby inducing a global transition function. To define the transition function, given an action {a mathematical formula}a∈⋃i∈A∪{E}Acti, let {a mathematical formula}Agent(a)={i∈A∪{E}:a∈Acti} be the set of agents admitting the action in their repertoire.</paragraph><paragraph label="Definition 2.2">Global transition functionThe global transition function {a mathematical formula}t:G×Act1×…Actn×ActE→G on a set G of global states is a partial function defined as follows: {a mathematical formula}t(g,a1,…,an,aE)=g′ iff there is an action {a mathematical formula}b∈⋃i∈A∪{E}Acti such that for all {a mathematical formula}i∈Agent(b), we have that {a mathematical formula}ai=b, {a mathematical formula}ai∈Pi(lsi(g)), and {a mathematical formula}ti(lsi(g),ai)=lsi(g′); and for all {a mathematical formula}i∈(A∪{E})∖Agent(b), we have that {a mathematical formula}ai=ϵi and {a mathematical formula}ti(lsi(g),ai)=lsi(g′)=lsi(g). In short we write the above as {a mathematical formula}g→ag′.</paragraph><paragraph>Thus the global transition function is given in a similar fashion to blocking synchronisation in automata. At each round all agents participating in the global transition are required to perform the same local action; the agents not participating in the global transition are assumed to perform the null action. Every agent admitting said local action in its repertoire has to perform it at the round; if there is a local protocol not permitting this, then the local action cannot be performed in the system. A local action is said to be shared by two or more agents if said agents admit that action in their repertoire of actions. So, communication in IIS is by means of shared actions. We assume that the joint silent action is always enabled. Therefore t is serial.</paragraph><paragraph>Given a set of actions {a mathematical formula}X⊆⋃i∈A∪{E}Acti, we write {a mathematical formula}g→Xg′ to mean that {a mathematical formula}g→ag′ for some {a mathematical formula}a∈X. The reflexive and transitive closure of {a mathematical formula}→X is denoted by {a mathematical formula}→X⁎. A path π is either a finite or an infinite sequence {a mathematical formula}π=g1a1g2a2g3… such that {a mathematical formula}gi→aigi+1, for every {a mathematical formula}i≥1. Given a path π, we write {a mathematical formula}π(i) (respectively {a mathematical formula}π(i,Act)) for the i-th state (action respectively) in π. If π is finite, then we write {a mathematical formula}π[] for the last state in π. By {a mathematical formula}π[i], we denote the suffix {a mathematical formula}giaigi+1… of π, and by {a mathematical formula}[i]π we denote its prefix {a mathematical formula}g1a1…gi. The set of all paths originating from a state g is denoted by {a mathematical formula}Π(g). A global state g is said to be reachable from a global state {a mathematical formula}g1 if there is a path {a mathematical formula}π∈Π(g1) such that {a mathematical formula}π(i)=g, for some {a mathematical formula}i≥1. Since the global transition relation is deterministic we sometimes (uniquely) denote a path {a mathematical formula}g1a1g2a2… by the sequence {a mathematical formula}g1a1a2… .</paragraph><paragraph>We associate temporal models to IIS that, as shown below, can be used to interpret temporal-epistemic formulae as follows.</paragraph><paragraph label="Definition 2.3">ModelGiven an IIS {a mathematical formula}〈{Li,ιi,Acti,Pi,ti}i∈A∪{E},V〉, its associated model is a tuple {a mathematical formula}SIIS=〈G,ι,R,(∼i)i∈A,V〉, where {a mathematical formula}G is the set of global states reachable via {a mathematical formula}R from the initial global state {a mathematical formula}ι=(ι1,…,ιn), {a mathematical formula}R⊆G×G is a global transition relation defined as {a mathematical formula}(g,g′)∈R iff {a mathematical formula}g→ag′ for some action a, and {a mathematical formula}∼i={(g,g′)∈G×G:lsi(g)=lsi(g′)} is the epistemic accessibility relation for agent i defined on local equalities for the agents' states.</paragraph><paragraph label="Example 2.4">Fig. 1 presents the interleaved interpreted system of the untimed version of the Train-Gate-Controller (TGC) as presented in [55] and adapted from [56]. The system of TGC is composed of a controller and two trains. Each train runs along a circular track and both tracks pass through a narrow tunnel. The tunnel can accommodate only one train to be in it at any time. Both sides of the tunnel are equipped with traffic lights, which can be either green or red. The controller operates the colour of the traffic lights to let the trains enter and exit the tunnel. In the figure, the initial states of the controller and the trains are GREEN and WAIT respectively. The transitions that are depicted with the same style of edges are synchronised. Null ϵ actions are omitted in the figure.</paragraph></section><section label="2.2"><section-title>Parameterised interleaved interpreted systems</section-title><paragraph>We introduce a semantics for parameterised MAS representing several types of agents. Agents of a type are said to be adhering to a role. Each role is associated with a generic agent template which specifies the behaviour of each agent of said role. So, the generic description of a parameterised system consists of the descriptions of a finite number of agent templates and the description of the environment template. A parameter for a parameterised system is a tuple of natural numbers, one for each role, whose sum determines the actual number of agents in the system. Given a parameter {a mathematical formula}(n1,…,nk) for the system, the concrete interleaved interpreted system corresponding to the composition of {a mathematical formula}ni agents, for each role i, can be constructed. Hence, a parameterised system gives a finite description of an unbounded number of differently populated interleaved interpreted systems.</paragraph><paragraph>We now describe an agent template. The template is similarly defined to agents in IIS. However, to determine the agents' synchronisation patterns in a concrete system, an agent template distinguishes between five types of actions: (i) asynchronous actions; (ii) agent-environment actions; (iii) role-synchronous actions; (iv) global-synchronous actions; (v) multi-role actions. Each type of action model a different type of interaction.</paragraph><list><list-item label="i.">An asynchronous action from a template i is uniquely instantiated for each concrete agent performing role i. Thus, whenever an asynchronous action is performed, exactly one agent is active in the global transition.</list-item><list-item label="ii.">An agent-environment action, modelling agent-environment communication, is instantiated as an asynchronous action, but each instantiation is shared by the concrete environment. Hence, whenever an agent-environment action is performed, exactly one agent and the environment participate in the global transition.</list-item><list-item label="iii.">A role-synchronous action, describing multi-agent-environment communication, is instantiated only once; the copy is shared by all the concrete agents performing role i and the concrete environment. Therefore, whenever a role-synchronous action is performed, all the agents performing role i and the environment participate in the global transition.</list-item><list-item label="iv.">Similarly, global-synchronous actions are instantiated only once, but the copy is shared by all the concrete agents and the concrete environment. Consequently, whenever a global-synchronous action is performed, all the agents and the environment participate in the global transition.</list-item><list-item label="v.">Multi-role actions encode pairwise communication between the environment and agents performing different roles. A multi-role action is always admitted in the repertoire of actions of exactly two agent templates. Similarly to disjunctive guards [46], one and only one of the two templates guards the action. A multi-role action is said to be guarded by an agent template if the transition function of the template returns the same template state at which the action is performed. The set of multi-role actions admitted by template i is the disjoint union {a mathematical formula}⋃r∈{1,…,k}MRi,r of the sets {a mathematical formula}MRi,1,…,MRi,k of actions shared with and guarded by templates {a mathematical formula}1,…,k, and of the sets {a mathematical formula}GMR1,i,…,GMRk,i of actions shared with templates {a mathematical formula}1,…,k and guarded by i. Note that each {a mathematical formula}GMRr,i, for {a mathematical formula}1≤r≤k, is equal to the set {a mathematical formula}MRr,i of multi-role actions admitted by template r. A multi-role action shared by templates i and r and guarded by r is instantiated for each pair of concrete agents performing roles i and r; the instantiation is also admitted by the concrete environment. As a result, whenever a multi-role action is performed, the following agents are participating in the global transition: exactly one agent performing role i, exactly one agent performing role r, and the environment. The agent performing role i may update its state via the global transition, whereas the agent performing role r remains in its current local state. Intuitively, the agent from role r guards the action as it has to be in a local state where the action is enabled for the global transition to occur.</list-item></list><paragraph label="Definition 2.5">Agent templateAn agent template{a mathematical formula}Ti=〈Li,ιi,Acti,Pi,ti〉 is an agent with a set {a mathematical formula}Acti=Ai∪AEi∪RSi∪GS∪MRi∪GMRi of actions, where {a mathematical formula}Ai is a set asynchronous actions, {a mathematical formula}AEi is a set of agent-environment actions, {a mathematical formula}RSi is a set of role-synchronous actions, GS is a set of global-synchronous actions, {a mathematical formula}MRi=⋃1≤r≤kMRi,r is a set of multi-role actions that are guarded by other templates, and {a mathematical formula}GMRi=⋃1≤r≤rGMRr,i is the set of multi-role actions that are guarded by template i. The following conditions are assumed: the sets {a mathematical formula}Ai,AEi,RSi,GS,MRi,1,…,MRi,k, {a mathematical formula}GMR1,i,…,GMRk,i are pairwise disjoint; for each {a mathematical formula}a∈GMRr,i,l∈Li we have that {a mathematical formula}ti(l,a)=l.</paragraph><paragraph>The environment template {a mathematical formula}E is similarly described as an agent, but for the synchronisation purposes described above, {a mathematical formula}E's set of actions is the union of the agent templates' sets of agent-environment, role-synchronous, global-synchronous, and multi-role actions.</paragraph><paragraph label="Definition 2.6">Environment templateAn environment template{a mathematical formula}E=〈LE,ιE,ActE,PE,tE〉 is an agent defined on the set {a mathematical formula}ActE=⋃1≤i≤k(AEi∪RSi∪MRi)∪GS of actions.</paragraph><paragraph>A parameterised interleaved interpreted system consists of a finite collection of agent templates and a template environment.</paragraph><paragraph label="Definition 2.7">Parameterised interleaved interpreted systemA Parameterised Interleaved Interpreted System is a tuple {a mathematical formula}PIIS=〈T,E,V〉, where {a mathematical formula}T={T1,…,Tk} is a nonempty and finite set of agent templates, {a mathematical formula}E is an environment template, and {a mathematical formula}V={Vi:Li→P(APi):1≤i≤k} is a set of valuation functions, one for each agent template. It is assumed that {a mathematical formula}AP1,…,APk are pairwise disjoint sets of atomic propositions.</paragraph><paragraph>Let {a mathematical formula}PIIS=〈T,E,V〉 be a parameterised system with {a mathematical formula}k≥1 roles. Let {a mathematical formula}n¯∈Nk be a value of the system's parameter where {a mathematical formula}N={i:i≥1} denotes the set of natural numbers. Assume {a mathematical formula}n¯(i) to denote the i-th component in {a mathematical formula}n¯. We now describe the {a mathematical formula}n¯-st concrete instantiation of a parameterised system. The concrete system {a mathematical formula}PIIS(n¯) results from the parallel composition of {a mathematical formula}n¯(i) instantiations {a mathematical formula}(i,1),…,(i,n¯(i)) of each agent template {a mathematical formula}Ti and an instantiation {a mathematical formula}E(n¯) of the environment template. We write {a mathematical formula}A(n¯) for the set {a mathematical formula}A(n¯)={(i,j):1≤i≤k,1≤j≤n¯(i)} of all concrete agents. Each concrete agent is instantiated by taking indexed copies of its agent template.</paragraph><paragraph label="Definition 2.8">Concrete agentGiven a {a mathematical formula}PIIS=〈T,E,V〉 of k roles and {a mathematical formula}n¯∈Nk, the concrete agent {a mathematical formula}(i,j)=〈Lij,ιij,Actij,Pij,tij〉 is defined as follows.</paragraph><list><list-item label="•">{a mathematical formula}Lij=Li×{j} is set of concrete local states;</list-item><list-item label="•">{a mathematical formula}ιij∈Lij is the initial concrete state;</list-item><list-item label="•">{a mathematical formula}Actij is the set of concrete local actions that is defined as the union of the following sets of actions.</list-item><list-item label="•">{a mathematical formula}Pij:Lij→P(Actij) is defined as {a mathematical formula}Pij(l)={a:aτ∈Pi(lτ)}, where {a mathematical formula}aτ ({a mathematical formula}lτ, respectively) denotes the corresponding template action (state, respectively) from which a (l, respectively) has been instantiated;</list-item><list-item label="•">{a mathematical formula}tij:Lij×Actij→Lij is given by {a mathematical formula}tij(l,a)=l′ iff {a mathematical formula}ti(lτ,aτ)=lτ′.</list-item></list><paragraph>So, each local state of a concrete agent is made of the template local states indexed by the name of the agent in question and inherits from its template the actions, the protocols and the transition function. The concrete environment is similarly obtained by instantiating each action shared with the agent templates.</paragraph><paragraph label="Definition 2.9">Concrete environmentGiven a {a mathematical formula}PIIS=〈T,E,V〉 of k roles and {a mathematical formula}n¯∈Nk, the concrete environment {a mathematical formula}E(n¯)=〈LE(n¯),ιE(n¯),ActE(n¯),PE(n¯),tE(n¯)〉 is defined as follows.</paragraph><list><list-item label="•">{a mathematical formula}LE(n¯)=LE;</list-item><list-item label="•">{a mathematical formula}ActE(n¯)=⋃(i,j)∈A(n¯)Actij;</list-item><list-item label="•">{a mathematical formula}PE(n¯):LE(n¯)→P(ActE(n¯)) is defined as {a mathematical formula}PE(n¯)(lE)={a:aτ∈PE(lE)};</list-item><list-item label="•">{a mathematical formula}tE(n¯):LE(n¯)×ActE(n¯)→LE(n¯) is given by {a mathematical formula}tE(n¯)(lE,a)=lE′ iff {a mathematical formula}tE(lE,aτ)=lE′;</list-item></list><paragraph>Finally, a parameterised system's instantiation, and the concrete semantics we consider, is the IIS composed of the concrete agents and the concrete environment. The concrete system's valuation function is defined on atomic propositions indexed by the agents' identities so that a proposition holds on a global state iff the proposition holds by the template valuation function on the template state that the agent indexing the proposition is in the global state. This will enable us in Section 3 to specify collective properties that range over all concrete agents irrespectively of the size of the system.</paragraph><paragraph label="Definition 2.10">Concrete systemGiven a {a mathematical formula}PIIS=〈T,E,V〉 of k roles and {a mathematical formula}n¯∈Nk, the concrete system{a mathematical formula}PIIS(n¯), composed of {a mathematical formula}∏1≤i≤kn¯(i) concrete agents, is a tuple{a mathematical formula} The concrete valuation function {a mathematical formula}V(n¯):G→P(AP) is defined on the set {a mathematical formula}G=L11×…×Lkn¯(k)×LE(n¯) of possible global states and on the set {a mathematical formula}AP=(AP1×{1,…,n¯(1)})∪…∪(APk×{1,…,n¯(k)}) of atomic propositions as follows:{a mathematical formula} where l is the template local state of agent {a mathematical formula}(i,j) in g.</paragraph><paragraph>For each concrete system {a mathematical formula}PIIS(n¯) we can associate a temporal-epistemic model {a mathematical formula}SPIIS(n¯)=〈G(n¯),ι(n¯),R(n¯),(∼ij)(i,j)∈A(n¯),V(n¯)〉 as standard. When {a mathematical formula}PIIS(n¯) is clear from the context we simply write {a mathematical formula}S(n¯) for {a mathematical formula}SPIIS(n¯). For a global state g in {a mathematical formula}S(n¯) we write {a mathematical formula}lsij(g) for the local state of agent {a mathematical formula}(i,j) in g. The template local state of agent {a mathematical formula}(i,j) in g is denoted by {a mathematical formula}tlsij(g).</paragraph><paragraph>In compliance with the interleaved semantics, we can distinguish five types of transitions on a concrete system. In particular, a global transition from a state g can only happen in the following cases (see Fig. 2): (i) a concrete asynchronous {a mathematical formula}Aij action is enabled for agent {a mathematical formula}(i,j) performing role i at g; (ii) a concrete agent-environment {a mathematical formula}AEij action is enabled for the environment and for agent {a mathematical formula}(i,j) performing role i at g; (iii) a concrete role-synchronous {a mathematical formula}RSi action is enabled for the environment and for all the agents performing role i at g; (iv) a concrete global-synchronous GS action is enabled for the environment and for all the agents at g; (v) a concrete multi-role {a mathematical formula}MRi,rj,q action is enabled for the environment, for agent {a mathematical formula}(i,j) performing role i, and for agent {a mathematical formula}(r,q) performing role r at g.</paragraph><paragraph>To summarise, we introduced a notion of parameterised systems giving a concise description of an arbitrarily big set of IIS. Each system is built from {a mathematical formula}n¯(i) identical agents for each role {a mathematical formula}i∈{1,…,k} and from the concrete environment corresponding to the {a mathematical formula}n¯-th instantiation of the template environment. The concrete agents may evolve asynchronously, communicate with the environment via agent-environment actions, synchronise with the agents of the same role via role-synchronous actions, synchronise with all the agents in the system via global-synchronous actions, and communicate with an agent performing another role via multi-role actions. We refer to Appendix A for a summary of the notation used in the paper.</paragraph></section><section label="2.3"><section-title>Examples</section-title><paragraph>We exemplify the technical notions introduced above on three examples: a train-gate-controller model [55], a robot foraging scenario [57], an autonomous robot example [6]. The train-gate-controller illustrates the agent-environment and global-synchronous communication patterns. The robot-foraging scenario gives an intuitive example of multi-role synchronisations. We discuss role-synchronous communication in the context of the autonomous robot example. We here focus on the semantic modelling. We will later discuss specifications and verification methodologies.</paragraph><section label="2.3.1"><section-title>Robot foraging scenario</section-title><paragraph>Swarm robotics concerns the coordination and analysis of an unbounded collection of behaviourally simple robotic agents [58], [59], [60]. The interaction between the agents and their environment is meant to exhibit a collective, emergent behaviour often inspired by biological systems, e.g., ant colonies [61]. As argued in [59], despite the lack of centralised coordination, biological swarm-based systems can still be robust, scalable, and flexible. It is therefore of interest to design swarm robotic systems that can be shown to be in compliance with their specifications. To do this, we need to analyse the properties of a swarm irrespectively of the number of robots in the system.</paragraph><paragraph>In the following we describe an untimed version of the robot foraging scenario (RFS) from [57]. The RFS includes an arbitrary number of robots initially resting in a nest before undertaking a campaign in search for food by means of a random walk. Upon observing a food source, a robot tries to reach for it. If it succeeds, then (i) it collects and deposits the food in the nest; (ii) it makes the location of the food known so that all other robots can find it. Otherwise, if it fails to reach the food source, it then scans the area to locate the source again, or locate a new source. If the scan is successful, then the robot attempts to reach the food source. Otherwise, if the scan is not successful (under a timeout), then the robot returns to its nest.</paragraph><paragraph>We can encode the scenario as a PIIS {a mathematical formula}SRFS composed of a template agent TR representing the robots and a template agent TFS representing the food sources. The template robot is depicted in Fig. 3a. TR is initially in state R representing that the robot is resting in its nest. The states RW, MF, SA represent that the robot is performing a random walk, the robot is moving to the food, and the robot is scanning the area, respectively. The template food source is given by Fig. 3b. TFS is initially in the state N_F representing that the food source has not been found, whereas the state F represents that the food source is found.</paragraph><paragraph>We now describe the global transitions induced by the templates. As discussed in the previous section, a multi-role action is always admitted in the repertoire of actions of two agent templates, and it is guarded by one of them. A multi-role action is instantiated for each pair of agents instantiated from the two templates. In a global transition induced by a multi-role action only the agents for which the action is instantiated and the environment are participating in the transition. The concrete agent from the template not guarding the action may update its state in the global transition, whereas the concrete agent from the template guarding the action remains in its current local state. We describe the possible actions for the templates in the system.</paragraph><list><list-item label="•">search. This an asynchronous action that is defined for the template robot. It is enabled at state R and it represents a robot moving out of its nest to search for food. A global transition by means of the search action results the robot performing the action to move to state RW.</list-item><list-item label="•">fail. This is also an asynchronous action that is enabled at states RW and SA of the template robot. The action represents a robot failing to locate a food source when performing a random walk and when scanning the area, respectively. A global transition via the fail action results the robot performing the action to move to state R.</list-item><list-item label="•">observe. This is a multi-role action that is guarded by TFS. Assume the instantiation {a mathematical formula}(observe,i,j) of the action for robot i and food source j. A concrete transition via the {a mathematical formula}(observe,(i,j)) action is only enabled if the robot i is either in state RW or in state SA, and the food source j is in state N_F. Intuitively the robot can observe the food source if the latter has not already been found. The action causes the robot i to change its state to MF.</list-item><list-item label="•">reached. This is also a multi-role action that is guarded by TR. Following the transition described above, a concrete transition via the {a mathematical formula}(reached,(j,i)) action is enabled. This transition causes the food source j to change its state to F thus modelling that robot i has succeeded in reaching the food source j.</list-item><list-item label="•">deposit. The above transition enables the multi-role action {a mathematical formula}(deposit,(i,j)) that is guarded by TFS. A transition via this action causes the robot to move to state R.</list-item><list-item label="•">scan. Finally, scan is a multi-role action that is guarded by TFS. Intuitively, robot i may fail to reach the food source j (i.e., the {a mathematical formula}(reached,(j,i)) action is not performed). In this case the {a mathematical formula}(scan,(i,j)) action is enabled. Upon this transition the robot updates its state to SA.</list-item></list></section><section label="2.3.2"><section-title>Train-gate-controller</section-title><paragraph>In Section 2.1 we defined the IIS of the train-gate-controller (TGC) composed of a controller and two trains. We now give the PIIS model of a parameterised version of the TGC. We extend the original description to include an arbitrary number of two types of trains: prioritised trains and normal trains. A prioritised train can enter the tunnel at any given time, assuming there is no other train in the tunnel, whereas a normal train can only enter the tunnel when there is no other train waiting to enter the tunnel. To accomplish this, the traffic lights include two shades of the green colour: prioritised green and normal green. Prioritised green is used by the controller to serve prioritised trains, whereas normal green is used by the controller to serve normal trains.</paragraph><paragraph>The scenario can be encoded as a PIIS composed of an agent template representing prioritised trains (Fig. 4a), an agent template representing normal trains (Fig. 4c), and an environment template representing the controller (Fig. 4b). A prioritised train is initially in state WAIT, the controller is initially in state P_GREEN, and a normal train is initially in state TUNNEL_LOCKED. Therefore prioritised trains are initially waiting to enter the tunnel, normal trains are initially locked from entering the tunnel, and the controller initially serves only prioritised trains. The actions p_enter and p_exit are agent-environment actions modelling the prioritised trains entering and exiting the tunnel. Similarly, the actions n_enter and n_exit are agent-environment actions enabling the normal trains to enter and exit the tunnel. The action n_lock is a global-synchronous action and represents the normal trains taking the lock on the tunnel. Also, the action p_lock is a global-synchronous action; it models the prioritised trains taking the lock on tunnel. Finally, the actions {a mathematical formula}p_approach,n_appoach are asynchronous actions.</paragraph><paragraph>The templates induce the following agent-environment and global-synchronous concrete transitions:</paragraph><list><list-item label="•">{a mathematical formula}p_enter,n_enter. In addition to the agent performing the action entering the tunnel, the environment participates in the global transition. This causes the environment to change its state to RED, thereby disallowing other trains to enter the tunnel.</list-item><list-item label="•">{a mathematical formula}p_exit,n_exit. The environment synchronises with the agent that is currently in the tunnel via the p_exit and n_exit actions. The synchronisation causes the environment to change its state to P_GREEN if the agent is a prioritised train or to N_GREEN if the agent is a normal train. Following this, other trains are allowed to enter the tunnel.</list-item><list-item label="•">n_lock. This action is only enabled if: (i) the environment is in state P_GREEN; (ii) there is no train in the tunnel; (iii) all prioritised trains are in state AWAY. A concrete global-transition via the n_lock action causes the environment to update its state to N_GREEN. Thus the transition frees the tunnel to serve normal trains whenever there are no prioritised trains waiting to be served.</list-item><list-item label="•">p_lock. This action is only enabled if: (i) the environment is in state N_GREEN; (ii) there is no train in the tunnel. Upon performing this action the environment moves to state P_GREEN. Therefore the transition locks the tunnel to serve prioritised trains and it can happen irrespective of whether there are normal trains waiting to be served.</list-item></list><paragraph>The above transitions are depicted in Fig. 5 for a fragment of the concrete system with two prioritised trains and two normal trains.</paragraph></section><section label="2.3.3"><section-title>Autonomous robot</section-title><paragraph>We now consider a parameterised version of the autonomous robot (AR) scenario from [6]. The scenario includes an autonomous robot running along an endless straight track. The position of the robot is given in terms of locations numbered as {a mathematical formula}0,1,2,…. The robot can only move forward along the track starting at position 0 and its movement is controlled by the environment. A sensor is attached to the robot measuring its position. The sensor is faulty in the sense that a sensor reading at position q can be any of the values in {a mathematical formula}{q−1,q,q+1}. The only action the robot can perform is to halt. If the robot halts, then the environment can no longer move the robot. Otherwise, the environment may move the robot one position forward at each time step. The goal of the robot is to halt in the goal region {a mathematical formula}GR={2,3,4}. A solution to the AR problem in the single robot case is for the robot to do nothing while the value of its sensor is less than 3 and to halt once the value of its sensor is greater than or equal to 3 [6]. We show in Section 7 that this solution applies to the arbitrary case with an unbounded number of robots.</paragraph><paragraph>We model a generalisation of the above description in which an arbitrary number of robots run synchronously along the track and in which the robots have access to a unique shared sensor. To illustrate the role-synchronous actions, we assume a second type of robots, identical to the description of the first type, but with no access to a sensor. We refer to the two types of robots as type 1 robots and type 2 robots, respectively. Type 2 robots halt after receiving a halting event from type 1 robots. The event is signaled after the type 1 robots have halted.</paragraph><paragraph>We encode the AR scenario as a PIIS {a mathematical formula}SAR composed of a template agent TR1 representing robots with access to a sensor, a template agent TR2 representing robots with no access to a sensor, and a template environment {a mathematical formula}E for synchronisation purposes. The encoding assumes a finite track with 8 distinct locations.</paragraph><paragraph>TR1 is given by Fig. 6a. A template state represents the position of the robot, its sensor reading, and whether it has halted or not, respectively. TR2 is depicted in Fig. 6b. A template state represents the position of the robot and whether it has halted or not, respectively. Finally, {a mathematical formula}E is defined by Fig. 6c. A template state represents the position of the robots and whether or not the type 1 robots have halted.</paragraph><list><list-item label="•">{a mathematical formula}move+,move=,move−. These are global-synchronous actions. A concrete transition via these actions causes all the robots to move one step forwards. Additionally, type 1 robots change their sensor reading to be either the correct reading ({a mathematical formula}move=), the correct reading plus 1 ({a mathematical formula}move+), or the correct reading minus 1 ({a mathematical formula}move−).</list-item><list-item label="•">halt. The role-synchronous action halt is enabled at any state in which the sensor reading of type 1 robots is greater than or equal to 3. Type 1 robots halt upon this transition and the environment stores in its state the fact that they have halted.</list-item><list-item label="•">signal. Following the above transition, a concrete transition via the global-synchronous action signal is enabled. The transition causes the type 2 robots to halt.</list-item></list></section></section><section label="2.4">The systems {a mathematical formula}SMR,SGS,SFE<paragraph>Because of their importance with respect to their amenability to verification, we now identify three noteworthy classes of PIIS. The classes correspond to different combinations of template actions. They are defined as follows.</paragraph><paragraph>{a mathematical formula}SMR is the class of PIIS generated from agent templates defined only on asynchronous, agent-environment, and multi-role actions.{a mathematical formula}</paragraph><paragraph>Decentralised systems may be encoded in {a mathematical formula}SMR using the machinery of multi-role actions, whereas centralised systems can be represented in {a mathematical formula}SMR using the communication primitive of agent-environment actions. As a result, the {a mathematical formula}SMR class is particularly suitable for modelling swarm robotics, which are naturally decentralised systems, but interacting with their environment [58].</paragraph><paragraph>{a mathematical formula}SGS is the class of PIIS generated from agent templates defined only on asynchronous, agent-environment, and global-synchronous actions.{a mathematical formula} This class can represent broadcast protocols [37], cache coherence protocols, swarm aggregation algorithms in a grid environment, and several scenarios where synchronous handshaking is required.</paragraph><paragraph>{a mathematical formula}SFE is the class of PIIS generated from agent templates defined only on asynchronous, role-synchronous, and global-synchronous actions.{a mathematical formula} The absence of agent-environment actions implies that all the agents evolve in the same way following synchronisation with the environment. Differently from the {a mathematical formula}SMR and {a mathematical formula}SGS classes, the PMCP for this class is, as we will show, decidable. This gives clear advantages when protocols can be expressed by {a mathematical formula}SFE.</paragraph><paragraph>An example of an {a mathematical formula}SMR system is the robot foraging scenario discussed in Section 2.3.1, an example of an {a mathematical formula}SGS system is the train-gate-controller described in Section 2.3.2, an example of an {a mathematical formula}SFE system is the autonomous robot example given in Section 2.3.3. We will study the {a mathematical formula}SMR, {a mathematical formula}SGS, and {a mathematical formula}SFE classes in detail in Section 5, Section 6, and Section 7, respectively.</paragraph></section></section><section label="3">The parameterised specification language indexed {a mathematical formula}ACTL⁎K∖X<paragraph>We verify parameterised MAS against properties expressed in indexed{a mathematical formula}ACTL⁎K∖X. This logic extends {a mathematical formula}ACTL⁎K∖X[13] by introducing indexed atomic propositions and indexed epistemic modalities. As we describe below indices enable us to express properties irrespectively of the number of agents present. We first recall {a mathematical formula}ACTL⁎K∖X; we then introduce indexed {a mathematical formula}ACTL⁎K∖X. This is followed by the definition of a notion of simulation between concrete systems and an analysis on the preservation of logical satisfaction between similar systems.</paragraph><section label="3.1">{a mathematical formula}ACTL⁎K∖X<paragraph>{a mathematical formula}ACTL⁎K∖X is a temporal-epistemic logic combining the epistemic logic S5 with the temporal logic {a mathematical formula}ACTL⁎∖X, the universal fragment of {a mathematical formula}CTL⁎ without the next time operator X. Note that restrictions on the specification language are typically assumed in parameterised verification given the problem's general undecidability. It is known that if the language can express the number of agents in the system, then the parameterised verification problem is undecidable [51]. The next operator is therefore excluded to accommodate this [62], [46], [51]. We further restrict the language to universal path quantification to establish the behavioural equivalence results required, as presented in Section 5, Section 6, and Section 7.</paragraph><paragraph>Given sets of atomic propositions {a mathematical formula}AP1,…,APk for each agent template and a set {a mathematical formula}A(n¯) of concrete agents, the state and path formulae of {a mathematical formula}ACTL⁎K∖X are defined by the following BNF expressions:{a mathematical formula} where ϕ and ψ are state and path formulae, {a mathematical formula}(i,j)∈A(n¯) ({a mathematical formula}1≤i≤k,1≤j≤n¯(i)), and {a mathematical formula}p∈APi. The knowledge modality {a mathematical formula}Kij stands for “agent j of role i knows that”; the path quantifier A is read “for all paths”; the temporal operators U and R denote the “until” and “release” modalities. Formulae expressed in {a mathematical formula}ACTL⁎K∖X are interpreted on a model {a mathematical formula}S(n¯) as standard [6]: the temporal modalities are interpreted by means of the global transition relation, and the epistemic modalities are interpreted by the respective epistemic accessibility relations. We write {a mathematical formula}(S(n¯),g)⊨ϕ ({a mathematical formula}(S(n¯),π)⊨ϕ respectively) to mean that a state formula (path formula respectively) is true at a state g (path π respectively) in {a mathematical formula}S(n¯). If {a mathematical formula}S(n¯) is clear, then we simplify the notation to {a mathematical formula}g⊨ϕ ({a mathematical formula}π⊨ϕ respectively).</paragraph><paragraph label="Definition 3.1">SatisfactionGiven a model {a mathematical formula}S(n¯), the satisfaction relation ⊨ is inductively defined as follows.{a mathematical formula}</paragraph><paragraph>A formula ϕ is said to be true in {a mathematical formula}S(n¯), denoted {a mathematical formula}S(n¯)⊨ϕ, if {a mathematical formula}ι⊨ϕ. The customary abbreviations of truth and falsity are assumed: {a mathematical formula}⊤≜p∨¬p, {a mathematical formula}⊥≜p∧¬p, for some {a mathematical formula}p∈APi and {a mathematical formula}1≤i≤k. Further we define {a mathematical formula}Fϕ≜U(⊤,ϕ) with the usual meaning of “Eventually ϕ”, and {a mathematical formula}Gϕ≜R(⊥,ϕ) standing for “Always ϕ”.</paragraph></section><section label="3.2">Indexed {a mathematical formula}ACTL⁎K∖X<paragraph>To establish the correctness of a system irrespectively of the number of agents present, we express properties that reflect its parameterised nature. In other words, we are interested in expressing collective behaviours for the system under consideration; this interest corresponds, for example, to emergent behaviours[63] in swarm-based systems. Such properties are expressible by introducing indexed atomic propositions and indexed epistemic modalities. In particular, the atomic propositions and epistemic modalities appearing in a formula are indexed with variables instead of the identities of the concrete agents. Then, given an arbitrary concrete system, the variables in a formula are quantified over the concrete agents in the system. This gives an {a mathematical formula}ACTL⁎K∖X formula which can be evaluated on the concrete system by means of Definition 3.1.</paragraph><paragraph>Let {a mathematical formula}VAR=VAR1∪…∪VARk be the union of disjoint sets of variable symbols, where each {a mathematical formula}VARi is associated with role i, and recall that {a mathematical formula}AP1,…,APk are disjoint sets of atomic propositions, one for each template role. The state and path formulae of indexed {a mathematical formula}ACTL⁎K∖X are defined as the state and path formulae of {a mathematical formula}ACTL⁎K∖X, but built from template atomic propositions, and with each proposition {a mathematical formula}p∈APi and epistemic modality {a mathematical formula}Ki (note that only the template role is specified in {a mathematical formula}Ki) indexed by a variable {a mathematical formula}v∈VARi. The domain of a variable {a mathematical formula}v∈VARi appearing in a formula ϕ is defined by the concrete system on which ϕ is evaluated: if ϕ is evaluated on {a mathematical formula}S(n¯), then the potential set of values for v is {a mathematical formula}{1,…,n¯(i)}. We write {a mathematical formula}ϕ(v¯), where {a mathematical formula}v¯=(V1,…,Vk) is a k-tuple of sets of variables, to indicate that each of the variables {a mathematical formula}v∈Vi ({a mathematical formula}Vi⊆VARi) appears in an atomic proposition or epistemic modality in ϕ. We say that {a mathematical formula}ϕ(v¯) is an {a mathematical formula}m¯-indexed formula, where {a mathematical formula}m¯ is k-tuple of natural numbers, if {a mathematical formula}|Vi|=m¯(i), for all {a mathematical formula}1≤i≤k. The properties we use in the verification of PIIS are constructed in compliance with the following formula schema:{a mathematical formula} where ∀ is a universal quantifier over the variables. We denote such a formula by {a mathematical formula}∀v¯ϕ(v¯).</paragraph><paragraph>When evaluated on a concrete system, an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯) denotes a specific formula in {a mathematical formula}ACTL⁎K∖X corresponding to the conjunction of all ground instantiations of {a mathematical formula}∀v¯ϕ(v¯). Given a concrete system {a mathematical formula}S(n¯) ({a mathematical formula}n¯≥m¯){sup:1} and an injective function {a mathematical formula}ξi:Vi→{1,…,n¯(i)} for each agent template i, a ground instantiation of {a mathematical formula}∀v¯ϕ(v¯) is the {a mathematical formula}ACTL⁎K∖X formula obtained from {a mathematical formula}ϕ(v¯) by assigning to each variable {a mathematical formula}v∈Vi the value {a mathematical formula}ξi(v).</paragraph><paragraph>Using the above schema we may now express properties independently of the number of agents as the following examples illustrate.</paragraph><paragraph label="Example 3.2">In Section 2.3.1 we encoded the robot foraging scenario as a PIIS composed of a template agent TR representing the robots and a template agent TFS representing the food sources. TFS was built from two states expressing whether or not a food source has been found by a robot. Having modelled the scenario as a PIIS we are interested in checking the property: “whenever a food source is found, every robot knows that the source is found”. This property can be expressed by the following {a mathematical formula}(1,1)-indexed formula:{a mathematical formula} where u is variable of TR, x is a variable of TFS and the atomic proposition f holds in the template state in which the template food source is “Found”. When evaluated on a concrete system with 2 robots and 2 food sources {a mathematical formula}ϕRFS is a shortcut for the {a mathematical formula}ACTL⁎K∖X formula{a mathematical formula} We show how to check {a mathematical formula}ϕRFS against all possible concrete systems in Section 5.</paragraph><paragraph label="Example 3.3">In Section 2.3.2 we encoded the train-gate-controller as a PIIS composed of an agent template PT representing prioritised trains, an agent template representing NT representing normal trains, and a template environment representing the controller. A commonly used benchmark concerns assessing the correctness of the train-gate-controller against the property “whenever a train is in the tunnel, it knows that no other train is in the tunnel at the same time”. This property can be expressed in indexed {a mathematical formula}ACTL⁎K∖X by the following {a mathematical formula}(2,2)-indexed formula:{a mathematical formula} where {a mathematical formula}u,v are variables of PT, {a mathematical formula}x,y are variables of NT, the atomic proposition pt holds in the template states in which the template prioritised train is in the tunnel and the atomic proposition nt holds in the template states in which the template normal train is in the tunnel. We show how to check {a mathematical formula}ϕTGC against all possible concrete systems in Section 6.</paragraph><paragraph label="Example 3.4">In Section 2.3.3 we encoded the autonomous robot example as a PIIS composed of an agent template TR1 representing robots with access to a sensor, an agent template TR2 representing robots with no access to a sensor, and an environment template representing the environment moving the robots forward along the track. According to the scenario the goal of the robots is to halt in the goal region {a mathematical formula}{2,3,4} of the track. A solution to the problem in the single-robot case is for the robot to do nothing while the value of its sensor is less than 3 and to halt once the value of its sensor is greater than or equal to 3. We are interested to show the correctness of the autonomous robot solution in the unbounded case, i.e., whenever the robots halt, they know that they are in the goal region. This is expressed by the following {a mathematical formula}(1,1)-indexed formula:{a mathematical formula} where v is a variable of TR1, u is a variable of TR2, the atomic proposition {a mathematical formula}gr_1 ({a mathematical formula}gr_2, respectively) holds in the template states where the value of the position component of template robot 1 (template robot 2, respectively) is in {a mathematical formula}{2,3,4}, and the atomic proposition {a mathematical formula}h_1 ({a mathematical formula}h_2, respectively) holds in the template states where the template robot 1 (template robot 2, respectively) has halted. We show how to check {a mathematical formula}ϕAR against all possible concrete systems in Section 7.</paragraph></section><section label="3.3">Symmetry reduction for {a mathematical formula}ACTL⁎K∖X<paragraph>Consider an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯). As noted above, the evaluation of the formula on a concrete system {a mathematical formula}S(n¯) corresponds to evaluating the conjunction of all its ground instantiations. But the conjuncts are identical up to re-indexing of the agents' indices. Thus the symmetric nature of {a mathematical formula}∀v¯ϕ(v¯) suggests that its evaluation on a concrete system is equivalent to checking only one of its ground instantiations. The following Lemma, adapted from [64], shows precisely this by taking (for simplicity) the aforementioned ground formula to be the trivial instantiation. The trivial instantiation of {a mathematical formula}∀v¯ϕ(v¯), written {a mathematical formula}ϕ[trivial] is the ground formula resulting from assigning the values {a mathematical formula}{1,…,m¯(i)} to the variables appearing in each set of variables {a mathematical formula}Vi; i.e.; for an assignment {a mathematical formula}ξi defined as {a mathematical formula}ξi(v1)=1,…,ξi(|Vi|)=|Vi| for each agent template i, {a mathematical formula}ϕ[trivial] is the {a mathematical formula}ACTL⁎K∖X formula obtained from {a mathematical formula}∀v¯ϕ(v¯) by assigning to each variable {a mathematical formula}v∈Vi the value {a mathematical formula}ξi(v).</paragraph><paragraph label="Example 3.5">The following formulae are the trivial instantiations of {a mathematical formula}ϕRFS,ϕTGC and {a mathematical formula}ϕAR, respectively.{a mathematical formula}</paragraph><paragraph label="Lemma 3.6">Symmetry reductionGiven a PIIS{a mathematical formula}Scomposed of k roles, an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯)and{a mathematical formula}n¯≥m¯, we have that{a mathematical formula}S(n¯)⊨∀v¯ϕ(v¯)iff{a mathematical formula}S(n¯)⊨ϕ[trivial].</paragraph><paragraph label="Proof">For the left to right direction, suppose that {a mathematical formula}S(n¯)⊨∀v¯ϕ(v¯). As {a mathematical formula}∀v¯ϕ(v¯) expresses the conjunction of all its instantiations we have that {a mathematical formula}S(n¯)⊨ϕ[ξ1,…,ξk], where {a mathematical formula}ϕ[ξ1,…,ξk] is the ground formula obtained from any k-tuple of assignments {a mathematical formula}ξ1,…,ξk. Therefore {a mathematical formula}S(n¯)⊨ϕ[trivial].For the right to left direction, suppose that {a mathematical formula}S(n¯)⊨ϕ[trivial]. So for each {a mathematical formula}1≤i≤k the variables {a mathematical formula}v1,…,vm¯(i)∈Vi are mapped into the concrete agents {a mathematical formula}(i,1),…,(i,m¯(i)), respectively. Let {a mathematical formula}ξ¯=(ξ1,…,ξk) be an arbitrary assignment.For each {a mathematical formula}1≤i≤k, consider {a mathematical formula}ζi to be either a bijective mapping from natural numbers to natural numbers, or a bijective mapping from global states to global states, or a bijective mapping from actions to actions, or a bijective mapping from {a mathematical formula}ACTL⁎K∖X formulae to {a mathematical formula}ACTL⁎K∖X formulae, the exact mapping depending on the context.In the first case, define {a mathematical formula}ζi:{1,…,n¯(i)}→{1,…,n¯(i)} to be an arbitrary mapping.For the second case, recall that for a global state g, {a mathematical formula}lsij(g) returns the concrete local state of agent {a mathematical formula}(i,j) in g, and {a mathematical formula}tlsij(g) returns the template local state of agent {a mathematical formula}(i,j) in g. Then define {a mathematical formula}ζi:G(n¯)→G(n¯) by {a mathematical formula}ζi(g)=g′ iff {a mathematical formula}tlsij(g′)=tlsiζi−1(j)(g), for each {a mathematical formula}1≤j≤n¯(i), and {a mathematical formula}lsE(g′)=lsE(g). For example, if {a mathematical formula}k=1,n¯(1)=3 and {a mathematical formula}ζi:{1,2,3}→{1,2,3} if given by {a mathematical formula}{1→3,2→1,3→2}, then the state {a mathematical formula}((s,1),(t,2),(u,3),lE) is mapped to the state {a mathematical formula}((t,1),(u,2),(s,3),lE).Next define {a mathematical formula}ζi:(Acti1∪…∪Actin¯(i))→(Acti1∪…∪Actin¯(i)) as follows.<list>if {a mathematical formula}(a,j)∈Aij∪AEij is an asynchronous action or an agent-environment action of agent {a mathematical formula}(i,j), then {a mathematical formula}ζi((a,j))=(a,ζi(j));if {a mathematical formula}a∈RSi∪GS is a role-synchronous or a global-synchronous action of agent {a mathematical formula}(i,j), then {a mathematical formula}ζi(a)=a;if {a mathematical formula}(a,(j,r))∈MRi,q is a multi-role action of agent {a mathematical formula}(i,j) that is shared with an agent {a mathematical formula}(q,r), then {a mathematical formula}ζi((a,(j,r)))=(a,(ζi(j),ζq(r))).Finally define </list><paragraph>{a mathematical formula}ζi to map {a mathematical formula}ACTL⁎K∖X formulae to {a mathematical formula}ACTL⁎K∖X formulae by {a mathematical formula}ζi(ϕ)=ϕ′ iff {a mathematical formula}ϕ′ is obtained from ϕ by replacing each atomic proposition {a mathematical formula}(p,j)∈APi×{1,…,n¯(i)} with {a mathematical formula}(p,ζi(j)), and each epistemic modality {a mathematical formula}Kij with {a mathematical formula}Kiζi(j).Now consider {a mathematical formula}ζ=ζ1∘…∘ζk to be the composition of {a mathematical formula}ζ1,…,ζk. Then in compliance with the interleaved semantics, we have that {a mathematical formula}g→ag′ iff {a mathematical formula}ζ(g)→ζ(a)ζ(g′) and {a mathematical formula}g∼ijg′ iff {a mathematical formula}ζ(g)∼iζi(j)ζ(g′). Therefore by assumption we obtain {a mathematical formula}(S(n¯),ζ(ι(n¯)))⊨ζ(ϕ[trivial]). Hence {a mathematical formula}(S(n¯),ζ(ι(n¯)))⊨ϕ[ξ¯]. But as all concrete agents share a unique template local state in {a mathematical formula}ι(n¯), it follows that {a mathematical formula}ζ(ι(n¯))=ι(n¯). Consequently, {a mathematical formula}(S(n¯),ι(n¯))⊨ϕ[ξ¯]. As {a mathematical formula}ξ¯ was arbitrary, the latter concludes {a mathematical formula}S(n¯)⊨∀v¯ϕ(v¯).  □</paragraph></paragraph><paragraph>The above will enable us to reduce the size of the formulae to check when we introduce the parameterised model checking problem in Section 4.</paragraph></section><section label="3.4"><section-title>Stuttering simulations</section-title><paragraph>As noted above, cutoff techniques concern the identification of a cutoff, the number of agents in a concrete system that can be used to check whether a given property holds for all concrete systems. A notion of equivalence between the system instances is often used to show this result. Stuttering insensitive logics (i.e., logics without the next-time operator) are accompanied with the standard notion of stuttering simulation [65]. A system stuttering simulates another system if for every behaviour of the latter, there is a stuttering equivalent behaviour of the former. Informally, two behaviours are stuttering equivalent if the behaviours coincide when each sequence of stutter steps (i.e., steps that do not affect the labelling of the states) are collapsed onto a single step. Since we consider only universal path quantification, it follows that any {a mathematical formula}ACTL⁎∖X formula satisfied by the simulating model is also satisfied by the simulated model. We here define an epistemic variant of the notion of stuttering simulation between concrete systems. We show that similar systems preserve {a mathematical formula}ACTL⁎K∖X specifications. To do this, we fix throughout this section a PIIS {a mathematical formula}S of k roles and two concrete instantiations {a mathematical formula}S(n¯)=〈G(n¯),ι(n¯),R(n¯),(∼ij)(i,j)∈A(n¯),V(n¯)〉, {a mathematical formula}S(n¯′)=〈G(n¯′),ι(n¯′),R(n¯′),(∼ij)(i,j)∈A(n¯′),V(n¯′)〉 of {a mathematical formula}S.</paragraph><paragraph label="Definition 3.7">Stuttering simulationA relation {a mathematical formula}∼ss⊆G(n¯)×G(n¯′) is a stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′) if {a mathematical formula}ι(n¯)∼ssι(n¯′) and whenever {a mathematical formula}g∼ssg′ we have the following.</paragraph><list><list-item label="(i)">{a mathematical formula}V(n¯)(g)=V(n¯′)(g′);</list-item><list-item label="(ii)">If {a mathematical formula}g∼ijg1, then {a mathematical formula}g′∼ijg′1 for some {a mathematical formula}g′1 such that {a mathematical formula}g1∼ssg′1;</list-item><list-item label="(iii)">For every {a mathematical formula}π∈Π(g), there is a {a mathematical formula}π′∈Π(g′), a partition {a mathematical formula}B1,B2,… of the states in π, and a partition {a mathematical formula}B1′,B2′,… of the states in {a mathematical formula}π′ such that for each {a mathematical formula}j≥1, {a mathematical formula}Bj and {a mathematical formula}Bj′ are nonempty and finite, and every state in {a mathematical formula}Bj is related by {a mathematical formula}∼ss to every state in {a mathematical formula}Bj′.</list-item></list><paragraph>We say that a model {a mathematical formula}S(n¯′) stuttering simulates a model {a mathematical formula}S(n¯), denoted {a mathematical formula}S(n¯)≤ssS(n¯′), if there is a stuttering simulation relation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′). If {a mathematical formula}S(n¯)≤ssS(n¯′), then {a mathematical formula}S(n¯′)⊨ϕ implies that {a mathematical formula}S(n¯)⊨ϕ[13]. Following Lemma 3.6, since we will only be checking a concrete system against a formula's trivial instantiation, the above simulation conditions on the atomic propositions and epistemic modalities only need to refer to agents in {a mathematical formula}A(m¯). Therefore we relax the notion of stuttering simulation to one of {a mathematical formula}m¯-stuttering simulation.</paragraph><paragraph label="Definition 3.8">{a mathematical formula}m¯-stuttering simulationGiven {a mathematical formula}m¯∈Nk, an {a mathematical formula}m¯-stuttering simulation is a relation {a mathematical formula}∼m¯ss⊆G(n¯)×G(n¯′) ({a mathematical formula}n¯,n¯′≥m¯) between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′) if it is defined as in Definition 3.7, but replacing conditions (i) and (ii) with the following.</paragraph><list><list-item label="(i)">{a mathematical formula}V(n¯)(g)∩X=V(n¯′)(g′)∩X, where {a mathematical formula}X=⋃1≤i≤k{(p,j):p∈APi and 1≤j≤m¯(i)};</list-item><list-item label="(ii)">If {a mathematical formula}g∼ijg1, for {a mathematical formula}(i,j)∈A(m¯), then {a mathematical formula}g′∼ijg′1 for some {a mathematical formula}g′1 such that {a mathematical formula}g1∼m¯ssg′1.</list-item></list><paragraph>We say that a concrete system {a mathematical formula}S(n¯′){a mathematical formula}m¯-stuttering simulates a concrete system {a mathematical formula}S(n¯), denoted {a mathematical formula}S(n¯)≤m¯ssS(n¯′), if there is an {a mathematical formula}m¯-stuttering-simulation relation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′). The following shows that {a mathematical formula}m¯-indexed formulae are preserved under {a mathematical formula}m¯-stuttering simulation.</paragraph><paragraph label="Theorem 3.9">Let{a mathematical formula}S(n¯)≤m¯ssS(n¯′)for a given{a mathematical formula}m¯∈Nksuch that{a mathematical formula}n¯≥m¯,n¯′≥m¯. If{a mathematical formula}S(n¯′)⊨∀v¯ϕ(v¯), then{a mathematical formula}S(n¯)⊨∀v¯ϕ(v¯), for any{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯).</paragraph><paragraph label="Proof">Fix an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯). By Lemma 3.6 it suffices to show that {a mathematical formula}S(n¯′)⊨ϕ[trivial] implies {a mathematical formula}S(n¯)⊨ϕ[trivial]. Thus note that {a mathematical formula}ACTL⁎K∖X formulae are known to be preserved under stuttering simulation [13]. Then note that atomic propositions and epistemic modalities in {a mathematical formula}ϕ[trivial] refer only to agents in {a mathematical formula}A(m¯). The latter two observations entail {a mathematical formula}S(n¯)⊨ϕ([trivial]).  □</paragraph><paragraph>The result above will enable us to access the truth of a specification on an arbitrarily big system by checking it on a smaller system. To do this, however, only conditions (i) and (iii) of Definition 3.8 have to be considered. Indeed, as the following shows, in the context of fully symmetric parameterised systems, the notion of stuttering simulation preserving temporal formulae [65] and the notion of stuttering simulation preserving temporal-epistemic formulae [13] coincide.</paragraph><paragraph label="Proposition 3.10">Fix{a mathematical formula}m¯∈Nkand{a mathematical formula}n¯≥m¯,n¯′≥m¯. If{a mathematical formula}∼x⊆G(n¯)×G(n¯′)is a relation between{a mathematical formula}S(n¯)and{a mathematical formula}S(n¯′)that satisfies conditions (i) and (iii) ofDefinition 3.8, then{a mathematical formula}∼xis an{a mathematical formula}m¯-stuttering simulation between{a mathematical formula}S(n¯)and{a mathematical formula}S(n¯′).</paragraph><paragraph label="Proof">Suppose the LHS of the thesis. We show that {a mathematical formula}∼x is an {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′). By assumption on {a mathematical formula}∼x we only have to show simulation requirement ii. Let {a mathematical formula}g∼xg′ and suppose that {a mathematical formula}g∼ijg1 for some {a mathematical formula}(i,j)∈A(m¯). We show that there is a {a mathematical formula}g′1∈G(n′) with {a mathematical formula}g′∼ijg′1 and {a mathematical formula}g1∼xg′1. To show this, consider a path {a mathematical formula}π∈Π(ι(n¯)) such that {a mathematical formula}π(z)=g1 for some {a mathematical formula}z≥1. As {a mathematical formula}ι(n¯)∼xι(n¯′), there is a path {a mathematical formula}π′∈Π(ι(n¯′)) satisfying condition (iii) of {a mathematical formula}m¯-stuttering simulation. Thus {a mathematical formula}π(z)∼xπ′(z′) for some {a mathematical formula}z′≥1. Therefore {a mathematical formula}lsij(π(z))=lsij(π′(z′)) as {a mathematical formula}∼x satisfies condition (i) of {a mathematical formula}m¯-stuttering simulation. Consequently {a mathematical formula}g′∼ijπ′(z′). So {a mathematical formula}g′1=π′(z′) is as required. Since {a mathematical formula}(g,g′) was arbitrary we obtain {a mathematical formula}S(n¯)≤m¯ssS(n¯′).  □</paragraph></section></section><section label="4"><section-title>Parameterised model checking problem and MAS cutoffs</section-title><paragraph>We now proceed to state the parameterised model checking problem.</paragraph><paragraph label="Definition 4.1">Parameterised model checking problemGiven a PIIS {a mathematical formula}S and an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯), the parameterised model checking problem (PMCP) concerns establishing whether or not the following holds:{a mathematical formula} If the above holds, then {a mathematical formula}∀v¯ϕ(v¯) is said to be satisfied by {a mathematical formula}S and this is denoted by {a mathematical formula}S⊨∀v¯ϕ(v¯).</paragraph><paragraph>In other words, differently from the standard model checking problem, the PMCP involves establishing whether a specification is satisfied on an unbounded number of systems resulting from the instantiations of the agent templates. The problem is known to be undecidable in general [18]. Following this, restrictions are typically imposed on the systems or the properties to be checked thereby obtaining decidable fragments [16], [31], [46], [51].</paragraph><paragraph>In this paper we study the {a mathematical formula}SMR, {a mathematical formula}SGS, and {a mathematical formula}SFE classes of systems and for each of these we put forward a parameterised model checking procedure. The common theoretical notion underlying all three procedures is the concept of MAS cutoffs. This reflects the key observation that to solve the PMCP it is at times sufficient to consider a finite number (the cutoff) of concrete systems. While theoretically cutoff identification procedures seldomly provide complete approaches to the parameterised model checking problem, there is empirical evidence that errors often manifest themselves on small systems with a small number of participants [46], [47], [19], [16], [17], [49]. We now give a formal definition of MAS cutoffs, and we show that no cutoff-based model checking procedure exists in general. We will then focus our analysis on the {a mathematical formula}SMR, {a mathematical formula}SGS and {a mathematical formula}SFE classes of systems in Section 5, Section 6 and Section 7, respectively.</paragraph><paragraph>A cutoff for a system is the number of components that is sufficient to consider when evaluating a given specification.</paragraph><paragraph label="Definition 4.2">MAS cutoffGiven a PIIS {a mathematical formula}S composed of k roles and {a mathematical formula}m¯∈Nk, a k-tuple {a mathematical formula}c¯∈Nk is said to be a MAS cutoff if the following holds:{a mathematical formula} for any {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯). We say that {a mathematical formula}S admits a cutoff for {a mathematical formula}m¯-indexed formulae and we call {a mathematical formula}S(c¯) the cutoff system.</paragraph><paragraph>By definition, if a cutoff exists, then the PMCP can be reduced to model checking all concrete systems up to the cutoff system. However the following shows that cutoffs do not generally exist.</paragraph><paragraph label="Theorem 4.3">There are PIIS{a mathematical formula}Sthat admit no cutoff for 1-indexed formulae.</paragraph><paragraph label="Proof">We show that the PIIS {a mathematical formula}S specified in Fig. 7 does not admit a cutoff. {a mathematical formula}S is composed of one agent template that is defined on the agent-environment actions {a mathematical formula}a,b,d and the asynchronous action e. For contradiction suppose that {a mathematical formula}S admits a cutoff. Then there is a {a mathematical formula}c≥1 such that {a mathematical formula}S(c)⊨∀{v}ϕ({v}) iff {a mathematical formula}∀n≥c:S(n)⊨∀{v}ϕ({v}) for any 1-indexed formula {a mathematical formula}∀{v}ϕ({v}). We inductively construct an 1-indexed {a mathematical formula}γc such that {a mathematical formula}S(c)⊨γc and {a mathematical formula}S(c+1)⊭γc thereby contradicting our assumption.To do this let {a mathematical formula}p_ι,p_s,p_u and p_t be atomic propositions that are only true in templates states {a mathematical formula}ι,s,u and t, respectively. Now inductively define a string {a mathematical formula}δc as follows:<list>{a mathematical formula}δc=(p_ι,v) if {a mathematical formula}c=1;{a mathematical formula}δc=(p_ι,v)∧F((p_u,v)∧Fδc−1) if {a mathematical formula}c&gt;1.We now show that </list><paragraph>{a mathematical formula}S(c+1)⊭γc[{v→1}]. To do this we construct a path {a mathematical formula}π∈S(c+1) with {a mathematical formula}π⊨∀{v}δc[{v→1}] and {a mathematical formula}π⊭∀{v}G(¬(p_t,v))[{v→1}]. So consider the path{a mathematical formula} where {a mathematical formula}ι(c+1) is the initial global state in {a mathematical formula}S(c+1) and each {a mathematical formula}(x,i) is a concrete action of agent i. In the path, for {a mathematical formula}2≤i≤c, each sequence {a mathematical formula}(a,i)(d,1)(e,1) of actions corresponds to one loop of agent 1 through the cycle {a mathematical formula}(ι,u,ι); the suffix {a mathematical formula}(a,c+1)(b,1) results in agent 1 moving to state t. Thus {a mathematical formula}π⊨∀{v}δc[{v→1}]. However {a mathematical formula}π⊭∀{v}G(¬(p_t,v))[{v→1}]. Therefore {a mathematical formula}S(c+1)⊭γc[{v→1}]. Consequently {a mathematical formula}S(c+1)⊭γc.We have thus shown that {a mathematical formula}S does not admit a cutoff for 1-indexed formulae.  □</paragraph></paragraph><paragraph>Theorem 4.3 applies for the {a mathematical formula}SGS and {a mathematical formula}SMR classes of systems to give that cutoffs for these classes do not generally exist. Having established the negative result above, we now proceed to exploit some properties of the {a mathematical formula}SMR and {a mathematical formula}SGS classes. The properties follow the existence of a notion of simulation between the agent and environment templates. This assumption will enable us to devise a simple and efficient test to check whether cutoff exists for a given system and specification. We do this for the {a mathematical formula}SMR class in Section 5 and for the {a mathematical formula}SGS class in Section 6. In Section 7 we show that cutoffs always exist for {a mathematical formula}SFE systems.</paragraph></section><section label="5">Verifying {a mathematical formula}SMR systems<paragraph>Following the negative result on the existence of cutoffs in the general case, we now analyse each of the {a mathematical formula}SMR, {a mathematical formula}SGS and {a mathematical formula}SFE classes. For each of the subclasses we put forward a parameterised model checking procedure. We use the procedures to verify examples from the MAS literature in a parametric setting, including the robot foraging scenario (Section 2.3.1), the trains-gate-controller (Section 2.3.2) and the autonomous robot example (Section 2.3.3).</paragraph><paragraph>We begin with the {a mathematical formula}SMR class of systems defined on asynchronous, agent-environment and multi-role actions. Given Theorem 4.3 cutoffs do not generally exist for this class. However, we identify a notion of simulation, and show that the existence of this simulation between the agent and environment templates guarantees the existence of a cutoff, which we show how to calculate given a PIIS and a specification. This will enable us to define a model checking procedure which we will exemplify on the robot foraging scenario following a discussion on its applicability.</paragraph><section label="5.1"><section-title>Agent-environment simulation</section-title><paragraph>We introduce a notion of agent-environment simulation between the agent templates and the environment template. We fix a PIIS {a mathematical formula}S=〈T,E,V〉 composed of k agent templates {a mathematical formula}T={Ti=〈Li,ιi,Acti,Pi,ti〉:1≤i≤k} and an environment template {a mathematical formula}E. For a template {a mathematical formula}Ti we write {a mathematical formula}l⇢al′ to mean that {a mathematical formula}ti(l,a)=l′. Given a set of template actions {a mathematical formula}X⊆Acti we let {a mathematical formula}l⇢Xl′ to denote that {a mathematical formula}l⇢al′ for some {a mathematical formula}a∈X. The reflexive and transitive closure of {a mathematical formula}⇢X is denoted by {a mathematical formula}⇢X⁎. In a similar manner, for a concrete system {a mathematical formula}S(n¯)=〈G(n¯),ι(n¯),R(n¯),(∼ij)(i,j)∈[n],V(n¯)〉 we write {a mathematical formula}g→ag′ to denote that {a mathematical formula}(g,g′)∈R(n¯) by means of action a. For a set of actions {a mathematical formula}X⊆⋃(i,j)∈A(n¯)Actij, {a mathematical formula}g→Xg′ expresses that {a mathematical formula}g→ag′ for an action {a mathematical formula}a∈X. The reflexive and transitive closure of {a mathematical formula}→X is denoted by {a mathematical formula}→X⁎. To simplify our analysis in the following we assume without loss of generality that for each action {a mathematical formula}a∈ActE we have that {a mathematical formula}|{l∈LE:a∈PE(l)}|=1; i.e., an environment's action is enabled at exactly one template state. Note that any PIIS can be translated into a PIIS for which each action of the environment is enabled at exactly one template state. The translation is given in two steps.</paragraph><list><list-item label="1.">Replace each template transition {a mathematical formula}lE⇢alE′ of the environment template with {a mathematical formula}lE⇢(lE,a)lE′, where {a mathematical formula}(lE,a) is a fresh action of the same type with a.</list-item><list-item label="2.">Replace each template transition {a mathematical formula}l⇢al′ of an agent template with the set of transitions {a mathematical formula}X={l⇢(lE,a)l′:(lE,a) is an action introduced in step 1 } iff {a mathematical formula}X≠∅.</list-item></list><paragraph> It is easy to see that a PIIS {a mathematical formula}S and its translation {a mathematical formula}S′ given above are equivalent in that every concrete system {a mathematical formula}S(n¯) can simulate {a mathematical formula}S′(n¯) and vice versa. {a mathematical formula}S′ is bigger than {a mathematical formula}S by a polynomial factor in the number of transitions of the environment template.</paragraph><paragraph>Intuitively, the existence of an agent-environment simulation between the agent and environment templates restricts the environment to one of shared resources, where each resource is accessible by exactly one agent at a given time. Formally, there is an agent-environment simulation between agent template {a mathematical formula}Ti and {a mathematical formula}E if {a mathematical formula}E can simulate {a mathematical formula}Ti only by means of the template states in which an action shared with the environment is enabled (see Fig. 8).{sup:2}</paragraph><paragraph label="Definition 5.1">Agent-environment simulationA relation {a mathematical formula}∼aes⊆Li×LE is an agent-environment simulation between {a mathematical formula}Ti and {a mathematical formula}E if {a mathematical formula}ιi∼aesιE and whenever {a mathematical formula}li∼aeslE the following condition holds: if {a mathematical formula}li⇢Ai⁎li′⇢ali″, for some {a mathematical formula}a∈AEi∪MRi∪GS, then there is {a mathematical formula}lE′ with {a mathematical formula}lE⇢alE′ and {a mathematical formula}li″∼aeslE′.</paragraph><paragraph>We write {a mathematical formula}Ti≤aesE to denote that there is an agent-environment simulation between {a mathematical formula}Ti and {a mathematical formula}E. We write {a mathematical formula}T≤aesE if {a mathematical formula}Ti≤aesE for all {a mathematical formula}Ti∈T. Intuitively, if {a mathematical formula}T≤aesE, then an agent can always take the lock on a resource by synchronising with the environment via an agent-environment or a multi-role action. As we show below, following this synchronisation the agent is the only agent that may synchronise with the environment. The agent releases the resources whenever the environment performs a loop in which case other agents can synchronise with the environment.</paragraph><paragraph label="Definition 5.2">Environment loopA subsequence {a mathematical formula}giai…gj, {a mathematical formula}j&gt;i&gt;0, of a path {a mathematical formula}g1a1… in {a mathematical formula}S(n¯) is an environment loop if {a mathematical formula}lsE(gi)=lsE(gj).</paragraph><paragraph>So if {a mathematical formula}T≤aesE, then the concrete environment conforms to a certain looping behaviour whenever it synchronises between different agents. As we show below, an environment loop occurs whenever the environment synchronises between two different agents in successive synchronisations. If g is a global state occurring in a path from the first synchronisation to the latter, then we say that g has the environment loop condition.</paragraph><paragraph label="Definition 5.3">Environment loop conditionA global state {a mathematical formula}π(d) in a path π in {a mathematical formula}S(n¯) has the environment loop condition, denoted {a mathematical formula}ELC(π(d)), if there is a pair of agents {a mathematical formula}(i,r) and {a mathematical formula}(j,q) with {a mathematical formula}(i,r)≠(j,q) such that the following hold:</paragraph><list><list-item label="(i)">{a mathematical formula}π(e)→Xπ(e+1)→Y⁎π(d), where {a mathematical formula}e&lt;d, {a mathematical formula}X=AEir∪MRir and {a mathematical formula}Y=⋃(x,y)∈A(n¯)Axy;</list-item><list-item label="(ii)">{a mathematical formula}π(d)→Y′⁎π(e′−1)→X′π(e′), where {a mathematical formula}e′&gt;d, {a mathematical formula}X′=AEjq∪MRjq and {a mathematical formula}Y′=⋃(x,y)∈A(n¯)Axy.</list-item></list><paragraph>In other words a global state g in a path π has the environment loop condition if: (i) there is an agent who lastly synchronised with the environment earlier in the path; (ii) there is a different agent who firstly synchronised with the environment later in the path (see Fig. 9).</paragraph><paragraph label="Example 5.4">Consider the following path of the concrete Train-Gate-Controller with two prioritised trains and two normal trains (Fig. 5).{a mathematical formula} The states {a mathematical formula}(A1,W2,PG,L1,L2) and {a mathematical formula}(A1,A2,PG,L1,L2) have the environment loop condition, whereas the other states do not.</paragraph><paragraph>We now show that the environment loop condition is a sufficient condition for the occurrence of an environment loop. Specifically, we show that whenever {a mathematical formula}ELC(g) holds, the environment's local state in g is equal to its initial local state. Thus, intuitively, whenever {a mathematical formula}ELC(g) holds, an agent releases the lock on a shared resource to a different agent.</paragraph><paragraph label="Lemma 5.5">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SMRwith{a mathematical formula}T≤aesEand a path π in{a mathematical formula}S(n¯). If{a mathematical formula}ELC(π(d))for some{a mathematical formula}d&gt;1, then{a mathematical formula}[d]πis an environment loop.</paragraph><paragraph label="Proof">Assume that {a mathematical formula}ELC(π(d)) for some {a mathematical formula}d&gt;1. This means that there is a pair of agents {a mathematical formula}(i,i′),(j,j′) with {a mathematical formula}(i,i′)≠(j,j′) such that agent {a mathematical formula}(i,i′) is the last agent to synchronise with the environment in the prefix {a mathematical formula}[d]π of π, and agent {a mathematical formula}(j,j′) is the first agent to synchronise with the environment in the suffix {a mathematical formula}π[d] of π. We show that {a mathematical formula}lsE(π(1))=lsE(π(d)) by induction on d.Suppose {a mathematical formula}d=2. Consider the template action a from which the concrete action {a mathematical formula}π(1,Act) has been instantiated. Observe that {a mathematical formula}a∈AEi∪MRi. Therefore {a mathematical formula}tlsjj′(π(1))⇢Aj⁎tlsjj′(π(d′−1))⇢atlsjj′(π(d′)) for some {a mathematical formula}d′≥2. As {a mathematical formula}T≤aesE, the latter gives {a mathematical formula}lsE(π(1))⇢alE′ for a template state {a mathematical formula}lE′ with {a mathematical formula}tlsjj′(π(d′))∼aeslE′. Since the set {a mathematical formula}{l∈LE:a∈PE(l)} is singleton, it follows that {a mathematical formula}lsE(π(1))=lsE(π(d′−1)). Additionally, {a mathematical formula}lsE(π(2))=lsE(π(d′−1)) as the subsequence {a mathematical formula}π(d),…,π(d′−1) of π does not contain agent-environment or multi-role actions. Therefore {a mathematical formula}lsE(π(1))=lsE(π(2)). So the claim is true of paths with two states. Suppose that it is true for all paths with at most {a mathematical formula}x−1 states for {a mathematical formula}x≥3. Let π be a path with x states. We show that {a mathematical formula}lsE(π(1))=lsE(π(x)) in terms of two cases.Case 1: {a mathematical formula}[x]π does not contain any {a mathematical formula}AEjj′ action or any {a mathematical formula}MRjj′ action. In this case we can proceed with the same argument used in the base step and conclude that {a mathematical formula}lsE(π(1))=lsE(π(x)).Case 2: {a mathematical formula}[d]π contains an {a mathematical formula}AEjj′ action or an {a mathematical formula}MRjj′ action. Let q be the greatest integer in {a mathematical formula}{1,…,x} with {a mathematical formula}π(q−1,Act)∈AEjj′∪MRjj′. From {a mathematical formula}Tj≤aesE we obtain that there is template state {a mathematical formula}lE such that {a mathematical formula}tlsjj′(π(q))∼aeslE. For this state we have {a mathematical formula}lE=lsE(π(q)) since {a mathematical formula}π(q−1,Act) is enabled by the environment's protocol at exactly one template state. Therefore {a mathematical formula}tlsjj′(π(q))∼aeslsE(π(q)). From the latter observation and the observation that {a mathematical formula}tlsjj′(π(q))⇢Aj⁎tlsjj′(π(d′−1)) for some {a mathematical formula}d′≥x, the base step's argument applies to conclude that {a mathematical formula}lsE(π(q))=lsE(π(x)). It is left to show that {a mathematical formula}[q]π is an environment loop thereby showing that {a mathematical formula}[x]π is an environment loop. To show this, note that there is an agent {a mathematical formula}(r,r′)≠(j,j′) which either performs an agent-environment or a multi-role action in the path sequence {a mathematical formula}π(q),…,π(x). Therefore {a mathematical formula}ELC(π(q)). So {a mathematical formula}lsE(π(1))=lsE(π(q)) holds by the inductive hypothesis.  □</paragraph><paragraph>The above lemma reports a key consequence of the agent-environment simulation assumption. This will be central to the behavioural equivalence results shown in the next section. Lemma 5.5 can be interpreted as stating that the environment implements a mutual exclusion controller governing the access to shared resources.</paragraph></section><section label="5.2">Model checking procedure for {a mathematical formula}SMR systems<paragraph>The model checking procedure Check_{a mathematical formula}SMR for {a mathematical formula}SMR systems is defined by Algorithm 1. Given a PIIS {a mathematical formula}S∈SMR and an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯), the procedure first establishes whether or not {a mathematical formula}T≤aesE. Upon a successful simulation test the procedure calculates the cutoff for the given system and specification.</paragraph><paragraph>The cutoff function {a mathematical formula}cutoff_SMR maps a PIIS {a mathematical formula}S of k roles and a k-tuple {a mathematical formula}m¯ of natural numbers into a k-tuple {a mathematical formula}c¯ of natural numbers that corresponds to the cutoff for {a mathematical formula}m¯-indexed formulae. Intuitively, to calculate a cutoff, we require that each agent in the cutoff system, referred to by the atomic propositions and epistemic modalities in the trivial instantiation of an {a mathematical formula}m¯-indexed formula, is able to make any transition that the agent can make in any bigger system. This will enable us to establish that the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system. By Theorem 3.9 we can then conclude that if the cutoff system satisfies a formula then the formula is satisfied by every bigger system.</paragraph><paragraph>Consider an agent {a mathematical formula}(i,j) indexing an atomic proposition or an epistemic modality in the trivial instantiation of an {a mathematical formula}m¯-indexed formula and a transition by means of a multi-role action of agent {a mathematical formula}(i,j) that is guarded by agent {a mathematical formula}(r,q). As discussed in Section 2.2, the enabling of the action depends on whether or not the action is enabled by the protocols at the current local states of the agents and the environment. If the action is enabled, then the agent {a mathematical formula}(i,j) may update its state upon performing the action, whereas the agent {a mathematical formula}(r,q) remains in its current local state. Obviously, agent {a mathematical formula}(r,q) may not be present in cutoff system, as the index q can be arbitrarily large. Still, we can simulate the transition in the cutoff system by insisting on the presence of an agent, say {a mathematical formula}(r,q′), in the local state of agent {a mathematical formula}(r,q). Then, the instantiation of the multi-role action that is shared between the agents {a mathematical formula}(i,j) and {a mathematical formula}(r,q′) is enabled, and so the agent {a mathematical formula}(i,j) is able to simulate the transition of the bigger system by performing said instantiation. To simulate any multi-role action performed by agent {a mathematical formula}(i,j), we insist on the presence of an agent in every local state enabling a multi-role action. In other words, for each agent template, in addition to the number of agents that need to be simulated, we require that the cutoff system composes as many agents as the cardinality of the set of template states that enable a multi-role action guarded by the template. We call this set the action dependency set of the template.</paragraph><paragraph label="Definition 5.6">Action dependency setGiven a PIIS {a mathematical formula}S=〈T,E,V〉∈SMR, the action dependency set{a mathematical formula}Di⊆Li of an agent template {a mathematical formula}Ti is a subset of template {a mathematical formula}Ti's states that is defined as follows:{a mathematical formula}</paragraph><paragraph>So, each action dependency set {a mathematical formula}Di reflects the states of template {a mathematical formula}Ti that enable at least one multi-role action shared with another template. The cutoff function is defined in terms of {a mathematical formula}m¯ and the action dependency sets for the agent templates.</paragraph><paragraph label="Definition 5.7">Cutoff function for {a mathematical formula}SMR systemsThe cutoff function{a mathematical formula}cutoff_SMR is defined for {a mathematical formula}SMR systems as follows:{a mathematical formula} for any {a mathematical formula}S∈SMR with {a mathematical formula}k≥1 roles and any {a mathematical formula}m¯≥Nk.</paragraph><paragraph>Following the cutoff calculation, Check_{a mathematical formula}SMR checks the set {a mathematical formula}{S(x¯):m¯≤x¯≤c¯} of concrete systems against the trivial instantiation {a mathematical formula}ϕ[trivial] of {a mathematical formula}∀v¯ϕ(v¯). If {a mathematical formula}ϕ[trivial] is not satisfied by at least one system, then the procedure returns false, otherwise it returns true. We assess the soundness of the Check_{a mathematical formula}SMR procedure in Section 5.4. First, we exemplify it by means of the robot foraging scenario.</paragraph></section><section label="5.3"><section-title>Verifying the robot foraging scenario</section-title><paragraph>In Section 2.3.1 we represented the robot foraging scenario as a PIIS {a mathematical formula}SRFS composed of an agent template TR encoding the robots and an agent template TFS encoding the food sources. In Section 3.2 we expressed the property “whenever a food source is found, every robot knows that the source is found” in the following {a mathematical formula}(1,1)-indexed formula:{a mathematical formula} where u is variable of TR, x is a variable of TFS and the atomic proposition f holds in the template state in which the template food source is “Found”.</paragraph><paragraph>Observe that model checking {a mathematical formula}SRFS against {a mathematical formula}ϕRFS amounts to checking each concrete system {a mathematical formula}SRFS(n¯) for any {a mathematical formula}n¯≥(1,1). Since the number of systems involved is unbounded the problem cannot be solved by traditional model checking techniques. In contrast, we now show how {a mathematical formula}SRFS can be verified using the Check_{a mathematical formula}SMR procedure.</paragraph><paragraph>Clearly {a mathematical formula}SRFS satisfies the agent-environment simulation assumption as the system does not specify an environment template. Therefore we may proceed to compute the cutoff function {a mathematical formula}cutoff_SMR(SRFS,(1,1)). To do this we first calculate the action dependency sets. We have that {a mathematical formula}DTR={MF} and {a mathematical formula}DTFS={N_F,F} for TR and TFS, respectively. Hence,{a mathematical formula} Thus, we need to check whether or not {a mathematical formula}SRFS(x¯)⊨ϕRFS[trivial], for {a mathematical formula}(1,1)≤x¯≤(2,3). These checks can be performed on a standard model checker; the result is true thereby establishing the correctness of the protocol irrespectively of the number of robots and the number of food sources.</paragraph></section><section label="5.4">Soundness of the Check_{a mathematical formula}SMR procedure<paragraph>We can now assess the soundness of the Check_{a mathematical formula}SMR procedure.</paragraph><paragraph label="Theorem 5.8">Given{a mathematical formula}S=〈T,E,V〉∈SMRand an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯), if{a mathematical formula}T≤aesE, thenCheck_{a mathematical formula}SMR(S,∀v¯ϕ(v¯))returns true iff{a mathematical formula}S⊨∀v¯ϕ(v¯).</paragraph><paragraph>To prove this result we need to establish some intermediate steps. Firstly observe that by the definition of the PMCP and Theorem 3.9, it suffices to show that if {a mathematical formula}T≤aesE, then: (i) the cutoff system {a mathematical formula}S(c¯){a mathematical formula}m¯-stuttering simulates every bigger system; (ii) every bigger system {a mathematical formula}m¯-stuttering simulates {a mathematical formula}S(c¯). As related states in each of the simulations need only to agree on the atomic propositions indexed by the agents in {a mathematical formula}A(m¯), we only have to simulate transitions taken by the agents in {a mathematical formula}A(m¯). We first show the former.</paragraph><section label="5.4.1">Part A: the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system<paragraph>Consider an arbitrarily big system {a mathematical formula}S(n¯) with {a mathematical formula}n¯≥c¯, where {a mathematical formula}S(c¯) is the cutoff system. To simulate {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) first executes the action dependency path. The path results in an agent to be in every local state enabling a multi-role action. Following the execution of the action dependency path, {a mathematical formula}S(c¯) can simulate the multi-role transitions of {a mathematical formula}S(n¯) in the way described earlier. More specifically, the action dependency path associates the concrete agents in {a mathematical formula}A(c¯)∖A(m¯) with the action dependency sets as follows. Let {a mathematical formula}λi:Di→{(i,m¯(i)+1),…,(i,c¯(i))} be a bijective mapping from the set {a mathematical formula}Di of template states to the set {a mathematical formula}{(i,m¯(i)+1),…,(i,c¯(i))} of concrete agents. Given {a mathematical formula}l∈Di, {a mathematical formula}λi(l) denotes the concrete agent of role i which moves to template state l via the execution of the action dependency path. Then, each agent {a mathematical formula}(i,j)∈A(c¯)∖A(m¯) remains forever in its corresponding state {a mathematical formula}λi−1((i,j)). Thus, {a mathematical formula}S(c¯) can mimic the multi-role transitions of the agents in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯) as follows: for each multi-role action {a mathematical formula}(b,(r,q))∈MRi,jr,q shared by the agents {a mathematical formula}(i,r)∈A(m¯),(j,q)∈A(n¯) that is performed at a global state g in {a mathematical formula}S(n¯), the multi-role action {a mathematical formula}(b,(r,q′)) shared by the agents {a mathematical formula}(i,r) and {a mathematical formula}(j,q′), where {a mathematical formula}q′=λj(tlsjq(g)) is performed in {a mathematical formula}S(c¯).</paragraph><paragraph>We now give a formal definition of the action dependency path described above. The path is inductively defined so that at each step an agent {a mathematical formula}(i,j)∈A(c¯)∖A(m¯) moves to its associated state {a mathematical formula}λi−1((i,j)). Following Lemma 5.5, however, the definition insists on the occurrence of an environment loop at each step. If an agent cannot move to its associated state while the environment performs an environment loop, then said agent remains in its initial state. This is because the environment is locked on synchronising with exactly one agent unless an environment loop occurs.</paragraph><paragraph label="Definition 5.9">Action dependency pathLet {a mathematical formula}S=〈T,E,V〉∈SMR be a PIIS of k roles. Consider {a mathematical formula}D=D1∪…∪Dk to be the union of the action-dependency sets. For a global state g, assume {a mathematical formula}D(g)={l∈D:there is an agent (i,r) with tlsir(g)=l} to be the set of template states in D that appear in g. Then, for {a mathematical formula}m¯∈Nk and {a mathematical formula}c¯=cutoff_SMR(S,m¯), the action dependency path{a mathematical formula}p in {a mathematical formula}S(c¯) is inductively defined as follows.</paragraph><list><list-item label="•">{a mathematical formula}p0=ι(c¯);</list-item><list-item label="•">Let {a mathematical formula}X⊆Π(pi[]) be a set of finite paths such that {a mathematical formula}π∈X if and only if π satisfies the following conditions.<list>π is an environment loop;{a mathematical formula}D(π[])=D(pi[])∪{l} for some {a mathematical formula}l∈D∖D(pi[]);Every action occurring in π is in {a mathematical formula}Ajq∪AEjq∪MRjq, where {a mathematical formula}(j,q) is the agent associated with l.If </list><paragraph>{a mathematical formula}X=∅, then {a mathematical formula}pi+1=pi. Otherwise, {a mathematical formula}pi+1=pi∘π for an arbitrary {a mathematical formula}π∈X.</paragraph></list-item></list><paragraph label="Example 5.10">Consider the robot forging scenario discussed in Section 5.3, where the action dependency sets were calculated to be {a mathematical formula}DTR={MF} for the template robot, and {a mathematical formula}DTFS={N_F,F} for the template food source. The cutoff was shown to be {a mathematical formula}c¯=(2,3) for {a mathematical formula}(1,1)-indexed formulae. We now construct the action dependency path. To do this, we first associate the concrete agents with the action dependency sets by the mappings:{a mathematical formula} So, the concrete robot 2 is associated with the state MF, the concrete food source 2 is associated with the state N_F, and the concrete food source 3 is associated with the state F. For the base step we have that {a mathematical formula}p0=ι(c¯), where {a mathematical formula}ι(c¯)=((R,1),(R,2),(N_F,1),(N_F,2),(N_F,3)) is the initial global state that denotes the concrete local states {a mathematical formula}(R,1),(R,2) of concrete robots 1 and 2, and the concrete local states {a mathematical formula}(N_F,1),(N_F,2),(N_F,3) of concrete food sources 1,2, and 3. Clearly, the agent {a mathematical formula}(TFS,2) is already in its associated state N_F in {a mathematical formula}ι(c¯). Now assume the path{a mathematical formula} It follows that π is an environment loop. Also, {a mathematical formula}D(π[])=D(p0[])∪{MF}, where {a mathematical formula}MF∈D∖D(p0[]). Additionally, every action in π is in {a mathematical formula}ATR2∪AETR2∪MRTR2. Thus, π satisfies all three conditions of Definition 5.9. So, {a mathematical formula}p1=π. For the next step, consider the path{a mathematical formula} Obviously, {a mathematical formula}π′ is an environment loop. Also, {a mathematical formula}D(π′[])=D(p1[])∪{F}, where {a mathematical formula}F∈D∖D(p1[]). Additionally, every action in {a mathematical formula}π′ is in {a mathematical formula}ATFS3∪AETR3∪MRTR3. Therefore, {a mathematical formula}p2 is equal to the following:{a mathematical formula}As {a mathematical formula}D(p2)=D, {a mathematical formula}p2 is the required action dependency path.</paragraph><paragraph>In other words, every template state in D that can be reached by an agent via an environment loop is a local state for an agent in {a mathematical formula}p[]. Moreover, there is no global state g in any bigger system satisfying the environment loop condition and also satisfying {a mathematical formula}D(g)⊄D(p[]). So, {a mathematical formula}S(c¯) can simulate the multi-role transitions of the agents in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯) with the execution of the action dependency path. Other types of actions are simulated as follows. For an agent-environment or an asynchronous action performed by the agents in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) performs the same action. Finally, for any type of action performed by an agent not in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) performs the null action. This implies that the state of the environment in {a mathematical formula}S(n¯) may change, whereas the state of the environment in {a mathematical formula}S(c¯) remains the same. However, the environment in {a mathematical formula}S(c¯) is not blocked from synchronising with an agent in {a mathematical formula}A(m¯) at a later point. For example, assume the path {a mathematical formula}g1a1g2…ax−1gx in {a mathematical formula}S(n¯), where {a mathematical formula}a1,ax−1∈⋃(i,j)∈A(m¯)AEij and {a mathematical formula}a2,…,ax−2∉⋃(i,j)∈A(m¯)Aij∪AEij∪MRij. Clearly the state of the environment in {a mathematical formula}S(n¯) may be updated after the environment synchronises on the {a mathematical formula}a2,…,ax−2 actions. Even so, the environment in {a mathematical formula}S(c¯) may still synchronise on the {a mathematical formula}ax−1 action after performing the null actions. This is because both {a mathematical formula}g2 and {a mathematical formula}gx−1 satisfy the environment loop condition. Therefore, the state of the environment in {a mathematical formula}g2 is the same to its state in {a mathematical formula}gx−1. Intuitively, whenever an agent not in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯) takes the lock on a resource via synchronising with the environment, it has to release the resource via the occurrence of an environment loop before an agent in {a mathematical formula}A(m¯) can take the lock on a resource.</paragraph><paragraph label="Lemma 5.11">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SMRof k roles with{a mathematical formula}T≤aesEand{a mathematical formula}m¯∈Nk. Then,{a mathematical formula}S(n¯)≤m¯ssS(c¯)for all{a mathematical formula}n¯≥c¯, where{a mathematical formula}c¯=cutoff_SMR(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯ be arbitrary. We show that {a mathematical formula}S(n¯)≤m¯ssS(c¯). The simulation relation we define follows Fig. 10. This ensures that whenever an action is performed by an agent in {a mathematical formula}S(n¯) that is required to satisfy condition (i) of {a mathematical formula}m¯-stuttering simulation, the agent can also perform the action in {a mathematical formula}S(c¯). In line with this, the state of the environment is defined to allow the actions to be performed. The simulation relation {a mathematical formula}∼m¯ss=(R1∩R2∩R3)∪R4⊆G(n¯)×G(c¯) is defined as follows.{a mathematical formula} The above ensures that the local states of the agents in {a mathematical formula}A(m¯) are the same in the related global states of {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯). The following ensures that the agents in {a mathematical formula}A(c¯)∖A(m¯) in {a mathematical formula}S(c¯) are in their associated local states as per the action dependency path.{a mathematical formula}{a mathematical formula}(R1∩R2)-related states must also agree on the state of the environment. Assume {a mathematical formula}(g,g′)∈G(n¯)×G(c¯). Suppose that there is a state {a mathematical formula}g1 reachable from g at which an agent-environment or a multi-role action of the agents in {a mathematical formula}A(m¯) is enabled. Clearly for the action to be enabled, the environment is in a local state at which the environment's protocol enables the action. Further assume that {a mathematical formula}g1 can be reached by asynchronous actions and by actions of agents not in {a mathematical formula}A(m¯). As previously discussed, {a mathematical formula}S(c¯) simulates these actions by performing asynchronous and null actions. These do not change the state of the environment in {a mathematical formula}S(c¯). So, we define {a mathematical formula}R3 to insist on the equality of the environment's states in g and {a mathematical formula}g1 as {a mathematical formula}S(c¯) simulates the agent-environment or the multi-role action enabled at {a mathematical formula}g1 by performing the same action.{a mathematical formula} Finally, to simulate the multi-role action in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) first executes the action dependency path. {a mathematical formula}R4 suggests exactly this.{a mathematical formula}We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯). As {a mathematical formula}ι(c¯)=p(1), we have that {a mathematical formula}(ι(n¯),ι(c¯))∈R4, therefore {a mathematical formula}ι(n¯)∼m¯ssι(c¯). Now assume that {a mathematical formula}g∼m¯ssg′ for an arbitrary pair of global states in {a mathematical formula}G(n¯)×G(c¯). We show the simulation requirements (i) and (iii). We have that {a mathematical formula}(g,g′)∈R1∩R2∩R3 or {a mathematical formula}(g,g′)∈R4. The first simulation requirement follows trivially by the definition of {a mathematical formula}R1 and by observing that each agent in {a mathematical formula}A(m¯) remains in its initial local state in {a mathematical formula}p.To show the simulation requirement (iii), let {a mathematical formula}π∈Π(g). We inductively construct a path {a mathematical formula}π′∈Π(g′) as required by the {a mathematical formula}m¯-stuttering-simulation.For the base step, we have two cases:<list>{a mathematical formula}(g,g′)∈R4. Then, there is a {a mathematical formula}q≥1 such that {a mathematical formula}g′=p(q). Consider {a mathematical formula}π′=p[q]. Define the first blocks {a mathematical formula}B1,B1′ by {a mathematical formula}B1=g and {a mathematical formula}B1′=p(q),p(q+1),…,p[]. {a mathematical formula}B1,B1′ are as required: for each x in {a mathematical formula}B1′, {a mathematical formula}g∼m¯ssx, since {a mathematical formula}(g,x)∈R4.{a mathematical formula}(g,g′)∉R4. In this case, define {a mathematical formula}π′=g′, {a mathematical formula}B1=g, and {a mathematical formula}B1′=g′.For the inductive step, assume that we have already constructed a prefix </list><paragraph>{a mathematical formula}[x]π, a prefix {a mathematical formula}[x′]π′, and a partition of the states in {a mathematical formula}[x]π and {a mathematical formula}[x′]π′ into corresponding blocks. We now define {a mathematical formula}[x′+1]π′ and the next blocks {a mathematical formula}Bx and {a mathematical formula}Bx′ by considering cases on the type of the action {a mathematical formula}π(x,Act).</paragraph><list><list-item label="•">if {a mathematical formula}π(x,Act)∈Air∪AEir for {a mathematical formula}(i,r)∈A(m¯), then {a mathematical formula}π′(x′,Act)=π(x,Act).</list-item><list-item label="•">if {a mathematical formula}π(x,Act)=(a,(r,q))∈MRi,jr,q for {a mathematical formula}(i,r)∈A(m¯), {a mathematical formula}(j,q)∈A(n¯), then {a mathematical formula}π′(x′,Act)=(a,(r,q′)), where {a mathematical formula}q′=λj(tlsjq(π(x)));</list-item><list-item label="•">Otherwise, {a mathematical formula}π′(x′,Act)=ϵ.</list-item></list><paragraph>Let {a mathematical formula}Bx=π(x+1) and {a mathematical formula}Bx′=π′(x′+1). We have to show that {a mathematical formula}π′(x′)→π′(x′,Act)π′(x′+1) is a valid transition. The case follows trivially when {a mathematical formula}π′(x′,Act) is an asynchronous action or when {a mathematical formula}π′(x′,Act) is the joint null action. If {a mathematical formula}π′(x′,Act) is an agent-environment action, then we have to show that the state of the environment enables the action in {a mathematical formula}π′(x′). If {a mathematical formula}π′(x′,Act) is a multi-role action, say {a mathematical formula}π′(x′,Act)=(a,(r,q′))∈MRi,jr,q′, then we additionally have to show that the state of the agent {a mathematical formula}(j,q′) enables the action as well. So, it suffices to show the case for multi-role actions. That is, we need to show: (i) {a mathematical formula}a∈PE(lE), where {a mathematical formula}lE=lsE(π′(x′)); (ii) {a mathematical formula}a∈Pj(l), where {a mathematical formula}l=tlsjq′(π′(x′)). We show the former by means of two cases.</paragraph><list><list-item label="1.">There is a y with {a mathematical formula}1≤y≤x−1 such that {a mathematical formula}π(y,Act)∈⋃(i,r)∈A(m¯)AEir∪MRir. Let z be the greatest integer with {a mathematical formula}1≤z≤x−1 that satisfies {a mathematical formula}π(z,Act)∈⋃(i,r)∈A(m¯)AEir∪MRir. By construction of {a mathematical formula}π′ there is a greatest {a mathematical formula}z′ with {a mathematical formula}1≤z′≤x′−1 that satisfies {a mathematical formula}π′(z′,Act)∈⋃(i,r)∈A(m¯)AEir∪MRir. Since {a mathematical formula}π(z,Act)=π′(z′,Act), it follows that {a mathematical formula}lsE(π(z+1))=lsE(π′(z′+1)). By construction of {a mathematical formula}π′, the path {a mathematical formula}π′(z′+1),…,π′(x′) does not contain AE or MR actions. Hence, {a mathematical formula}lsE(π′(z′+1))=lsE(π′(x′)). The latter gives {a mathematical formula}lsE(π(z+1))=lsE(π′(x′)).We now show that {a mathematical formula}lsE(π(z+1))=lsE(π(x)). If the path {a mathematical formula}π(z+1),…,π(x) does not contain an AE action or an MR action, then the environment does not change its state in {a mathematical formula}π(z+1)…π(x) and the claim follows trivially. Otherwise, if there is at least one AE action or at least one MR action in {a mathematical formula}π(z+1),…,π(x), then {a mathematical formula}ELC(π(z+1)) and {a mathematical formula}ELC(π(x)). Therefore, Lemma 5.5 gives that {a mathematical formula}[z+1]π and {a mathematical formula}[x]π are environment loops. It follows that {a mathematical formula}lsE(π(z+1))=lsE(π(x)).The above two observations entail {a mathematical formula}lsE(π(x))=lsE(π′(x′)). As {a mathematical formula}a∈PE(lsE(π(x))), we obtain {a mathematical formula}a∈PE(lE).</list-item><list-item label="2.">For all y with {a mathematical formula}1≤y≤x−1 we have that {a mathematical formula}π(y,Act)∉⋃(i,r)∈A(m¯)AEir∪MRir. We have two cases.For the first case assume that {a mathematical formula}(g,g′)∈R3. As {a mathematical formula}g→X⁎π(x)→aπ(x+1), we obtain that {a mathematical formula}lsE(g′)=lsE(π(x)). By construction of {a mathematical formula}π′, {a mathematical formula}lsE(g′)=lsE(π′(x′)), therefore {a mathematical formula}lsE(π(x))=lsE(π′(x′)), and therefore {a mathematical formula}a∈PE(lE).For the second case assume that {a mathematical formula}(g,g′)∉R3. Then it must be the case that {a mathematical formula}(g,g′)∈R4. It follows that {a mathematical formula}lsE(g)=ιE. By construction of {a mathematical formula}π′, {a mathematical formula}lsE(π′(x′))=ιE. We show that {a mathematical formula}lsE(π(x))=ιE is also the case. If there is no AE or MR action in {a mathematical formula}[x]π, then the case follows trivially. Otherwise, we deduce that {a mathematical formula}ELC(π(x)), hence {a mathematical formula}[x]π is an environment loop. Therefore, {a mathematical formula}lsE(π(x))=ιE. Thus, {a mathematical formula}lsE(π(x))=lsE(π′(x′)). Hence, {a mathematical formula}a∈PG(lE).</list-item></list><paragraph>To show the latter, let ρ in {a mathematical formula}S(n¯) be a finite path of length len such that {a mathematical formula}ρ(len)=g and consider the concatenation {a mathematical formula}γ=ρ∘π of ρ and π. If there is a y with {a mathematical formula}1≤y≤x+len such that {a mathematical formula}ELC(γ(y)), then let z be the greatest integer such that {a mathematical formula}ELC(γ(z)); otherwise, let {a mathematical formula}z=1. As there is no state in the path {a mathematical formula}γ(z+1),…,γ(len+x) that satisfies the environment loop condition, and as {a mathematical formula}γ(len+x,Act)=(a,(r,q)),a∈MRi,jr,q for some {a mathematical formula}(j,q)∈A(n¯), it follows that only agent {a mathematical formula}(i,r) (possibly) synchronises with the environment in the path {a mathematical formula}γ(z),…,γ(len+x). By construction of {a mathematical formula}p, {a mathematical formula}D(γ(z))⊆D(p[]). Therefore, {a mathematical formula}(D(γ(len+x))∖{tlsir(γ(len+x))})⊆D(p[]). That is, {a mathematical formula}(D(π(x))∖{tlsir(π(x))})⊆D(p[])⊆D(π′(x′)). This means that the template state of agent {a mathematical formula}(j,q) in {a mathematical formula}π(x) that enables the action a is in {a mathematical formula}D(π(x′)). Therefore, by construction of {a mathematical formula}p, {a mathematical formula}lsjq(π(x))=lsjq′(π′(x′)). It follows that {a mathematical formula}a∈Pj(l).We have thus shown that {a mathematical formula}π′(x′)→π′(x′,Act)π′(x′+1) is a valid transition. It is left to show that {a mathematical formula}π(x+1)∼m¯ssπ′(x′+1). To do this, we show that {a mathematical formula}(π(x+1),π′(x′+1))∈R1∩R2∩R3. The case of {a mathematical formula}(π(x+1),π′(x′+1))∈R1∩R2 follows trivially. Consider the case of {a mathematical formula}(π(x+1),π′(x′+1))∈R3. Suppose that {a mathematical formula}π(x+1)→X⁎π(x+d)→aπ(x+d+1), for some {a mathematical formula}d≥1, {a mathematical formula}a∈⋃(i,r)∈A(m¯)AEir∪MRir, and {a mathematical formula}X=⋃(i,r)∈A(m¯)Air∪⋃(i,r)∉A(m¯)Actir. We need to show that {a mathematical formula}lsE(π′(x′+1))=lsE(π(x+d)). If the path {a mathematical formula}π(x+1)…π(x+d) consists only of asynchronous actions, then the case follows trivially. If not, then we obtain {a mathematical formula}ELC(π(x+1)) and {a mathematical formula}ELC(π(x+d)). Therefore, {a mathematical formula}lsE(π′(x′+1))=lsE(π(x+d)). We thus have that {a mathematical formula}(π(x+1),π′(x′+1))∈R3.It follows that simulation requirement (iii) is satisfied. As {a mathematical formula}(g,g′) was arbitrary, we have that {a mathematical formula}S(n¯)≤m¯ssS(c¯).  □</paragraph></paragraph><paragraph>Lemma 5.11 concludes part A of the proof for Theorem 5.8: the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system. The following constitutes part B of the proof: every bigger system {a mathematical formula}m¯-stuttering simulates the cutoff system.</paragraph></section><section label="5.4.2">Part B: every bigger system {a mathematical formula}m¯-stuttering simulates the cutoff system<paragraph>Fig. 11 shows the {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(c¯) and {a mathematical formula}S(n¯). {a mathematical formula}S(n¯) performs precisely every action performed by {a mathematical formula}S(c¯) while it lets the agents not in {a mathematical formula}A(c¯) stutter at their initial states.</paragraph><paragraph label="Lemma 5.12">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SMRof k roles with{a mathematical formula}T≤aesEand{a mathematical formula}m¯∈Nk. Then,{a mathematical formula}S(c¯)≤m¯ssS(n¯)for all{a mathematical formula}n¯≥c¯, where{a mathematical formula}c¯=cutoff_SMR(S,m¯).</paragraph><paragraph label="Proof">Choose an arbitrary {a mathematical formula}n¯≥c¯. We show that {a mathematical formula}S(c¯)≤m¯ssS(n¯). We do this by letting each additional agent in {a mathematical formula}S(n¯) stutter at its initial state. Then, {a mathematical formula}S(n¯) can simulate {a mathematical formula}S(c¯) by performing the same actions performed in {a mathematical formula}S(c¯).Define {a mathematical formula}R1,R2,R3⊆G(c¯)×G(n¯) to be the following relations.{a mathematical formula} Let {a mathematical formula}∼m¯ss=R1∩R2∩R3; the information encoded in a state in {a mathematical formula}S(c¯) is present in a related state in {a mathematical formula}S(n¯) by {a mathematical formula}R1; the additional agents in {a mathematical formula}S(n¯) are left stuttering at their initial states by {a mathematical formula}R2; the environment's states are equal in every pair of related states by {a mathematical formula}R3.We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(c¯) and {a mathematical formula}S(n¯). It should be clear that {a mathematical formula}ι(c¯)∼m¯ssι(n¯). To show the simulation requirements (i) and (iii), assume that {a mathematical formula}g∼m¯ssg′ for an arbitrary pair of global states in {a mathematical formula}G(c¯)×G(n¯). Requirement (i) follows by definition of {a mathematical formula}R1. To show the requirement (iii), let {a mathematical formula}π∈Π(g). Define a path {a mathematical formula}π′ by {a mathematical formula}g′π(1,Act),π(2,Act),…. Clearly, {a mathematical formula}π′∈Π(g′) and {a mathematical formula}π(j)∼m¯ssπ′(j), for all {a mathematical formula}j≥1. Thus, define {a mathematical formula}B1,B2,… and {a mathematical formula}B1′,B2′,… to be a partition of π and {a mathematical formula}π′ into singleton blocks. It follows that {a mathematical formula}S(c¯)≤m¯ssS(n¯).  □</paragraph><paragraph label="Corollary 5.13">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SMRwith{a mathematical formula}T≤aesEand an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯). Then,{a mathematical formula}S(c¯)⊨∀v¯ϕ(v¯)iff{a mathematical formula}∀n¯≥c¯.S(n¯)⊨∀v¯ϕ(v¯), where{a mathematical formula}c¯=cutofff_SMR(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯ be arbitrary. By Theorem 3.9 it suffices to show that {a mathematical formula}S(n¯)≤m¯ssS(c¯) and {a mathematical formula}S(c¯)≤m¯ssS(n¯). The former is given by Lemma 5.11, and the latter is given by Lemma 5.12.  □</paragraph><paragraph>This concludes the proof of Theorem 5.8. Corollary 5.13 provides a constructive methodology for solving the PMCP by giving the conditions under which the problem can be solved by checking each concrete system up to the cutoff system.</paragraph></section></section></section><section label="6">Verifying {a mathematical formula}SGS systems<paragraph>We now investigate the {a mathematical formula}SGS class of systems. The class is generated from agent templates defined on asynchronous, agent-environment and global-synchronous actions. By Theorem 4.3, cutoffs do not generally exist for this class. However, we show that the existence of an agent-environment simulation between the agent and environment templates guarantees a cutoff. We show how to calculate the cutoff under these conditions.</paragraph><paragraph>We begin with an analysis of the agent-environment simulation for {a mathematical formula}SGS systems. We then define the model checking procedure, and we exemplify it on the train-gate-controller. Finally, we prove its soundness. To simplify our analysis in the following we assume without loss of generality that for each action {a mathematical formula}a∈ActE we have that {a mathematical formula}|{l∈LE:a∈PE(l)}|=1; i.e., an environment's action is enabled at exactly one template state.</paragraph><section label="6.1"><section-title>Agent-environment simulation</section-title><paragraph>Similarly to the {a mathematical formula}SMR class, the concrete environment for the {a mathematical formula}SGS class implements a mutual exclusion controller governing the access to shared resources. This is modelled by means of the environment's looping behaviour as per Lemma 5.5. As we show below, an analogous lemma holds for the {a mathematical formula}SGS class. However, an environment loop is guaranteed to occur only in path sections that do not contain global-synchrnous actions. A subsequence of a path π that does not contain GS actions is said to be a GS-free section of π. A GS-free section {a mathematical formula}π(i),…,π(j) is said to be maximal if {a mathematical formula}π(i−1,Act)∈GS whenever {a mathematical formula}i&gt;1, and {a mathematical formula}π(j,Act)∈GS.</paragraph><paragraph label="Lemma 6.1">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SGSwith{a mathematical formula}T≤aesEand a maximal GS-free section π in{a mathematical formula}S(n¯). If{a mathematical formula}ELC(π(d))for some{a mathematical formula}d&gt;1, then{a mathematical formula}[d]πis an environment loop.</paragraph><paragraph label="Proof">Assume that {a mathematical formula}ELC(π(d)) for some {a mathematical formula}d&gt;1. Given π is a maximal GS-free section, it follows that: (i) π does not contain GS actions; (ii) {a mathematical formula}tlsij(π(1))∼aeslsE(π(1)) for each {a mathematical formula}(i,j)∈A(n¯). Therefore, Lemma 5.5 applies to π, and therefore {a mathematical formula}[d]π is an environment loop.  □</paragraph><paragraph>Intuitively, a global-synchronous action determines a subclass of the shared resources the agents can access. Upon performing a global-synchronous action the system enters a GS-free section where the agents can access the shared resources associated with the action in the same way described for {a mathematical formula}SMR systems.</paragraph></section><section label="6.2">Model checking procedure for {a mathematical formula}SGS systems<paragraph>The model checking procedure Check_{a mathematical formula}SGS for {a mathematical formula}SGS systems is defined by Algorithm 2. Given a PIIS {a mathematical formula}S∈SGS and an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯), the procedure first establishes whether or not {a mathematical formula}T≤aesE. Upon a successful simulation test the procedure calculates the cutoff for the given system and specification.</paragraph><paragraph>The cutoff function {a mathematical formula}cutoff_SGS maps a PIIS {a mathematical formula}S and tuple {a mathematical formula}m¯ of natural numbers into a tuple {a mathematical formula}c¯ of natural numbers that corresponds to the cutoff for {a mathematical formula}m¯-indexed formulae. The function is defined in terms of {a mathematical formula}m¯.</paragraph><paragraph label="Definition 6.2">Cutoff function for {a mathematical formula}SGS systemsThe cutoff function {a mathematical formula}cutoff_SGS is defined for {a mathematical formula}SGS systems as follows:{a mathematical formula} for any {a mathematical formula}S∈SGS with {a mathematical formula}k≥1 roles and any {a mathematical formula}m¯∈Nk.</paragraph><paragraph>Note that differently from {a mathematical formula}cutoff_SMR, {a mathematical formula}cutoff_SGS depends on the given system only in terms of the number of roles specified for the system. Following the cutoff calculation, the model checking procedure checks the concrete system {a mathematical formula}S(c¯) against the trivial instantiation {a mathematical formula}ϕ[trivial] of {a mathematical formula}∀v¯(ϕ(v¯)). If {a mathematical formula}ϕ[trivial] is satisfied by {a mathematical formula}S(c¯), then the procedure returns true, otherwise it returns false. We assess the soundness of the Check_{a mathematical formula}SGS procedure in Section 6.4. First, we exemplify it by means of the train-gate-controller.</paragraph></section><section label="6.3"><section-title>Verifying the train-gate-controller</section-title><paragraph>In Section 2.3.2 we represented the train-gate-controller as a PIIS {a mathematical formula}STGC composed of an agent template PT encoding prioritised trains, an agent template NT encoding normal trains, and an environment template {a mathematical formula}E encoding the controller. In Section 3.2 we expressed the property “whenever a train is in the tunnel, it knows that no other train is in the tunnel at the same time” in the following {a mathematical formula}(2,2)-indexed formula:{a mathematical formula} where {a mathematical formula}u,v are variables of PT, {a mathematical formula}x,y are variables of NT, the atomic proposition pt holds in the template states in which the template prioritised train is in the tunnel and the atomic proposition nt holds in the template states in which the template normal train is in the tunnel.</paragraph><paragraph>We now use the procedure Check_{a mathematical formula}SGS to establish whether or not the train-gate-controller meets the above specification. To do this, we first observe that {a mathematical formula}PT≤aesE and {a mathematical formula}NT≤aesE. Thus, we can use the cutoff function to calculate a cutoff:{a mathematical formula} Therefore, we need to check whether or not {a mathematical formula}STGC((2,2))⊨ϕTGC[trivial]. This check, if mechanised on a standard checker such as MCMAS, would return true thereby establishing the correctness of the protocol irrespectively of the number of agents present.</paragraph></section><section label="6.4">Soundness of the Check_{a mathematical formula}SGS procedure<paragraph>We now assess the soundness of the Check_{a mathematical formula}SGS procedure.</paragraph><paragraph label="Theorem 6.3">Given{a mathematical formula}S=〈T,E,V〉∈SGSand an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯), if{a mathematical formula}T≤aesE, thenCheck_{a mathematical formula}SGS(S,∀v¯ϕ(v¯))returns true iff{a mathematical formula}S⊨∀v¯ϕ(v¯).</paragraph><paragraph>To prove this result we firstly observe that by the definition of the PMCP and Theorem 3.9, it suffices to show that if {a mathematical formula}T≤aesE, then : (i) the cutoff system {a mathematical formula}S(c¯){a mathematical formula}m¯-stuttering simulates every bigger system; (ii) every bigger system {a mathematical formula}m¯-stuttering simulates {a mathematical formula}S(c¯). We first show the former.</paragraph><section label="6.4.1">Part A: the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system<paragraph>Consider an arbitrarily big system {a mathematical formula}S(n¯) with {a mathematical formula}n¯≥c¯, where {a mathematical formula}S(c¯) is the cutoff system. To simulate an action performed by the agents in {a mathematical formula}A(c¯) in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) performs the same action. To simulate an action performed by an agent not in {a mathematical formula}A(c¯) in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) performs the null action. Similarly to the simulation defined in Lemma 5.11 for {a mathematical formula}SMR systems, the latter does not block potential synchronisations of the environment with the agents in {a mathematical formula}A(c¯) at a later a point. To see this, note that a sequence of actions that are not admitted in the repertoire of the agents in {a mathematical formula}A(c¯) happens only in a GS-free section. Thus, if, for example, {a mathematical formula}g1a1g2…ax−1gx is a GS-free section in {a mathematical formula}S(n¯), where {a mathematical formula}a1,ax−1∈⋃(i,j)∈A(c¯)AEij and {a mathematical formula}a2,…,ax−2∉⋃(i,j)∈A(c¯)Actij, then both {a mathematical formula}g2 and {a mathematical formula}gx−1 satisfy the environment loop condition. Therefore, the state of the environment in {a mathematical formula}g2 is the same to its state in {a mathematical formula}gx−1. Intuitively, whenever an agent not in {a mathematical formula}A(m¯) in {a mathematical formula}S(n¯) takes the lock on a resource via synchronising with the environment, it has to release the resource via the occurrence of an environment loop before an agent in {a mathematical formula}A(m¯) can take the lock on a resource.</paragraph><paragraph>Fig. 12 shows the {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯).</paragraph><paragraph label="Lemma 6.4">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SGSof k roles with{a mathematical formula}T≤aesEand{a mathematical formula}m¯∈Nk. Then,{a mathematical formula}S(n¯)≤m¯ssS(c¯)for all{a mathematical formula}n¯≥c¯, where{a mathematical formula}c¯=cutoff_SGS(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯ be arbitrary. We show that {a mathematical formula}S(n¯)≤m¯ssS(c¯). Define {a mathematical formula}∼m¯ss=R1∩R2⊆G(n¯)×G(c¯) as follows:{a mathematical formula} We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation relation between {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯).Clearly, {a mathematical formula}(ι(n¯),ι(c¯))∈R1. To show that {a mathematical formula}(ι(n¯),ι(c¯))∈R2, suppose that {a mathematical formula}ι(n¯)→X⁎g1→ag2, where {a mathematical formula}a∈⋃(i,r)∈A(c¯)AEir and {a mathematical formula}X=⋃(i,r)∈A(c¯)Air∪⋃(i,r)∉A(c¯)Actir. We have to show that {a mathematical formula}lsE(g1)=lsE(ι(c¯)). If the path {a mathematical formula}ι(n¯),…,g1 consists only of asynchronous actions, then the case follows trivially. Otherwise, there must be an agent-environment action in {a mathematical formula}ι(n¯),…,g1. In this case, it follows that {a mathematical formula}ELC(g1). By Lemma 6.1, {a mathematical formula}ι(n¯),…,g1 is an environment loop. So, as {a mathematical formula}lsE(ι(n¯))=lsE(ι(c¯)), {a mathematical formula}lsE(g1)=lsE(ι(c¯)). Therefore, {a mathematical formula}(ι(n¯),ι(c¯))∈R2, and therefore, {a mathematical formula}ι(n¯)∼m¯ssι(c¯).Now assume that {a mathematical formula}g∼m¯ssg′ for an arbitrary pair of global states in {a mathematical formula}G(n¯)×G(c¯). We show the simulation requirements (i) and (iii). Requirement (i) follows by the definition of {a mathematical formula}R1. To show requirement (iii), let {a mathematical formula}π∈Π(g). Define a path {a mathematical formula}π′∈Π(g′) as {a mathematical formula}π′=π′(1)π′(1,Act)π′(2,Act)…, where {a mathematical formula}π′(x,Act) is defined for each {a mathematical formula}x≥1 as follows:<list>{a mathematical formula}π′(x,Act)=π(x,Act) if {a mathematical formula}π(x,Act)∈⋃(i,r)∈A(c¯)Actir;otherwise, {a mathematical formula}π′(x,Act)=ϵ.Partition </list><paragraph>π and {a mathematical formula}π′ into singleton blocks. We use induction on the length of π to show that: (i) {a mathematical formula}π′ is a valid path; (ii) {a mathematical formula}π(y)∼m¯ssπ′(y) for each {a mathematical formula}y≥1. The base step for π of length 1 follows trivially. For the inductive step, assume that {a mathematical formula}[x−1]π′∈Π(g′) and {a mathematical formula}π(y)∼m¯ssπ′(y) for each y with {a mathematical formula}1≤y≤x−1. We show that {a mathematical formula}[x]π′∈Π(g′) and {a mathematical formula}π(x)∼m¯ssπ′(x). The latter follows by the same argument used to show earlier that {a mathematical formula}ι(n¯)∼m¯ssι(c¯). To establish the former, we consider cases on the type of the action {a mathematical formula}π′(x−1,Act). The case where {a mathematical formula}π′(x−1,Act) is the ϵ action, or an asynchronous action, or a global-synchronous action follows trivially. So, assume that {a mathematical formula}π′(x−1,Act)∈⋃(i,r)∈A(c¯)AEir. We have to show that the action is enabled by the protocol of the agent and the protocol of the environment. The former is clear by the definition of {a mathematical formula}R0. In the following we show the latter.Define an integer d is follows. If there is no global-synchronous action in {a mathematical formula}[x−1]π, then {a mathematical formula}d=1. Otherwise, {a mathematical formula}d=d′+1, where {a mathematical formula}d′ is the largest integer with {a mathematical formula}1≤d′≤x−1 that satisfies {a mathematical formula}π(d′,Act)∈GS. By definition of d, {a mathematical formula}π(d),…,π(x−1) is a GS-free section. We have two cases.</paragraph><list><list-item label="1.">{a mathematical formula}π(d),…,π(x−1) contains an action in {a mathematical formula}⋃(i,r)∈A(c¯)AEir. In this case, let z be the greatest integer with {a mathematical formula}d≤z≤x−1 such that {a mathematical formula}π(z,Act)∈⋃(i,r)∈A(c¯)AEir. We show that {a mathematical formula}lsE(π(z+1))=lsE(π(x−1)). The claim follows trivially when {a mathematical formula}π(z+1),…,π(x−1) does not contain an agent-environment action. For the case where {a mathematical formula}π(z+1),…,π(x−1) contains an agent-environment action, it follows that {a mathematical formula}ELC(π(x−1)). Thus, by Lemma 6.1, we obtain {a mathematical formula}lsE(π(z+1))=lsE(π(x−1)). As {a mathematical formula}lsE(π(z+1))=lsE(π′(z+1)), and as {a mathematical formula}lsE(π′(z+1))=lsE(π′(x−1)) by construction of {a mathematical formula}π′, the latter gives {a mathematical formula}lsE(π′(x−1))=lsE(π(x−1)). Hence, {a mathematical formula}π′(x−1,Act)∈PE(π′(x−1)).</list-item><list-item label="2.">{a mathematical formula}π(d),…,π(x−1) does not contain an action in {a mathematical formula}⋃(i,r)∈A(c¯)AEir. By the inductive hypothesis, {a mathematical formula}(π(d),π′(d))∈R2. Therefore, {a mathematical formula}π(d)→X⁎π(x−1)→aπ(x) for some {a mathematical formula}a∈⋃(i,r)∈A(c¯)AEir. Consequently, {a mathematical formula}lsE(π(x−1))=lsE(π′(d)). Therefore, by the construction of {a mathematical formula}π′, {a mathematical formula}lsE(π(x−1))=lsE(π′(x−1)). It follows that {a mathematical formula}π(x−1,Act)∈PE(π′(x−1)).</list-item></list><paragraph>Consequently, {a mathematical formula}π′ is a valid path, and {a mathematical formula}π(y)∼m¯ssπ′(y) for each {a mathematical formula}y≥1. Therefore, {a mathematical formula}∼m¯ss satisfies simulation requirement (iii). As {a mathematical formula}(g,g′) was arbitrary, {a mathematical formula}S(n¯)≤m¯ssS(c¯) is entailed as required.  □</paragraph></paragraph><paragraph>We have thus shown that the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system. We conclude the proof for Theorem 6.3 by showing that every bigger system {a mathematical formula}m¯-stuttering simulates the cutoff system.</paragraph></section><section label="6.4.2">Part B: every bigger system {a mathematical formula}m¯-stuttering simulates the cutoff system<paragraph>Fig. 13 shows the {a mathematical formula}m¯-stuttering simulation between the cutoff system {a mathematical formula}S(c¯) and a bigger system {a mathematical formula}S(n¯). To simulate an asynchronous or an agent-environment action of {a mathematical formula}S(c¯), {a mathematical formula}S(n¯) performs the same action. Consider a global-synchronous action performed in {a mathematical formula}S(c¯). Clearly, every agent in {a mathematical formula}S(c¯) is at a state enabling the global-synchronous action. {a mathematical formula}S(n¯) simulates a global-synchronous action as follows. One by one, every agent {a mathematical formula}(i,j)∈A(n¯)∖A(c¯) in {a mathematical formula}S(n¯) mimicks agent {a mathematical formula}(i,1) by performing the same sequence of actions, thereby reaching the local state of agent {a mathematical formula}(i,1) in which the global-synchronous action is enabled. Then, {a mathematical formula}S(n¯) performs the global-synchronous action. The following lemma formally defines this simulation and shows it to be an {a mathematical formula}m¯-stuttering simulation.</paragraph><paragraph label="Lemma 6.5">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SGSof k roles with{a mathematical formula}T≤aesEand{a mathematical formula}m¯∈Nk. Then,{a mathematical formula}S(c¯)≤m¯ssS(n¯)for all{a mathematical formula}n¯≥c¯, where{a mathematical formula}c¯=cutoff_SGS(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯. Assume an integer i with {a mathematical formula}1≤i≤k. Define {a mathematical formula}n¯′ to be a k-tuple of integers such that: {a mathematical formula}n¯′(i)=n¯(i)+1; {a mathematical formula}n¯′(j)=n¯(j) for all j with {a mathematical formula}1≤j≤k and {a mathematical formula}j≠i. We show that {a mathematical formula}S(n¯)≤m¯ssS(n¯′). That is, we prove that the system obtained by adding one concrete agent (of an arbitrary role) to {a mathematical formula}S(n¯){a mathematical formula}m¯-stuttering simulates {a mathematical formula}S(n¯). The inductive application of the latter entails the main claim of the lemma.Let {a mathematical formula}r=n¯′(i). The simulation relation {a mathematical formula}∼m¯ss=R1∩R2∩R3⊆G(n¯)×G(n¯′) is defined by the following:{a mathematical formula} The above ensures that the local state of each agent in {a mathematical formula}S(n¯) is equal to its local state in a related global state in {a mathematical formula}S(n¯′). The relations {a mathematical formula}R2 and {a mathematical formula}R3 specify the local state of the environment and the local state of agent {a mathematical formula}(i,r) in related global states. Specifically, {a mathematical formula}R2 and {a mathematical formula}R3 are defined to induce a mimicking behaviour on agent {a mathematical formula}(i,r) in {a mathematical formula}S(n¯′) w.r.t. agent {a mathematical formula}(i,1) in {a mathematical formula}S(n¯):{a mathematical formula} If {a mathematical formula}(g,g′)∈R2 and a state {a mathematical formula}g1 is reachable from g in which a GS action is enabled, then agent {a mathematical formula}(i,r) in {a mathematical formula}S(n¯′) is able to change its local state to the local state of agent {a mathematical formula}(i,1) in {a mathematical formula}S(n¯) via asynchronous and agent-environment transitions. Thus, whenever a GS-transition is taken in {a mathematical formula}S(n¯), agent {a mathematical formula}(i,r) is able to move to a local state in which the GS action is enabled. Note that {a mathematical formula}(R1∩R2)-related states may disagree on the environment's local state. Because of this, given an arbitrary pair of {a mathematical formula}(R1∩R2)-related states, {a mathematical formula}S(n¯′) may not be able to simulate {a mathematical formula}S(n¯). To circumvent this, we define {a mathematical formula}R3 to ensure that whenever {a mathematical formula}(R1∩R2)-related states disagree on the environment's state, agent {a mathematical formula}(i,r) can cause the environment to appropriately change its state.{a mathematical formula} We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation relation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′). To do this, we first show that {a mathematical formula}(ι(n¯),ι(n¯′))∈∼m¯ss. It is obvious that {a mathematical formula}(ι(n¯),ι(n¯′))∈R1∩R3. To show that {a mathematical formula}(ι(n¯),ι(n¯′))∈R2, suppose that {a mathematical formula}ι(n¯)→X⁎g1→GSg2. We have to show that {a mathematical formula}ι(n¯′)→Y⁎g′1, where {a mathematical formula}tlsir(g′1)=tlsi1(g1) and {a mathematical formula}lsE(g′1)=lsE(g1). Let θ be the sequence of actions of agent {a mathematical formula}(i,1) in the path {a mathematical formula}π=ι(n¯),…,g1. Define {a mathematical formula}θ′ to be the sequence θ, but with each action indexed with r instead of 1. Let {a mathematical formula}π′=ι(n¯′)∘θ′ be a path in {a mathematical formula}S(n¯′). It should be clear that {a mathematical formula}π′ is a valid path if it consists only of asynchronous actions. If this is not the case, then observe that for every two successive synchronisations, say in states {a mathematical formula}π(d) and {a mathematical formula}π(d′), of agent {a mathematical formula}(i,1) with the environment in π, if there is a different agent that synchronises with the environment in the path from {a mathematical formula}π(d) to {a mathematical formula}π(d′), then the local state of the environment is the same in {a mathematical formula}π(d) and {a mathematical formula}π(d′). This follows by Lemma 6.1 which gives {a mathematical formula}ELC(π(d)) and {a mathematical formula}ELC(π(d′)). So, the environment allows for the actions in {a mathematical formula}θ′ to be performed. It follows that {a mathematical formula}ι(n¯′)→Y⁎π′[], where {a mathematical formula}tlsir(π′[])=tlsi1(g1) and {a mathematical formula}lsE(π′[])=lsE(g1).Now assume an arbitrary pair {a mathematical formula}(g,g′)∈G(n¯)×G(n¯′) of global states such that {a mathematical formula}g∼m¯ssg′. We show the simulation requirements (i) and (iii). Requirement (i) follows by the definition of {a mathematical formula}R1. Consider requirement (iii) and a path {a mathematical formula}π∈Π(g). We construct a path {a mathematical formula}π′∈Π(g′) as required by the {a mathematical formula}m¯-stuttering-simulation. The construction is inductive on the length of π. Assume that, for a prefix {a mathematical formula}[x−1]π, we have already constructed a prefix {a mathematical formula}[x′−1]π′, a partition {a mathematical formula}B1,…,By−1 of the states in {a mathematical formula}[x−1]π, and a partition {a mathematical formula}B1′,…,By−1′ of the states in {a mathematical formula}[x′−1]π′ into corresponding blocks. Let {a mathematical formula}π(d),…,π(x−1) be the maximal GS-free section that is a suffix of {a mathematical formula}[x−1]π. We now define the next blocks {a mathematical formula}By and {a mathematical formula}By′. We have two cases depending on the equality of the environment's local state in {a mathematical formula}π(x−1) and {a mathematical formula}π′(x′−1).<list>{a mathematical formula}lsE(π(x−1))=lsE(π′(x′−1)). If {a mathematical formula}π(x−1,Act)∈X, then define {a mathematical formula}By=π(x) and {a mathematical formula}By′=π′(x′), where {a mathematical formula}π′(x′−1)→π(x−1,Act)π′(x′). It is obvious that the latter is a valid transition and that {a mathematical formula}π(x)∼m¯ssπ′(x′).Otherwise, assume that {a mathematical formula}π(x−1,Act)∈GS. By {a mathematical formula}(π(x−1),π(x′−1))∈R2, we have that {a mathematical formula}π′(x′−1)→Y⁎π′(x′+d), where {a mathematical formula}d≥0, {a mathematical formula}tlsir(π′(x′+d))=tlsi1(π(x−1)) and {a mathematical formula}lsE(π′(x′+d))=lsE(π(x−1)). Therefore, {a mathematical formula}π(x−1,Act) is enabled at {a mathematical formula}π′(x′+d). Extend {a mathematical formula}By−1′ to {a mathematical formula}By−1′∘π′(x′),…,π′(x′+d). Define {a mathematical formula}By=π(x) and {a mathematical formula}By′=π′(x′+d+1), where {a mathematical formula}π′(x′+d)→π(x−1,Act)π′(x′+d+1). We get that {a mathematical formula}π(x−1) is {a mathematical formula}∼m¯ss-related to every state in {a mathematical formula}By−1′. Additionally, {a mathematical formula}(π(x),π′(x′+d+1))∈R1∩R3. Moreover, the argument used earlier to show that {a mathematical formula}(ι(n¯),ι(n¯′))∈R2 can be used here to show that {a mathematical formula}(π(x),π′(x′+d+1))∈R2. Hence, {a mathematical formula}π(x)∼m¯ssπ′(x′+d+1).{a mathematical formula}lsE(π(x−1))≠lsE(π′(x′−1)). In this case, from {a mathematical formula}(π(x−1),π′(x′−1))∈R3 it follows that {a mathematical formula}π′(x′−1)→Y⁎π′(x′+d), where {a mathematical formula}d≥0,tlsir(π′(x′+d))=tlsi1(π(x−1)) and {a mathematical formula}lsE(π′(x′+d))=lsE(π(x−1)). Therefore, {a mathematical formula}π(x−1,Act) is enabled in {a mathematical formula}π′(x′+d). Extend {a mathematical formula}By−1′ to {a mathematical formula}By−1′∘π(x′),…,π′(x′+d). Define {a mathematical formula}By=π(x) and {a mathematical formula}By′=π′(x′+d+1), where {a mathematical formula}π′(x′+d)→π(x−1,Act)π′(x′+d+1). We get that {a mathematical formula}π(x−1) is {a mathematical formula}∼m¯ss-related to every state in {a mathematical formula}By−1′. Additionally, {a mathematical formula}(π(x),π′(x′+d+1))∈R1∩R3. Moreover, the argument used earlier to show that {a mathematical formula}(ι(n¯),ι(n¯′))∈R2 can be used here to show that {a mathematical formula}(π(x),π′(x′+d+1))∈R2. Hence, {a mathematical formula}π(x)∼m¯ssπ′(x′+d+1).Having shown simulation requirements (i) and (iii) for an arbitrary pair of global states, it follows that </list><paragraph>{a mathematical formula}S(n¯)≤m¯ssS(n¯′). By the inductive application of the latter and by transitivity of {a mathematical formula}≤m¯ss, {a mathematical formula}S(c¯)≤m¯ssS(n¯).  □</paragraph></paragraph><paragraph label="Corollary 6.6">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SGSof k roles with{a mathematical formula}T≤aesEand an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯). Then,{a mathematical formula}S(c¯)⊨∀v¯ϕ(v¯)iff{a mathematical formula}∀n¯≥c¯.S(n¯)⊨∀v¯ϕ(v¯), where{a mathematical formula}c¯=cutofff_SGS(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯ be arbitrary. By Theorem 3.9 it suffices to show that {a mathematical formula}S(n¯)≤m¯ssS(c¯) and {a mathematical formula}S(c¯)≤m¯ssS(n¯). The former is given by Lemma 6.4. The latter is given by Lemma 6.5.  □</paragraph><paragraph>This concludes the proof of Theorem 6.3. In contrast with the {a mathematical formula}SMR class where cutoffs depend on the cardinality of the action dependency sets, Corollary 6.6 provides a methodology for solving the PMCP by giving the conditions under which the problem can be solved by checking only the cutoff system. This clearly has considerable advantages in applications as Section 6.3 demonstrates.</paragraph></section></section></section><section label="7">Verifying {a mathematical formula}SFE systems<paragraph>We finally investigate the {a mathematical formula}SFE class of systems defined on asynchronous, role-synchronous and global-synchronous actions. In contrast with {a mathematical formula}SMR and {a mathematical formula}SGS, the existence of cutoffs in the {a mathematical formula}SFE class does not depend on the existence of an agent-environment simulation between the agent and environment templates. In particular, we show that a cutoff exists for any given system and any given specification. This enables us to define a sound and complete model checking procedure. We begin with the definition of the model checking procedure and we exemplify it on the autonomous robot scenario. We then show it to be sound.</paragraph><section label="7.1">Model checking procedure for {a mathematical formula}SFE systems<paragraph>The model checking procedure for {a mathematical formula}SFE systems is defined by Algorithm 3. Given a PIIS {a mathematical formula}S∈SFE and an {a mathematical formula}m¯-indexed formula {a mathematical formula}∀v¯ϕ(v¯), the procedure calculates the cutoff for the given system and specification. The cutoff function {a mathematical formula}cutoff_SFE maps a PIIS {a mathematical formula}S and a tuple {a mathematical formula}m¯ of natural numbers into a tuple {a mathematical formula}c¯ of natural numbers that corresponds to the cutoff for {a mathematical formula}m¯-indexed formulae. Identically to {a mathematical formula}cutoff_SGS and differently from {a mathematical formula}cutoff_SMR, {a mathematical formula}cutoff_SFE depends on the system under analysis only in terms of {a mathematical formula}m¯.</paragraph><paragraph label="Definition 7.1">Cutoff function for {a mathematical formula}SFE systemsThe cutoff function {a mathematical formula}cutoff_SFE is defined for {a mathematical formula}SFE systems as follows.{a mathematical formula} for any {a mathematical formula}S∈SFE with {a mathematical formula}k≥1 roles and any {a mathematical formula}m¯∈Nk.</paragraph><paragraph>Following the cutoff calculation, the model checking procedure checks the concrete system {a mathematical formula}S(c¯) against the trivial instantiation {a mathematical formula}ϕ[trivial] of {a mathematical formula}∀v¯(ϕ(v)). If {a mathematical formula}ϕ[trivial] is satisfied by {a mathematical formula}S(c¯), then the procedure returns true, otherwise it returns false. Note that, differently from the model checking procedures for {a mathematical formula}SMR and {a mathematical formula}SGS systems, the model checking procedure for {a mathematical formula}SFE systems always produces an output. We show that this output is always correct in Section 7.3. First, we compute its value for the autonomous robot example.</paragraph></section><section label="7.2"><section-title>Verifying the autonomous robot example</section-title><paragraph>In Section 2.3.3 we encoded the autonomous robot example as a PIIS {a mathematical formula}SAR composed of an agent template TR1 representing robots with access to a sensor, an agent template TR2 representing robots with no access to a sensor, and a template environment {a mathematical formula}E representing the environment. In Section 3.2 we expressed the property “whenever a robot halts, it knows that it is in the goal region” in the following {a mathematical formula}(1,1)-indexed formula:{a mathematical formula} where v is a variable of TR1, u is a variable of TR2, the atomic proposition {a mathematical formula}gr_1 ({a mathematical formula}gr_2, respectively) holds in the template states where the value of the position component of template robot 1 (template robot 2, respectively) is in {a mathematical formula}{2,3,4}, and the atomic proposition {a mathematical formula}h_1 ({a mathematical formula}h_2, respectively) holds in the template states where the template robot 1 (template robot 2, respectively) has halted.</paragraph><paragraph>We now use the procedure Check_{a mathematical formula}SFE to establish whether or not the autonomous robot meets the above specification. We have that{a mathematical formula} Thus, we need to check whether or not {a mathematical formula}SAR((1,1))⊨ϕAR[trivial]. The latter query can be tested with a standard model checker; this will return true thereby establishing the correctness of the protocol irrespectively of the number of robots present.</paragraph></section><section label="7.3">Soundness of the Check_{a mathematical formula}SFE procedure<paragraph>We now assess the soundness of the Check_{a mathematical formula}SFE procedure.</paragraph><paragraph label="Theorem 7.2">Given{a mathematical formula}S=〈T,E,V〉∈SFEand an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯),Check_{a mathematical formula}SFE(S,∀v¯ϕ(v¯))returns true iff{a mathematical formula}S⊨∀v¯ϕ(v¯).</paragraph><paragraph>We prove this result by showing that: (i) the cutoff system {a mathematical formula}S(c¯){a mathematical formula}m¯-stuttering simulates every bigger system; (ii) every bigger system {a mathematical formula}m¯-stuttering simulates {a mathematical formula}S(c¯). Differently from the corresponding results for the {a mathematical formula}SMR and {a mathematical formula}SGS classes, the absence of agent-environment and multi-role actions in the {a mathematical formula}SFE class removes the necessity to simulate synchronisations of the environment on actions that are not admitted by the agents in {a mathematical formula}A(m¯). Indeed, whenever an agent not in {a mathematical formula}A(m¯) synchronises with the environment, all agents of the same role (or all agents in the system depending on the type of the action) synchronise the environment as well.</paragraph><section label="7.3.1">Part A: the cutoff system {a mathematical formula}m¯-stuttering simulates every bigger system<paragraph>Consider an arbitrarily big system {a mathematical formula}S(n¯) with {a mathematical formula}n¯≥c¯, where {a mathematical formula}S(c¯) is the cutoff system. Fig. 14 shows the {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯). To simulate an action performed by the agents in {a mathematical formula}A(c¯) in {a mathematical formula}S(n¯), {a mathematical formula}S(c¯) performs the same action. Any action performed in {a mathematical formula}S(n¯) that is not admitted by an agent in {a mathematical formula}A(c¯) is bound to be an asynchronous action. As only the state of the agent performing the action is updated, {a mathematical formula}S(c¯) simulates these actions by performing the null action.</paragraph><paragraph label="Lemma 7.3">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SFEof k roles and{a mathematical formula}m¯≥Nk. Then,{a mathematical formula}S(n¯)≤m¯ssS(c¯)for all{a mathematical formula}n¯≥c¯, where{a mathematical formula}c¯=cutoff_SFE(S,m¯).</paragraph><paragraph label="Proof">Choose an arbitrary {a mathematical formula}n¯≥c¯. We show that {a mathematical formula}S(n¯)≤m¯ssS(c¯). Define the simulation relation {a mathematical formula}∼m¯ss⊆G(n¯)×G(c¯) as follows:{a mathematical formula} We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(c¯). It is clear that {a mathematical formula}ι(n¯)∼m¯ssι(c¯). Let {a mathematical formula}g∼m¯ssg′ for an arbitrary pair of global states in {a mathematical formula}G(n¯)×G(c¯). We show simulation requirements (i) and (iii). Requirement (i) follows by the definition of {a mathematical formula}∼m¯ss. For simulation requirement (iii), let {a mathematical formula}π∈Π(g). Construct a path {a mathematical formula}π′∈Π(g′) as follows: for each {a mathematical formula}j≥1, {a mathematical formula}π′(j,Act)=π(j,Act) if {a mathematical formula}π(j,Act)∈⋃(i,r)∈A(c¯)Actir; otherwise, {a mathematical formula}π′(j,Act)=ϵ. It can be checked that {a mathematical formula}π′ is a valid path, and that {a mathematical formula}π(j)∼m¯ssπ′(j), for each {a mathematical formula}j≥1. Thus, partition π and {a mathematical formula}π′ into singleton blocks. It follows that {a mathematical formula}S(n¯)≤m¯ssS(c¯).  □</paragraph></section><section label="7.3.2">Part B: every bigger system {a mathematical formula}m¯-stuttering simulates the cutoff system<paragraph>Fig. 15 shows the {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(c¯) and {a mathematical formula}S(n¯). An asynchronous action a defined for template i is simulated by {a mathematical formula}S(c¯) by means of two cases. If a is not admitted in the repertoire of agent {a mathematical formula}(i,1), then {a mathematical formula}S(n¯) simply performs a. If a is admitted in the repertoire of agent {a mathematical formula}(i,1), then, one by one, the agents {a mathematical formula}(i,1),(i,c¯(i)+1),…,(i,n¯(i)) perform a. Thus, for each role i, every agent in {a mathematical formula}{c¯(i)+1,…,n¯(i)} mimics agent {a mathematical formula}(i,1). {a mathematical formula}S(n¯) may then simulate a role-synchronous action or a global-synchronous action by performing the action in question.</paragraph><paragraph label="Lemma 7.4">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SFEof k roles and{a mathematical formula}m¯∈Nk. Then,{a mathematical formula}S(c¯)≤m¯ssS(n¯), where{a mathematical formula}c¯=cutoff_SFE(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯. Assume an integer i with {a mathematical formula}1≤i≤k. Define {a mathematical formula}n¯′ to be a k-tuple of integers such that: {a mathematical formula}n¯′(i)=n¯(i)+1; {a mathematical formula}n¯′(j)=n¯(j) for all j with {a mathematical formula}1≤j≤k and {a mathematical formula}j≠i. We show that {a mathematical formula}S(n¯)≤m¯ssS(n¯′). That is, we prove that the system obtained by adding one concrete agent (of an arbitrary role) to {a mathematical formula}S(n¯){a mathematical formula}m¯-stuttering simulates {a mathematical formula}S(n¯). The inductive application of the latter entails the main claim of the lemma.Assume {a mathematical formula}r=n¯′(i). Define the simulation relation {a mathematical formula}∼m¯ss⊆G(n¯)×G(n¯′) as follows:{a mathematical formula}If {a mathematical formula}g∼m¯ssg′, then the local states of the agents in {a mathematical formula}A(n¯) and the local states of the environment are the same in the two global states. Additionally, the agent {a mathematical formula}(i,r) in {a mathematical formula}S(n¯′) is able to change its local state to the local state of agent {a mathematical formula}(i,1) in {a mathematical formula}S(n¯′) via asynchronous transitions. We show that {a mathematical formula}∼m¯ss is an {a mathematical formula}m¯-stuttering simulation between {a mathematical formula}S(n¯) and {a mathematical formula}S(n¯′).The case of {a mathematical formula}ι(n¯)∼m¯ssι(n¯′) follows trivially. Suppose that {a mathematical formula}g∼m¯ssg′ for an arbitrary pair of global states in {a mathematical formula}G(n¯)×G(n¯′). We show simulation requirements (i) and (iii). The former requirement follows by the definition of {a mathematical formula}∼m¯ss. For the latter requirement, let {a mathematical formula}π∈Π(g). By induction on the length of π, we construct a path {a mathematical formula}π′∈Π(g′) such that: (i) {a mathematical formula}π′ is as required by the {a mathematical formula}m¯-stuttering simulation; (ii) {a mathematical formula}tlsir(π′[])=tlsi1(π′[]).For the base step, {a mathematical formula}g∼m¯ssg′ gives {a mathematical formula}g′→Air⁎g′1, where {a mathematical formula}tlsir(g′1)=tlsi1(g′). Let {a mathematical formula}π′ be the path from {a mathematical formula}g′ to {a mathematical formula}g′1. The first blocks {a mathematical formula}B1,B1′ are defined as follows: {a mathematical formula}B1=g and {a mathematical formula}B1′ is the sequence of states in {a mathematical formula}π′. Clearly, g is {a mathematical formula}∼m¯ss-related to every state in {a mathematical formula}π′.For the inductive step, assume that for a prefix {a mathematical formula}[x−1]π we have already constructed a prefix {a mathematical formula}[x′−1]π′ such that {a mathematical formula}tlsir(π′(x′−1))=tlsi1(π′(x′−1)), and a partition of the states in {a mathematical formula}[x−1]π and {a mathematical formula}[x′−1]π′ into corresponding blocks. We now define the next blocks {a mathematical formula}Bx and {a mathematical formula}Bx′. There are two cases.<list>{a mathematical formula}π(x−1,Act)∉Ai1. Define {a mathematical formula}Bx=π(x) and {a mathematical formula}Bx′=π′(x′), where {a mathematical formula}π′(x′−1)→π(x−1,Act)π′(x′). The inductive hypothesis gives {a mathematical formula}π(x−1)∼m¯ssπ′(x′−1) and {a mathematical formula}tlsir(π′(x′−1))=tlsi1(π′(x′−1)). Therefore, {a mathematical formula}π′(x′−1)→π(x−1,Act)π′(x′) is a valid transition, {a mathematical formula}π(x)∼m¯ssπ′(x′), and {a mathematical formula}tlsir(π′(x′))=tlsi1(π(x)).{a mathematical formula}π(x−1,Act)∈Ai1. Let a be the corresponding template action of {a mathematical formula}π(x−1,Act). Define {a mathematical formula}Bx=π(x) and {a mathematical formula}Bx′=π′(x′)∘π′(x′+1), where {a mathematical formula}π′(x′−1)→(a,1)π′(x′)→(a,r)π′(x′+1). The inductive hypothesis gives {a mathematical formula}π(x−1)∼m¯ssπ′(x′−1) and {a mathematical formula}tlsir(π′(x′−1))=tlsi1(π′(x′−1)). Therefore, {a mathematical formula}π′(x′−1)→(a,1)π′(x′)→(a,r)π′(x′+1) are valid transitions, {a mathematical formula}π(x)∼m¯ssπ′(x′), {a mathematical formula}π(x)∼m¯ssπ′(x′+1), and {a mathematical formula}tlsir(π′(x′+1))=tlsi1(π′(x′)).Simulation requirement (iii) is therefore satisfied. It follows that </list><paragraph>{a mathematical formula}S(n¯)≤m¯ssS(n¯′). By the inductive application of the latter and by transitivity of {a mathematical formula}≤m¯ss, we obtain that {a mathematical formula}S(c¯)≤m¯ssS(n¯).  □</paragraph></paragraph><paragraph label="Corollary 7.5">Consider a PIIS{a mathematical formula}S=〈T,E,V〉∈SFEof k roles and an{a mathematical formula}m¯-indexed formula{a mathematical formula}∀v¯ϕ(v¯). Then,{a mathematical formula}S(c¯)⊨∀v¯ϕ(v¯)iff{a mathematical formula}∀n¯≥c¯.S(n¯)⊨∀v¯ϕ(v¯), where{a mathematical formula}c¯=cutoff_SFE(S,m¯).</paragraph><paragraph label="Proof">Let {a mathematical formula}n¯≥c¯ be arbitrary. By Theorem 3.9 it suffices to show that {a mathematical formula}S(n¯)≤m¯ssS(c¯) and {a mathematical formula}S(c¯)≤m¯ssS(n¯). The former is given by Lemma 7.3. The latter is given by Lemma 7.4.  □</paragraph><paragraph>This concludes the proof of Theorem 7.2. Corollary 7.5 gives a methodology for solving the PMCP by model checking the cutoff system. Differently from Corollary 5.13 and Corollary 6.6, where certain conditions are assumed, by means of Corollary 7.5 we always solve the PMCP for any given system and specification. In other words, while Check_{a mathematical formula}SMR and Check_{a mathematical formula}SGS do not provide an answer to the PMCP in the absence of an agent-environment simulation, Check_{a mathematical formula}SFE always provides a solution. Therefore, the PMCP for the {a mathematical formula}SFE class of PIIS is decidable.</paragraph><paragraph label="Corollary 7.6">The PMCP for the{a mathematical formula}SFEclass of PIIS is decidable.</paragraph></section></section></section><section label="8">The model checker MCMAS-P<paragraph>In this section we introduce MCMAS-P[66], an experimental model checking toolkit that implements the techniques presented in Section 5, Section 6, and Section 7. MCMAS-P is built on top of the open source model checker MCMAS[11]. In its current version, MCMAS-P supports indexed {a mathematical formula}ACTLK∖X formulae.</paragraph><section label="8.1">MCMAS-P architecture<paragraph>Fig. 16 presents the key steps carried out by the checker. We extended ISPL, MCMAS's input language, to allow for the definition of the semantic structures and the parametric specifications considered here. As exemplified in Fig. 17, a PIIS is described in the extended language, called PISPL, by declaring the agent templates and the environment template. These extend ISPL's semantics by considering, among other concepts, the different kind of actions that PIIS are defined on. Given a PIIS {a mathematical formula}S=〈T,E,V〉 specified in PISPL and a set of {a mathematical formula}m¯-indexed formulae Λ, the steps 2-6 of Fig. 16 are performed automatically by the checker. In the following, we describe these steps.</paragraph><list><list-item label="•">In step 2, the PISPL input file is parsed. The declarations of the agent templates and the environment template are stored in temporary structures to be used in the following steps.</list-item><list-item label="•">In step 3, the simulation test is performed to check if there is an agent-environment simulation between the agent templates and the environment template. This step is only performed if the specified PIIS is either a member of the {a mathematical formula}SMR class or a member of the {a mathematical formula}SGS class. Instead of explicitly traversing the template transition relations, the test is more efficiently performed by utilising the OBDD representation of the templates. In particular, the test for an agent-environment simulation between an agent template i and the environment template is performed by checking the system composed of the two templates against a set of formulae expressing that whenever an {a mathematical formula}AEi action, or a GS action, or an {a mathematical formula}MRi action is enabled for the agent, the action is also enabled for the environment. We discuss this in more detail in Section 8.2 where we present the underlying theoretical background.</list-item><list-item label="•">Following a successful simulation test, in step 4, MCMAS-P calculates the cutoff as in Definition 5.7, Definition 6.2, and Definition 7.1. If {a mathematical formula}S∈SMR, then the cutoff is computed from the action dependency sets and the cardinality of the sets of variables in the specifications to check; if {a mathematical formula}S∉SMR, then the cutoff is only computed in terms of the latter.</list-item><list-item label="•">In step 5, the concrete system {a mathematical formula}S(m¯) is built and encoded symbolically using the structures obtained in step 2. In step 6, the specification formulae Λ are reduced to their trivial instantiations {a mathematical formula}Λ[trivial] as in Lemma 3.6. MCMAS is then called to verify {a mathematical formula}S(m¯) against {a mathematical formula}Λ[trivial]. These steps are repeated for each concrete system up to the cutoff system {a mathematical formula}S(c¯).</list-item></list><paragraph>If all checks up to the cutoff system satisfy the corresponding specification, then MCMAS-P returns true; otherwise, MCMAS-P returns false.</paragraph></section><section label="8.2"><section-title>Simulation test</section-title><paragraph>We describe the procedure utilised by MCMAS-P for the existence of an agent-environment simulation. The procedure is based on the assumption that the agent-environment actions, global-synchronous actions, and multi-role actions are enabled at exactly one state for the environment template. This allows us to check for an agent-environment simulation between an agent template {a mathematical formula}Ti=〈Li,ιi,Acti,Pi,ti〉 and the environment template {a mathematical formula}E=〈LE,ιE,ActE,PE,tE〉 by model checking the interleaved interpreted system {a mathematical formula}Si against the set of formulae {a mathematical formula}Δi, where {a mathematical formula}Si and {a mathematical formula}Δi are defined as follows.</paragraph><list><list-item label="•">{a mathematical formula}Si=〈Ti,E,Vi〉 is the IIS composed of the agent template {a mathematical formula}Ti and the environment template {a mathematical formula}E. The global states {a mathematical formula}Gi⊆Li×LE in {a mathematical formula}Si are assigned atomic propositions by the valuation function {a mathematical formula}Vi:Li×LE→P(AP), where {a mathematical formula}AP={aT,aE|a∈AEi∪GS∪MRi}, defined as {a mathematical formula}aT∈Vi((l,lE)) iff {a mathematical formula}a∈Pi(l) and {a mathematical formula}aE∈Vi((l,lE)) iff {a mathematical formula}a∈PE(lE). In other words, a global state {a mathematical formula}g∈Gi is labelled with {a mathematical formula}aT (respectively, {a mathematical formula}aE) if the action a is enabled for the agent template (respectively, the environment template) at g.</list-item><list-item label="•">{a mathematical formula}Δi={AG(aT→aE):a∈AEi∪GS∪MRi}.</list-item></list><paragraph>{a mathematical formula}Si satisfies the formulae in {a mathematical formula}Δi iff there is an agent-environment simulation between {a mathematical formula}Ti and {a mathematical formula}E.</paragraph><paragraph label="Lemma 8.1">{a mathematical formula}Ti≤aesEiff{a mathematical formula}∀δ∈Δi.Si⊨δ.</paragraph><paragraph label="Proof"><list><list-item label="⇒">Suppose that {a mathematical formula}Ti≤aesE. We show that {a mathematical formula}∀δ∈Δi.Si⊨δ. Let {a mathematical formula}δ∈Δi. So, {a mathematical formula}δ=AG(aT→aE) for some {a mathematical formula}a∈AEi∪GS∪MRi. Let π be an arbitrary path in {a mathematical formula}Si. Suppose that {a mathematical formula}π(i)⊨aT for some {a mathematical formula}i≥1. Since {a mathematical formula}Ti≤aesE, there is an {a mathematical formula}i′≤i such that {a mathematical formula}π(i′)→Ai⁎π(i) and {a mathematical formula}lsTi(π(i′))∼aeslsE(π(i′)). Therefore, {a mathematical formula}a∈PE(π(i′)) as otherwise we would have {a mathematical formula}lsTi(π(i′))≁aeslsE(π(i′)). So, {a mathematical formula}π(i′)⊨aE, and therefore, {a mathematical formula}π(i)⊨aE. As i was arbitrary, {a mathematical formula}π⊨AG(aT→aE) follows. As π was arbitrary, {a mathematical formula}Si⊨δ is entailed. Therefore, {a mathematical formula}∀δ∈Δi.Si⊨δ.</list-item><list-item label="⇐">Suppose that {a mathematical formula}∀δ∈Δi.Si⊨δ. We show that {a mathematical formula}Ti≤aesE. Let {a mathematical formula}∼aes=Gi. We show that {a mathematical formula}∼aes is an agent-environment simulation between {a mathematical formula}Ti and {a mathematical formula}E. Clearly, {a mathematical formula}ιi∼aesιE. Let {a mathematical formula}g=(l,lE)∈∼aes be arbitrary and suppose that {a mathematical formula}l⇢Ai⁎l1⇢al2 for some {a mathematical formula}a∈AEi∪GS∪MRi. We need to show that {a mathematical formula}lE⇢alE1 for some {a mathematical formula}lE1 with {a mathematical formula}(l2,lE1)∈∼aes. As {a mathematical formula}l1 is reachable from l through asynchronous actions, there is a global state {a mathematical formula}g1 reachable from g such that {a mathematical formula}lsTi(g1)=l1 and {a mathematical formula}lsE(g1)=lE. As {a mathematical formula}a∈P(l1) and {a mathematical formula}Si⊨AG(aT→aE), it follows that {a mathematical formula}a∈PE(lE). As the action a is enabled at {a mathematical formula}g1, we obtain {a mathematical formula}(l2,lE1)∈∼aes for {a mathematical formula}lE1=tE(lE,a). Therefore, {a mathematical formula}Ti≤aesE.  □</list-item></list></paragraph><paragraph>So, we have that {a mathematical formula}T∼aesE iff {a mathematical formula}Si satisfies the formulae in {a mathematical formula}Δi for all i with {a mathematical formula}1≤i≤k. This has considerable advantages in applications in terms of efficiency as the following demonstrates.</paragraph></section><section label="8.3"><section-title>Experimental results</section-title><paragraph>We tested the cutoff techniques on the robot foraging scenario (RFS), the train-gate-controller (TGC) model, and the autonomous robot (AR) example against the specifications {a mathematical formula}ϕRFS,ϕTGC, and {a mathematical formula}ϕAR, respectively. Table 1 shows the intractability of these problems in traditional model checking: the time and space requirements grow exponentially in the number of agents to consider. In our case the base model checker MCMAS could not verify the RFS system {a mathematical formula}SRFS((30,30)) and the TGC system {a mathematical formula}STGC((40,40)) with a timeout of one hour. In comparison, MCMAS-P established the simulations as above and verified the cutoff instances {a mathematical formula}SRFS((2,3)), {a mathematical formula}STGC((2,2)), and {a mathematical formula}SAR((1,1)) in under 0.1 seconds for each of the three scenarios. The MAS cutoffs MCMAS-P found correspond to MAS with 5 agents, 4 agents, and 2 agents respectively. The formulae checked, and found to be true, were {a mathematical formula}ϕRFS[trivial],ϕTGC[trivial] and {a mathematical formula}ϕAR[trivial]. This establishes the correctness of the RFS, TGS and AR scenarios with any number of agents.</paragraph><paragraph>The above exemplifies the efficiency of the model checking procedures. Indeed, recall that the complexity of the CTL labelling algorithm is {a mathematical formula}O(f⋅(V+E)), where f is the number of connectives in the formula, V is the number of states, and E is the number of transitions [4]. Given the cutoffs are typically small, the procedures provide an effective verification for unbounded MAS. To see this in terms of the simulation test, observe that each {a mathematical formula}Si has at most as many states and transitions as {a mathematical formula}Ti. Thus, checking a template agent against {a mathematical formula}δ∈Δi requires {a mathematical formula}O(3⋅|Ti|) time, where {a mathematical formula}|Ti| is the sum of the number of states and the number of transitions in {a mathematical formula}Ti. Therefore, establishing an agent-environment simulation between {a mathematical formula}Ti and {a mathematical formula}E requires {a mathematical formula}O(|AEi∪MRi∪GS|⋅|Ti|) time. If {a mathematical formula}x=max⁡(|AEi∪MRi∪GS|:1≤i≤k) and {a mathematical formula}y=max⁡(|Ti|:1≤i≤k), then the simulation test for a PIIS of k roles requires {a mathematical formula}O(k⋅x⋅y) time.</paragraph></section></section><section label="9"><section-title>Conclusions</section-title><paragraph>With the deployment of systems based on MAS-architectures there has been a growing interest in their verification. Considerable progress has been made in model checking MAS against specifications based on temporal, epistemic, deontic and strategic properties; open-source implementations based on efficient symbolic approaches have been put forward and compared.</paragraph><paragraph>While this work has proven to be valuable, it is limited to scenarios where the number of components is known at design time. This is not a realistic assumption in certain MAS where the number of components cannot be known before deployment. A typical case is robotic swarms, whereby the properties of the swarm need to hold irrespective of how many robots are present in the system and should hold even if some of the robots develop a fault and leave the system.</paragraph><paragraph>In this paper we put forward a methodology to solve the parameterised model checking problem for MAS in a number of noteworthy classes of PIIS. As we showed, this enabled us to give a methodology for the cutoff identification of a given parametric system. When a cutoff can be determined, the parameterised model checking problem can be solved via standard model checking by verifying all system instances up to the cutoff. We showed the procedure to be sound.</paragraph><paragraph>Table 2 summarises the theoretical results obtained. Since the PMCP is in general undecidable, no complete results can be established in general. In Section 5 we presented an incomplete technique for the {a mathematical formula}SMR class; in Section 6 we analysed an incomplete technique for the {a mathematical formula}SGS class; in Section 7 we studied a complete technique for the {a mathematical formula}SFE class. Incompleteness for the {a mathematical formula}SMR and the {a mathematical formula}SGS classes follows in the absence of an agent-environment simulation between the templates since in this case the techniques cannot assess the correctness of a given specification. In contrast, we can always assess the correctness of a specification on {a mathematical formula}SFE systems. This level of confidence, which follows from the decidability result of Corollary 7.6, comes with considerable limitations on the range of systems that the technique can be applied to. For instance, the result cannot be applied to any scenario where the agents evolve in any other way other than lock-step evolution. Other systems may be modelled as {a mathematical formula}SMR or {a mathematical formula}SGS systems. {a mathematical formula}SMR is suitable for scenarios requiring refined interactions between agents of different roles, whereas {a mathematical formula}SGS is suitable for simulating synchronous semantics. The technique for the former class generally returns cutoffs that are larger than those for the latter class. Both techniques are limited by the requirement of an agent-environment simulation between the agent and environment templates. This makes it difficult to model certain applications of interest; including cache coherence protocols [67].</paragraph><paragraph>In future work we plan to explore other methodologies, including counter-abstraction [40] for obtaining cutoffs for even wider classes of systems. Furthermore, we believe the technique here put forward can serve as an ideal stepping stone to verify open MAS where the agents can dynamically join or leave the system at runtime. We are not aware of any formal methodologies addressing this aspect.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>The research described in this paper was supported by the EPSRC Research Project “Trusted Autonomous Systems” (grant No. EP/I00520X/1). The data reported in this article, including the source code and the models tested, can be accessed from [66].</paragraph></acknowledgements><appendices><section label="Appendix A"><section-title>Notation</section-title><paragraph>Table 3 summarises the notation used in the paper.</paragraph></section></appendices><references><reference label="[1]"><authors>R.R. Murphy</authors><title>Marsupial and shape-shifting robots for urban search and rescue</title><host>IEEE Intell. Syst. Appl.15 (2)(2000) pp.14-19</host></reference><reference label="[2]"><authors>E.M. Maximilien,M.P. Singh</authors><title>A framework and ontology for dynamic web services selection</title><host>Internet Comput.8 (5)(2004) pp.84-93</host></reference><reference label="[3]"><authors>A. Rosenfeld,I. Zuckerman,E. Segal-Halevi,O. Drein,S. Kraus</authors><title>Negochat: a chat-based negotiation agent</title><host>Proceedings of the 2014 International Conference on Autonomous Agents and Multi-Agent SystemsInternational Foundation for Autonomous Agents and Multiagent Systems(2014) pp.525-532</host></reference><reference label="[4]"><authors>E. Clarke,O. Grumberg,D. Peled</authors><title>Model Checking</title><host>(1999)The MIT Press</host></reference><reference label="[5]"><authors>A. Pnueli</authors><title>Applications of temporal logic to the specification and verification of reactive systems: a survey of current trends</title><host>Current Trends in Concurrency, Overviews and TutorialsLect. Notes Comput. Sci.vol. 224 (1986)Springer pp.510-584</host></reference><reference label="[6]"><authors>R. Fagin,Y. Moses,J.Y. Halpern,M.Y. Vardi</authors><title>Reasoning About Knowledge</title><host>(2003)The MIT Press</host></reference><reference label="[7]"><authors>A. Rao</authors><title>Agentspeak (L): BDI agents speak out in a logical computable language</title><host>Proceedings of MAAMAW'96(1996)Springer pp.42-55</host></reference><reference label="[8]"><authors>M. Dastani,M. van Riemsdijk,F. Dignum,J.J. Meyer</authors><title>A programming language for cognitive agents goal directed 3APL</title><host>Proceedings of ProMAS'03(2003)Springer pp.111-130</host></reference><reference label="[9]"><authors>R. Alur,T.A. Henzinger,O. Kupferman</authors><title>Alternating-time temporal logic</title><host>J. ACM49 (5)(2002) pp.672-713</host></reference><reference label="[10]"><authors>P. Gammie,R.V.D. Meyden</authors><title>Mck: model checking the logic of knowledge</title><host>Proceedings of CAV'04(2004)Springer pp.256-259</host></reference><reference label="[11]"><authors>A. Lomuscio,H. Qu,F. Raimondi</authors><title>MCMAS: a model checker for the verification of multi-agent systems</title><host>Proceedings of CAV'09(2009)Springer pp.682-688</host></reference><reference label="[12]"><authors>M. Cohen,M. Dam,A. Lomuscio,F. Russo</authors><title>Abstraction in model checking multi-agent systems</title><host>Proceedings of AAMAS'09(2009)IFAAMAS Press pp.945-952</host></reference><reference label="[13]"><authors>A. Lomuscio,W. Penczek,H. Qu</authors><title>Partial order reductions for model checking temporal-epistemic logics over interleaved multi-agent systems</title><host>Fundam. Inform.101 (1)(2010) pp.71-90</host></reference><reference label="[14]"><authors>A. Lomuscio,W. Penczek,B. Woźna</authors><title>Bounded model checking knowledge and real time</title><host>Artif. Intell.171 (16–17)(2007) pp.1011-1038</host></reference><reference label="[15]"><authors>M. Kwiatkowska,H.Q.A. Lomuscio</authors><title>Parallel model checking for temporal epistemic logic</title><host>Proceedings of ECAI'10(2010)IOS Press pp.543-548</host></reference><reference label="[16]"><authors>E. Emerson,K. Namjoshi</authors><title>Reasoning about rings</title><host>Proceedings POPL'95(1995)Pearson Education pp.85-94</host></reference><reference label="[17]"><authors>Y. Hanna,S. Basu,H. Rajan</authors><title>Behavioral automata composition for automatic topology independent verification of parameterized systems</title><host>Proceedings of ESEC/FSE'09(2009)ACM pp.325-334</host></reference><reference label="[18]"><authors>K. Apt,D. Kozen</authors><title>Limits for automatic verification of finite-state concurrent systems</title><host>Inf. Process. Lett.22 (6)(1986) pp.307-309</host></reference><reference label="[19]"><authors>P.A. Abdulla,F. Haziza,L. Holík</authors><title>All for the price of few</title><host>Verification, Model Checking, and Abstract Interpretation(2013)Springer pp.476-495</host></reference><reference label="[20]"><authors>Y. Hanna,D. Samuelson,S. Basu,H. Rajan</authors><title>Automating cut-off for multi-parameterized systems</title><host>Proceedings of ICFEM'10(2010)Springer pp.338-354</host></reference><reference label="[21]"><authors>R.v. Meyden,H. Shilov</authors><title>Model checking knowledge and time in systems with perfect recall</title><host>Proceedings of FST&amp;TCSHyderabad, IndiaLect. Notes Comput. Sci.vol. 1738 (1999) pp.432-445</host></reference><reference label="[22]"><authors>W. Penczek,A. Lomuscio</authors><title>Verifying epistemic properties of multi-agent systems via bounded model checking</title><host>Proceedings of the Second International Joint Conference on Autonomous Agents and Multi-Agent SystemsAAMAS'03(2003)ACM pp.209-216</host></reference><reference label="[23]"><authors>R. van der Meyden,K. Su</authors><title>Symbolic model checking the knowledge of the dining cryptographers</title><host>Proceedings of the 17th IEEE Computer Security Foundations WorkshopCSFW'04(2004)IEEE Computer SocietyWashington, DC, USA pp.280-291</host></reference><reference label="[24]"><authors>F. Raimondi,A. Lomuscio</authors><title>Automatic verification of multi-agent systems by model checking via OBDDs</title><host>J. Appl. Log.5 (2)(2005) pp.235-251</host></reference><reference label="[25]"><authors>F. Raimondi,A. Lomuscio</authors><title>Automatic verification of deontic interpreted systems by model checking via OBDDs</title><host>Proceedings of the Sixteenth European Conference on Artificial IntelligenceECAI04(2004)IOS Press pp.53-57</host></reference><reference label="[26]"><authors>B. Wozna,A. Lomuscio,W. Penczek</authors><title>Bounded model checking for deontic interpreted systems</title><host>Electron. Notes Theor. Comput. Sci.126 (2005) pp.93-114</host></reference><reference label="[27]"><authors>M. Kacprzak,W. Penczek</authors><title>A SAT-based approach to unbounded model checking for alternating-time temporal epistemic logic</title><host>Synthese142 (2004) pp.203-227</host></reference><reference label="[28]"><authors>A. Lomuscio,F. Raimondi</authors><title>Model checking knowledge, strategies, and games in multi-agent systems</title><host>Proceedings of the Fifth International Joint Conference on Autonomous Agents and Multiagent SystemsAAMAS'06(2006)ACM Press pp.161-168</host></reference><reference label="[29]"><authors>M. Kacprzak,W. Nabiałek,A. Niewiadomski,W. Penczek,A. Półrola,M. Szreter,B. Woźna,A. Zbrzezny</authors><title>Verics 2007—a model checker for knowledge and real-time</title><host>Fundam. Inform.85 (1)(2008) pp.313-328</host></reference><reference label="[30]"><authors>A. Pnueli,J. Xu,L. Zuck</authors><title>Liveness with (0, 1, infinity)-counter abstraction</title><host>Proceedings of CAV'02(2002)Springer pp.93-111</host></reference><reference label="[31]"><authors>E. Clarke,M. Talupur,H. Veith</authors><title>Proving Ptolemy right: the environment abstraction framework for model checking concurrent systems</title><host>Proceedings of TACAS'08(2008)Springer pp.33-47</host></reference><reference label="[32]"><authors>S.M. German,A.P. Sistla</authors><title>Reasoning about systems with many processes</title><host>J. ACM39 (3)(1992) pp.675-735</host></reference><reference label="[33]"><authors>E. Clarke,M. Talupur,H. Veith</authors><title>Environment abstraction for parameterized verification</title><host>Verification, Model Checking, and Abstract Interpretation(2006)Springer pp.126-141</host></reference><reference label="[34]"><authors>E.A. Emerson,K.S. Namjoshi</authors><title>Automatic verification of parameterized synchronous systems</title><host>Computer Aided Verification(1996)Springer pp.87-98</host></reference><reference label="[35]">J. Esparza,A. Finkel,R. MayrOn the verification of broadcast protocolsProceedings, 14th Symposium on Logic in Computer Science(1999)IEEE1999, pp. 352–359</reference><reference label="[36]"><authors>Q. Yang,M. Li</authors><title>A cut-off approach for bounded verification of parameterized systems</title><host>2010 ACM/IEEE 32nd International Conference on Software Engineering, Vol. 1(2010)IEEE pp.345-354</host></reference><reference label="[37]"><authors>E.A. Emerson,K.S. Namjoshi</authors><title>On model checking for non-deterministic infinite-state systems</title><host>Proceedings of Thirteenth Annual IEEE Symposium on Logic in Computer Science(1998)IEEE pp.70-80</host></reference><reference label="[38]"><authors>P. Wolper,V. Lovinfosse</authors><title>Verifying properties of large sets of processes with network invariants</title><host>Proceedings of AVMFSS'89(1990)Springer pp.68-80</host></reference><reference label="[39]"><authors>L. Zuck,A. Pnueli</authors><title>Model checking and abstraction to the aid of parameterized systems (a survey)</title><host>Comput. Lang. Syst. Struct.30 (3)(2004) pp.139-169</host></reference><reference label="[40]"><authors>T. Arons,A. Pnueli,S. Ruah,Y. Xu,L. Zuck</authors><title>Parameterized verification with automatically computed inductive assertions?</title><host>Computer Aided Verification(2001)Springer pp.221-234</host></reference><reference label="[41]"><authors>P.A. Abdulla,B. Jonsson</authors><title>On the existence of network invariants for verifying parameterized systems</title><host>Correct System Design(1999)Springer pp.180-197</host></reference><reference label="[42]"><authors>P.A. Abdulla,B. Jonsson,M. Nilsson,J. d'Orso</authors><title>Regular model checking made simple and effcient*</title><host>CONCUR 2002—Concurrency Theory(2002)Springer pp.116-131</host></reference><reference label="[43]"><authors>T. Touili</authors><title>Regular model checking using widening techniques</title><host>Electron. Notes Theor. Comput. Sci.50 (4)(2001) pp.342-356</host></reference><reference label="[44]"><authors>A. Pnueli,E. Shahar</authors><title>Liveness and acceleration in parameterized verification</title><host>Computer Aided Verification(2000)Springer pp.328-343</host></reference><reference label="[45]"><authors>B. Boigelot,A. Legay,P. Wolper</authors><title>Iterating transducers in the large</title><host>Computer Aided Verification(2003)Springer pp.223-235</host></reference><reference label="[46]"><authors>E. Emerson,V. Kahlon</authors><title>Reducing model checking of the many to the few</title><host>Proceedings of CADE'00(2000)Springer pp.236-254</host></reference><reference label="[47]"><authors>A. Kaiser,D. Kroening,T. Wahl</authors><title>Dynamic cutoff detection in parameterized concurrent programs</title><host>Proceedings of CAV'10(2010)Springer pp.645-659</host></reference><reference label="[48]"><authors>E. Clarke,M. Talupur,T. Touili,H. Veith</authors><title>Verification by network decomposition</title><host>CONCUR 2004—Concurrency Theory(2004)Springer pp.276-291</host></reference><reference label="[49]"><authors>B. Aminof,S. Jacobs,A. Khalimov,S. Rubin</authors><title>Parameterized model checking of token-passing systems</title><host>Verification, Model Checking, and Abstract Interpretation(2014)Springer pp.262-281</host></reference><reference label="[50]"><authors>E.A. Emerson,V. Kahlon</authors><title>Model checking large-scale and parameterized resource allocation systems</title><host>Tools and Algorithms for the Construction and Analysis of Systems(2002)Springer pp.251-265</host></reference><reference label="[51]"><authors>E. Emerson,V. Kahlon</authors><title>Model checking guarded protocols</title><host>Proceedings of LICS'03(2003)IEEE pp.361-370</host></reference><reference label="[52]"><authors>A. Abdulla,K. Cerans,B. Jonsson,Y.-K. Tsay</authors><title>General decidability theorems for infinite-state systems</title><host>Proceedings of Eleventh Annual IEEE Symposium on Logic in Computer ScienceLICS'96(1996)IEEE pp.313-321</host></reference><reference label="[53]"><authors>P. Kouvaros,A. Lomuscio</authors><title>Automatic verification of parameterised interleaved multi-agent systems</title><host>Proceedings of AAMAS'13IFAAMAS(2013) pp.861-868</host></reference><reference label="[54]"><authors>P. Kouvaros,A. Lomuscio</authors><title>A cutoff technique for the verification of parameterised interpreted systems with parameterised environments</title><host>Proceedings of the 13th International Joint Conference on Artificial IntelligenceIJCAI'13(2013)AAAI Press pp.2013-2019</host></reference><reference label="[55]"><authors>W.V.D. Hoek,M. Wooldridge</authors><title>Tractable multi-agent planning for epistemic goals</title><host>Proceedings of AAMAS'02IFAAMAS(2002) pp.1167-1174</host></reference><reference label="[56]"><authors>R. Alur,T. Henzinger,F. Mang,S. Qadeer,S. Rajamani,S. Tasiran</authors><title>MOCHA: User Manual</title><host>(1998)</host></reference><reference label="[57]"><authors>W. Liu,A. Winfield,J. Sa,J. Chen,L. Dou</authors><title>Strategies for energy optimisation in a swarm of foraging robots</title><host>Swarm Robotics(2007)Springer pp.14-26</host></reference><reference label="[58]"><authors>E. Bonabeau,M. Dorigo,G. Theraulaz</authors><title>Swarm Intelligence</title><host>(1999)Oxford</host></reference><reference label="[59]"><authors>E. Şahin</authors><title>Swarm robotics: from sources of inspiration to domains of application</title><host>Swarm Robotics(2005)Springer pp.10-20</host></reference><reference label="[60]"><authors>E. Şahin,A. Winfield</authors><title>Special issue on swarm robotics</title><host>Swarm Intell.2 (2)(2008) pp.69-72</host></reference><reference label="[61]"><authors>A.P. Engelbrecht</authors><title>Fundamentals of Computational Swarm Intelligence</title><host>(2006)John Wiley &amp; Sons</host></reference><reference label="[62]"><authors>E. Clarke,O. Grumberg,M. Browne</authors><title>Reasoning about networks with many identical finite state processes</title><host>Inf. Comput.81 (1)(1989) pp.13-31</host></reference><reference label="[63]"><authors>C. Rouff,A. Vanderbilt,M. Hinchey,W. Truszkowski,J. Rash</authors><title>Properties of a formal method for prediction of emergent behaviors in swarm-based systems</title><host>Proceedings of the Second International Conference on Software Engineering and Formal MethodsSEFM 2004(2004)IEEE pp.24-33</host></reference><reference label="[64]"><authors>E. Emerson,A. Sistla</authors><title>Symmetry and model checking</title><host>Form. Methods Syst. Des.9 (1)(1996) pp.105-131</host></reference><reference label="[65]"><authors>M. Browne,E. Clarke,O. Grümberg</authors><title>Characterizing finite kripke structures in propositional temporal logic</title><host>Theor. Comput. Sci.59 (1)(1988) pp.115-131</host></reference><reference label="[66]">MCMAS-P, Model Checking Parameterised Multi-Agent Systems, http://vas.doc.ic.ac.uk/software/tools, 2015.</reference><reference label="[67]"><authors>K. Baukus,R. Meyden</authors><title>A knowledge based analysis of cache coherence</title><host>Formal Methods and Software Engineering(2004)Springer pp.99-114</host></reference></references><footnote><note-para label="1">{a mathematical formula}n¯≥m¯ denotes that {a mathematical formula}n¯(1)≥m¯(1),…,n¯(k)≥m¯(k).</note-para><note-para label="2">Recall that {a mathematical formula}SMR systems do not support GS actions. However the definition of agent-environment simulation includes GS actions as the definition will be reused for the analysis of {a mathematical formula}SGS systems.</note-para></footnote></root>