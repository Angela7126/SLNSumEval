<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370214001271</url><title>Subdimensional expansion for multirobot path planning</title><authors>Glenn Wagner,Howie Choset</authors><abstract>Planning optimal paths for large numbers of robots is computationally expensive. In this paper, we introduce a new framework for multirobot path planning called subdimensional expansion, which initially plans for each robot individually, and then coordinates motion among the robots as needed. More specifically, subdimensional expansion initially creates a one-dimensional search space embedded in the joint configuration space of the multirobot system. When the search space is found to be blocked during planning by a robot–robot collision, the dimensionality of the search space is locally increased to ensure that an alternative path can be found. As a result, robots are only coordinated when necessary, which reduces the computational cost of finding a path. We present the M⁎ algorithm, an implementation of subdimensional expansion that adapts the A⁎ planner to perform efficient multirobot planning. M⁎ is proven to be complete and to find minimal cost paths. Simulation results are presented that show that M⁎ outperforms existing optimal multirobot path planning algorithms.</abstract><keywords>Motion and path planning;Multiagent system</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Multirobot systems offer flexibility, sensor coverage, and redundancy, which makes them attractive for tasks such as surveillance, search and rescue, and warehouse automation. Exploiting the benefits of multirobot systems requires addressing a multitude of issues including task assignment, communication, synchronization of world models, and the coordination of large numbers of robots, in addition to all the challenges that face single robot systems.</paragraph><paragraph>In this paper, we focus on issues surrounding planning paths for large numbers of robots. Such issues center on the fundamental trade-off between path quality and computational cost. The trade-off is illustrated by the differences between coupled and decoupled approaches to multirobot path planning. Coupled approaches use the high-dimensional joint configuration space of a multirobot system{sup:1} as the search space, and can find paths that are collision-free and minimal cost, i.e. optimal, but at high computational cost [1], [2]. For example, finding optimal paths for multirobot systems on graphs is known to be NP-hard [3]. Decoupled algorithms explore a low dimensional search space to coordinate the motion of robots on paths computed for each robot individually; they can rapidly find paths for large numbers of robots, but are not guaranteed to find a path for all solvable problems [4], [5], [6], [7], [8].</paragraph><paragraph>In this paper, we introduce a new approach that combines the advantages of coupled and decoupled algorithms called subdimensional expansion. Subdimensional expansion is not a specific algorithm, but rather a method for manipulating the search spaces of existing search algorithms to decrease the computational cost of solving multirobot path planning problems. Subdimensional expansion starts by finding a path for each robot in its individual configuration space. Combining the individual paths of each robot defines a one-dimensional search space for the full multirobot system embedded in the joint configuration space. When robots are found to collide in the multirobot search space, subdimensional expansion locally grows the dimensionality of the search space to allow an alternative path for the colliding robots to be found with coupled planning. Although the search space may grow to cover the entire joint configuration space in the worst case, for many problems subdimensional expansion can construct a low dimensional search space that allows for efficient computation of a high quality path.</paragraph><paragraph>This paper combines and extends results previously published in conference papers [9], [10]. We describe an implementation of subdimensional expansion for planning on arbitrary graphs called {a mathematical formula}M⁎.{sup:2}{a mathematical formula}M⁎ uses {a mathematical formula}A⁎[1] as the underlying planner that both computes paths for individual robots to guide the construction of the multirobot search space, and explores the multirobot search space to find a path for the entire system. {a mathematical formula}M⁎ is guaranteed to find the optimal path. Several improved versions of {a mathematical formula}M⁎ are described which further reduce the dimensionality of the search space and reduce the time required to explore the search space. Simulation results are presented that show that {a mathematical formula}M⁎ has better performance than existing optimal multirobot path planning algorithms.</paragraph></section><section label="2"><section-title>Prior work</section-title><paragraph>We place multirobot path planning algorithms on a continuum between coupled and decoupled approaches. Coupled planning algorithms search the joint configuration space of the multirobot system, guaranteeing that the optimal path will be found. Decoupled approaches, on the other hand, compute paths separately for individual robots, then adjust the paths to avoid collisions. Decoupled approaches generally can not guarantee that a path will be found, much less the optimal path.</paragraph><section label="2.1"><section-title>Coupled multirobot path planning</section-title><paragraph>A straightforward multirobot path planner could use standard {a mathematical formula}A⁎[1] to find a path for a multirobot system, resulting in a simple, coupled planner. However, the exponential growth in the number of possible joint actions would render such an approach computationally infeasible as the number of robots increases. Operator Decomposition (OD) [2] and Enhanced Partial Expansion {a mathematical formula}A⁎ ({a mathematical formula}EPEA⁎) [12], [13] are lazy variants of {a mathematical formula}A⁎ designed for multirobot path planning which delay enumerating paths that are expensive based on a heuristic, thereby dramatically reducing the effective branching factor of multirobot systems. Iterative Deepening {a mathematical formula}A⁎ ({a mathematical formula}IDA⁎) is a general purpose heuristic depth-first search algorithm, which can be applied to the problem of finding optimal paths for systems of multiple robots. However, it is effective only when robots are packed densely enough that only a few robots can move at any time [14].</paragraph><paragraph>Probabilistic planners were developed to find paths for robot mechanisms with many internal degrees of freedom, for which deterministic planners such as {a mathematical formula}A⁎ were unable to find paths in a reasonable amount of time. The suitability of probabilistic planners for high-dimensional planning has led to the development of coupled algorithms that use probabilistic planners directly to explore the joint configuration space of multirobot systems [15], [16], [17], [18]. The shear size of the joint configuration space of multirobot systems limits such approaches to relatively small numbers of robots. MA-RRT* [19], dRRT [20], and sPRM [21] are probabilistic planning algorithms customized for multirobot path planning that decouple planning to avoid robot–obstacle and robot–robot collisions, resulting in substantial reductions in the computational cost of finding paths.</paragraph><paragraph>An alternate approach to coupled planning is to recast the multirobot path planning problem as a Boolean Satisfiability (SAT) problem, for which there are very efficient general-purpose solvers. The multirobot path planning problem can be recast as a SAT problem by creating a set of Boolean variables to track the location of each robot, and adding terms to the Boolean formula to enforce collision avoidance, defining a logical formula for which the solver tries to find a valid assignment of truth values [22], [23], [24], [25], [26]. SAT planners have also been used to find shortcuts to reduce the cost of non-optimal paths computed by rule-based planners [27], [28].</paragraph></section><section label="2.2"><section-title>Decoupled multirobot path planning</section-title><paragraph>Decoupled approaches compute paths separately for individual robots, then adjust the paths to avoid collisions. Because the search for both the individual robot paths and the necessary adjustments to avoid collisions are performed in low-dimensional search spaces, decoupled approaches can rapidly find paths for systems containing many robots [6], [7]. Velocity planners fix the paths that will be followed by each robot, then find a velocity schedule along those paths that avoids collisions [5], [29], [30], [31], [32], [33], [34]. Priority planners assign a priority to each robot, then plan for individual robots in decreasing order of priority, treating higher priority robots as moving obstacles [4], [35], [36], [37], [38], [39]. The choice of priority ordering is critical, leading to a number of heuristics for choosing priority orders that are likely to lead to a solution [38], [40], [41]. Turpin et al. [42], [43] showed that for permutation invariant multirobot path planning, where any robot can move to any goal location, there is a polynomial time algorithm for choosing an assignment of robots to goals and a priority order that is guaranteed to produce a solution. The drawback of decoupled algorithms is that the search spaces employed represent only a small portion of the joint configuration space, and thus decoupled algorithms are not guaranteed to find a path for all solvable problems [18], excepting permutation invariant multirobot path planning.</paragraph></section><section label="2.3"><section-title>Intermediate multirobot path planning</section-title><paragraph>Several approaches have been developed that lie between coupled and decoupled approaches: they allow for more rich robot–robot behaviors than can be achieved with decoupled planners, while avoiding planning in the joint configuration space.</paragraph><paragraph>Rule based approaches use a set of stereotyped behaviors to govern robot–robot interactions, and can find paths in polynomial time. The existence of polynomial time algorithms for non-optimal multirobot path planning was first proved by Wilson [44] and Kornhauser et al. [45]. Gabriele and Helmert [46] brought this early work back to the attention of the planning community, and worked to adapt the proofs of Kornhauser et al. [45] into a practical planning algorithm. Several approaches to rule based path planning have been developed. Warehousing approaches shift robots into configurations which will not interfere with the motion of other robots [47], [48]. Push and Swap [49], [50], Push and Rotate [51], and the Tree-Based Agent Swapping Strategy algorithm [52] utilize behaviors that exchange the positions of two robots without disturbing other robots. While these algorithms are guaranteed to find paths in polynomial time, the stereotyped behaviors induced by the rules can lead to low quality paths. In particular, only a few robots are typically allowed to move at any given time. Parallel Push and Swap (PPAS) [53] is a variant of Push and Swap which allows all robots to move simultaneously, significantly reducing the typical makespan of plans, i.e. the time required for the last robot to reach its goal.</paragraph><paragraph>An alternative approach followed by dynamically coupled algorithms is to grow the search space during path planning, so that the search space can initially be very small, then grow only where necessary. Al-Wahedi [54] presented an approach in which paths are found separately for each robot, followed by coupled planning in a window around conflicts, but does not return optimal paths. The work of van den Berg et al. [55] shows how to identify the minimal sets of robots which must execute a cooperative path instead of sequentially executing single robot paths. The Increasing Cost Tree Search (ICTS) [56] limits the cost that can be incurred by an individual robot, then uses pairwise tests to determine for which robots the cost limits must be raised. Conflict-Based Search (CBS) [57] constructs a set of constraints when planning for individual robots to find optimal solutions without exploring higher-dimensional spaces. Enhanced CBS (ECBS) [58] is a variant of CBS that can rapidly find near optimal solutions to problems involving large numbers of robots. Independence Detection (ID) [2] and Meta-Agent Conflict-Based Search (MA-CBS) [59] initially attempt to find a path using decoupled planning approaches, but revert to coupled planning for subsets of robots for which the decoupled planner cannot find paths. In the worst case, the search spaces constructed by dynamically coupled algorithms may cover the entire joint configuration space, but for most problems a substantially smaller search space suffices.</paragraph></section></section><section label="3"><section-title>Subdimensional expansion</section-title><paragraph>In multirobot path planning there is an inherent trade-off between path quality and the computational cost of finding a path. However, in many problem instances of interest, the multirobot path planning problem naturally decomposes into small subproblems, which permits optimal paths{sup:3} to be found at low computational cost. Specifically, if the interactions between robots are sparse, the multirobot path planning problem can be split into two parts: planning paths for individual robots and optimally resolving conflicts between robots.</paragraph><paragraph>Subdimensional expansion is a framework for multirobot path planning that exploits the aforementioned natural decomposition to find optimal paths at low computational cost. Subdimensional expansion begins by computing an individual policy for each robot. The individual policy specifies the individually optimal path from each point in the free configuration space of a robot to its goal configuration, neglecting the presence of other robots. The path of the multirobot system induced by each robot obeying its individual policy is termed the joint policy path. Robot–robot collisions are likely present in the joint policy path.</paragraph><paragraph>Subdimensional expansion then uses the individual policies to guide the construction of a search space of variable dimensionality, embedded in the joint configuration space of the system, in which to coordinate the motion of the multirobot system and resolve any conflicts. Subdimensional expansion makes the optimistic assumption that the joint policy path is collision free until there is evidence otherwise, and thus each robot is initially restricted to obeying its individual policy. The resulting search space is one-dimensional, as the only free parameter is for how long to follow the individual policies, and planning is fully decoupled, i.e. each robot follows an independently computed plan. An underlying planner, such as {a mathematical formula}A⁎, is then employed to find an optimal path in the search space. When the underlying planner encounters a robot–robot collision, the involved robots are permitted to diverge from their individual policies, locally increasing the dimensionality of the search space. In the region of increased dimensionality, planning is conducted as a search over the joint actions of the robots involved in the collision, i.e. coupled planning for those robots.</paragraph><paragraph>Two constructs, the backpropagation set and the collision set, are employed to ensure that the search space is only expanded where and as much as necessary. Subdimensional expansion only expands the search space when the underlying planner finds a collision, but to ensure that a path can be found the search space must be expanded along all paths explored by the underlying planner that lead to the collision. The backpropagation set is used to propagate information about a collision back along all explored paths leading to the collision. The backpropagation set of a point q in the search space is the set of all points for which the underlying planner has considered q as a possible successor. For instance, if the underlying planner is {a mathematical formula}A⁎, when a vertex is expanded it is added to the backpropagation set of each of its out-neighbors, whereas if RRT is employed as the underlying planner the backpropagation set of a configuration contains its parent in the search tree.</paragraph><paragraph>Subdimensional expansion uses the collision set to aggregate information about collisions and to determine the local dimensionality of the search space. The collision set C of a given point q in the search space is the set of robots involved in a collision either at q or at some point on a path passing through q that has been explored by the underlying planner. If a configuration has not been visited by the underlying planner, its collision set is empty. The collision set is computed using the backpropagation set. If the collision set {a mathematical formula}Ck of a configuration {a mathematical formula}qk changes, including the first time the underlying planner visits a configuration at which a robot–robot collision occurs, then the robots in {a mathematical formula}Ck are added to the collision set of each point in the backpropagation set of {a mathematical formula}qk. In addition, if a new configuration {a mathematical formula}ql is added to the backpropagation set of {a mathematical formula}qk, then the robots in {a mathematical formula}Ck are added to {a mathematical formula}Cl. Note that the above rules imply that the collision set is a function of the current state of search, and the collision set of any given point in the search space will only grow as the search progresses.</paragraph><paragraph>Robots in the collision set are known to collide with other robots if restricted to their individually optimal paths, but there is no evidence that robots outside the collision set will collide while obeying their individual policies. Therefore to ensure that a collision-free path can be found, the search space must include any possible joint action for the robots in the collision set, while the robots not in the collision set obey their individual policies. The result is a local increase in the dimensionality of the search space, but the search space will likely still be of lower dimensionality than the joint configuration space in which the search space is embedded. Because the search space is embedded in the joint configuration space, each point in the search space fully defines the configuration of the system, regardless of the local dimensionality of the search space. A locally low dimensional search space just restricts which paths of the system will be explored by the underlying planner.</paragraph><paragraph>Although the search space constructed by subdimensional expansion is embedded in a high-dimensional space and is thus hard to visualize, the geometry of the search space can still be succinctly described, and provides an alternate way of understanding subdimensional expansion. The search space will have the appearance of a set of elongated “tubes” of decreasing dimensionality embedded in the joint configuration space, extending from the initial configuration towards the goal (Fig. 1). Each tube grows around an explored path or set of paths that lead to a robot–robot collision, and thus the interior of each tube consists of states with non-empty collision sets. The surface of each tube are covered with one-dimensional “hairs” that extend towards the goal. Each hair is the joint policy path leading from a state on the surface of the tube with an empty collision set to the goal. The search space starts as a single hair, which thickens and branches as robot–robot collisions are found.</paragraph><paragraph>To better illustrate the workings of subdimensional expansion, we present an example for multirobot path planning on graphs. Planning is done using the {a mathematical formula}M⁎ algorithm, an implementation of subdimensional expansion that uses {a mathematical formula}A⁎ as the underlying planner. {a mathematical formula}M⁎ will be described in detail in Section 4, but for the purposes of this example, {a mathematical formula}M⁎ can be described as being equivalent to running {a mathematical formula}A⁎ on a small search graph which grows every time a robot–robot collision is found.</paragraph><paragraph>Consider a team of three robots, {a mathematical formula}r1,r2,r3, which move on a graph representing a 4 connected grid. The X coordinates of the graph labeled with letters, while the Y coordinates are labeled with numbers. Robot {a mathematical formula}r1 starts at the initial configuration {a mathematical formula}vs1=A1 and has the goal {a mathematical formula}vf1=B2. Robots {a mathematical formula}r2 and {a mathematical formula}r3 have initial configurations {a mathematical formula}vs2=C1 and {a mathematical formula}vs3=A3, and goal configurations {a mathematical formula}vf2=B2 and {a mathematical formula}vf3=C3 respectively (Fig. 2). The initial configuration of the multirobot system is denoted {a mathematical formula}(A1,C1,A3), while the goal configuration is {a mathematical formula}(B2,B1,C3). The robots incur a cost of 1 for any action, including remaining in place, but the robots can wait at their goal for zero cost.</paragraph><paragraph>Subdimensional expansion begins by computing an individual policy for each robot (Fig. 3). The choice of policies is not unique. For instance, an alternate policy for {a mathematical formula}r1 would be to move up from A1 rather than right. Choice of individual policies is discussed in Section 5.4.</paragraph><paragraph>Once the individual policies are computed, search for the multirobot system can commence. {a mathematical formula}M⁎ maintains an open list of candidate nodes which are explored in order of f-value, the sum the cost to reach a node and a heuristic cost-to-go. When search begins the open list only contains the initial configuration, with an empty collision set (Fig. 4). An empty collision set means that every robot obeys its individual policy. Therefore, when the initial configuration is expanded, there is only one neighbor, {a mathematical formula}(B1,B1,B3) (Fig. 4a). At {a mathematical formula}(B1,B1,B3) robots {a mathematical formula}r1 and {a mathematical formula}r2 are in collision, which triggers a collision set update. The initial configuration is in the backpropagation set of {a mathematical formula}(B1,B1,B3) (Fig. 4b), so {a mathematical formula}r1 and {a mathematical formula}r2 are added to the collision set of the initial configuration, which implicitly modifies the search graph. To allow the modified search graph to be explored, the initial configuration is added back to the open list (Section 4.2).</paragraph><paragraph>In the second iteration of {a mathematical formula}M⁎, the initial configuration is once more taken from the open list, and expanded (Fig. 5). This time, {a mathematical formula}r1 and {a mathematical formula}r2 are in the collision set of the initial configuration, so only {a mathematical formula}r3 is restricted to its individual policy. As a result, the initial configuration now has nine neighbors (Fig. 5a), including {a mathematical formula}(B1,B1,B3). The backpropagation set of each neighbor contains only the initial configuration, as the only paths that have been explored lead from the initial configuration to one of its neighbors (Fig. 5b). The initial configuration has an empty backpropagation set, because no paths have been explored that lead to the initial configuration, and thus collisions at one of the neighbors cannot be propagated to the collision set of a different neighbor. The only robot–robot collision occurs at {a mathematical formula}(B1,B1,B3), and the involved robots have already been added to the collision set of the initial configuration, the only state in the backpropagation set of {a mathematical formula}(B1,B1,B3). Therefore, no further modification of the collision sets is required. The collision-free neighbors are then added to the open list and sorted by f-value.</paragraph><paragraph>In the third iteration, the most promising vertex is {a mathematical formula}(A2,B1,B3) (Fig. 6). {a mathematical formula}(A2,B1,B3) was never previously expanded, and thus has an empty collision set, and therefore a single neighbor {a mathematical formula}(B2,B1,C3), the goal configuration. The goal configuration is collision free, and thus is added to open list. Note that in the counterfactual case that the neighbor of {a mathematical formula}(A2,B1,B3) had contained a robot–robot collision, the involved robots would be added to the collision sets of both {a mathematical formula}(A2,B1,B3) and {a mathematical formula}(A1,C1,A3).</paragraph><paragraph>In the fourth iteration, the goal configuration has the lowest f-value of any vertex in the open list, and is thus expanded (Fig. 7), which indicates that the optimal path has been found.</paragraph></section><section label="4">{a mathematical formula}M⁎<paragraph>In this section the {a mathematical formula}M⁎ algorithm will be described in detail. {a mathematical formula}M⁎ is an implementation of subdimensional expansion for multirobot path planning when the configuration space of each robot can be described by a graph. {a mathematical formula}M⁎ uses {a mathematical formula}A⁎[1] as the underlying planner, because {a mathematical formula}A⁎ is optimal, meaning it finds optimal paths, and complete, meaning that it will take finite time to either find a path or determine that no path exists. {a mathematical formula}M⁎ will be shown to have the same optimality and completeness properties as {a mathematical formula}A⁎. The section will end with a discussion of the performance of {a mathematical formula}M⁎.</paragraph><section label="4.1"><section-title>Problem definition</section-title><paragraph>Consider a system of n robots {a mathematical formula}ri indexed by the set {a mathematical formula}I={1,…,n}. Let the free configuration space of {a mathematical formula}ri be represented by the directed graph {a mathematical formula}Gi={Vi,Ei}. {a mathematical formula}Vi is the set of vertices in {a mathematical formula}Gi, each of which represents a configuration of {a mathematical formula}ri. {a mathematical formula}Ei is the set of directed edges, each of which represents an action that transitions {a mathematical formula}ri from one configuration to another. Each edge is associated with a non-negative cost. Each robot has an initial configuration {a mathematical formula}vsi∈Vi and a goal configuration {a mathematical formula}vfi∈Vi.</paragraph><paragraph>The joint configuration space which describes the state of the entire multirobot system is represented by the tensor product of the individual robot graphs {a mathematical formula}G=G1×⋯×Gn, with vertex set V and edge set E. Recall that the tensor product of two graphs, {a mathematical formula}Gi×Gj, has the vertex set {a mathematical formula}Vi×Vj. Two vertices {a mathematical formula}(vki,vkj) and {a mathematical formula}(vli,vlj) in {a mathematical formula}Vi×Vj are connected by an edge in the product graph if the edge {a mathematical formula}ekli connecting {a mathematical formula}vki to {a mathematical formula}vli is present in {a mathematical formula}Ei and the edge {a mathematical formula}eklj connecting {a mathematical formula}vkj to {a mathematical formula}vlj is present in {a mathematical formula}Ej. Note that G may contain vertices at which robots collide.</paragraph><paragraph>Let {a mathematical formula}Πi denote the set of all valid paths in {a mathematical formula}Gi, where a valid path consists of a sequence of vertices such that each vertex in the sequence is an out-neighbor of its predecessor in {a mathematical formula}Gi. {a mathematical formula}Π=Π1×⋯×Πn denotes the set of all paths in G. Let {a mathematical formula}πi(vk,vl) denote a path in {a mathematical formula}Gi from {a mathematical formula}vk to {a mathematical formula}vl. The cost of a single robot path {a mathematical formula}gi:Πi↦R+ is the sum of the costs of the edges traversed in the path. The cost {a mathematical formula}g:Π↦R+ of a path {a mathematical formula}π(vk,vl) in G is the sum of the costs of the corresponding single robot paths {a mathematical formula}πi(vki,vli), where {a mathematical formula}vki is the position of {a mathematical formula}ri at the joint configuration {a mathematical formula}vk,{a mathematical formula}</paragraph><paragraph>The task of {a mathematical formula}M⁎ is to find an optimal, collision-free path from the joint initial configuration {a mathematical formula}vs=vs1×⋯×vsn to the joint goal configuration {a mathematical formula}vf=vf1×⋯×vfn, denoted {a mathematical formula}π⁎(vs,vf). To determine where robots collide with one another, we define a collision function {a mathematical formula}Ψ:V→P(I) which returns the set of robots in collision at a given vertex, with {a mathematical formula}P(I) denoting the power set of I which contains all subsets of I. What constitutes a collision depends on the problem instance being solved, and may represent a physical collision, a contention for a shared resource, or some other conflict. Note that {a mathematical formula}Ψ(vk) describes the robots which are locally in collision at {a mathematical formula}vk, whereas {a mathematical formula}Ck collects all collisions occurring at a successor of {a mathematical formula}vk on some path explored by the underlying {a mathematical formula}A⁎ planner, thus {a mathematical formula}Ψ(vk)⊆Ck. For the purpose of description, only collisions at vertices will be considered, as collisions taking place during the traversal of edges can be modeled by inserting additional vertices into the graph.</paragraph><paragraph>The notation in this paper can get complex, due to the number of different objects that the text must describe, and the number of different spaces in which said objects may lie. To make the notation more comprehensible, a standard format is employed. The symbol {a mathematical formula}xzy refers to an object of type x, where z is a label for the specific object instance, and {a mathematical formula}y⊂I is robot or set of robots which are described by x. For instance, {a mathematical formula}vki refers to a vertex k describing the configuration of robot {a mathematical formula}ri. The symbols {a mathematical formula}xki and {a mathematical formula}xkj refer to the components of {a mathematical formula}xk describing robots i and j respectively. The symbols {a mathematical formula}i,j,k and l are reserved for short term indexing, and are reused throughout the paper in different contexts. The definitions of symbols used in the problem definition are summarized in Table 1.</paragraph></section><section label="4.2"><section-title>Algorithmic description</section-title><paragraph>{a mathematical formula}M⁎ is broadly similar to {a mathematical formula}A⁎[1] in implementation. The primary difference is that {a mathematical formula}M⁎ restricts the set of possible successors of a vertex based on the collision set. Only robots in the collision set are allowed to consider any possible action; all other robots must obey their individual policies (Fig. 4, Fig. 5, Fig. 6, Fig. 7). A more detailed description follows.</paragraph><paragraph>{a mathematical formula}M⁎ is most easily described as a set of modifications to {a mathematical formula}A⁎. Recall that {a mathematical formula}A⁎ maintains an open list of vertices {a mathematical formula}vk to explore. Each vertex represents one point in the joint configuration space of the multirobot system, specifying the configuration of every robot. These are sorted by f-value, which is the sum of a g-value and a heuristic cost. The g-value is the cost of the cheapest path to {a mathematical formula}vk found thus far, and is therefore an upper bound on {a mathematical formula}g(π⁎(vs,vk)). The heuristic cost, {a mathematical formula}h(vk), is a lower bound on the cost of the optimal path from {a mathematical formula}vk to the goal, i.e.{a mathematical formula}h(vk)≤g(π⁎(vk,vf)). At each iteration, the vertex {a mathematical formula}vk with the smallest f-value in the open list is expanded. Each neighbor {a mathematical formula}vl of {a mathematical formula}vk is added to the open list if the path reaching {a mathematical formula}vl via {a mathematical formula}vk is cheaper than the current g-value of {a mathematical formula}vl. The process continues until the goal vertex {a mathematical formula}vf is expanded, which indicates that an optimal path to the goal has been found for the multirobot system.</paragraph><paragraph>Prior to planning for the multirobot system, {a mathematical formula}M⁎ computes the individual policies {a mathematical formula}ϕi:Vi→Vi for each robot, where {a mathematical formula}ϕi(vi) is the successor of {a mathematical formula}vi along the minimal cost path to {a mathematical formula}vfi for robot {a mathematical formula}ri, ignoring robot–robot interactions. {a mathematical formula}ϕi can be efficiently computed by Reverse Resumable {a mathematical formula}A⁎[8]. The path induced by {a mathematical formula}ϕi from {a mathematical formula}vi is denoted {a mathematical formula}πϕi(vi,vfi). The joint policy {a mathematical formula}ϕ:V→V moves each individual robot along its individual policy, with the joint policy path induced by ϕ from v denoted {a mathematical formula}πϕ(v,vf). Computing the individual policies permits the efficient computation of the highly informative Sum of Individual Costs (SIC) heuristic, which is commonly employed for multirobot path planning [14], [2], [12]. The SIC heuristic evaluated at {a mathematical formula}vk is the sum of the costs of the individually optimal paths of all robots{a mathematical formula}</paragraph><paragraph>The primary difference in implementation between {a mathematical formula}M⁎ and {a mathematical formula}A⁎ lies in the expansion step: while {a mathematical formula}A⁎ considers all neighbors of a vertex {a mathematical formula}vk for addition to the open list, {a mathematical formula}M⁎ only considers a subset of the neighbors of {a mathematical formula}vk, denoted the limited neighbors. The limited neighbors {a mathematical formula}Vknbh are the set of neighbors of {a mathematical formula}vk which can be reached from {a mathematical formula}vk when each robot not in the collision set {a mathematical formula}Ck of {a mathematical formula}vk moves according to its individual policy. A robot in the collision set of {a mathematical formula}vk is allowed to move to any neighboring state in the robots individual graph {a mathematical formula}Gi. More formally, the limited neighbors {a mathematical formula}Vknbh are the set of neighbors {a mathematical formula}vl of {a mathematical formula}vk such that the i'th component of {a mathematical formula}vl satisfies one of two properties: i) if {a mathematical formula}i∈Ck then {a mathematical formula}vli is an out-neighbor of {a mathematical formula}vki, or ii) if {a mathematical formula}i∉Ck then {a mathematical formula}vli is the individually optimal successor of {a mathematical formula}vki according to {a mathematical formula}ϕi. If there is a robot–robot collision at {a mathematical formula}vk then {a mathematical formula}Vknbh=∅ to prevent paths from passing through collisions.{a mathematical formula}</paragraph><paragraph>The collision sets of each vertex must be updated whenever {a mathematical formula}M⁎ finds a new path to a robot–robot collision. To this end, {a mathematical formula}M⁎ maintains a backpropagation set for each vertex {a mathematical formula}vk, which is the set of all vertices {a mathematical formula}vl that were expanded while {a mathematical formula}vk was an element of {a mathematical formula}Vlnbh. The backpropagation set is thus the set of neighbors of {a mathematical formula}vk through which the planner has explored a path to {a mathematical formula}vk. {a mathematical formula}M⁎ propagates information about a collision at {a mathematical formula}vk by adding the robots in {a mathematical formula}Ψ(vk) to the collision set of each vertex {a mathematical formula}vl in the backpropagation set of {a mathematical formula}vk. The robots in {a mathematical formula}Cl are then added to the collision set of each vertex in the backpropagation set of {a mathematical formula}vl, with the process repeating recursively until a vertex {a mathematical formula}vm is reached with {a mathematical formula}Ψ(vk)⊆Cm. Because {a mathematical formula}Vlnbh is dependent on {a mathematical formula}Cl, changing {a mathematical formula}Cl adds new paths through {a mathematical formula}vl to the search space. To allow these new paths to be explored, {a mathematical formula}vl is added to the open list (Algorithm 1). The meanings of symbols used to describe {a mathematical formula}M⁎ are summarized in Table 2. Pseudocode for {a mathematical formula}M⁎ is provided in Algorithm 2.</paragraph></section><section label="4.3"><section-title>Completeness and cost optimality</section-title><paragraph>In this section, {a mathematical formula}M⁎ will be shown to be both complete and optimal. The description of {a mathematical formula}M⁎ given in Section 4.2 is well suited to implementation, but provides only a local description of the operation of {a mathematical formula}M⁎, which is not optimal for proving global properties. In the following subsection, a global description of {a mathematical formula}M⁎ is provided which is more suited to proving properties of the {a mathematical formula}M⁎ algorithm, with a focus on the search space that is constructed by {a mathematical formula}M⁎. {a mathematical formula}M⁎ will be shown to be equivalent to alternating between running {a mathematical formula}A⁎ on a search graph, and expanding the search graph based on collisions found by {a mathematical formula}A⁎. As a result, demonstrating that the construction of the search graph takes finite time and that the search graph will eventually contain the optimal path, if extant, is sufficient to prove that {a mathematical formula}M⁎ is complete and optimal.</paragraph><section label="4.3.1"><section-title>Alternative graph-centric description</section-title><paragraph>{a mathematical formula}M⁎ differs from {a mathematical formula}A⁎ solely in the use of the limited neighbors when expanding a vertex and the presence of the backprop function (Algorithm 1). The backprop function does nothing unless a new path to a collision is found. Therefore, between discoveries of new paths to collisions, {a mathematical formula}M⁎ behaves exactly like {a mathematical formula}A⁎ running on a search graph {a mathematical formula}Gsch which is a subgraph of the configuration graph G that represents the joint configuration space.</paragraph><paragraph>The search graph {a mathematical formula}Gsch consists of three subgraphs: the explored graph{a mathematical formula}Gexp, the neighbor graph{a mathematical formula}Gnbh, and the policy graph{a mathematical formula}Gϕ (Table 3). {a mathematical formula}Gexp is the portion of G which has been searched by {a mathematical formula}M⁎, {a mathematical formula}Gnbh represents the limited neighbors of the vertices in {a mathematical formula}Gexp, and {a mathematical formula}Gϕ consists of the paths induced by ϕ that connect vertices in {a mathematical formula}Gnbh to {a mathematical formula}vf. Only {a mathematical formula}Gexp is explicitly constructed, with {a mathematical formula}Gnbh and {a mathematical formula}Gϕ being implicitly defined by {a mathematical formula}Gexp and the collision sets of the vertices in {a mathematical formula}Gexp.</paragraph><paragraph>We now describe the explored graph {a mathematical formula}Gexp, neighbor graph {a mathematical formula}Gnbh, and policy graph {a mathematical formula}Gϕ in greater detail. The vertex set of {a mathematical formula}Gexp consists of all vertices which have been added to the open list. When a vertex {a mathematical formula}vk∈Gexp is expanded, its limited neighbors {a mathematical formula}Vknbh are added to the open list, and thus to the vertex set of {a mathematical formula}Gexp. The edges connecting {a mathematical formula}vk to each of its limited neighbors are added to the edge set of {a mathematical formula}Gexp.</paragraph><paragraph>The collision set of a vertex is a function of the paths that have been explored by the underlying planner. {a mathematical formula}Gexp contains all such paths, and therefore encodes all the information required to compute the collision set of any vertex {a mathematical formula}vk.{a mathematical formula} where {a mathematical formula}Vk={vl|∃π(vk,vl)⊆Gexp} is the set of vertices to which there exists a path from {a mathematical formula}vk in {a mathematical formula}Gexp. If {a mathematical formula}vk∉Gexp, then {a mathematical formula}M⁎ has never visited {a mathematical formula}vk, and thus {a mathematical formula}vk has not been explicitly constructed and thus {a mathematical formula}Ψ(vk) has not yet been computed. In accordance to the optimistic assumption, {a mathematical formula}vk is assumed to be collision-free, and {a mathematical formula}Ck is initialized as the empty set. Therefore, a path in {a mathematical formula}Gsch may contain a vertex {a mathematical formula}vk in {a mathematical formula}Gsch∖Gexp at which robots collide. However, {a mathematical formula}vk must be added to the open list, and thus to {a mathematical formula}Gexp, before any such path could be returned. At that point, {a mathematical formula}Ψ(vk) would be computed, leading to the out-neighbors of {a mathematical formula}vk being removed from {a mathematical formula}Gsch, as per the definition of the limited neighbors.</paragraph><paragraph>The neighbor graph {a mathematical formula}Gknbh is the subgraph of the configuration graph {a mathematical formula}Gsch that represents the limited neighbors of {a mathematical formula}vk∈Gexp. {a mathematical formula}Gknbh contains {a mathematical formula}vk, {a mathematical formula}Vknbh, and the edges leading from {a mathematical formula}vk to the vertices in {a mathematical formula}Vknbh. Let {a mathematical formula}Gnbh=⋃vk∈GexpGknbh, and therefore {a mathematical formula}Gexp⊂Gnbh.</paragraph><paragraph>Because {a mathematical formula}Ck=∅ for all {a mathematical formula}vk which are not in the explored graph {a mathematical formula}Gexp, search from {a mathematical formula}vk∈Gnbh∖Gexp will proceed along {a mathematical formula}πϕ(vk,vf) until either {a mathematical formula}vf or a vertex in {a mathematical formula}Gexp{sup:4} is reached. The resulting path segment is denoted {a mathematical formula}πϕ(vk), and is represented as a subgraph {a mathematical formula}Gkϕ, whose vertex set is the set of vertices in {a mathematical formula}πϕ(vk), and whose edge set contains each edge connecting a vertex in {a mathematical formula}πϕ(vk) to its successor. Let the policy graph be defined as {a mathematical formula}Gϕ=⋃vk∈Gnbh∖GexpGkϕ.</paragraph><paragraph>{a mathematical formula}Gsch can now be defined as the union of {a mathematical formula}Gexp, the subgraph explored by {a mathematical formula}M⁎; {a mathematical formula}Gnbh, the limited neighbors of vertices in {a mathematical formula}Gexp, and {a mathematical formula}Gϕ, the individually optimal paths connecting vertices in {a mathematical formula}Gnbh∖Gexp to {a mathematical formula}vf. By the definitions of {a mathematical formula}Gexp, {a mathematical formula}Gnbh and {a mathematical formula}Gϕ, vertices and edges shift from {a mathematical formula}Gϕ to {a mathematical formula}Gnbh, and from {a mathematical formula}Gnbh to {a mathematical formula}Gexp as search progresses. However, {a mathematical formula}Gsch as a whole only changes when the collision set of a vertex in {a mathematical formula}Gsch changes. See Fig. 8 for an illustration of how the subgraphs change over time.</paragraph></section><section label="4.3.2"><section-title>Proof of optimality and completeness</section-title><paragraph>As demonstrated in the previous section, {a mathematical formula}M⁎ can be treated as alternating between exploring the search graph {a mathematical formula}Gsch with {a mathematical formula}A⁎ and modifying {a mathematical formula}Gsch based on the partial search results. Because {a mathematical formula}A⁎ is complete and optimal [1], {a mathematical formula}M⁎ is complete and optimal if {a mathematical formula}Gsch will contain {a mathematical formula}π⁎(vs,vf) and no cheaper path after a finite number of modifications or, if {a mathematical formula}π⁎(vs,vf) does not exist, {a mathematical formula}Gsch will be modified at most a finite number of times.</paragraph><paragraph>We proceed by showing that if no solution exists, {a mathematical formula}M⁎ will terminate in finite time without returning a path. We then show that {a mathematical formula}M⁎ will eventually find the optimal path if one of two conditions always hold: {a mathematical formula}Gsch contains the optimal path, or {a mathematical formula}Gsch contains an unexplored path containing a robot–robot collision which costs no more than the optimal path. We complete the proof by showing that at least one of the two conditions always holds.</paragraph><paragraph label="Lemma 1">If no solution exists,{a mathematical formula}M⁎will terminate in finite time without returning a path.</paragraph><paragraph label="Proof">Assume no solution exists. As part of {a mathematical formula}M⁎, {a mathematical formula}A⁎ is run on the search graph {a mathematical formula}Gsch. {a mathematical formula}A⁎ will explore all of {a mathematical formula}Gsch in finite time and conclude that no solution exists, except if the {a mathematical formula}A⁎ search is interrupted by a modification of {a mathematical formula}Gsch. {a mathematical formula}Gsch is only modified when the collision set of at least one vertex in {a mathematical formula}Gsch is changed. Each modification adds one or more robots to the collision set, and thus each collision set can be modified at most {a mathematical formula}n−1 times; the first modification must add at least two robots. Therefore, {a mathematical formula}Gsch can be modified at most {a mathematical formula}(n−1)⁎|V| times. Thus if no solution exists, {a mathematical formula}M⁎ will always terminate in finite time.We now show that {a mathematical formula}M⁎ will never return an invalid path containing a robot–robot collision. A vertex {a mathematical formula}vk has out-neighbors only if it is collision free, unless {a mathematical formula}vk is not in the explored graph {a mathematical formula}Gexp. Before {a mathematical formula}M⁎ will return a path passing through {a mathematical formula}vk, {a mathematical formula}vk must be added to the open list, and thus to {a mathematical formula}Gexp. When {a mathematical formula}vk which is not collision free is added to the open list, {a mathematical formula}Gsch is modified to remove all out-neighbors of {a mathematical formula}vk, which removes any path passing through {a mathematical formula}vk from {a mathematical formula}Gsch. Therefore, {a mathematical formula}M⁎ will never return a path passing through a state at which robots collide. Thus, if no solution exists, {a mathematical formula}M⁎ will terminate in finite time without returning a path.  □</paragraph><paragraph>Next, assume that an optimal collision-free path from {a mathematical formula}vs to {a mathematical formula}vf exists, i.e. the configuration graph G contains an optimal path {a mathematical formula}π⁎(vs,vf).</paragraph><paragraph label="Lemma 2">If an optimal path exists,{a mathematical formula}M⁎will find the optimal path in finite time if one of two cases always hold</paragraph><list><list-item>The search graph{a mathematical formula}Gschcontains an optimal path,{a mathematical formula}π⁎(vs,vf).</list-item><list-item>The search graph{a mathematical formula}Gschcontains a path{a mathematical formula}π(vs,vc)such that{a mathematical formula}g(π(vs,vc))+h(vc)≤g(π⁎(vs,vf)), and{a mathematical formula}∃vb∈π(vs,vc)such that{a mathematical formula}Ψ(vc)⊈Cb.</list-item></list><paragraph>Case 2 implies the existence of a path which has not been explored by {a mathematical formula}M⁎ that leads to a robot–robot collision at {a mathematical formula}vc, and which costs no more than {a mathematical formula}π⁎(vs,vf). If the path had been explored, {a mathematical formula}vb and {a mathematical formula}vc would have been added to the open list and thus to the explored graph {a mathematical formula}Gexp. In this case, {a mathematical formula}Cb would include all robots involved in the collision at {a mathematical formula}vc, i.e. the robots in {a mathematical formula}Ψ(vc).</paragraph><paragraph>To prove Lemma 2, we proceed by showing that if case 1 holds, the optimal path will be found unless a cheaper path containing a collision exists in the search graph {a mathematical formula}Gsch, i.e., case 2 holds (Lemma 3). We then show that {a mathematical formula}M⁎ will never explore a suboptimal path to the goal as long as case 2 holds (Lemma 4), and that case 2 will not hold after finite time (Lemma 5). We conclude by proving that either case 1 or case 2 will always hold, demonstrating that the optimal path will be found (Lemma 7).</paragraph><paragraph label="Lemma 3">If the search graph{a mathematical formula}Gschcontains an optimal path (i.e. case 1 holds),{a mathematical formula}M⁎will find the optimal path, unless case 2 also holds.</paragraph><paragraph label="Proof">If case 1 holds, running {a mathematical formula}A⁎ on {a mathematical formula}Gsch will find {a mathematical formula}π⁎(vs,vf) in finite time, unless there exists a cheaper path {a mathematical formula}πcheaper(vs,vf)⊆Gsch, which we now show would satisfy the conditions for case 2 to hold. Because {a mathematical formula}π⁎(vs,vf) is a minimal cost collision-free path, {a mathematical formula}πcheaper(vs,vf) must contain a robot–robot collision. Therefore a vertex {a mathematical formula}vk∈πcheaper(vs,vf) must exist such that {a mathematical formula}Ψ(vk)≠∅, and by (2){a mathematical formula}g(πcheaper(vs,vk))+h(vk)&lt;g(π⁎(vs,vf)). The existence of a path through {a mathematical formula}vk implies that {a mathematical formula}vk∉Gexp, as a vertex containing robot–robot collisions has its outneighbors removed when added to the explored graph {a mathematical formula}Gexp. Therefore, {a mathematical formula}Ck=∅ by (4). Since {a mathematical formula}Ψ(vk)⊈Ck, {a mathematical formula}vk fulfills the roles of both {a mathematical formula}vb and {a mathematical formula}vc in the definition of case 2. As a result, if case 1 holds, {a mathematical formula}M⁎ will find {a mathematical formula}π⁎(vs,vf), unless case 2 also holds.{sup:5}  □</paragraph><paragraph label="Lemma 4">If the search graph{a mathematical formula}Gschcontains an unexplored path cheaper than{a mathematical formula}g(π⁎(vs,vf))(i.e. case 2 holds),{a mathematical formula}M⁎will not return a suboptimal path.</paragraph><paragraph label="Proof">If case 2 holds, then {a mathematical formula}π(vs,vc) will be explored by {a mathematical formula}A⁎ and added to the explored graph {a mathematical formula}Gexp before {a mathematical formula}A⁎ finds any path to {a mathematical formula}vf that costs more than {a mathematical formula}g(π⁎(vs,vf))[1]. Adding {a mathematical formula}π(vs,vc) to {a mathematical formula}Gexp will modify {a mathematical formula}Cb. {a mathematical formula}Gsch will then be modified to reflect the new limited neighbors of {a mathematical formula}vb and {a mathematical formula}A⁎ will be restarted. Therefore, {a mathematical formula}M⁎ will never return a suboptimal path as long as case 2 holds. □</paragraph><paragraph label="Lemma 5">The search graph{a mathematical formula}Gschwill cease to contain any unexplored path cheaper{a mathematical formula}g(π⁎(vs,vf))(i.e. case 2 will cease to hold) after finite time.</paragraph><paragraph label="Proof">For case 2 to hold, there must be at least one vertex {a mathematical formula}vb such that {a mathematical formula}Cb is a strict subset of I. {a mathematical formula}Gsch can be modified at most {a mathematical formula}(n−1)⁎|V| times before all collision sets are equal to I. Therefore, after a finite number of modifications of {a mathematical formula}Gsch case 2 cannot hold. {a mathematical formula}A⁎ will fully explore any finite graph in finite time, implying that the time between any two successive modifications of {a mathematical formula}Gsch is finite. Therefore, case 2 will not hold after finite time. □</paragraph><paragraph>With these auxiliary results in hand, the proof of Lemma 2 is as follows. If case 1 holds, then {a mathematical formula}M⁎ will find the optimal path in finite time, unless case 2 also holds (Lemma 3). While case 2 holds, {a mathematical formula}M⁎ will not return a suboptimal path (Lemma 4), and case 2 cannot hold after finite time (Lemma 5). Therefore, after finite time, only case 1 will hold, implying that {a mathematical formula}M⁎ will find the optimal path in finite time.</paragraph><paragraph>To complete the proof of the completeness and optimality of {a mathematical formula}M⁎, we must show that case 1 or case 2 will always hold. To do so, we first need an auxiliary result (Lemma 6) showing that the optimal path for some subset of robots costs no more than the joint path taken by those robots in the optimal, joint path for the entire set of robots. The auxiliary result is used to demonstrate that an optimal path can be found by combining optimal paths for disjoint subsets of robots.</paragraph><paragraph>Let {a mathematical formula}πΩ′(vk,vf) be the path constructed by combining the optimal path for a subset {a mathematical formula}Ω⊂I of robots with the individually optimal paths for the robots in {a mathematical formula}I∖Ω.</paragraph><paragraph label="Lemma 6">If the configuration graph contains an optimal path{a mathematical formula}π⁎(vk,vf), then{a mathematical formula}∀Ω⊂I,{a mathematical formula}g(πΩ′(vk,vf))≤g(π⁎(vk,vf). Furthermore, if{a mathematical formula}Ω1⊂Ω2, then{a mathematical formula}g(πΩ1′(vk,vf))≤g(πΩ2′(vk,vf)).</paragraph><paragraph label="Proof">If {a mathematical formula}π⁎(vk,vf) from an arbitrary {a mathematical formula}vk to {a mathematical formula}vf exists in G, then for any subset of robots Ω there exists an optimal path {a mathematical formula}π⁎Ω(vkΩ,vfΩ) which costs no more than the path taken by those robots in {a mathematical formula}π⁎(vk,vf). Let {a mathematical formula}Ω¯=I∖Ω be the complement of Ω and {a mathematical formula}πϕΩ¯(vkΩ¯,vfΩ¯) be the path for the robots in {a mathematical formula}Ω¯ induced by each robot obeying its individual policy. {a mathematical formula}πϕΩ¯(vkΩ¯,vfΩ¯) costs no more than the paths taken by the robots in {a mathematical formula}Ω¯ in {a mathematical formula}π⁎(vk,vf) by the construction of the individual policies. A path for all robots in I, {a mathematical formula}πΩ′(vk,vf), is then constructed by having each robot in Ω follow its path in {a mathematical formula}π⁎Ω(vkΩ,vfΩ), while each robot in {a mathematical formula}Ω¯ follows its path in {a mathematical formula}πϕΩ¯(vkΩ¯,vfΩ¯). Since the individual path for each robot in {a mathematical formula}πΩ′(vk,vf) costs no more than the path for the same robot in {a mathematical formula}π⁎(vk,vf), {a mathematical formula}g(πΩ′(vk,vf))≤g(π⁎(vk,vf)). By the same logic, if {a mathematical formula}Ω1⊆Ω2, then {a mathematical formula}g(πΩ1′(vk,vf))≤g(πΩ2′(vk,vf)). □</paragraph><paragraph label="Proof">The search graph{a mathematical formula}Gschwill always contain an optimal path (i.e. case 1 will hold) or an unexplored path which costs no more than the optimal path (i.e. case 2 will hold) at all points in the execution of{a mathematical formula}M⁎.We proceed by showing that the limited neighbors of each vertex in {a mathematical formula}Gsch are sufficient to construct either the optimal path, or some unexplored, no more expensive path. Consider the vertex {a mathematical formula}vk∈Gsch with collision set {a mathematical formula}Ck. The successor of {a mathematical formula}vk in {a mathematical formula}πCk′(vk,vf), {a mathematical formula}vl, is a limited neighbor of {a mathematical formula}vk by the definition of the limited neighbors (2). Since {a mathematical formula}Cl⊆Ck by (4), Lemma 6 implies{a mathematical formula} We apply the above bound vertex by vertex from the initial vertex to show that a path {a mathematical formula}π″(vs,vf)∈Gsch can be constructed which satisfies either case 1 or case 2. The successor of the m'th vertex {a mathematical formula}vm in {a mathematical formula}π″(vs,vf) is the successor of {a mathematical formula}vm in {a mathematical formula}πCm′(vm,vf). Applying (5) gives the bound {a mathematical formula}g(π″(vs,vf))≤g(πCs′(vs,vf))≤g(π⁎(vs,vf)). If {a mathematical formula}π″(vs,vf)=π⁎(vs,vf) then case 1 is satisfied. Otherwise, there is a vertex {a mathematical formula}vc∈π″(vs,vf) such that {a mathematical formula}Ψ(vc)≠∅. Let {a mathematical formula}vb be the predecessor of {a mathematical formula}vc, which implies that {a mathematical formula}vc lies in {a mathematical formula}πCb′(vb,vf). Then {a mathematical formula}Ψ(vc)⊈Cb, because by construction the robots in {a mathematical formula}Cb do not collide with one another in {a mathematical formula}πCb′(vb,vf). By (2), {a mathematical formula}g(π″(vs,vc))+h(vc)≤g(π″(vs,vf))≤g(π⁎(vs,vf)), which implies case 2 is satisfied.There is an edge case which must be considered if case 1 does not hold. If {a mathematical formula}π″(vs,vf) contains a vertex {a mathematical formula}vk∉Gexp with a successor {a mathematical formula}vl∈Gexp, {a mathematical formula}Cl may not be a subset of {a mathematical formula}Ck, because no path exists from {a mathematical formula}vk to {a mathematical formula}vl in the explored graph {a mathematical formula}Gexp, so the bound given by (5) does not apply. However, in this case the path induced by ϕ from {a mathematical formula}vl must terminate at some vertex {a mathematical formula}vc with {a mathematical formula}Ψ(vc)≠∅. We construct a new path by following {a mathematical formula}π″(vs,vf) to {a mathematical formula}vl, and then following {a mathematical formula}πϕ(vl,vf) to {a mathematical formula}vc. The sum of the cost of this path and {a mathematical formula}h(vc) must be less than {a mathematical formula}g(π⁎(vs,vf)), and {a mathematical formula}Ψ(vc)⊈Ck, so case 2 still holds. □</paragraph><paragraph label="Theorem 1">{a mathematical formula}M⁎is complete and optimal.</paragraph><paragraph label="Proof">If the configuration graph G does not contain an optimal path, then {a mathematical formula}M⁎ will terminate in finite time without returning an invalid path (Lemma 1). If G does contain an optimal path, then the search graph must always contain either the optimal path, or an unexplored path which costs no more than the optimal path (Lemma 7), which implies that then {a mathematical formula}M⁎ will find the optimal path in finite time (Lemma 2). {a mathematical formula}M⁎ will thus find the optimal path in finite time, if one exists, or terminate in finite time if no path exists. Therefore, {a mathematical formula}M⁎ is complete and optimal. □</paragraph></section></section><section label="4.4"><section-title>Performance analysis</section-title><paragraph>Consider {a mathematical formula}M⁎ running on a worst case problem where every robot interacts with every other robot. Over time, the collision sets will grow until each collision set contains every robot, at which point {a mathematical formula}M⁎ will reduce to {a mathematical formula}A⁎. The question is then how much additional overhead {a mathematical formula}M⁎ imposes in the most difficult problem instances compared to {a mathematical formula}A⁎. {a mathematical formula}M⁎ may expand each vertex up to n times; once when the collision set is empty, and once when the collision set contains {a mathematical formula}2,…,n robots, where n is the total number of robots. The computational cost of expanding a vertex with a given collision set C is proportional to the number of limited neighbors {a mathematical formula}b|C|, where b is the number of outneighbors of each vertex in the individual robot graphs. Normalized to the cost of a single {a mathematical formula}A⁎ expansion, {a mathematical formula}bn, the total cost of all {a mathematical formula}M⁎ expansions of a given vertex is{a mathematical formula} using rules for the sum of finite and infinite geometric series. Therefore, repeated {a mathematical formula}M⁎ expansions of a given vertex do at most a constant factor more work than a single {a mathematical formula}A⁎ expansion of the same vertex.</paragraph><paragraph>Updating the collision set of a vertex takes time linear in the number robots, and the collision set of each vertex may be updated at most {a mathematical formula}(n−1) times, and thus total complexity of maintaining the collision sets may be {a mathematical formula}O(n2|V|), where {a mathematical formula}|V| is the total number of vertices in the configuration graph. {a mathematical formula}|V| is exponential in the number of robots. In practice the cost of maintaining the collision set is not significant.</paragraph></section></section><section label="5">Variants of {a mathematical formula}M⁎<paragraph>Several variants of {a mathematical formula}M⁎ with improved performance have been developed. Recursive {a mathematical formula}M⁎ ({a mathematical formula}rM⁎) breaks the collision set into independent subsets of robots that can be planned for separately, reducing the maximum dimensionality of the search space. Inflated {a mathematical formula}M⁎ uses an inflated heuristic function to reduce planning time, but returns a path costing up to a specified factor more than the optimal path. {a mathematical formula}ODM⁎ and {a mathematical formula}EPEA⁎ replace {a mathematical formula}A⁎ with Operator Decomposition (OD) [2] and Enhanced Partial Expansion {a mathematical formula}A⁎ ({a mathematical formula}EPEA⁎) [12], variants of {a mathematical formula}A⁎ tuned for multirobot path planning. Recursive versions of {a mathematical formula}ODM⁎ and {a mathematical formula}EPEM⁎ can be created, resulting in {a mathematical formula}ODrM⁎ and {a mathematical formula}EPEM⁎, as well as their inflated variants. Finally, the performance of {a mathematical formula}M⁎ is sensitive to choice of individual policies. The Meta-Agent Conflict Based Search framework [59] can be employed to optimize the individual policies using rapid, decoupled planning for individual robots, before applying {a mathematical formula}ODrM⁎ or {a mathematical formula}EPErM⁎ to sets of robots requiring coupled planning.</paragraph><section label="5.1">Recursive {a mathematical formula}M⁎<paragraph>The {a mathematical formula}M⁎ algorithm described in Section 4.2 performs coupled planning for all robots in the collision set, even when the collision set consists of spatially separated subsets of robots. {a mathematical formula}rM⁎ finds an optimal, collision-free path for each such subset via a recursive call to {a mathematical formula}rM⁎. Such paths constrain the motion for each subset of robots in the same fashion that the individual policies constrain the motion of individual robots. By separating the planning for independent subsets of robots, the worst case computational cost of {a mathematical formula}rM⁎ is exponential in the size of the largest set of mutually colliding robots, rather than in the total number of robots found to collide with other robots.</paragraph><paragraph>Implementing recursive {a mathematical formula}M⁎ requires few modifications to basic {a mathematical formula}M⁎. The collision set for {a mathematical formula}vk in {a mathematical formula}rM⁎ becomes a collection of the largest disjoint sets that can be formed from the collisions reachable from {a mathematical formula}vk in {a mathematical formula}Gexp. For example, if collisions involving the sets of robots {a mathematical formula}{1,2}, {a mathematical formula}{2,3}, and {a mathematical formula}{4,5} can be reached from {a mathematical formula}vk, then {a mathematical formula}Ck={{1,2,3},{4,5}}, instead of {a mathematical formula}{1,2,3,4,5} as would be the case in basic {a mathematical formula}M⁎. If {a mathematical formula}ri is not in any element of {a mathematical formula}Ck then it obeys its individual policy {a mathematical formula}ϕi, as in {a mathematical formula}M⁎. Otherwise, {a mathematical formula}ri follows the optimal path for the subset of robots in {a mathematical formula}Ck to which it belongs, as computed by a recursive call to {a mathematical formula}rM⁎. The exception is if {a mathematical formula}Ck={I}, in which case {a mathematical formula}Vˆk is computed as usual for {a mathematical formula}M⁎, using I as the collision set. This functions as the base case of the recursive calls to {a mathematical formula}rM⁎.</paragraph><paragraph>Recursive {a mathematical formula}M⁎ retains the optimality and completeness properties of {a mathematical formula}M⁎. Each disjoint set of colliding robots can be thought of as a single, high-dimensional meta-agent. The recursive calls to {a mathematical formula}rM⁎ then serve to compute the individual policy for each meta-agent. With these concepts in place, the proofs in Section 4.3.2 apply to {a mathematical formula}rM⁎.</paragraph></section><section label="5.2">Inflated {a mathematical formula}M⁎<paragraph>One problem with the basic {a mathematical formula}M⁎ implementation is that every time a new robot is involved in a collision, it is added to the collision set of {a mathematical formula}vs. Unless {a mathematical formula}g(π⁎(vs,vf))=g(πϕ(vs,vf)), {a mathematical formula}vs must then be re-expanded at a computational cost that is exponential in the size of {a mathematical formula}Cs. Inflating the heuristic by multiplying the heuristic by some {a mathematical formula}ϵ&gt;1 is known to significantly decrease the time {a mathematical formula}A⁎ requires to find a solution in many cases [60], [61], [62], [63], [64]. Furthermore, the resultant path will cost no more than {a mathematical formula}ϵ⋅g(π⁎(vs,vf))[65]. The logic in Section 4.3.2 can be extended to show that {a mathematical formula}M⁎ has the same sub-optimality bound when used with an inflated heuristic.</paragraph><paragraph>An inflated heuristic benefits {a mathematical formula}M⁎ in two fashions. First of all, an inflated heuristic biases the search towards the leaves of the search tree close to the goal, where a solution is more likely to be found quickly, which is the source of benefit in inflated {a mathematical formula}A⁎. In addition, the vertices near the leaves of the search tree will generally have smaller collision sets. Therefore, an inflated heuristic will bias search to occur in a region of the search space of low dimensionality.</paragraph></section><section label="5.3">Replacements for {a mathematical formula}A⁎<paragraph>{a mathematical formula}A⁎ is fundamentally limited for multirobot path planning because the number of out-neighbors of a single vertex increases exponentially with the number of robots. {a mathematical formula}A⁎ adds all out-neighbors of a vertex to the open list, even if many will never be expanded. As a result, {a mathematical formula}A⁎ will run out of memory when dealing with systems containing even moderate numbers of robots. Operator Decomposition (OD) [2] and Enhanced Partial Expansion {a mathematical formula}A⁎ ({a mathematical formula}EPEA⁎) [12] are variants of {a mathematical formula}A⁎ which delay instantiating expensive neighbors, thus reducing the effective branching factor of the graph. Replacing {a mathematical formula}A⁎ in {a mathematical formula}M⁎ with OD and {a mathematical formula}EPEA⁎ results in the {a mathematical formula}ODM⁎ and {a mathematical formula}EPEM⁎ algorithms, respectively.</paragraph><section label="5.3.1">{a mathematical formula}ODM⁎<paragraph>In {a mathematical formula}ODM⁎, {a mathematical formula}A⁎ is replaced as the underlying planner by Operator Decomposition, a variant of {a mathematical formula}A⁎ developed explicitly for multirobot path planning. OD mitigates the problem of growth in the number of out-neighbors by procedurally generating the out-neighbors so that low cost neighbors are generated first, and high-cost neighbors may never be instantiated. OD generates two types of search vertices; standard and intermediate. A standard vertex represents the configuration of all robots in the system. When a standard vertex is expanded, OD generates intermediate vertices which specify all possible actions for the first robot. The cost and heuristic cost-to-go of the intermediate vertices are updated to reflect the new position of the first robot; then the intermediate vertices are added to the open list. When an intermediate vertex is expanded, additional intermediate vertices specifying the action of the next robot are generated. Standard vertices are generated once actions are assigned for the last robot. This procedure results in the creation of standard vertices which represent heuristically promising actions, such as each robot moving directly towards its goal, before instantiating any less promising vertices. Typically fewer total vertices are created, reducing the computational cost of finding a path.</paragraph><paragraph>Fig. 9 illustrates the vertex expansion of operator decomposition for a problem involving two robots. When coupled with an admissible heuristic, operator decomposition is complete and optimal with respect to path cost. Thus, {a mathematical formula}ODM⁎ is also guaranteed to find optimal paths.</paragraph></section><section label="5.3.2">{a mathematical formula}EPEM⁎<paragraph>In {a mathematical formula}EPEM⁎, {a mathematical formula}A⁎ is replaced as the underlying planner by Enhanced Partial Expansion {a mathematical formula}A⁎, a variant of {a mathematical formula}A⁎ that has been applied to single- and multi-agent planning [12]. {a mathematical formula}EPEA⁎ seeks to eliminate the generation of excess nodes, which have a f-value larger than the cost of the optimal path and thus will never be expanded.</paragraph><paragraph>{a mathematical formula}EPEA⁎ sorts the open list based on the sum of the f-value of a vertex and an offset, {a mathematical formula}Δf(v), which is initially set to zero. When {a mathematical formula}EPEA⁎ expands a vertex {a mathematical formula}vk, it employs a domain specific Operator Selection Function (OSF) to instantiate only those neighbors of {a mathematical formula}vk whose f-value is equal to {a mathematical formula}f(vk)+Δf(vk). {a mathematical formula}Δf(vk) is then incremented, and {a mathematical formula}vk is added back to the open list. As a result, no excess nodes will ever be generated.</paragraph><paragraph>For multirobot path planning, {a mathematical formula}EPEA⁎ uses an OSF which generates neighbors of a vertex {a mathematical formula}vk in a two step process: allocating costs to specific robots and generating neighbors. The offset of {a mathematical formula}vk can be interpreted as an excess cost compared to the heuristically optimal neighbor of {a mathematical formula}vk. In the first step of expansion, {a mathematical formula}EPEA⁎ allocates individual robots a specific amount of excess to incur. All neighbors of {a mathematical formula}vk that match the allocation of excess cost are then generated, and added to the open list. This is more efficient than a direct search over all possible neighbors. Felner et al. [12] report that {a mathematical formula}EPEA⁎ outperforms {a mathematical formula}A⁎ and OD when solving dense multirobot path planning problems.</paragraph></section></section><section label="5.4"><section-title>Policy optimization</section-title><paragraph>The performance of {a mathematical formula}M⁎ is very sensitive to the choice of individual policies when many optimal paths exist for each robot. One choice of individual policies may result in few collisions, while another choice may result in a large number of robots colliding at a single bottleneck, preventing a solution from being found in reasonable time. Therefore, it may be desirable to optimize the choice of individual policies prior to starting {a mathematical formula}M⁎ search.</paragraph><paragraph>Meta-Agent Conflict-Based Search (MA-CBS) [59] is a planning framework introduced by Sharon et al. based on their Conflict-Based Search (CBS) planning algorithm [57], and generalizes the earlier Independence Detection (ID) algorithm by Standley [2]. Conflict-Based Search explores a space of constraints on individual robots, rather than the joint configuration space of the system. Each search node contains a set of constraints and the optimal path for each robot subject to the constraints. The constraints prohibit individual robots from occupying a specific position at a specific time that would lead to interference with another robot.</paragraph><paragraph>At each step, the search node with the smallest total path cost is checked for collisions between the constrained paths of the individual robots. If no collisions are detected, then the optimal solution has been found. If a collision is found between two robots at position q and time t, the search tree branches. Two new nodes are created, each with an added constraint prohibiting one of the involved robots from occupying q at time t. New paths are then computed for each of the involved robots that obey the newly expanded set of constraints. When planning for an individual robot, conflicts with paths of other robots are used for tie breaking: i.e. paths which do not conflict with the paths of other robots are preferred, but no additional cost will be incurred to avoid such conflicts.</paragraph><paragraph>While the search space for constrained planning is of constant dimensionality, the set of possible constraints grows exponentially. As a result, CBS performs poorly when there are many alternate paths which require a large number of constraints to cover. In such cases, it is more efficient to use coupled search to find a path for the effected robots. MA-CBS [59] is an extension of CBS in which robots are permanently merged into a meta-agent when the number of mutual constraints generated exceeds a merge threshold B. Within a meta-agent, planning is conducted using a coupled planning algorithm respecting the constraints placed on the meta-agent. Internal constraints upon the constituent robots are removed when they are merged into a meta-agent, although the new meta-agent inherits constraints that resulted from collisions with agents not included in the meta-agent. MA-CBS with a given merge threshold B is denoted as MA-CBS(B). Typically, smaller values of B work better in more open environments with many alternate paths, resorting to coupled search earlier, while larger values of B work better in more constrained environments. MA-CBS(0) is equivalent to ID [59].</paragraph><paragraph>Using {a mathematical formula}ODrM⁎ as the coupled planner for MA-CBS results in the {a mathematical formula}MA-CBS+ODrM⁎ algorithm. The individual policies computed for {a mathematical formula}ODrM⁎ respect the constraints imposed on the meta-agent, and attempt to minimize conflicts with robots not in the meta-agent. In this fashion, the individual policies are optimized to minimize robot–robot conflicts.</paragraph><paragraph>{a mathematical formula}ODrM⁎ and MA-CBS complement each other well. MA-CBS can minimize the total number of collisions via rapid, decoupled search, and is effective in narrow bottlenecks which pose a problem for {a mathematical formula}ODrM⁎, while {a mathematical formula}ODrM⁎ is more suited to open regions than other coupled planners, as {a mathematical formula}ODrM⁎ will reject alternate, low cost paths which cannot resolve collisions.</paragraph></section></section><section label="6">Comparison of {a mathematical formula}M⁎ and similar algorithms<paragraph>{a mathematical formula}M⁎, {a mathematical formula}EPEA⁎, OD, ID and MA-CBS all exploit the same natural decomposition of the multirobot path planning problem by exploring paths that minimize the costs incurred by individual robots before considering more expensive paths. As a result, there are a number of similarities in these algorithms. This section will describe how {a mathematical formula}M⁎ differs from the other algorithms, and where {a mathematical formula}M⁎ can show a performance improvement.</paragraph><paragraph>{a mathematical formula}EPEA⁎ and OD are both approaches that intelligently search the joint configuration space. While {a mathematical formula}EPEA⁎ and OD can delay instantiating unpromising vertices, they cannot identify and exclude unnecessary portions of the joint configuration space. By tracking which robots collide where, {a mathematical formula}M⁎ can construct a search space that excludes unnecessary regions of the joint configuration space. Consider a 3 robot example, where {a mathematical formula}r1 and {a mathematical formula}r2 must swap positions in a narrow corridor, while {a mathematical formula}r3 is alone in an open room (Fig. 10a). Clearly, {a mathematical formula}r2 needs to wait for {a mathematical formula}r1 to enter the alcove, or vice versa. However, such a path would have a greater f-value than the initial state. Therefore, before OD or {a mathematical formula}EPEA⁎ could consider such a path, they must first examine all optimal alternate paths for {a mathematical formula}r3, even though none of those paths could possibly resolve the conflict (Fig. 10b). In the case of {a mathematical formula}M⁎, {a mathematical formula}r3 is not involved in any collision, and thus will remain restricted to its individually optimal path (Fig. 10c). {a mathematical formula}M⁎ can therefore proceed immediately to considering alternate paths for the robots involved in the collision, rather than waisting time on alternate paths for {a mathematical formula}r3.</paragraph><paragraph>MA-CBS, ID and {a mathematical formula}rM⁎ share a common purpose: splitting the multirobot system into independent subsets of robots. The approach {a mathematical formula}rM⁎ takes to splitting the system is less sophisticated than that employed by ID and MA-CBS. When {a mathematical formula}rM⁎ detects a collision between two robots, it immediately merges them to form a meta-agent, instead of checking whether choosing a different individual policy of one of the robots could avoid the collision, as MA-CBS or ID would do. However, {a mathematical formula}rM⁎ has much more fine-grained control over the merging of robots. Once {a mathematical formula}rM⁎ resolves a collision between the agents composing a meta-agent, it splits the meta-agent back into individual robots, whereas once MA-CBS or ID generates a meta-agent, it remains merged. The local merging of {a mathematical formula}rM⁎ will typically not reduce the peak dimensionality of the search space, as {a mathematical formula}vs accumulates all collisions and must be re-expanded if {a mathematical formula}g(π⁎(vs,vf))&gt;f(vs). However, it will reduce the number of vertices at which the search space will have maximal dimensionality. Furthermore, the fine-grained nature of {a mathematical formula}rM⁎ allows it to be used within the MA-CBS or ID frameworks as the coupled planner, thus gaining the benefit of both the more sophisticated policy optimization performed by MA-CBS and ID, and the local merging of agents that {a mathematical formula}rM⁎ provides.</paragraph></section><section label="7">{a mathematical formula}M⁎ results<paragraph>To validate the performance of {a mathematical formula}M⁎ on systems of up to 200 robots, we turn to simulation. All simulations were implemented in python and run on a computer with an Intel Core i5-2500 processor clocked at 3.30 GHz (Turbo Boost disabled) with 8 GB of RAM. The test environment was a {a mathematical formula}32×32, four-connected grid of cells, with a 20% probability of a given cell being marked as an obstacle, as in [2] (Fig. 11). Unique initial and goal positions for each robot were chosen randomly within the same connected component of the workspace. Any action by an individual robot, including waiting, incurred a cost of one, although a robot could wait at its assigned goal with zero cost. The existence of a wait action implies the presence of a self-loop for each vertex {a mathematical formula}vk∈Gi, so that {a mathematical formula}vk is its own out-neighbor.</paragraph><paragraph>Each trial was given 5 minutes to find a solution. 100 random environments were tested for a given number of robots. We present the percentage of trials that were successful within 5 minutes as well as the median time required to find solutions. Run time is plotted on a logarithmic scale.</paragraph><section label="7.1">{a mathematical formula}M⁎, operator decomposition and {a mathematical formula}rM⁎<paragraph>We start by comparing {a mathematical formula}A⁎, OD, {a mathematical formula}EPEA⁎, {a mathematical formula}M⁎, {a mathematical formula}EPEM⁎, {a mathematical formula}ODM⁎, {a mathematical formula}rM⁎, {a mathematical formula}ODrM⁎ and {a mathematical formula}EPErM⁎ (Fig. 12). The plateauing of the median time to solution plots is the result of at least 50% of trials reaching the 5 minute time limit. Python's CPU time function has a resolution of one millisecond, resulting in solutions that take less than one millisecond being reported as taking zero time, which cannot be represented on a logarithmic plot.</paragraph><paragraph>As expected, {a mathematical formula}A⁎ demonstrated the worst performance, being unable to find solutions for problems of 10 or more robots. {a mathematical formula}A⁎ was limited by the exponential growth in the number of neighbors of a given vertex as the number of robots increases. OD, {a mathematical formula}EPEA⁎, {a mathematical formula}M⁎, {a mathematical formula}ODM⁎ and {a mathematical formula}EPEM⁎ all show roughly similar performance. {a mathematical formula}M⁎ solved the most problems with 15 robots, but decayed in performance rapidly until it underperformed all other algorithms at 20 robots. OD generally underperformed {a mathematical formula}EPEA⁎, {a mathematical formula}M⁎, {a mathematical formula}ODM⁎, and {a mathematical formula}EPEM⁎, while {a mathematical formula}EPEA⁎ unexpectedly showed the best performance for problems involving 20 robots.</paragraph><paragraph>The recursive variants of {a mathematical formula}M⁎ showed noticeable improvement over the non-recursive approaches, and solved twice as many problems involving 20 robots as {a mathematical formula}EPEA⁎ (Fig. 12b). Recall that {a mathematical formula}rM⁎ uses {a mathematical formula}A⁎ as the underlying planning algorithm, so that {a mathematical formula}rM⁎ typically expands more vertices than {a mathematical formula}ODrM⁎ or {a mathematical formula}EPErM⁎. Thus, we expected {a mathematical formula}ODrM⁎ to solve more instances within the given time limit. {a mathematical formula}ODrM⁎ and {a mathematical formula}EPErM⁎ solved twice as many problems involving 25 robots as basic {a mathematical formula}rM⁎. The near identical performance of {a mathematical formula}ODrM⁎ and {a mathematical formula}EPErM⁎ can be accounted for by the similarity in performance of OD and {a mathematical formula}EPEA⁎.</paragraph><paragraph>The degree to which {a mathematical formula}M⁎ and its variants can solve problems which involve dense interactions between many robots can be measured by the maximum size of the collision set of {a mathematical formula}vs encountered during a successful trial (Table 4). Recall that the collision set of {a mathematical formula}vs accumulates all robots found to collide with another robot at any point in the search. However, if {a mathematical formula}g(π⁎(vs,vf)=g(πϕ(vs,vf) then {a mathematical formula}vs may not be expanded with its largest collision set, depending on how ties are broken when vertex f-values are compared. {a mathematical formula}ODM⁎, {a mathematical formula}ODrM⁎, {a mathematical formula}EPEM⁎, and {a mathematical formula}EPErM⁎ were able to handle larger collision sets than {a mathematical formula}M⁎ and {a mathematical formula}rM⁎, which is to be expected because OD and {a mathematical formula}EPEA⁎ could solve problems involving more robots than {a mathematical formula}A⁎.</paragraph><paragraph>The recursive implementations solved problems in which roughly twice as many total robots were involved in collisions as the equivalent non-recursive implementation. This is because the recursive implementations split the collision set into independent subsets of robots, for which coupled planning is performed separately. The largest independent subset of the collision set in the recursive implementations were equivalent in size to the largest collision sets for which the non-recursive implementations found solutions. Thus, while recursive implementations could solve problems involving more total robots, the number of robots which could interact in a single region of the workspace, and thus require coupled planning, was determined by the underlying planner.</paragraph></section><section label="7.2"><section-title>Policy optimization</section-title><paragraph>We now present simulation results using the MA-CBS planning framework, and demonstrate that integrating {a mathematical formula}ODrM⁎ or {a mathematical formula}EPErM⁎ provides state of the art results for optimal multirobot path planning. MA-CBS is parametrized by a merge threshold which must be tuned to a specific problem's characteristics. MA-CBS+OD, MA-CBS+{a mathematical formula}EPEA⁎, MA-CBS+{a mathematical formula}ODrM⁎, and MA-CBS+{a mathematical formula}EPErM⁎ were tested with merge thresholds of 3, 10, 30, 100, 300, 1000 and 3000. MA-CBS+{a mathematical formula}ODrM⁎ and MA-CBS+{a mathematical formula}EPErM⁎ performed best with a merge threshold of 1000, while MA-CBS+OD and MA-CBS+{a mathematical formula}EPEA⁎ performed best with a merge threshold of 3000.</paragraph><paragraph>The planning results for CBS, equivalent to MA-CBS(∞), MA-CBS(3000)+OD, MA-CBS(3000)+{a mathematical formula}EPEA⁎, MA-CBS(1000)+{a mathematical formula}ODrM⁎, and MA-CBS(1000)+{a mathematical formula}EPErM⁎ are given in Fig. 13. CBS outperformed MA-CBS(3000)+OD, MA-CBS(3000)+{a mathematical formula}EPEA⁎, which is not surprising given that the environment is very cluttered, which is where CBS is known to perform best [59]. The greater planning power of {a mathematical formula}M⁎ allowed MA-CBS(1000)+{a mathematical formula}ODrM⁎ and MA-CBS(1000)+{a mathematical formula}EPErM⁎ to substantially outperform CBS, while the performance of MA-CBS(1000)+{a mathematical formula}ODrM⁎ and MA-CBS(1000)+{a mathematical formula}EPErM⁎ were nearly identical. We note that on 8-connected grids, where there are more alternate paths, the performance benefit of MA-CBS+{a mathematical formula}ODrM⁎ over CBS and MA-CBS+OD becomes even more substantial [10].</paragraph></section><section label="7.3"><section-title>Inflated heuristics</section-title><paragraph>We tested {a mathematical formula}A⁎, {a mathematical formula}M⁎, {a mathematical formula}EPEA⁎ and variants of {a mathematical formula}M⁎ with a heuristic inflated by a factor of 1.1 (Fig. 14a). All algorithms were thus guaranteed to find a path costing no more than 10% more than that of the optimal solution. Inflated {a mathematical formula}A⁎ was still unable to find solutions for systems of 10 or more robots, as each vertex has ten million neighbors. While the success rate for inflated OD, inflated {a mathematical formula}EPEA⁎ and inflated {a mathematical formula}M⁎ all improved, {a mathematical formula}M⁎ benefited substantially more from an inflated heuristic than OD or {a mathematical formula}EPEA⁎ did. Basic inflated {a mathematical formula}M⁎ was held back by inefficient neighbor generation for larger collision sets, and thus performed on par with inflated {a mathematical formula}EPEA⁎, but inflated {a mathematical formula}ODM⁎ and inflated {a mathematical formula}EPEM⁎ solved problems involving roughly twice as many robots. The inflated heuristic concentrates search on the leaves of the search graph nearest to the goal, providing a benefit to {a mathematical formula}EPEA⁎, OD and {a mathematical formula}M⁎. However, such leaves will also have smaller collision sets, reducing the dimensionality of the search space for {a mathematical formula}M⁎, and accounting for the greater reduction in computation time for inflated {a mathematical formula}ODM⁎ and inflated {a mathematical formula}EPEM⁎ compared to inflated OD or inflated {a mathematical formula}EPEA⁎.</paragraph><paragraph>Inflated {a mathematical formula}rM⁎, {a mathematical formula}ODrM⁎ and {a mathematical formula}EPErM⁎ show further improvements in performance, as expected (Fig. 14b). Inflated {a mathematical formula}ODrM⁎ and {a mathematical formula}EPErM⁎ were able to find solutions more quickly, in more cases, and with a simpler implementation than MA-CBS(1000)+{a mathematical formula}ODrM⁎, reflecting the computational benefits of relaxing the requirement to find optimal cost paths, even if only slightly.</paragraph></section><section label="7.4"><section-title>Comparison to rule-based approaches</section-title><paragraph>{a mathematical formula}M⁎ and inflated {a mathematical formula}M⁎ can find optimal or bounded suboptimal paths to problems involving many robots, but in the worst case the computational complexity of {a mathematical formula}M⁎ is still exponential in the number of robots. This raises the question of what benefits {a mathematical formula}M⁎ conveys in practice in comparison to polynomial-time, rule based approaches which do not provide bounds on path cost. To this end, we compared variants of {a mathematical formula}M⁎ against a C++ implementation of Parallel Push and Swap (PPAS) graciously provided by Sajid et al. [53]. The PPAS code was not optimized for performance or run time (Fig. 15).</paragraph><paragraph>Four variants of {a mathematical formula}M⁎ are used as points of comparison, {a mathematical formula}MA-CBS(1000)+EPErM⁎, which produces optimal paths, and inflated {a mathematical formula}EPErM⁎ with inflation factors of 1.1, 3, and 10. The performance of inflated {a mathematical formula}ODrM⁎ was essentially the same as {a mathematical formula}EPErM⁎, so results for {a mathematical formula}ODrM⁎ are omitted. The failures of PPAS were the result of the implementation tested crashing. While PPAS has only been shown to be complete on trees, the observed failures are most likely the result of bugs in the provided code. All successful runs of PPAS terminated in under 6 seconds.</paragraph><paragraph>The mean path cost and mean makespan (time until all robots reach their goals) of paths found by PPAS and {a mathematical formula}M⁎ variants are shown in Fig. 16. PPAS consistently found paths of substantially greater cost than those found by {a mathematical formula}EPErM⁎ variants, demonstrating the benefits of approaches which bound path cost. Note that the cost bounds on inflated {a mathematical formula}EPErM⁎ are loose; while {a mathematical formula}EPErM⁎{a mathematical formula}(ϵ=10) could potentially find paths that cost ten times the minimal cost, it generally finds substantially cheaper paths. The results are slightly distorted by the fact that the mean cost and makespan are only computed for trials for which a given algorithm was able to find a solution. As a result, the mean makespan for {a mathematical formula}EPErM⁎{a mathematical formula}(ϵ=1.1) appears to decline for instances involving more than 50 robots (Fig. 16b), but this is an artifact of {a mathematical formula}EPErM⁎{a mathematical formula}(ϵ=1.1) only solving the easier instances of those problems. However, the success rates of PPAS and {a mathematical formula}EPErM⁎{a mathematical formula}(ϵ=10) are similar enough, especially up to 150 robots, for the cost comparisons to be valid.</paragraph></section><section label="7.5"><section-title>Fully coupled tests</section-title><paragraph>In the previously discussed simulations, the environment was comparatively open, allowing a substantial degree of decoupling between robots. To examine the performance of {a mathematical formula}M⁎ in fully coupled environments, a series of tests were run in a {a mathematical formula}4×4 gird world with up to 15 robots, equivalent to the 15 puzzle.</paragraph><paragraph>Six optimal approaches were tested, {a mathematical formula}EPEM⁎, {a mathematical formula}EPErM⁎, CBS, {a mathematical formula}MA-CBS(1000)+EPErM⁎, {a mathematical formula}EPEA⁎, and {a mathematical formula}MA-CBS(1000)+EPEA⁎{sup:6} (Fig. 17a). There is a general trend that the more aggressively an algorithm exploits decoupling between robots, the worse its performance. {a mathematical formula}EPErM⁎ is out performed by {a mathematical formula}EPEM⁎, and {a mathematical formula}EPEA⁎ outperforms both {a mathematical formula}EPEM⁎ and CBS. {a mathematical formula}MA-CBS(1000)+EPEA⁎ does outperform {a mathematical formula}EPEA⁎ for 13 robots, which we interpret as MA-CBS slightly simplifying some problems before falling back on {a mathematical formula}EPEA⁎.</paragraph><paragraph>Five bounded suboptimal methods were tested; inflated {a mathematical formula}EPEA⁎, inflated OD, inflated {a mathematical formula}EPEM⁎, inflated {a mathematical formula}EPErM⁎, all with an inflation factor of {a mathematical formula}ϵ=10. The bounded suboptimal methods were tested against PPAS, a non-optimal, rule based method. PPAS can find solutions much faster than any of the bounded suboptimal methods, but fails on all of the 15 robot problems, because PPAS makes the assumption that there are always at least two free vertices. The failures of PPAS at 10 robots were due to bugs in the implementation that was tested. Inflated {a mathematical formula}EPErM⁎ performed the worst of any of the bounded suboptimal methods, due to the overhead of computing paths for disjoint subsets of robots that were later invalidated due to collisions with other robots. Inflated OD outperforms inflated {a mathematical formula}EPEA⁎, which may be surprising given the performance of those algorithms with a lower inflation factor of {a mathematical formula}ϵ=1.1 (Fig. 14a). However {a mathematical formula}EPEA⁎ generates all neighboring vertices of a given f-value at once, while OD iteratively generates the neighboring vertices. High inflation factors bias search towards the goal, causing OD to behave in a more depth-first manner, effectively generating a single neighbor for a given state at a time. Goldenberg et al. [66] described but did not implement optimal-generation variants of {a mathematical formula}EPEA⁎ which may mitigate the reduced performance of {a mathematical formula}EPEA⁎ with large inflation factors. Inflated {a mathematical formula}ODM⁎ and {a mathematical formula}EPEM⁎ are roughly a constant factor slower than inflated OD, but have similar success rates. Note that even with a high inflation factor OD substantially underperforms inflated {a mathematical formula}EPErM⁎ in less cluttered environments; in the {a mathematical formula}32×32 grid environment inflated OD with {a mathematical formula}ϵ=10 performs roughly on par with {a mathematical formula}EPErM⁎{a mathematical formula}ϵ=1.1.</paragraph></section></section><section label="8"><section-title>Conclusions and further work</section-title><paragraph>In this paper, we presented subdimensional expansion, a method for constructing low-dimensional search spaces tailored to specific multirobot path planning problems. We implemented subdimensional expansion using {a mathematical formula}A⁎ as the underlying planning algorithm, resulting in the {a mathematical formula}M⁎ algorithm. While the performance of {a mathematical formula}M⁎ and its variants are marginal on fully coupled problems, in the more expansive environments for which {a mathematical formula}M⁎ was designed, {a mathematical formula}M⁎ provides considerable improvements in performance for finding minimal cost paths for multirobot systems compared to the existing state of the art. Furthermore, inflated {a mathematical formula}M⁎ can solve large problems involving 200 robots, and produce paths that cost significantly less than those generated by existing rule based planners which can also solve such large problems.</paragraph><paragraph>In our future work, we will consider several extensions of subdimensional expansion. Barer et al. [58] recently published a bounded-suboptimal variant of CBS termed ECBS which can outperform inflated {a mathematical formula}ODrM⁎/EPErM⁎ when small inflation factors are used. We believe that combining ECBS and inflated {a mathematical formula}EPErM⁎ will result in further performance improvements, similar to the improvements in optimal path planning seen in {a mathematical formula}MA-CBS+ODrM⁎. Minimal cost paths for multirobot systems often feature robots passing very close to one another. Minor errors in plan execution can thus result in collisions, or time consuming reactive collision avoidance, which may invalidate the entire plan. Subdimensional expansion can be extended to account for uncertainty in plan execution by utilizing a collision function which treats each robot as occupying a distribution of possible states. The collision sets would then track the probability of a collision occurring, with the dimensionality of the search space increased when the probability of a collision rises above some threshold value.</paragraph><paragraph>While subdimensional expansion is currently formatted for multirobot systems, we plan to extend the concept of subdimensional expansion to other high-dimensional systems. There are some single robot systems with high-dimensional configuration spaces which can be decomposed into semi-independent subspaces in a similar manner to how multirobot systems can be decomposed into individual robots. For instance, changing the motion of joints of a robot arm distal to a collision cannot resolve said collision. The challenge will lie in identifying how a decomposition into largely independent subsystems can be performed for systems without the natural structure of multirobot systems.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>We would like to thank Cornelia Ferner for her assistance with policy optimization. We would also like to thank Professor Bekris and Qandeel Sajid for making their Parallel Push and Swap code available.</paragraph></acknowledgements><references><reference label="[1]"><authors>P. Hart,N. Nilsson,B. Raphael</authors><title>A formal basis for the heuristic determination of minimum cost paths</title><host>IEEE Trans. Syst. Sci. Cybern.4 (2)(1968) pp.100-107</host></reference><reference label="[2]"><authors>T. Standley</authors><title>Finding optimal solutions to cooperative pathfinding problems</title><host>Proceedings of the 24th AAAI Conference on Artificial Intelligence (AAAI)Atlanta, GA, USA(2010) pp.173-178</host></reference><reference label="[3]"><authors>D. Ratner,M. Warmuth</authors><title>Finding a shortest solution for the N×N extension of the 15-puzzle is intractable</title><host>J. Symb. Comput.10 (1990) pp.111-137</host></reference><reference label="[4]">M. Erdmann,T. Lozano-PerezOn multiple moving objectsAlgorithmica2 (1)(1987) pp.477-521ISSN 0178-4617</reference><reference label="[5]">K. Kant,S. ZuckerToward efficient trajectory planning: the path–velocity decompositionInt. J. Robot. Res.5 (3)(1986) pp.72-89ISSN 0278-3649</reference><reference label="[6]"><authors>S. Leroy,J.-P. Laumond,T. Siméon</authors><title>Multiple path coordination for mobile robots: a geometric algorithm</title><host>Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence(1999)Morgan Kaufmann Publishers Inc.San Francisco, CA, USA1-55860-613-0 pp.1118-1123</host></reference><reference label="[7]"><authors>M. Saha,P. Isto</authors><title>Multi-robot motion planning by incremental coordination</title><host>Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and SystemsBeijing, China(2006) pp.5960-5963</host></reference><reference label="[8]"><authors>D. Silver</authors><title>Cooperative pathfinding</title><host>Proceedings of the 1st Conference on Artificial Intelligence and Interactive Digital EntertainmentMarina del Rey, California, USA(2005) pp.23-28</host></reference><reference label="[9]"><authors>G. Wagner,H. Choset</authors><title>M⁎: a complete multirobot path planning algorithm with performance bounds</title><host>Proceedings of the IEEE International Conference on Intelligent Robots and SystemsSan Francisco, CA, USA(2011) pp.3260-3267</host></reference><reference label="[10]"><authors>C. Ferner,G. Wagner,H. Choset</authors><title>ODrM*: optimal multirobot path planning in low dimensional search spaces</title><host>Proceedings of the IEEE/RSJ International Conference on Robotics and AutomationKarlsruhe, Germany(2013)</host></reference><reference label="[11]"><authors>D. Carmel,S. Markovitch</authors><title>Incorporating opponent models into adversary search</title><host>AAAI/IAAIPortland OR, USAvol. 1 (1996)</host></reference><reference label="[12]"><authors>A. Felner,M. Goldenberg,G. Sharon,R. Stern,T. Beja,N. Sturtevant,J. Schaeffer,R. Holte</authors><title>Partial-expansion A⁎ with selective node generation</title><host>Proceedings of the AAAI Conference on Artificial IntelligenceToronto, Canada(2012)</host></reference><reference label="[13]"><authors>M. Goldenberg,A. Felner,R. Stern,G. Sharon,N. Sturtevant,R. Holt,J. Schaeffer</authors><title>Enhanced partial expansion A⁎</title><host>J. Artif. Intell. Res.50 (2014) pp.141-18710.1613/jair.4171</host></reference><reference label="[14]">R. KorfDepth-first iterative-deepening: an optimal admissible tree searchArtif. Intell.27 (1)(1985) pp.97-10910.1016/0004-3702(85)90084-0ISSN 00043702</reference><reference label="[15]">S. Carpin,E. PagelloOn parallel RRTs for multi-robot systemsProceedings of the 8th Conference of the Italian Association for Artificial Intelligence(2002) pp.834-841Citeseer</reference><reference label="[16]"><authors>D. Ferguson,N. Kalra,A. Stentz</authors><title>Replanning with RRTs</title><host>Proceedings of the IEEE International Conference on Robotics and AutomationOrlando, FL, USA(2006) pp.1243-1248</host></reference><reference label="[17]"><authors>G. Sánchez,J. Latombe</authors><title>On delaying collision checking in PRM planning: application to multi-robot coordination</title><host>Int. J. Robot. Res.21 (1)(2002) pp.5-</host></reference><reference label="[18]"><authors>G. Sanchez,J. Latombe</authors><title>Using a PRM planner to compare centralized and decoupled planning for multi-robot systems</title><host>Proceedings of the IEEE International Conference on Robotics and AutomationWashington D.C., USAvol. 2 (2002) pp.2112-2119</host></reference><reference label="[19]"><authors>M. Cáp,P. Novák,J. Vokřínek,M. Pěchouček</authors><title>Multi-agent RRT*: sampling-based cooperative pathfinding</title><host>Autonomous Robots and Multirobot Systems Workshop at AAMAS 2013(2013)</host></reference><reference label="[20]"><authors>K. Solovey,O. Salzman,D. Halperin</authors><title>Finding a needle in an exponential haystack: discrete RRT for exploration of implicit roadmaps in multi-robot motion planning</title><host>WAFR(2014)</host></reference><reference label="[21]"><authors>G. Wagner,M. Kang,H. Choset</authors><title>Probabilistic path planning for multiple robots with subdimensional expansion</title><host>Proceedings of the IEEE/RSJ International Conference on Robotics and Automation(2012)</host></reference><reference label="[22]"><authors>R. Huang,Y. Chen,W. Zhang</authors><title>A novel transition based encoding scheme for planning as satisfiability</title><host>AAAI Conference on Artificial Intelligence(2010) pp.89-94</host></reference><reference label="[23]"><authors>H. Kautz,B. Selman</authors><title>Unifying SAT-based and graph-based planning</title><host>IJCAI(1999)</host></reference><reference label="[24]"><authors>P. Surynek</authors><title>An SAT-based approach to cooperative path-finding using all-different constraints</title><host>Proceedings of Symposium on Combinatorial Search(2012) pp.191-192</host></reference><reference label="[25]"><authors>P. Surynek</authors><title>Optimal cooperative path-finding with generalized goals in difficult cases</title><host>Tenth Symposium of Abstraction, Reformulation, and Approximation(2013) pp.119-122</host></reference><reference label="[26]"><authors>E. Erdem,D.G. Kisa,U. Oztok,P. Schueller</authors><title>A general formal framework for pathfinding problems with multiple agents</title><host>AAAI Conference on Artificial Intelligence(2013) pp.290-296</host></reference><reference label="[27]"><authors>T. Balyo,R. Bartak,P. Surynek</authors><title>Shortening plans by local re-planning</title><host>24th International Conference on Tools with Artificial IntelligenceAthens, Greece(2012)</host></reference><reference label="[28]"><authors>P. Surynek</authors><title>Solving abstract cooperative path-finding in densely populated environments</title><host>Computational Intelligencevol. 30 (2012)</host></reference><reference label="[29]">R. Cui,B. Gao,J. GuoPareto-optimal coordination of multiple robots with safety guaranteesAuton. Robots32 (3)(2011) pp.189-205ISSN 0929-5593</reference><reference label="[30]">J. Peng,S. AkellaCoordinating multiple robots with kinodynamic constraints along specified pathsInt. J. Robot. Res.24 (4)(2005) pp.295-310ISSN 0278-3649</reference><reference label="[31]"><authors>S. LaValle,S. Hutchinson</authors><title>Optimal motion planning for multiple robots having independent goals</title><host>IEEE Trans. Robot. Autom.14 (6)(1998) pp.912-925</host></reference><reference label="[32]"><authors>S. Leroy,J.-P. Laumond,T. Siméon</authors><title>Multiple path coordination for mobile robots: a geometric algorithm</title><host>Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence(1999)Morgan Kaufmann Publishers Inc.San Francisco, CA, USA1-55860-613-0 pp.1118-1123</host></reference><reference label="[33]">J. Peng,S. AkellaCoordinating multiple robots with kinodynamic constraints along specified pathsInt. J. Robot. Res.24 (4)(2005) pp.295-310ISSN 0278-3649</reference><reference label="[34]"><authors>T. Siméon,S. Leroy,J.-p. Laumond</authors><title>Path coordination for multiple mobile robots: a resolution-complete algorithm</title><host>IEEE Trans. Robot. Autom.18 (1)(2002) pp.42-49</host></reference><reference label="[35]"><authors>M. Cáp,P. Novák,M. Selecký,J. Faigl,J. Vokřínek</authors><title>Asynchronous decentralized prioritized planning for coordination in multi-robot system</title><host>IEEE/RSJ International Conference on Intelligent Robots and Systems(2013)9781467363587 pp.3822-3829</host></reference><reference label="[36]">V.R. Desaraju,J.P. HowDecentralized path planning for multi-agent teams with complex constraintsAuton. Robots32 (4)(2012) pp.385-403ISSN 0929-5593</reference><reference label="[37]"><authors>R. Regele,P. Levi</authors><title>Cooperative multi-robot path planning by heuristic priority adjustment</title><host>IEEE/RSJ International Conference on Intelligent Robots and Systems(2006)IEEE1-4244-0258-1 pp.5954-5959</host></reference><reference label="[38]"><authors>J. van den Berg,M. Overmars</authors><title>Prioritized motion planning for multiple robots</title><host>Proceedings of the IEEE/RSJ International Conference on Intelligent Robots and SystemsEdmonton, Alberta, Canada(2005) pp.2217-2222</host></reference><reference label="[39]"><authors>A. Geramifard,P. Chubak,V. Bulitko</authors><title>Biased cost pathfinding</title><host>AAAI Conference on Artificial Intelligence and Interactive Digital EntertainmentMarina del Rey, California(2006)978-1-57735-235-8 pp.112-114</host></reference><reference label="[40]"><authors>S. Buckley</authors><title>Fast motion planning for multiple moving robots</title><host>Proceedings of IEEE International Conference on Robotics and Automationvol. 1 (1989) pp.322-326</host></reference><reference label="[41]"><authors>B. Maren,B. Wolfram,T. Sebastian</authors><title>Constraint-based optimization of priority schemes for decoupled path planning techniques</title><host>KI 2001: Advances in Artificial Intelligence(2001) pp.78-93</host></reference><reference label="[42]"><authors>M. Turpin,N. Michael,V. Kumar</authors><title>Trajectory planning and assignment in multirobot systems</title><host>International Workshop on Algorithmic Foundations of Robotics (WAFR)(2012)</host></reference><reference label="[43]"><authors>M. Turpin,N. Michael,V. Kumar</authors><title>Concurrent assignment and planning of trajectories for large teams of interchangeable robots</title><host>IEEE International Conference on Robotics and AutomationKarlsruhe, Germany(2013)9781467356428 pp.834-840</host></reference><reference label="[44]"><authors>R.M. Wilson</authors><title>Graph puzzles, homotopy, and the alternating group</title><host>J. Comb. Theory, Ser. B (1974) pp.86-96</host></reference><reference label="[45]"><authors>D. Kornhauser,G. Miller,P. Spirakis</authors><title>Coordinating pebble motion on graphs, the diameter of permutation groups, and applications</title><host>Proceedings of the 25th Symposium on Foundations of Computer Science (FOCS)Singer Island, FL, USA(1984) pp.241-250</host></reference><reference label="[46]"><authors>R. Gabriele,M. Helmert</authors><title>Non-optimal multi-agent pathfinding is solved (since 1984)</title><host>Symposium on Combinatorial Search(2012) pp.173-174</host></reference><reference label="[47]"><authors>M. Peasgood,J. McPhee,C. Clark</authors><title>Complete and scalable multi-robot planning in tunnel environments</title><host>Proceedings of the First IFAC Workshop on Multivehicle SystemsBahia, Brazil(2006) pp.75-80</host></reference><reference label="[48]"><authors>K. Wang,A. Botea</authors><title>MAPP: a scalable multi-agent path planning algorithm with tractability and completeness guarantees</title><host>J. Artif. Intell. Res.42 (2011) pp.55-90</host></reference><reference label="[49]"><authors>R. Luna,K. Bekris</authors><title>Push and swap: fast cooperative path-finding with completeness guarantees</title><host>Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI)Barcelona, Spain(2011) pp.294-300</host></reference><reference label="[50]"><authors>A. Krontiris,R. Luna,K.E. Bekris</authors><title>From feasibility tests to path planners for multi-agent pathfinding</title><host>Proceedings of the Sixth International Symposium on Combinatorial Search(2013) pp.114-122</host></reference><reference label="[51]"><authors>B. de Wilde,A.W. ter Mors,C. Witteveen</authors><title>Push and rotate: cooperative multi-agent path planning</title><host>Proceedings of the 12th International Conference on Autonomous Agents and Multiagent Systems (AAMAS)Saint Paul, Minnesota(2013) pp.87-94</host></reference><reference label="[52]"><authors>M. Khorshid,R. Holte,N. Sturtevant</authors><title>A polynomial-time algorithm for non-optimal multi-agent pathfinding</title><host>Proceedings of the Symposium on Combinatorial SearchBarcelona, Spain(2011) pp.76-83</host></reference><reference label="[53]"><authors>Q. Sajid,R. Luna,K.E. Bekris</authors><title>Multi-agent pathfinding with simultaneous execution of single-agent primitives</title><host>Proceedings of the Fifth Annual Symposium on Combinatorial Search(2012) pp.88-96</host></reference><reference label="[54]">K. Al-WahediA hybrid local–global motion planner for multi-agent coordinationMaster's thesis<host>(2000)Case Western Reserve University</host></reference><reference label="[55]"><authors>J. van den Berg,J. Snoeyink,M. Lin,D. Manocha</authors><title>Centralized path planning for multiple robots: optimal decoupling into sequential plans</title><host>Proceedings of the Robotics: Science and Systemsvol. 2 (2009)</host></reference><reference label="[56]"><authors>G. Sharon,R. Stern,M. Goldenberg,A. Felner</authors><title>The increasing cost tree search for optimal multi-agent pathfinding</title><host>Proceedings of the Twenty-Second International Joint Conference on Artificial IntelligenceSan Francisco, CA, USA(2011) pp.662-667</host></reference><reference label="[57]"><authors>G. Sharon,R. Stern,A. Felner,N. Sturtevant</authors><title>Conflict-based search for optimal multi-agent path finding</title><host>Proceedings of the AAAI Conference on Artificial IntelligenceToronto, Ontario, Canada(2012)</host></reference><reference label="[58]"><authors>M. Barer,G. Sharon,R. Stern,A. Felner</authors><title>Suboptimal variants of the conflict-based search algorithm for the multi-agent pathfinding problem</title><host>Proceedings of the Sixth International Symposium on Combinatorial Search(2014)</host></reference><reference label="[59]"><authors>G. Sharon,R. Stern,A. Felner,N. Sturtevant</authors><title>Meta-agent conflict-based search for optimal multi-agent path finding</title><host>Proceedings of the Symposium on Combinatorial Search, Niagara FallsOntario, Canada(2012)</host></reference><reference label="[60]"><authors>I. Pohl</authors><title>The avoidance of (relative) catastrophe, heuristic competence, genuine dynamic weighting and computational issues in heuristic problem solving</title><host>Proceedings of the 3rd International Joint Conference on Artificial Intelligence(1973) pp.12-17</host></reference><reference label="[61]">B. Bonet,H. GeffnerPlanning as heuristic searchArtif. Intell.129 (1–2)(2001) pp.5-33ISSN 0004-3702</reference><reference label="[62]">R. KorfLinear-space best-first searchArtif. Intell.62 (1)(1993) pp.41-78ISSN 0004-3702</reference><reference label="[63]"><authors>J. Pearl</authors><title>Heuristics: Intelligent Search Strategies for Computer Problem Solving</title><host>(1984)Addison–Wesley</host></reference><reference label="[64]">J. GaschnigPerformance measurement and analysis of certain search algorithmsPh.D. thesis<host>(1979)Carnegie-Mellon University</host></reference><reference label="[65]"><authors>H. Davis,A. Bramanti-Gregor,J. Wang</authors><title>The advantages of using depth and breadth components in heuristic search</title><host>Methodologies for Intelligent Systemsvol. 3 (1989) pp.19-28</host></reference><reference label="[66]"><authors>M. Goldenberg,A. Felner,N. Sturtevant</authors><title>Optimal-generation variants of EPEA⁎</title><host>Proceedings of the Sixth International Symposium on Combinatorial SearchLeavenworth, Washington, USA(2013) pp.89-97</host></reference></references><footnote><note-para label="1">In a slight abuse of terminology, we define the configuration space of a multirobot system as the Cartesian product of the free configuration spaces of the individual robots. The free configuration space of a robot is the space of all positions that a robot can occupy without colliding with itself or an obstacle. We use the term “joint” configuration space to emphasize that we are referring to the configuration space of the entire system, not that of a single robot.</note-para><note-para label="2">{a mathematical formula}M⁎ has previously been used as the name of an unrelated opponent modeling search algorithm [11].</note-para><note-para label="3">An optimal path is a collision-free path which minimizes some cost function.</note-para><note-para label="4">If {a mathematical formula}πϕ(vk,vf) encounters a vertex in the explored graph {a mathematical formula}Gexp, then there may be some {a mathematical formula}vl∈πϕ(vk,vf) such that {a mathematical formula}Ψ(vl)≠∅, with {a mathematical formula}vl∈Gexp. In such a case, {a mathematical formula}πϕ(vk,vf) is not wholly within {a mathematical formula}Gsch. For this reason, only the portion of {a mathematical formula}πϕ(vk,vf) prior to reaching a vertex in {a mathematical formula}Gexp is considered.</note-para><note-para label="5">We note that if the equality {a mathematical formula}g(π(vs,vc))+h(vc)≤g(π⁎(vs,vf)) holds for case 2, then {a mathematical formula}M⁎ may find the optimal path while both case 1 and case 2 hold. We gloss over this point in the main text, as it ultimately does not change the logic of the proof.</note-para><note-para label="6">The results for MA-CBS for fully coupled problems are insensitive to the merge threshold chosen for MA-CBS.</note-para></footnote></root>