<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370216000114</url><title>Solving QBF with counterexample guided refinement</title><authors>Mikoláš Janota,William Klieber,Joao Marques-Silva,Edmund Clarke</authors><abstract>This article puts forward the application of Counterexample Guided Abstraction Refinement (CEGAR) in solving the well-known PSPACE-complete problem of quantified Boolean formulas (QBF). The article studies the application of CEGAR in two scenarios. In the first scenario, CEGAR is used to expand quantifiers of the formula and subsequently a satisfiability (SAT) solver is applied. First it is shown how to do that for two levels of quantification and then it is generalized for arbitrary number of levels by recursion. It is also shown that these ideas can be generalized to non-prenex and non-CNF QBF solvers. In the second scenario, CEGAR is employed as an additional learning technique in an existing DPLL-based QBF solver. Experimental evaluation of the implemented prototypes shows that the CEGAR-driven solver outperforms existing solvers on a number of benchmark families and that the DPLL solver benefits from the additional type of learning.</abstract><keywords>QBF;Expansion;Counterexample guided abstraction refinement (CEGAR)</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>SAT solving has marked a considerable practical success by enabling efficient solving of large industrial NP-hard problems. This motivates the study of computationally harder problems. Quantified Boolean formulas (QBFs) [1] naturally extend the SAT problem by enabling quantification. The cost of this extension is that deciding QBF formulas is PSPACE-complete. However, this also means that a larger set of problems can be targeted [2], [3], [4], [5].</paragraph><paragraph>While nonrandom SAT solving has been dominated by the DPLL procedure, it has proven to be far from being a silver bullet for QBF solving. Indeed, a number of solving techniques have been proposed for QBF [6], [7], [8], [9], [10], complemented by a variety of preprocessing techniques[11], [12], [13], [14], [15], [16].</paragraph><paragraph>Currently, QBF solving can be divided into search-based and expansion-based. Search-based solvers apply conflict and solution-driven search throughout the formula's assignments [17]. In contrast, expansion-based solvers transform the formula into a propositional one by gradually rewriting quantifiers into the corresponding Boolean connectives [18], [8], [19], [9]. This, however, may lead to exponential blowup in the size of the formula. This article provides a technique that mitigates this issue. Instead of always expanding quantifiers, they are expanded carefully, on demand. For such, we apply the well-known paradigm of counterexample guided abstraction refinement (CEGAR) [20].</paragraph><paragraph>The article shows that CEGAR can be applied in two significantly different ways. The first approach gradually expands the given formula into a propositional one. Once the formula is propositional, a SAT solver is applied in a blackbox-fashion. In the spirit of CEGAR, the algorithm partially expands the formula and tests whether such expansion is sufficient. If it is not, the algorithm continues. The second approach employs CEGAR as an additional learning technique in an existing DPLL-based QBF solver. At the price of higher memory consumption, this learning technique enables more aggressive pruning of the search space than the existing techniques [17], [21]. The experimental evaluation carried out demonstrates that CEGAR-based techniques are useful for a large number of benchmark families.</paragraph><paragraph>This article builds on a previous paper on 2-level QBF solving [22] and solving of QBF of arbitrary levels [23]. This article extends this work by showing that CEGAR-driven expansion can be also applied to QBF formulas that are both non-CNF and non-prenex.</paragraph><paragraph>This article is organized as follows. Section 2 introduces concepts and notation used throughout the article. Section 3 shows a CEGAR-based algorithm for solving QBF formulas with two levels of quantification. Section 4 shows a CEGAR-based algorithm for solving arbitrary formulas in prenex form; this is an extension of the previous section availing of recursion. Section 5 extends the previous sections by showing an algorithm for solving formulas that are not necessarily in the prenex form. Section 6 shows how CEGAR is integrated into an existing search-based solver as a form of learning. Section 7 provides experimental evaluation of the implemented prototypes. Section 8 overviews related work and finally, Section 9 concludes and provides pointers to future work.</paragraph></section><section label="2"><section-title>Preliminaries</section-title><paragraph>We overview basic notation and concepts used throughout the article; for further details see [1].</paragraph><paragraph>Throughout the paper we operate on Boolean variables (x, {a mathematical formula}x1, etc.), which are composed into formulas by logical connectives with their standard semantics (∧, ∨, ¬, ⇒, ⇔). A Boolean formula in conjunctive normal form (CNF) is a conjunction of clauses, where a clause is a disjunction of literals, and a literal is either a variable or its complement. Whenever convenient, a CNF formula is treated as a set of clauses. For a literal l, {a mathematical formula}var(l) denotes the variable in l, i.e., {a mathematical formula}var(¬x)=var(x)=x. We write {a mathematical formula}|ϕ| to denote the size of a formula ϕ, defined as the sum of the number of connective and variable occurrences in ϕ.</paragraph><paragraph>Variable assignments (τ, μ, etc.) are mappings from variables to the constants 0 and 1, represented as {a mathematical formula}x/1,y/0 etc. The constant 1 represents true and 0 represents false.</paragraph><paragraph>Notation. We write {a mathematical formula}BY for the set of assignments to the variables Y.</paragraph><paragraph>For a Boolean formula ϕ and an assignment τ we write {a mathematical formula}ϕ[τ] for the substitution of τ in ϕ. A substitution also performs basic simplifications, e.g. {a mathematical formula}(¬x∨y)[x/0]=(¬0∨y)=1. An assignment τ satisfies ϕ if {a mathematical formula}ϕ[τ]=1.</paragraph><paragraph>The set of Quantified Boolean Formulas (QBF) is the smallest set satisfying the following rules: any Boolean formula is a QBF; if Φ is a QBF, then {a mathematical formula}∃x.Φ and {a mathematical formula}∀x.Φ are also QBFs. For {a mathematical formula}∃x.Φ we say that x is existentially bound in Φ; likewise {a mathematical formula}∀x.Φ makes x universally bound in Φ. A variable not bound by any quantifier is called a free variable. A QBF with no free variables is called closed. Without loss of generality, we assume that for any given formula, once a variable is quantified over, it is never quantified over in the same formula nor it appears as free.</paragraph><paragraph>We extend the notion of substitution to QBF so that it first removes the quantifiers of substituted variables and then substitutes all occurrences with their assigned values. For instance, if τ is an assignment to a variable x, then {a mathematical formula}(QyQxQz.ϕ)[τ] results in {a mathematical formula}(QyQz.ϕ[τ]).</paragraph><paragraph>We define the semantics of QBF by assigning satisfying assignments to a formula. This is done inductively so that {a mathematical formula}∃x.Φ has the same satisfying assignments as the formula {a mathematical formula}Φ[x/0]∨Φ[x/1] and {a mathematical formula}∀x.Φ has the same satisfying assignments as the formula {a mathematical formula}Φ[x/0]∧Φ[x/1].</paragraph><paragraph>Notation. For a quantifier type Q we write {a mathematical formula}Q¯ to denote the opposing quantifier type. In particular {a mathematical formula}Q¯ denotes ∀ if {a mathematical formula}Q=∃ and {a mathematical formula}Q¯ denotes ∃ if {a mathematical formula}Q=∀.</paragraph><paragraph>A QBF is in prenex form if it is in the form {a mathematical formula}Q1z1…Qnzn.ϕ where {a mathematical formula}Qi∈{∀,∃}, {a mathematical formula}zi are distinct variables, and ϕ is a propositional formula. The sequence of quantifiers is called prefix and the propositional formula matrix. The prefix is divided into quantifier blocks, {a mathematical formula}∀x1…∀xn, resp. {a mathematical formula}∃x1…∃xn, which we denote by ∀X, resp. ∃X, where {a mathematical formula}X={x1,…,xn}. We assume that such blocks are maximal. Hence a prenex QBF has the form {a mathematical formula}Q1X1…QkXk.ϕ with {a mathematical formula}Qi∈{∃,∀}, {a mathematical formula}Qi≠Qi+1. A block {a mathematical formula}QiXi is referred to as level i.</paragraph><paragraph>Whenever convenient, parts of a prefix are denoted as P with possible subscripts, e.g., {a mathematical formula}P1∀XP2.ϕ denotes a QBF with the matrix ϕ and a prefix that contains ∀X. If the quantifier of a block Y occurs within the scope of the quantifier of another block X, we say that variables in X are upstream of variables in Y and that variables in Y are downstream of variables in X.</paragraph><paragraph>The pseudocode throughout the article uses the function {a mathematical formula}SAT(ϕ) to represent a call to a SAT solver on a propositional formula ϕ. The function returns a satisfying assignment for ϕ, if such exists, and returns NULL otherwise. In practice SAT solvers require formulas in CNF, which can always be guaranteed in linear time by standard techniques [24], [25].</paragraph><section label="2.1"><section-title>Game-centric view</section-title><paragraph>An alternative view on QBF semantics is that a QBF is a game between the universal player and the existential player[26]. During the game, the existential player assigns values to the existentially quantified variables and the universal player assigns values to the universally quantified ones. A player can assign a value to a variable only if all variables upstream of it already have a value. The existential player wins if the formula evaluates to 1 and the universal player wins if it evaluates to 0.</paragraph><paragraph label="Example 1">Consider the formula {a mathematical formula}∃x∀u∃z.(u⇒(x⇔z))∧(¬u⇒(¬x⇔z)). The game {a mathematical formula}x=0, {a mathematical formula}u=0, {a mathematical formula}z=0 is losing for the existential player while {a mathematical formula}x=0, {a mathematical formula}u=0, {a mathematical formula}z=1 is losing for the universal player. In this formula the existential player can always ensure that he wins. One possible winning strategy for the existential player is to play {a mathematical formula}x=1 and {a mathematical formula}z=u. This is easily verified, as once x is set to 1, the formula simplifies to {a mathematical formula}∀u∃z.(u⇒z)∧(¬u⇒¬z). Now if the universal player sets u to 1, then the formula simplifies to {a mathematical formula}∃z.(z), where the existential player satisfies the matrix by setting z to 1. The case when the universal player sets u to 0 is analogous. ▴</paragraph><paragraph>We note that the order in which values are given to variables in the same block is unimportant. Hence, by a move we mean an assignment to variables in a certain block. A concept useful throughout the article are the winning moves.</paragraph><paragraph label="Definition 1">Winning moveConsider a (nonprenex) closed QBF {a mathematical formula}QX.Φ and an assignment τ to X. Then τ is called a winning move for QX in {a mathematical formula}QX.Φ if {a mathematical formula}Q=∃ and {a mathematical formula}Φ[τ] is true, or, {a mathematical formula}Q=∀ and {a mathematical formula}Φ[τ] is false.</paragraph><paragraph>Notation. We write {a mathematical formula}M(QX.Φ) to denote the set of winning moves for {a mathematical formula}QX.Φ.</paragraph><paragraph label="Definition 2">CountermoveConsider a (nonprenex) closed QBF {a mathematical formula}QXQ¯Y.Φ and an assignment τ to X and an assignment μ to Y. We say that μ is a countermove to τ in {a mathematical formula}QXQ¯Y.Φ if {a mathematical formula}Q=∃ and {a mathematical formula}Φ[τ][μ] is false or if {a mathematical formula}Q=∀ and {a mathematical formula}Φ[τ][μ] is true.</paragraph><paragraph label="Observation 1">A closed QBF{a mathematical formula}∃X.Φis true iff there exists a winning move for ∃X. A closed QBF{a mathematical formula}∀X.Φis false iff there exists a winning move for ∀X.</paragraph><paragraph label="Observation 2">Let{a mathematical formula}QXQ¯Y.Φbe a (nonprenex) closed QBF and τ be an assignment to X.</paragraph><list><list-item label="1.">The assignment τ is a winning move for QX iff there does not exists a countermove to τ.</list-item><list-item label="2.">An assignment μ to Y is a countermove to τ iff μ is a winning move for{a mathematical formula}Q¯Yin{a mathematical formula}Q¯Y.Φ[τ].</list-item></list><paragraph label="Example 2">Consider the formula {a mathematical formula}Ψ=∀x∃y.y∧(x∨y¯), then the following holds. The assignment {a mathematical formula}{x/0} is a winning move for ∀x, hence the formula is false from Observation 1. The assignment {a mathematical formula}{y/1} is a winning move for ∃y in {a mathematical formula}∃y.(y∧(x∨y¯))[x/1]. Hence, {a mathematical formula}{y/1} is a countermove to {a mathematical formula}{x/1} due to Observation 2(2). Since there exists a countermove to {a mathematical formula}{x/1}, the assignment {a mathematical formula}{x/1} is not a winning move for ∀x in Ψ due to Observation 2(1). ▴</paragraph></section></section><section label="3"><section-title>2-level QBF</section-title><paragraph>This section focuses on prenex QBF with 2 levels of quantification, i.e., {a mathematical formula}∀X∃Y.ϕ or {a mathematical formula}∃X∀Y.ϕ. First we take a look at an even simpler case and that is formulas with a single quantifier, i.e., {a mathematical formula}∀X.ϕ or {a mathematical formula}∃X.ϕ. Such formulas represent a 1-move game, where only one of the players is allowed to make a single move upon which the game ends. The problem of deciding 1-quantifier formulas naturally translates to propositional satisfiability. In particular, there exists a winning move for the formula {a mathematical formula}∃X.ϕ if and only if ϕ is satisfiable. Analogously, there exists a winning move for the ∀-player for the formula {a mathematical formula}∀X.ϕ if and only if ¬ϕ is satisfiable. Further, the satisfying assignments of the respective formula are winning moves for the corresponding player.</paragraph><paragraph>This observation motivates the following approach to solving QBF. Start eliminating quantifiers until only one is left at which point invoke a SAT solver. The question is how to eliminate quantifiers. The approach we take here is by expansion, in particular we apply the equivalences {a mathematical formula}∀x.Φ=Φ[x/0]∧Φ[x/1] and {a mathematical formula}∃x.Φ=Φ[x/0]∨Φ[x/1].</paragraph><paragraph>An observation, key to the CEGAR approach, is that in some cases a full expansion is not needed in order to decide the given formula. Instead, we consider partial expansions that consider only certain values of variables. The following example illustrates how partial expansions are useful.</paragraph><paragraph label="Example 3">Let {a mathematical formula}ϕ=(u∨e1)∧(u¯∨e2)∧(e¯1∨e¯2) and consider {a mathematical formula}∀u∃e1e2.ϕ. The formula is true and therefore there is no winning move for the ∀ player. One could expand {a mathematical formula}e1 and {a mathematical formula}e2 with the all 4 possible assignments to {a mathematical formula}e1 and {a mathematical formula}e2. However, we observe that considering only two is sufficient. In particular, considering the assignments {a mathematical formula}{e1/1,e2/0} and {a mathematical formula}{e1/0,e2/1} yields {a mathematical formula}(∀u.ϕ[e1/1,e2/0]∨ϕ[e1/0,e2/1])=(∀u.u¯∨u)=1. ▴</paragraph><paragraph>A partial expansion may be sufficient to decide a formula but there are also partial expansions that are not sufficient as illustrated by the following example.</paragraph><paragraph label="Example 4">The formula {a mathematical formula}∀u∃e.(u∨e)∧(u¯∨e¯) is true. Expanding e only by {a mathematical formula}{e/0} gives {a mathematical formula}∀u.u, which is false. Similarly, expanding e only by {a mathematical formula}{e/1} yields {a mathematical formula}∀u.u¯, which is also false. ▴</paragraph><paragraph>The key question is, how to discover the right expansions? This is where CEGAR comes into play: Start by a small partial expansion and gradually enlarge it until it becomes sufficient. To this effect, an abstraction corresponds to a partial expansion parameterized by the sets of values which are used to carry out the expansion.</paragraph><paragraph label="Definition 3">ω-abstractionLet {a mathematical formula}X,Y be sets of variables and {a mathematical formula}ω⊆BY.The ω-abstraction of the closed formula {a mathematical formula}∀X∃Y.ϕ is {a mathematical formula}∀X.⋁ν∈ωϕ[Y/ν].The ω-abstraction of the closed formula {a mathematical formula}∃X∀Y.ϕ is {a mathematical formula}∃X.⋀ν∈ωϕ[Y/ν].</paragraph><paragraph>For an abstraction to be useful, it must in some sense approximate the original problem. This is indeed the case for ω-abstraction because for any ω, the set of winning moves of the ω-abstraction is a superset of the winning moves of the original formula. Adding more countermoves to ω decreases the abstraction's set of winning moves. Consequently, if ω contains all possible countermoves, the abstraction becomes equivalent to the formula.</paragraph><paragraph label="Observation 3">Let{a mathematical formula}ω,ω1,ω2,⊆BY.</paragraph><list><list-item label="1.">{a mathematical formula}M(∀X∃Y.ϕ)=M(∀X.⋁μ∈BYϕ[μ])</list-item><list-item label="2.">{a mathematical formula}M(∃X∀Y.ϕ)=M(∃X.⋀μ∈BYϕ[μ])</list-item><list-item label="3.">If{a mathematical formula}ω1⊆ω2then{a mathematical formula}M(∀X.⋁μ∈ω2ϕ[μ])⊆M(∀X.⋁μ∈ω1ϕ[μ])</list-item><list-item label="4.">If{a mathematical formula}ω1⊆ω2then{a mathematical formula}M(∃X.⋀μ∈ω2ϕ[μ])⊆M(∃X.⋀μ∈ω1ϕ[μ])</list-item><list-item label="5.">{a mathematical formula}M(∀X∃Y.ϕ)⊆M(∀X.⋁μ∈ωϕ[μ])</list-item><list-item label="6.">{a mathematical formula}M(∃X∀Y.ϕ)⊆M(∃X.⋀μ∈ωϕ[μ])</list-item></list><paragraph>Observation 3 motivates how to use ω-abstraction in a CEGAR loop. The loop first finds a winning move of the current ω-abstraction and then it tests whether that move is also a winning move of the formula being solved. If it is, we are done. If however the winning move for the abstraction is not a winning move of the original formula, the abstraction needs to be refined. To facilitate the discussion, a winning move of an abstraction is referred to as a candidate.</paragraph><paragraph>Two questions remain. How do we know that a candidate is a winning move of the original formula? How is the abstraction refined if the candidate is not a winning move? The first question is directly answered by Observation 2, i.e., a candidate τ is a winning move for ∀X in {a mathematical formula}∀X∃Y.ϕ iff there is no winning move for ∃Y in {a mathematical formula}∃Y.ϕ[τ]. Analogously, a candidate τ is a winning move for ∃X in {a mathematical formula}∃X∀Y.ϕ iff there is no winning move for ∀Y in {a mathematical formula}∀Y.ϕ[τ]. This also gives an answer to the second question, i.e., if there is a countermove μ to a candidate τ under some ω-abstraction, the countermove μ is added to ω.</paragraph><paragraph>Algorithm 1 shows the above-presented ideas in pseudocode. The algorithm maintains a set of countermoves ω, initialized to the empty set (line 1). In each iteration of the loop it first constructs an abstraction according to Definition 3 (line 3). Note that upon initialization {a mathematical formula}ω=∅ and therefore we have {a mathematical formula}α=1, if {a mathematical formula}Q=∃, since the empty conjunction is semantically equal to 1; analogously, the initial {a mathematical formula}α=0 if {a mathematical formula}Q=∀. Subsequently, the algorithm tries to find a winning move for the abstraction (line 4). If no candidate is found, it means that there is no winning move for the given formula {a mathematical formula}QXQ¯Y.ϕ due to Observation 3 and thus the algorithm terminates. If on the other hand a candidate τ was found,{sup:1} a SAT solver is used to find a countermove for it (line 6). If there is no countermove, then τ is indeed a winning move and the algorithm terminates. If there is a countermove μ, this countermove is added to the set ω (line 8).</paragraph><paragraph label="Example 5">Consider the formula {a mathematical formula}∃e1e2∀u1u2.ϕ, where {a mathematical formula}ϕ=(e1∨(u1∧u2))∧(e2∨(u¯1∧u¯2)). The following is one possible run of Algorithm 1. Initial ω-abstraction for {a mathematical formula}ω=∅ is {a mathematical formula}α1=1. The first SAT call yields the candidate {a mathematical formula}τ1={e1/0,e2/0}. Subsequently, another SAT call is issued to obtain a countermove {a mathematical formula}SAT(¬ϕ[τ1]), which returns {a mathematical formula}μ1={u1/0,u2/0}. This countermove yields the refinement {a mathematical formula}α2=(α1∧e1)=e1. The second iteration produces a candidate {a mathematical formula}SAT(α2)=τ2 with {a mathematical formula}τ2={e1/1,e2/0} and a countermove {a mathematical formula}SAT(¬ϕ[τ2])=μ2 with {a mathematical formula}μ2={u1/0,u2/1}. The corresponding refinement is {a mathematical formula}α3=(α2∧e2)=(e1∧e2). The candidate in the third iteration is inevitably {a mathematical formula}τ3={e1/1,e2/1}, which is a winning move for {a mathematical formula}∃e1e2 as there are no countermoves to it, i.e., {a mathematical formula}SAT(¬ϕ[τ3])=NULL. ▴</paragraph><paragraph>To conclude the description of this algorithm, we would like to make an important remark about how the expansion is done. Recall that the main motivation for expansion was to get rid of one of the quantifiers in order to enable the use of a SAT solver. Now observe that Algorithm 1 always expands the innermost quantifier. So a natural question would be, why not expand the outermost quantifier? While this would be sound, it would not be useful. To illustrate why not, let us consider the case when {a mathematical formula}Φ=∃X∀Y.ϕ. Expanding the first quantifier by the set of assignments ω yields {a mathematical formula}⋁τ∈ω(∀Y.ϕ[τ]). Observe that the disjuncts {a mathematical formula}(∀Y.ϕ[τ]) are independent from one another. So Φ is true iff there exists a τ for which {a mathematical formula}(∀Y.ϕ[τ]) is true. Consequently, if Φ is true, it is unnecessary to construct the expansion because it is sufficient to come upon the right τ. If, on the other hand, Φ is false, none of the disjuncts is true for any ω. Hence, in such case it would be necessary to consider the full expansion, i.e., {a mathematical formula}ω=BX.</paragraph><section label="3.1"><section-title>Properties</section-title><paragraph>Let us now discuss correctness and several other important properties of Algorithm 1. The behavior of the algorithm largely hinges on the following property of ω-abstraction. Once a countermove is included into an ω-abstraction, the abstraction prohibits this countermove. This is formalized by the following lemma.</paragraph><paragraph label="Lemma 1">Let{a mathematical formula}Φ=QXQ¯Y.ϕand{a mathematical formula}ω⊆BY. If τ is a winning move of the ω-abstraction and{a mathematical formula}μ∈ωthen μ is not a countermove to τ in Φ.</paragraph><paragraph label="Proof">Consider the case {a mathematical formula}Q=∃. The ω-abstraction is equal to {a mathematical formula}∃X.(⋀ν∈ωϕ[ν]). Since {a mathematical formula}μ∈ω, the abstraction is also equal to {a mathematical formula}∃X.(ϕ[μ]∧⋀ν∈ωϕ[ν]). Since τ is a winning move for the abstraction, then also {a mathematical formula}ϕ[μ][τ] is true (note that ϕ does not have any other variables besides X and Y). For contradiction, let μ be a countermove to τ in Φ, i.e., the assignment μ is a winning move for ∀Y in {a mathematical formula}∀Y.ϕ[τ]. From definition of a winning move, it holds {a mathematical formula}¬ϕ[τ][μ]. This is an immediate contradiction because {a mathematical formula}ϕ[τ][μ]=ϕ[μ][τ] as τ and μ are assignments to disjoint sets of variables. The case {a mathematical formula}Q=∀ is shown analogously.  □</paragraph><paragraph>Lemma 1 lets us derive that candidates in the CEGAR loop cannot repeat.</paragraph><paragraph label="Proposition 1">Consider a run ofAlgorithm 1on a formula{a mathematical formula}Φ=QXQ¯Y.ϕ. Let{a mathematical formula}τiand{a mathematical formula}τkbe candidates found in the i-th and k-th iterations of the loop, respectively, where{a mathematical formula}i&lt;k. Then{a mathematical formula}τi≠τk.</paragraph><paragraph label="Proof">Let {a mathematical formula}ωk be the value of ω at the beginning of the k-th iteration. Let {a mathematical formula}μi be a countermove found in the i-th iteration. Since {a mathematical formula}μi∈ωk, from Lemma 1, {a mathematical formula}μi is not a countermove to {a mathematical formula}τk but at the same time {a mathematical formula}μiis a countermove to {a mathematical formula}τi, hence {a mathematical formula}τi≠τk.  □</paragraph><paragraph>Proposition 1 itself would be sufficient to show termination of the algorithm but Lemma 1 lets us derive another important property of Algorithm 1, which is that countermoves cannot repeat in the algorithm's loop.</paragraph><paragraph label="Proposition 2">Consider a run ofAlgorithm 1on a formula{a mathematical formula}Φ=QXQ¯Y.ϕ. Let{a mathematical formula}μiand{a mathematical formula}μkbe countermoves found in the i-th and k-th iterations of the loop, respectively, where{a mathematical formula}i&lt;k. Then{a mathematical formula}μi≠μk.</paragraph><paragraph label="Proof">Let {a mathematical formula}τk be a candidate found in the k-th step and {a mathematical formula}ωk be the value of ω at the beginning of k-th iteration. Since {a mathematical formula}μi∈ωk, due to Lemma 1, {a mathematical formula}μi is not a countermove to {a mathematical formula}τk in Φ. Since {a mathematical formula}μkis a countermove to {a mathematical formula}τk, it must be that {a mathematical formula}μi≠μk.  □</paragraph><paragraph>Proposition 1 and Proposition 2 tell us that neither candidates nor countermoves can repeat in the iteration loop, which yields the following upper bound on the total number of iterations.</paragraph><paragraph label="Proposition 3">Consider a run ofAlgorithm 1on a formula{a mathematical formula}QXQ¯Y.ϕ. Let{a mathematical formula}k=min(|X|,|Y|), thenAlgorithm 1performs at most{a mathematical formula}2kiterations of the loop. Consequently,Algorithm 1requires at most{a mathematical formula}2⋅2kSAT calls. Excluding the space required in SAT calls, the algorithm requires at most{a mathematical formula}O(|ϕ|⋅2k)space.</paragraph><paragraph label="Proof">There are {a mathematical formula}2|X| possible candidates and {a mathematical formula}2|Y| possible countermoves. Since due to Proposition 1 and Proposition 2 neither candidates nor countermoves repeat, the loop of Algorithm 1 can perform at most {a mathematical formula}2min(|X|,|Y|) iterations.In each iteration of the loop of Algorithm 1 the current ω-abstraction is augmented by {a mathematical formula}ϕ[μ], with μ the countermove, and it holds that {a mathematical formula}|ϕ[μ]|∈O(|ϕ|).  □</paragraph><paragraph>While the theoretical upper bound given by Proposition 3 is rather crude, we observe that Proposition 1 and Proposition 2 give us some further insights. A refinement by a countermove μ prevents the algorithm from finding any candidates to which μ is also a countermove.</paragraph><paragraph>This is illustrated by Fig. 1, which depicts a situation where we have possible candidates {a mathematical formula}τ1,…,τk,…,τm such that {a mathematical formula}μ1 is a countermove to the candidates {a mathematical formula}τ1…,τk and {a mathematical formula}μ2 is a countermove to the candidates {a mathematical formula}τk,…,τm. Now consider a scenario when Algorithm 1 finds a candidate {a mathematical formula}τ1 and subsequently the countermove {a mathematical formula}μ1. Upon refinement, due to Lemma 1, {a mathematical formula}τ1,…,τk are excluded from further search since they cannot be winning moves of the abstraction, which now contains {a mathematical formula}μ1. Hence, the next iteration of the algorithm must consider one of the candidates {a mathematical formula}τk+1,…,τm. Let's say it considers {a mathematical formula}τm and subsequently it finds the countermove {a mathematical formula}μ2. Once {a mathematical formula}μ2 is included into the abstraction, the algorithm terminates because the abstraction does not have any winning moves.</paragraph><paragraph>What we observe is that the space of possible candidates is diminished more if the countermove just found is a countermove to many possible candidates. This is useful in both situations when there exists a winning move for the given formula or when there does not exist a winning move. If there does not exist a winning move, the algorithm needs to find such set ω of countermoves that covers all the possible candidates (the full set of assignments). If there exists a winning move, the algorithm is more likely to find the winning one if the possible space of candidates is small. The following example illustrates this idea.</paragraph><paragraph label="Example 6">Let {a mathematical formula}Φ=∃xy∀q.((x∧q)∨(x∧¬q))∧((y∧q)∨(y∧¬q)) and consider the following run of the algorithm. The first candidate is {a mathematical formula}τ1={x/0,y/0} and countermove {a mathematical formula}μ1={q/1} with the corresponding refinement {a mathematical formula}α2=x∧y. Inevitably, the second candidate {a mathematical formula}τ1={x/1,y/1} is a winning move. Observe that {a mathematical formula}μ1 is a countermove to all candidates that are not winning moves. ▴</paragraph></section><section label="3.2"><section-title>Solving 2-level quantification with CNF matrices</section-title><paragraph>So far we have only required formulas to be in prenex form and there were no restrictions imposed on the matrix. This section looks in more detail at solving formulas where the matrix is in CNF. CNF is a popular form in SAT and QBF since it enables simple and efficient data structures. An important property of QBF with CNF matrices is that it is sufficient to consider prefixes that end with an existential quantifier block. This is because if there are universal variables at the innermost level, the corresponding literals can be removed from the formula.{sup:2}</paragraph><paragraph label="Lemma 2">Let x be a variable and ϕ a CNF. Define{a mathematical formula}ϕ′as ϕ after removing all occurrences of literals containing x. The QBFs{a mathematical formula}∀x.ϕand{a mathematical formula}ϕ′have the same set of satisfying assignments.</paragraph><paragraph label="Proof">Let C be a clause not containing the variable x and let {a mathematical formula}ϕ′ be such that {a mathematical formula}ϕ=ϕ′∧(C∨x). We show that x can be removed safely from the clause {a mathematical formula}C∨x. It holds that {a mathematical formula}∀x.(C∨x)∧ϕ=((C[x/0]∨x[x/0])∧ϕ[x/0])∧((C[x/1]∨x[x/1])∧ϕ[x/1])=C∧ϕ[x/0]∧ϕ[x/1]=∀x.C∧ϕ.  □</paragraph><paragraph>In the light of Lemma 2, for two-level QPCNF it is only meaningful to consider formulas in the form {a mathematical formula}∀X∃Y.ϕ. Hence, we are always looking for a winning move for the universal quantifier. Note that this is equivalent to looking for such assignment τ to X that makes {a mathematical formula}ϕ[X/τ] unsatisfiable.</paragraph><paragraph>The pseudo-code is presented by Algorithm 2. The structure of the algorithm remains the same as Algorithm 1 but several important implementation improvements can be achieved. The workings of the algorithm is greatly influenced by the interface of modern SAT solvers. The vast majority of modern SAT solvers accept formulas in CNF and therefore our objective is to construct formulas passed to the SAT solver in this form. Further, modern SAT solvers enable incremental SAT solving; that is, the same SAT solver can be invoked multiple times and the input formula can be strengthened in between the calls. In this fashion incremental SAT solving enables the SAT solver to reuse any information that the solver has learned about the formula. CEGAR-based solving can take advantage of incremental SAT solving because the constructed abstraction is always being strengthened by refinement.</paragraph><paragraph>Let us look more closely and how refinement is realized in Algorithm 2. Recall that our objective is to obtain a winning move for ∀X. Consequently, to obtain a candidate from an abstraction α, we wish to issue the call {a mathematical formula}SAT(¬α). At the same time, each refinement corresponds to disjoining to the current abstraction the formula {a mathematical formula}ϕ[μ], where μ is the current countermove. In order to implement this behavior, we observe that the abstraction α does not need to be explicitly constructed and we will rather directly construct its negation.</paragraph><paragraph>For such, Algorithm 2 maintains a set of clauses ρ, which is a CNF representation of the negation of the abstraction. The variable ρ is initialized to the empty set of clauses, i.e., semantically it is equal to the constant 1. Since the abstraction is weakened with {a mathematical formula}ϕ[μ] in each refinement, the negation is strengthened with {a mathematical formula}¬ϕ[μ]. However, because ϕ is in CNF, its negation is in DNF. In order to translate {a mathematical formula}¬ϕ[μ] to CNF, the standard technique of introducing new variables, sometimes called Tseitin variables, is used [24]. Additionally, we take advantage of the formula's specific form, and we use the Plaisted–Greenbaum transformation [25], which introduces implications between the new variables and the encoded structures only in one direction.</paragraph><paragraph>Using this standard CNF encoding techniques, one could simply augment ρ with the encoding of {a mathematical formula}¬ϕ[μ]. But there is another improvement stemming from the fact that clauses in {a mathematical formula}ϕ[μ] may reappear in different refinements. This is realized in the function EncodeNeg (Algorithm 3). The function is invoked on each of the clauses of {a mathematical formula}ϕ[μ]. During the course of the algorithm, the function maintains a mapping (clauseMap) from clauses to literals, where the mapped literal represents that the clause is false. If EncodeNeg is given a clause C that consists of a single literal, it simply returns the negation of this literal. If EncodeNeg is given a clause C that is already mapped to some Tseitin variable, this variable is returned. Otherwise, EncodeNeg creates a fresh variable {a mathematical formula}zC and adds to ρ the clauses forcing ¬C whenever {a mathematical formula}zC is true. Consequently, constructing the clause {a mathematical formula}Cr=⋁C∈ϕ[μ]EncodeNeg(C,ρ) represents that one of the clauses from {a mathematical formula}ϕ[μ] must be false, i.e., {a mathematical formula}¬ϕ[μ] must be true. Note that any clauses that are reduced to true by the assignment μ are ignored.</paragraph><paragraph>Since the above-described refinement only adds clauses to ρ, the actual implementation maintains the clauses of ρ in a SAT solver and new clauses are added via the interface of the SAT solver.{sup:3}</paragraph><paragraph>Incremental SAT interface can also be utilized for computing countermoves. Given a candidate τ, we wish to issue the SAT call {a mathematical formula}SAT(ϕ[τ]). For such, an implementation can avail of the assumption-based SAT call. In particular, an instance of a SAT solver is constructed at the beginning of the run of the algorithm and is populated with the clauses of ϕ. Whenever a countermove is needed, this SAT solver is called with assumptions representing the assignment τ.</paragraph></section><section label="3.3"><section-title>Heuristics</section-title><paragraph>The CEGAR loop relies on two calls to a SAT solver and either of these two calls may yield different models for the same abstraction or candidate, respectively. While the correctness of the algorithm is not affected by which of these models is returned, the overall efficiency of the algorithm may be affected. Here we propose two heuristics. One that discriminates between the possible candidates and one that discriminates between the possible counterexamples.</paragraph><paragraph>To formulate the heuristic we avail of the partial MaxSAT problem [29]. The partial MaxSAT problem is specified by two sets of clauses: a set of hard clauses {a mathematical formula}ϕh, and a set of soft clauses {a mathematical formula}ϕs. A solution to the problem is an assignment that satisfies all the hard clauses and maximizes the number of satisfied soft clauses.</paragraph><paragraph label="Example 7">Consider the MaxSAT problem with hard clauses {a mathematical formula}ϕh={(x∨y∨z),(¬z∨w)} and the soft clauses {a mathematical formula}ϕs={(¬x),(¬y),(¬z),(¬w)}. The assignment {a mathematical formula}{x/1,y/0,z/0,w/0} is a possible solution, which satisfies 3 soft clauses. In contrast, {a mathematical formula}{x/0,y/0,z/1,w/1}, satisfies all the hard clauses but it is not a solution to the problem because it satisfies only 2 soft clauses. Note that solving this problem is equivalent to finding a satisfying assignment to {a mathematical formula}ϕh and minimizing the sum {a mathematical formula}x+y+z+w. ▴</paragraph><paragraph>Candidate heuristic  The objective of the heuristic used in computing a candidate (the call {a mathematical formula}SAT(ω) in Algorithm 2) is to find such candidates that are likely to be winning moves for the universal player in the formula {a mathematical formula}∀X∃Y.ϕ. Recall that a complete assignment τ to X is a winning move for the universal player if {a mathematical formula}ϕ[X/τ] is unsatisfiable. Motivated by the intuition that larger formulas are more likely to be unsatisfiable than smaller ones, we pick such candidates that maximize the number of clauses of {a mathematical formula}ϕ[X/τ]. In another words, we wish to compute such τ that does not satisfy as many clauses as possible. Hence, the call {a mathematical formula}SAT(ω) is replaced by the following MaxSAT problem:{a mathematical formula}</paragraph><paragraph>Whenever {a mathematical formula}zC is true, all X literals of C are false. Hence, maximizing the number of variables {a mathematical formula}zC set to true achieves the objective.</paragraph><paragraph>Counterexample heuristic  In the refinement step we consider only those clauses that are not satisfied by the counterexample μ, i.e., such {a mathematical formula}C∈ϕ that {a mathematical formula}C[Y/μ]≠1. Hence, the clause {a mathematical formula}⋁zC, added in line 7, has less literals the more clauses of ϕ are satisfied by μ. Since, in general, short clauses represent stronger constraints than long clauses, we propose a heuristic that looks for those counterexamples that maximize the number of satisfied clauses in ϕ. Hence, the satisfiability problem {a mathematical formula}SAT(ϕ[X/ν]) is replaced by the following MaxSAT problem:{a mathematical formula}</paragraph><paragraph>Implementing heuristics  In both of the aforementioned heuristics the corresponding SAT problem is transformed into a MaxSAT problem. Solving these MaxSAT problems in each iteration of the CEGAR loop is not feasible because typically a large number of iterations is required (up to hundreds of thousands) and MaxSAT is significantly more time-consuming than SAT. Hence, in the implementation we compute an approximate solution to the MaxSAT problems by skewing the default decision polarity and variable activity of a SAT solver. Hard clauses are given to the SAT solver as standard clauses without any change. Each soft clause C is represented by the clause {a mathematical formula}rC∨C where {a mathematical formula}rC is a fresh variable. The polarity of the variable {a mathematical formula}rC is set to 0 and the activity increased. This instructs the SAT solver to set {a mathematical formula}rC to 0 as soon as possible in the search for a satisfying valuation, which then enforces C to be satisfied. While this approach does not guarantee the optimum, it is commonly used in modern MaxSAT and PB solvers and has been successfully applied to SAT solving with preference [30].</paragraph></section></section><section label="4"><section-title>Prenex QBF with arbitrary number of quantification levels</section-title><paragraph>This section generalizes algorithm from Section 3 for an arbitrary number of quantifier levels. This generalization follows the basic structure of Algorithm 1 and uses recursion to cope with the multiple levels. The recursion follows the prefix of the given formula starting with the most upstream variables progressing towards more downstream variables. It tries to find a winning move (Definition 1) for variables in a certain block by making recursive calls to obtain winning moves for the downstream variables. The base case of the recursion, i.e., a QBF with one quantifier, is handled by a SAT solver.</paragraph><paragraph>We begin by generalizing the observations and concepts introduced in the previous section. A quantifier can be expanded into a propositional operator (disjunction of conjunction) and a partial expansion lets us approximate a set of winning moves. An abstraction of a QBF with at least two quantifiers is obtained by partially expanding the second quantifier. Just as before, a candidate refers to a winning move of an abstraction.</paragraph><paragraph label="Observation 4">Let Φ be QBF with free variables in{a mathematical formula}X∪Yand{a mathematical formula}ω1,ω2the subset of{a mathematical formula}BY.</paragraph><list><list-item label="1.">{a mathematical formula}M(∀X∃Y.Φ)=M(∀X.⋁μ∈BYΦ[μ])</list-item><list-item label="2.">{a mathematical formula}M(∃X∀Y.Φ)=M(∃X.⋀μ∈BYΦ[μ])</list-item><list-item label="3.">If{a mathematical formula}ω1⊆ω2then{a mathematical formula}M(∀X.⋁μ∈ω2Φ[μ])⊆M(∀X.⋁μ∈ω1Φ[μ])</list-item><list-item label="4.">If{a mathematical formula}ω1⊆ω2then{a mathematical formula}M(∃X.⋀μ∈ω2Φ[μ])⊆M(∃X.⋀μ∈ω1Φ[μ])</list-item></list><paragraph label="Definition 4">ω-abstractionLet ω be a subset of {a mathematical formula}BY.The ω-abstraction of a closed QBF {a mathematical formula}∀X∃Y.Φ is the formula {a mathematical formula}∀X.⋁μ∈ωΦ[μ].The ω-abstraction of a closed QBF {a mathematical formula}∃X∀Y.Φ is the formula {a mathematical formula}∃X.⋀μ∈ωΦ[μ].</paragraph><paragraph>Note that the above observation and definition are generalizations of Observation 3 and Definition 3, which were aimed at formulas with a two-level prefix, while Observation 4 and Definition 4 hold for an arbitrarily long prefix.</paragraph><paragraph>Algorithm 4 presents a pseudocode utilizing the above-introduced concepts. The algorithm is presented as a recursive function {a mathematical formula}Solve(QX.Φ) that accepts a QBF in prenex form with maximal quantifier blocks. The function returns a winning move for QX, if such exists, it returns NULL otherwise.</paragraph><paragraph>If Φ does not contain any quantifiers (it is a propositional formula), a SAT solver is used to find a winning move (line 3). In the general case, utilizing this CEGAR paradigm, it initializes the set of countermoves ω to the empty set (line 4) and grows it by encountered countermoves (line 12).</paragraph><paragraph>In contrast to the 2-level case, the ω-abstraction cannot be directly solved. This is due to the abstraction not being in prenex form. Hence, before invoking the recursive call to obtain a candidate (line 7), the algorithm must compute a prenex form of the abstraction. Consequently, the prenexed version of the abstraction contains some fresh variables. These need to be filtered out in order to obtain values for the X variables only.</paragraph><paragraph>Let us look at this process in more detail. Consider the case for {a mathematical formula}∃X.Φ (the case {a mathematical formula}Q=∀ is analogous) and consider that Φ has at least two levels of quantification. Hence, the input formula is of the form {a mathematical formula}∃X∀Y∃ZP.ϕ, where {a mathematical formula}P is the rest of the prefix of the formula and ϕ is its matrix. Note that {a mathematical formula}P is empty or it starts with the universal quantifier.</paragraph><paragraph>Further, let us assume that the CEGAR loop carried out k iterations and thus set ω contains k countermoves, i.e., {a mathematical formula}ω={μ1,…,μk}. The abstraction constructed on line 6 is equal to {a mathematical formula}∃X.⋀i∈1..kΦ[μk]. Prenexing this abstraction means introducing for each {a mathematical formula}i∈1..k a fresh set of variables {a mathematical formula}Zi for the variables Z and introducing fresh variables for the variables appearing in the prefix {a mathematical formula}P. Hence, the prenexed form is equal to the following.{a mathematical formula} where {a mathematical formula}Z/Zi stands for the substitution of each variable of the set Z with the corresponding (fresh) variable from {a mathematical formula}Zi. Similarly, {a mathematical formula}Pi is the i-th fresh copy of the prefix {a mathematical formula}P and {a mathematical formula}P/Pi stands for replacing the corresponding variables with their fresh copies.</paragraph><paragraph>If formula (1) has a winning move {a mathematical formula}τ′, it will contain values for the freshly introduced variables {a mathematical formula}Zi. Observe that once these values are filtered out from {a mathematical formula}τ′ (line 9), this is a winning move for the unprenexed version of the abstraction.</paragraph><paragraph label="Example 8">Consider the QBF {a mathematical formula}∃vw.Φ, where{a mathematical formula} and the candidates {a mathematical formula}{v/1,w/1} and {a mathematical formula}{v/0,w/0}, and corresponding counterexamples {a mathematical formula}{u/1} and {a mathematical formula}{u/1}. Refinement yields the abstraction {a mathematical formula}∃vw.Φ[u/1]∧Φ[u/0], with the prenex form {a mathematical formula}∃vwxyx′y′.(v∨w∨x)∧(v¯∨y)∧(w¯∨y)∧(y¯)∧(v∨w∨x′)∧(v¯∨y′)∧(w¯∨y′)∧(x¯′) with no winning move and the algorithm terminates with the return value NULL. ▴</paragraph><section label="4.1"><section-title>Improving recursive CEGAR-based algorithm</section-title><paragraph>The 2-level algorithm already has a significant memory consumption since in each iteration of the loop the abstraction is increased by the size of the input formula. We will show that recursive calls may further exponentially amplify this behavior. Consider the following formula.{a mathematical formula} where {a mathematical formula}P is the rest of the quantifier prefix and ϕ the matrix of the formula. Further consider an ω-abstraction of (2) for {a mathematical formula}ω={μ11,…,μn11} corresponding to {a mathematical formula}n1 iterations of the CEGAR loop, which upon prenexing is equal to the following.{a mathematical formula}</paragraph><paragraph>The algorithm subsequently invokes the recursive call on formula (3) on line 7 in order to obtain a candidate. The recursive call operates on a matrix whose size is in {a mathematical formula}O(n1|ϕ|), i.e., {a mathematical formula}n1-times bigger than the original matrix. If the recursive call performs {a mathematical formula}n2 iterations of the CEGAR loop, it will produce an abstraction that will be {a mathematical formula}n1n2 bigger than the original matrix ϕ. In general, if the algorithm iterates {a mathematical formula}ni times at a recursion level i, the abstraction at level k is of the size {a mathematical formula}O(n1⋯nk⋅|ϕ|).</paragraph><paragraph>Clearly, such blowup would prohibit any practical application of the algorithm for larger number of quantification levels. To cope with this issue, we exploit the form of the formulas that the algorithm handles. In the case of the existential quantifier, the abstraction is a conjunct and it is a disjunct in the case of the universal quantifier. For the sake of uniformity, we bridge these two forms by introducing the notion of a multi-game where a player tries to find a move that wins multiple formulas simultaneously.</paragraph><paragraph label="Definition 5">Multi-gameLet Q be a quantifier and X be a set of variables. Let {a mathematical formula}Φ1,…,Φn be a set of prenex QBFs such that each {a mathematical formula}Φi starts with {a mathematical formula}Q¯ or has no quantifiers. Additionally, the free variables of each {a mathematical formula}Φi must be in X and all {a mathematical formula}Φi have the same number of quantifier blocks. A multi-game is the expression {a mathematical formula}QX.{Φ1,…,Φn}. We refer to the formulas {a mathematical formula}Φi as subgames and QX as the top-level prefix.A winning move for a multi-game is an assignment to the variables X such that it is a winning move for each of the formulas {a mathematical formula}QX.Φi.</paragraph><paragraph>Observe that the set of winning moves of a multi-game {a mathematical formula}QX.{Φ1,…,Φn} is the same as the set of winning moves of the QBF {a mathematical formula}∀X.(Φ1∨⋯∨Φn) for {a mathematical formula}Q=∀ and it is the same as {a mathematical formula}∃X.(Φ1∧⋯∧Φn) for {a mathematical formula}Q=∃. And, any prenex QBF {a mathematical formula}QX.Φ corresponds to a multi-game with a single subgame {a mathematical formula}QX.{Φ}.</paragraph><paragraph>Algorithm 5 shows an algorithm to solve multi-games. Just as Algorithm 4, this algorithm is represented as a recursive function named RAReQS. As input the algorithm accepts a multi-game and the abstraction it constructs is again a multi-game.</paragraph><paragraph>To determine whether a candidate τ is a winning move, it tests whether it is a winning move for the subgames in turn. If it finds a subgame {a mathematical formula}Φi such that the opponent {a mathematical formula}Q¯ wins {a mathematical formula}Φi[τ] by a move {a mathematical formula}μi, then {a mathematical formula}Φi[μi] is used to refine the abstraction.</paragraph><paragraph>Since an abstraction is a multi-game, it seems natural to add {a mathematical formula}Φi[μ] to the set of its subgames. This, however, cannot be done right away because the formula {a mathematical formula}Φi[μi] is not in the right form. In particular, for a multi-game, all the subgames must start with the opposing quantifier with respect to the top-level prefix. Hence, if {a mathematical formula}Φi is of the form {a mathematical formula}Q¯YQX1.Ψi and {a mathematical formula}μi∈BY, then {a mathematical formula}Φi[μi]=QX1.Ψi[μi]. To bring the formula into the right form, we introduce fresh variables for the variables {a mathematical formula}X1 and move them into the top-level prefix. More precisely, the function {a mathematical formula}Refine(α,Φl,μl) is defined as follows (observe that the subgames remain in prenex form).{a mathematical formula}</paragraph><paragraph>Similarly to Algorithm 4, after the refinement, the abstraction's top-level prefix contains additional variables besides the variables X. Hence, values for these variables are filtered out if a winning move for the abstraction is found.</paragraph></section><section label="4.2"><section-title>Properties of the algorithms</section-title><paragraph>Similar properties to the ones for 2QBF (see Section 3.1) can be derived for Algorithm 4 and Algorithm 5. Following the same argumentation as in Section 3.1, we can derive that once a counterexample μ is found in Algorithm 4, μ cannot be a countermove to any assignment that is a winning move for the future forms of the abstraction. Consequently, no candidate or counterexample repeats. From which follows that the loop is terminating and for a formula {a mathematical formula}QXQ¯Y.Φ the number of its iterations is bounded by the number of possible assignments to the variables X and Y, i.e., {a mathematical formula}min(2|X|,2|Y|). In the worst case, in each iteration the abstraction grows by the size of Φ.</paragraph><paragraph>For a multi-game {a mathematical formula}QX.{Φ1,…,Φn} in the CEGAR loop of Algorithm 5 no candidates repeat but counterexamples may repeat. However, for a given {a mathematical formula}i∈1..n, a counterexample {a mathematical formula}μi does not repeat. More precisely there are no two distinct iterations of the loop with the corresponding candidates and counterexamples {a mathematical formula}τ1,μ1, {a mathematical formula}τ2,μ2, such that {a mathematical formula}μ1=μ2 and {a mathematical formula}μ1 is a winning move for both {a mathematical formula}Φi[τ1] and {a mathematical formula}Φi[τ2] for some i. This demonstrates termination with the upper bound for the number of iterations as {a mathematical formula}min(2|X|,n⋅2|Y|). In the worst case, in each iteration the abstraction grows by the maximum of the sizes of the subgames {a mathematical formula}Φ1,…,Φn. Soundness and completeness of the Algorithm 4, Algorithm 5 are direct consequences of Observation 4.</paragraph></section><section label="4.3"><section-title>Implementation details</section-title><paragraph>We have implemented a prototype{sup:4} of RAReQS in C++, supporting the QDIMACS format, with the underlying SAT solver minisat 2.2[31].</paragraph><paragraph>The implementation has several distinctive features. In Algorithm 5, an abstraction computed within a sub-call is forgotten once the call returns. This may lead to repetition of work and hence the solver supports maintaining these abstractions and strengthening them gradually, similarly to the way SAT solvers provide incremental interface. This incremental approach, however, tends to lead to unwieldy memory consumption and therefore, it is used only when the given multigame's subgames have 2 or fewer quantification blocks.</paragraph><paragraph>If an assignment τ is a candidate for a winning move that turns out not to be a winning move, the refinement guarantees that τ is not a solution to the abstraction in the future iterations of the CEGAR loop. This knowledge enables us to make the subcall for solving the abstraction more efficient by explicitly disabling τ as a winning move for the abstraction. We refer to this technique as blocking and it is similar to the refinement used in certain SMT solvers [32], [33].</paragraph><paragraph>Throughout its course, the algorithm may produce a large number of new formulas, either by substitution or refinement. Since these formulas tend to be simpler than the given one, they can be further simplified by standard QBF preprocessing techniques. The implementation uses unit propagation and monotone (pure) literal rule [34]. These simplifications introduce the complication that in a multi-game {a mathematical formula}QX.{Φ1,…,Φn} the individual subgames might not necessarily have the same number of quantifier levels. In such case, all games with no quantifiers are immediately put into the abstraction before the loop starts.</paragraph></section></section><section label="5"><section-title>Non-CNF, non-prenex QBF</section-title><paragraph>In order to construct a non-CNF solver, we build on the ideas of multi-games, which were introduced in the previous section. Recall that a multi-game {a mathematical formula}∀X.{∃Y.Φ1,∃Y.Φ2} corresponds to the formula {a mathematical formula}∀X.(∃Y.Φ1)∨(∃Y.Φ2). So in fact, multi-games are a special cases of non-CNF QBFs. In multi-games, we were able to play each subgame separately and also refine by one subgame at a time and thus mitigating space explosion of the abstractions being constructed (see introduction to Section 4.1).</paragraph><paragraph>In the non-CNF case, we take this idea one step further. We consider a QBF {a mathematical formula}QX.Φ where Φ is a tree (or a directed acyclic graph) with internal nodes representing Boolean operators (∧, ∨) and leaves representing QBFs with the opposite quantifier ({a mathematical formula}Q¯). So for instance, we consider {a mathematical formula}∃X.(∀Y.Φ1)∧(∀Z.Φ2) but not {a mathematical formula}∃X.(∀Y.Φ1)∧(∃Z.Φ2). To construct an abstraction of a QBF in this form, we construct a tree with the same internal nodes but replace the leaves with their partial expansions.</paragraph><paragraph>Let us now look at the above presented ideas more precisely. We consider QBFs in the form given by the grammar in Fig. 2. As opposed to an arbitrary QBF, the grammar forces quantifiers to alternate, i.e., if some quantification {a mathematical formula}QX2 is in the scope of quantification {a mathematical formula}QX1, there must be another quantification {a mathematical formula}Q¯Z in the middle of the two. Further, negations must be only used on variables{sup:5} and we require the top-level expression to be a quantifier. Since this form requires quantifiers to alternate, we name it alternating form.</paragraph><paragraph>To convert an arbitrary QBF to alternating form, all negations are pushed inwards by using standard equivalences ({a mathematical formula}¬∃X.Ψ=∀X.¬Ψ, etc.) and non-alternating quantifiers are brought together by prefixing. So for instance the formula {a mathematical formula}∃x.¬(∀y.y∨x)∧(∀y.y∧x) becomes {a mathematical formula}∃xy′.(y¯′∧x¯)∧(∀y.y∧x). Note that alternating form also requires that the top-level expression is a quantifier which can always be guaranteed by adding a “dummy” existential quantification, i.e., {a mathematical formula}(∀x.x)∧(∃y.y) becomes {a mathematical formula}∃z.(∀x.x)∧(∃y.y).</paragraph><paragraph>Having a quantifier at the top level simplifies presentation of the algorithm because the definition of a winning move still applies (Definition 1) and we can decide a given formula by determining whether there is a winning move for the top-level quantification. Algorithm 6 presents an algorithm for formulas in alternating form with several facets not yet explained. These will be discussed in the following sections. Algorithm 6 provides the big picture at this point.</paragraph><paragraph>The structure of the algorithm is almost identical to the algorithms we have seen so far. An abstraction α is constructed from the given formula and a parameter ω. The parameter ω is explained later but the intuition behind it is that it determines how the opponent's quantifiers are expanded (similarly as abstraction was parameterized by the set of countermoves in previous sections). Then the algorithm finds a winning move for the abstraction and subsequently tests whether this is really a winning move for the given problem. If the abstraction has no winning move, the given problem also does not have a winning move. If the winning move for the abstraction is a winning move for the given problem, the algorithm terminates. Otherwise, the algorithm refines the abstraction. To fully explain the algorithm the following facets need to be addressed:</paragraph><list><list-item label="1.">form of the abstraction (function Abstract)</list-item><list-item label="2.">test that a given move is a winning move (function Test)</list-item><list-item label="3.">refinement</list-item></list><paragraph>Before we look at these aspects of the algorithm, we introduce the following notation, which enables us to unify certain operations for the universal and existential quantifier.</paragraph><paragraph>Notation{a mathematical formula} The intuition behind the operator is that in the formula {a mathematical formula}QX.ALLQ(Φ1,Φ2) the player Q must find a winning move for both {a mathematical formula}Φ1 and {a mathematical formula}Φ2. In contrast, {a mathematical formula}SOMEQ(Φ1,Φ2) means that Q must find a winning move for one of the {a mathematical formula}Φ1, {a mathematical formula}Φ2. In the same spirit, the top and the bottom constants are defined for the two players. These are Boolean constants that correspond to either of the players to win or lose, respectively. The operators {a mathematical formula}ALLQ and {a mathematical formula}SOMEQ are treated as prefix operators. Note that the operators are commutative and associative.</paragraph><paragraph label="Observation 5">Let{a mathematical formula}Φ1and{a mathematical formula}Φ2be QBFs and X a set of variables and τ a total assignment to X. The assignment τ is a winning move for{a mathematical formula}∀X.ALL∀(Φ1,Φ2)iff{a mathematical formula}Φ1[τ]and{a mathematical formula}Φ2[τ]are both false; it is a winning move for{a mathematical formula}∃X.ALL∃(Φ1,Φ2)iff{a mathematical formula}Φ1[τ]and{a mathematical formula}Φ2[τ]are both true. The assignment τ is a winning move for{a mathematical formula}∀X.SOME∀(Φ1,Φ2)iff one of{a mathematical formula}Φ1[τ],{a mathematical formula}Φ2[τ]is false; it is a winning move for{a mathematical formula}∃X.SOME∃(Φ1,Φ2)iff one of{a mathematical formula}Φ1[τ],{a mathematical formula}Φ2[τ]is true.</paragraph><paragraph label="Observation 6">The following equations hold.{a mathematical formula}</paragraph><section label="5.1"><section-title>Abstraction</section-title><paragraph>As hinted above, the crux of the abstraction is to replace the opponent's quantifiers by Boolean connectives. The following equations are the basis for these expansions.{a mathematical formula}</paragraph><paragraph>Equations (4) tell us that the opposing quantifier is expanded by the {a mathematical formula}ALLQ operator. So in order to construct an abstraction of a formula {a mathematical formula}QX.Φ we find each expression {a mathematical formula}QY.Ψ and replace it by the expression {a mathematical formula}ALLτ∈ωYQΨ[τ] where {a mathematical formula}ωY is the set of assignments that are considered for this expansion. Recall, however, that the algorithm operates on formulas in alternating form. And, performing these expansions might violate this form. Hence, we split the computation of an abstraction into two phases: the computation of a raw abstraction{a mathematical formula}α′ and a prenexing operation that brings {a mathematical formula}α′ to alternating form.</paragraph><paragraph>Throughout the computation, the algorithm remembers how the given formula has been expanded so far and expands it further in refinements (Algorithm 6). To do so, it maintains a variable ω, which determines for each subexpressions of the form {a mathematical formula}Q¯Y.Ψ that is not within the scope of another quantifier how it should be expanded, i.e., the variable ω parameterizes the abstraction. Now let us look more closely at the contents of ω.</paragraph><paragraph>We assume that each node in a formula is uniquely identified by an identifier which can be obtained by the function ID. The variable ω comprises pairs {a mathematical formula}(i,μ) where i is an identifier of some node {a mathematical formula}Q¯Y.Ψ in the given formula and μ is a total assignment to Y. Each such pair means that Y should be expanded with the assignment μ. The function RawAbstract (Algorithm 7) realizes this idea by traversing recursively the given formula and expanding each quantified node with the pertaining assignments. As noted before, such transformation constructs raw abstraction because it might not necessarily be in alternating form. Hence, the function Abstract used in Algorithm 6 first calls RawAbstract and applies prefixing in order to bring it into alternating form.</paragraph><paragraph>Fig. 3(a) shows an example of an abstraction of the formula {a mathematical formula}∀x.(x∨y¯)∧(∃z.z). The node {a mathematical formula}∃z.z is expanded by the assignments {a mathematical formula}z/0 and {a mathematical formula}z/1. Fig. 3(b) shows the same abstraction rewritten using the {a mathematical formula}ALLQ and {a mathematical formula}SOMEQ operators.</paragraph></section><section label="5.2"><section-title>Winning move test</section-title><paragraph>The function Test serves two purposes: the first purpose is to test whether a given candidate is a winning move; the second purpose is provide how the current abstraction should be refined. More precisely, for a QBF {a mathematical formula}QX.Φ and a total assignment τ to the variables X the function decides whether τ is a winning move for QX in {a mathematical formula}QX.Φ. The function either returns NULL if τ is a winning move or it returns a set of pairs {a mathematical formula}(i,μ), which are pairs that are eventually added to the variable ω (see Algorithm 6). Effectively, if a pair {a mathematical formula}(i,μ) is added to the return value, the node with identifier i is expanded by the assignment μ.</paragraph><paragraph>Algorithm 8 shows pseudocode for the function Test. The function recursively traverses the given formula until it reaches a quantified expression where it invokes the solving procedure to test whether this subexpression is won by τ. Note that any quantified expression found must be of the opposing quantifier due to the formula being in alternating form. If τ leads to a loss in some subexpression {a mathematical formula}Q¯Y.Ψ, there is a winning move μ for {a mathematical formula}Q¯Y in {a mathematical formula}Q¯.Ψ[τ]. This move μ is used to expand this subexpression in the upcoming abstractions. This is very much similar to countermoves were used in the algorithms for prenex QBFs.</paragraph><paragraph>Now let us look at how the function Test aggregates computed expansions in the internal notes of the formula. If the function Test operates on a {a mathematical formula}ALLQ node, it only needs to check whether one of the children needs to be refined. If τ leads to a loss in one of the children, that child is expanded. Otherwise, NULL is returned (no refinement needed). However, in the case of nodes of type {a mathematical formula}SOMEQ, computing refinements is slightly more complicated. If τ yields a win for one of the children, no expansion is needed in that subtree. In the opposite case, when τ loses for all the children, all these children are expanded.</paragraph><paragraph>Observe that when children of {a mathematical formula}ALLQ and {a mathematical formula}SOMEQ nodes are treated, the operations are short-circuited. So for instance once the function discovers that τ leads to a loss in some child of a {a mathematical formula}ALLQ node, it does not evaluate the other children. Analogously, if τ leads to a win in some child of a {a mathematical formula}SOMEQ node, the function stops without producing an expansion. This is also a motivation for why the aggregations of expansions are different for the two types of nodes. In the case of a {a mathematical formula}ALLQ node, there is a single child that calls for expansion. In the case of a {a mathematical formula}SOMEQ node, the recursive calls have produced expansions for all the children. It would be correct to randomly pick just one of the children for expansion. Like so, however, the computed expansions would go to waste.</paragraph><paragraph>Remark  When the given formula is given a single literal, τ might lead to a loss without generating any expansion to be added to the abstraction. ▴</paragraph></section></section><section label="6"><section-title>CEGAR as a learning technique in DPLL</section-title><paragraph>The previous section shows that CEGAR can give rise to a complete and sound algorithm for QBF. In this section we show that CEGAR enables us to extend existing DPLL solvers with an additional learning technique. We will employ the ghost variables and game sequents techniques to more easily present this technique.</paragraph><section label="6.1"><section-title>Ghost variables and sequent learning</section-title><paragraph>In this subsection, we briefly describe the techniques of ghost variables and sequent learning. A more complete treatment may be found in [35].</paragraph><paragraph>We employ ghost variables to provide a modification of the Tseitin transformation that is symmetric between the two players. The idea of using a symmetric transformation was first explored in [36], which performed the Tseitin transformation twice: once on the input formula, and once on its negation.</paragraph><paragraph>For each subformula of the original input formula, we introduce two ghost variables: an existentially quantified variable {a mathematical formula}g∃ and a universally quantified variable {a mathematical formula}g∀. We say that {a mathematical formula}g∃ and {a mathematical formula}g∀represent the labeled subformula. Variables that occur in the original input formula are called input variables, in distinction to ghost variables. Ghost variables are always downstream of all input variables.</paragraph><paragraph>We now introduce a semantics with ghost variables for the game formulation of QBF. As in the Tseitin transformation, the existential player should lose if an existential ghost variable {a mathematical formula}g∃ is assigned a different value than the subformula that it represents. Additionally, the universal player should lose if an universal ghost variable {a mathematical formula}g∀ is assigned a different value than the subformula that it represents.</paragraph><paragraph>As noted in Section 2, we write “{a mathematical formula}ϕ[π]” to denote the result of substituting assignment ϕ into formula ϕ. The assignment π may contain ghost variables, but a subformula labeled by a ghost variable is not replaced by the assigned value of the ghost variable. For example, if {a mathematical formula}g1Q represents {a mathematical formula}x∧y and {a mathematical formula}π1={g1Q/1}, then {a mathematical formula}(x∧y)[π1] evaluates to {a mathematical formula}(x∧y), and {a mathematical formula}g1Q[π1] evaluates to {a mathematical formula}true.</paragraph><paragraph label="Definition 6">Consistent assignment to ghost literalLet {a mathematical formula}Q∈{∃,∀}; let π be an assignment; let {a mathematical formula}gQ be a ghost literal; and let ξ be the formula represented by {a mathematical formula}gQ. We say that {a mathematical formula}gQ is assigned consistently under π iff {a mathematical formula}gQ[π]=ξ[π]. We say {a mathematical formula}gQ is assigned inconsistently under π iff {a mathematical formula}gQ[π]=¬ξ[π].</paragraph><paragraph>For example, if {a mathematical formula}g1Q represents {a mathematical formula}x∧y, then {a mathematical formula}g1Q is assigned consistently under {a mathematical formula}{g1Q/0,x/0}, while it assigned inconsistently under {a mathematical formula}{g1Q/0,x/1,y/1}. Under {a mathematical formula}{g1Q/0}, {a mathematical formula}g1Q is not said to be either consistently or inconsistently assigned.</paragraph><paragraph label="Definition 7">Winning under a total assignmentGiven a formula Φ, a quantifier type {a mathematical formula}Q∈{∃,∀}, and an assignment π to all the input variables and a subset of the ghost variables, we say “Player Qwins Φ under π” iff both of the following conditions hold true:</paragraph><list><list-item label="1.">{a mathematical formula}Φ[π]={true if Q is ∃false if Q is ∀</list-item><list-item label="2.">(Intuitively, a winning player's ghost vars must “respect the encoding”.)</list-item></list><paragraph>For example, if  {a mathematical formula}Φ=∃e∀u.(e∧u)  and  g labels {a mathematical formula}(e∧u)  then neither player wins Φ under {a mathematical formula}{e/0,u/1,g∀/1,g∃/0}. The existential player fails to win because {a mathematical formula}Φ[π]=false, and the universal player fails to win because the ghost variable {a mathematical formula}g∀ is assigned inconsistently, since {a mathematical formula}g∀[π]=true but the formula represented by {a mathematical formula}g∀ (i.e., the conjunction {a mathematical formula}e∧u) evaluates to {a mathematical formula}false.</paragraph><paragraph label="Definition 8">Losing under an assignmentGiven a formula Φ and an assignment π, we define the phrase “Player Qloses Φ under π” recursively. We say “Player Qloses Φ under π” iff either:</paragraph><list><list-item label="1.">Player Q does not win Φ under π and every input variable is assigned by π, or</list-item><list-item label="2.">there is an outermost unassigned input variable x such that either:</list-item></list><paragraph>For example, consider a formula  {a mathematical formula}Φ=∀u∃e.u∧e. Then:</paragraph><list><list-item label="•">Player ∃ loses Φ under {a mathematical formula}{u/0,e/0}, by subpart 1 of Definition 8.</list-item><list-item label="•">Player ∃ loses Φ under {a mathematical formula}{u/0}, by subpart 2(a) of Definition 8.</list-item><list-item label="•">Player ∀ loses Φ under {a mathematical formula}{u/1}, by subpart 2(b) of Definition 8.</list-item></list><paragraph label="Definition 9">Game-state specifier, matchA game-state specifier is a pair {a mathematical formula}〈Lnow,Lfut〉 consisting of two sets of literals, {a mathematical formula}Lnow and {a mathematical formula}Lfut. We say that {a mathematical formula}〈Lnow,Lfut〉matches an assignment π iff:</paragraph><list><list-item label="1.">for every literal ℓ in {a mathematical formula}Lnow, {a mathematical formula}ℓ[π]=true, and</list-item><list-item label="2.">for every literal ℓ in {a mathematical formula}Lfut, {a mathematical formula}ℓ[π]≠false (i.e., either {a mathematical formula}ℓ[π]=true or {a mathematical formula}var(ℓ)∉vars(π)).</list-item></list><paragraph>For example, {a mathematical formula}〈{u},{e}〉 matches the assignments {a mathematical formula}{u/1} and {a mathematical formula}{u/1,e/1} (because both conditions in Definition 9 are satisfied), but does not match the empty assignment (because condition 1 fails) or {a mathematical formula}{u/1,e/0} (because condition 2 fails).</paragraph><paragraph>Note that, for any literal ℓ, if {a mathematical formula}{ℓ,¬ℓ}⊆Lfut, then {a mathematical formula}〈Lnow,Lfut〉 matches an assignment π only if π does not assign ℓ. The intuition behind the names “{a mathematical formula}Lnow” and “{a mathematical formula}Lfut” is as follows: Under the game formulation of QBF, the assignment π can be thought of as a state of the game, and π matches {a mathematical formula}〈Lnow,Lfut〉 iff every literal in {a mathematical formula}Lnow is already true in the game and, for every literal ℓ in {a mathematical formula}Lfut, it is possible that ℓ can be true in a future state of the game.</paragraph><paragraph label="Definition 10">Game sequentThe sequent {a mathematical formula}〈Lnow,Lfut〉⊨(Q loses Φ) means “Player Q loses Φ under all assignments that match {a mathematical formula}〈Lnow,Lfut〉.”</paragraph><paragraph>As an example, let Φ be the following formula:{a mathematical formula} Note that sequent {a mathematical formula}〈{u},{e}〉⊨(∀ loses Φ) holds true: in any assignment π that matches it, {a mathematical formula}Φ[π]=true. However, {a mathematical formula}〈{u},∅〉⊨(∀ loses Φ) does not hold true: it matches the assignment {a mathematical formula}{u/1,e/0}, under which Player ∀ does not lose Φ.</paragraph><paragraph>For closed prenex instances, game sequents are isomorphic to the learned clauses/cubes; the differences are merely cosmetic. With the learning algorithm in [35], whenever a new game sequent is learned for a closed prenex instance, the literals owned by the winner all go in {a mathematical formula}Lfut, and the literals owned by the loser go in {a mathematical formula}Lnow. The relationship between game-state sequents and learned clauses/cubes (for prenex instances) is as follows.</paragraph><paragraph>A learned clause {a mathematical formula}(ℓ1∨…∨ℓn) is equivalent to the game sequent {a mathematical formula}〈Lnow,Lfut〉⊨(∃ loses Φin) where {a mathematical formula}Lnow contains all the existential literals from {a mathematical formula}{¬ℓ1,…,¬ℓn}, and {a mathematical formula}Lfut contains all the universal literals from {a mathematical formula}{¬ℓ1,…,¬ℓn}. Note that the literals from the clause occur negated in the sequent.</paragraph><paragraph>Likewise, a learned cube {a mathematical formula}(ℓ1∧…∧ℓn) is equivalent to the game sequent {a mathematical formula}〈Lnow,Lfut〉⊨(∀ loses Φin) where {a mathematical formula}Lnow contains all the universal literals from {a mathematical formula}{ℓ1,…,ℓn}, and {a mathematical formula}Lfut contains all the existential literals from {a mathematical formula}{ℓ1,…,ℓn}. Unlike the case for clauses, the literals in a cube do not get negated for the corresponding sequent.</paragraph></section><section label="6.2"><section-title>DPLL for 2-level QBF</section-title><paragraph>Notation. Given an assignment π, let {a mathematical formula}prop(π) be the assignment produced by adding literals that would be forced in boolean constraint propagation (BCP) using the solver's sequent database. For example, if the input formula contains a subformula {a mathematical formula}(x∨y) labeled by ghost variables {a mathematical formula}g∃ and {a mathematical formula}g∀, then {a mathematical formula}prop({x/1}) would contain x, {a mathematical formula}g∃, and {a mathematical formula}g∀.</paragraph><paragraph>To illustrate the basic idea of the CEGAR-in-DPLL technique, let Φ be a QBF of the form {a mathematical formula}∀X∃Y.ϕ. Let {a mathematical formula}πcand be an assignment to the variables in X such that {a mathematical formula}prop(πcand) does not match any sequent in the solver's sequent database. Let {a mathematical formula}πcex be a counterexample to {a mathematical formula}πcand; i.e., let {a mathematical formula}πcex be an assignment to the variables in Y such that {a mathematical formula}ϕ[πcand∪πcex]=true. The goal of the CEGAR learning is to produce a set of sequents such that, if these sequents are added to the sequent database, then for every assignment {a mathematical formula}πcand′ to X for which {a mathematical formula}πcex is a counterexample, some sequent in the database would match {a mathematical formula}prop(πcand′). This goal is accomplished as follows:</paragraph><list><list-item label="1.">Substitute the assignment {a mathematical formula}πcex into ϕ, yielding the formula {a mathematical formula}ϕ[πcex].</list-item><list-item label="2.">Introduce ghost variables for any subformulas in {a mathematical formula}ϕ[πcex] that are not already labeled by ghost variables. Add sequents that relate these ghost variables to the subformulas that they represent, as described in Sec. 2.4.1 of [35].</list-item><list-item label="3.">Let {a mathematical formula}g⁎∀ be the universal ghost variable that labels the formula {a mathematical formula}ϕ[πcex].</list-item><list-item label="4.">Learn the new sequent {a mathematical formula}〈{g⁎∀},πcex〉⊨(∀ loses Φ).</list-item></list><paragraph> Consider an arbitrary assignment {a mathematical formula}πcand′ to X to which {a mathematical formula}πcex is a counterexample. Then {a mathematical formula}ϕ[πcand∪πcex]=true. To prove that {a mathematical formula}prop(πcand′) matches {a mathematical formula}〈{g⁎∀},πcex〉, we must prove (1) {a mathematical formula}g⁎∀∈prop(πcand′) and (2) {a mathematical formula}prop(πcand′) does not contain the negation of any literal in {a mathematical formula}πcex:</paragraph><list><list-item label="1.">Since all the variables in the formula labeled by {a mathematical formula}g⁎∀ are assigned by {a mathematical formula}πcand′, it follows that either the variable {a mathematical formula}g⁎∀ or its negation must be a forced literal under {a mathematical formula}πcand′. And since {a mathematical formula}g⁎∀ labels {a mathematical formula}ϕ[πcex], and {a mathematical formula}(ϕ[πcex])[πcand]=true, it follows that the positive literal {a mathematical formula}g⁎∀ is forced, i.e., {a mathematical formula}g⁎∀∈prop(πcand′).</list-item><list-item label="2.">A literal ℓ is forced under an assignment π only if the owner of ℓ is doomed to lose under {a mathematical formula}π∪{ℓ/0}. Since Player ∃ owns {a mathematical formula}πcex and wins under {a mathematical formula}πcand′∪πcex, it follows that no literals from {a mathematical formula}πcex appear negated in {a mathematical formula}prop(πcand′).</list-item></list><paragraph> For example, consider the formula {a mathematical formula}Φ=∀X∃Y.ϕ where ϕ is:{a mathematical formula} Suppose that {a mathematical formula}πcand={u1/1,u2/1} and {a mathematical formula}πcex={e3/0,e4/0}. Then {a mathematical formula}ϕ[πcex]=u1∧u2. Let {a mathematical formula}g6∀ be the universal ghost variable for {a mathematical formula}u1∧u2. The solver learns the sequent {a mathematical formula}〈{g6∀},{¬e3,¬e4}〉⊨(∀ loses Φ), as well as sequents relating {a mathematical formula}g6∀ to the subformula which it represents.</paragraph><paragraph>To add CEGAR learning to the DPLL-based solver GhostQ, we insert a call to a new CEGAR-learning procedure after standard DPLL learning, as shown in Algorithm 9. As shown in Algorithm 9, CEGAR learning is performed only if the last decision literal in {a mathematical formula}πcur is owned by the winner. (The case where the last decision literal is owned by the losing player corresponds to the conflicts that take place within the underlying SAT solver in RAReQS.)</paragraph></section><section label="6.3"><section-title>DPLL for QBF with arbitrary quantification levels</section-title><paragraph>Consider a QBF {a mathematical formula}Q1Z1.…QnZn.ϕ. Suppose that the last decision literal belongs to the winner and is in the block {a mathematical formula}Zi. Then CEGAR learning would proceed as follows:</paragraph><list><list-item label="1.">Let {a mathematical formula}πcex be a total assignment to the variables in {a mathematical formula}Zi. If a variable in {a mathematical formula}Zi is assigned by {a mathematical formula}πcur, it should have the same value in {a mathematical formula}πcex; if it does not appear in {a mathematical formula}πcur, it can be assigned an arbitrary value in {a mathematical formula}πcex.</list-item><list-item label="2.">Let guard be a subset of {a mathematical formula}πcur that assigns a subset of variables in {a mathematical formula}Z1,…,Zi−2. The choice of guard is heuristicly picked.</list-item><list-item label="3.">Let {a mathematical formula}Zi+1′,…,Zn′ be fresh variables corresponding to {a mathematical formula}Zi+1,…,Zn, respectively.</list-item><list-item label="4.">Let {a mathematical formula}ϕ′ be the result of substituting the assignment {a mathematical formula}πcex∪guard into ϕ and replacing all occurrences of variables in {a mathematical formula}Zi+1,….,Zn with {a mathematical formula}Zi+1′,…,Zn′, respectively.</list-item><list-item label="5.">Introduce ghost variables for any formulas in {a mathematical formula}ϕ′ not already labeled by ghost variables. Add sequents that relate these ghost variables to the subformulas that they represent.</list-item><list-item label="6.">Let {a mathematical formula}Q⁎ be {a mathematical formula}Q¯i. Let {a mathematical formula}g⁎Q⁎ be the ghost variable that labels the formula {a mathematical formula}ϕ′ (if {a mathematical formula}Q⁎ is ∀) or the negation of this ghost variable (if {a mathematical formula}Q⁎ is ∃).</list-item><list-item label="7.">Learn the new sequent {a mathematical formula}〈guard∪{g⁎Q⁎},πcex〉⊨(Q⁎ loses Φ).</list-item></list></section></section><section label="7"><section-title>Experimental results</section-title><paragraph>This section shows experimental evaluation of the presented algorithms. All experiments were carried out on Intel Xeon 5160 3 GHz machines, with 4 GB of memory.</paragraph><section label="7.1"><section-title>Experimental results for 2-level QCNF</section-title><paragraph>Two versions of AReQS were evaluated: one that does not use any heuristics (denoted AReQS) and the second that uses the heuristics described in Section 3.3 (denoted AReQS-H). The solvers were compared to the CDCL solver DepQBF[37] and the expansion-based solvers Nenofex[9] and Quantor[8].</paragraph><paragraph>A variety of benchmarks were chosen for the empirical evaluation. The sources for the benchmarks were: QBF library [38], QBF evaluation [39], and two well-known {a mathematical formula}Σ2P and {a mathematical formula}Π2P complete problems. From the QBF library [38] we chose the RobotsD2 benchmarks, from QBF evaluation the set of problems used in 2010 2QBF track. Since the family of RobotsD2 is disproportionally large, only a random sample of 150 instances was considered. Entailment in propositional circumscription (circ) is a well-known {a mathematical formula}Π2P problem and instances from product configuration were used [40]. Implicate core (icore) is the problem of deciding for a given clause C, a constant k, and a CNF ϕ whether there exists a clause {a mathematical formula}C′⊆C, s.t. {a mathematical formula}|C′|&lt;k and {a mathematical formula}ϕ⇒C′; the problem is well known to be {a mathematical formula}Σ2P-complete [41].{sup:6} Only problems of the form ∀∃ were considered from the QBF library (this was true for all the problems in the 2QBF track of the QBF-Evaluation); the implicate core problem was directly generated in its negated form (again producing the ∀∃ form). All benchmarks were preprocessed by the preprocessor bloqqer[16] and instances solved by the preprocessor alone were excluded from further analysis. The experiments were obtained with a 800 s time limit and 2 GB memory limit.</paragraph><paragraph>Table 1 shows the number of solved instances for each set of benchmarks and solver. Fig. 4 shows a cactus plot for all of the instances. Both versions of AReQS dominate the results and are followed by DepQBF. The expansion-based solvers Nenofex and Quantor perform poorly.</paragraph><paragraph>The heuristics in AReQS-H do not seem to give a clear benefit. In fact, the heuristics implementation solves two instances fewer. Figs. 5(a) and 5(b) provide a more detailed view. Fig. 5(a) compares the number of iterations that the solver performed per instance. Fig. 5(b) compares the running times of the implementations. These figures do not show a clear advantage of either of the versions. However, it seems that the heuristics pay off more in harder instances, i.e., in instances where both of the solvers need a substantial amount of time or iterations. Hence, it would be interesting to explore a hybrid approach of invoking the heuristics. Another observation to be made is that there are instances where AReQS performs a large number of iterations (order of 10{sup:6}); this suggests that the complexity of the investigated problems is not the underlying SAT problems but the number of iterations overall.</paragraph></section><section label="7.2"><section-title>Experimental results for PQCNF</section-title><paragraph>Our objective was to analyze the effect of CEGAR on the different families of available benchmarks. Due to the large number of families in QBF-LIB [38], we have targeted families from formal verification and planning as two prominent applications of QBF. We have also included the family of benchmarks used for the 2012 evaluation.{sup:7} Several large and hard families were randomly sampled (terminator, tipfixpoint, Strat. Companies, traffic-controller, RobotsD3); the area of planning contains four classes for robot planning, each counting 1000 instances with similar characteristics and thus only one of these classes was selected (RobotsD3).</paragraph><paragraph>The solvers were compared to DepQBF[37] and the expansion-based solvers Nenofex[9] and Quantor[8]. GhostQ was evaluated in two versions. One, the original version GhostQ[42], [35] and second, with the CEGAR learning—GhostQ-CEGAR (see Section 6). The time limit was 800 s and the memory limit 2 GB.</paragraph><paragraph>All the instances were preprocessed by the preprocessor bloqqer[16] and instances solved by the preprocessor alone were excluded from further analysis. An exception was made for the family Debug where preprocessing turned out to be infeasible and the family was considered in its unpreprocessed form.</paragraph><paragraph>Unlike the other solvers, GhostQ's input format is not clause-based (QDIMACS) but it is circuit-based. To enable running GhostQ on the targeted instances, the solver was prepended with a reverse-engineering front-end. This reverse-engineering performs poorly on the bloqqer's output, since the original structure is “scrambled” by preprocessing. Hence, GhostQ was run directly on the instances without preprocessing. The other solvers were run on the preprocessed instances.</paragraph><paragraph>The relation between solving times and instances is presented by a cactus plot in Fig. 6; number of solved instances per family are shown in Table 3; a comparison of RAReQS with other solvers is presented in Table 2.</paragraph><paragraph>On the considered benchmarks, RAReQS solved the most instances, approximately 29% more than the solver DepQBF. RAReQS also turned out to be the best solver for most of the types of the considered instances. Table 2 further shows that for each of the other solvers, there is only a small portion of instances that the other solver can solve and RAReQS cannot.</paragraph><paragraph>In several families the addition of CEGAR learning to GhostQ worsened its performance. However, with the exception of RobotsD3, the performance was worse only slightly. Overall, GhostQ benefited from the additional CEGAR learning and in particular for certain families. A family worth noting is irqlkeapclte, where no instances were solved by any of the solvers except for GhostQ-CEGAR.</paragraph><paragraph>The usefulness of CEGAR was in particular demonstrated by the families incrementer-enc., conformant-planning, trafficlight-controller, Sorting-networks, and BMC where RAReQS solved significantly more instances than the existing solvers and GhostQ-CEGAR improved significantly over GhostQ. Most notably, for incrementer-encoder only one instance was not solved by RAReQS, and for RobotsD3, blackbox-01X-QBF and trafficlight-contr. RAReQS solved all instances.</paragraph><paragraph>CEGAR learning was also useful in GhostQ on the Evaluation 2012 benchmarks, where GhostQ-CEGAR solved significantly more instances than other solvers—this was confirmed by the QBF Gallery 2014 [43].</paragraph></section><section label="7.3"><section-title>Experimental results for non-prenex non-CNF QBF</section-title><paragraph>A prototype of RAReQS-NN (Algorithm 6) was implemented in C++, supporting the qpro format[44], with the underlying SAT solver minisat 2.2[31]. The whole set of qpro benchmarks from the QBF-LIB was used. The solvers CirQit[10], [45] and GhostQ were used for comparison. A timeout of 800 s was used along with a 2 GB memory limit. Table 4 shows how many instances were solved by each solver for each of the families of benchmarks. Fig. 7 provides a cactus plot for all the benchmarks. A more detailed overview can be found on the authors' website.{sup:8} The solvers GhostQ and CirQit behave rather similarly on the considered benchmarks. RAReQS-NN turned out to be very successful on families assertion and possibility. In contrast, for the dme family, both CirQit and GhostQ perform significantly better.</paragraph></section></section><section label="8"><section-title>Related work</section-title><paragraph>CEGAR has proven useful in number of areas, most notably in model checking [20] and SMT solving [32], [33]; more recently it has been applied to handle quantification in SMT [46], [47], [48]. Special cases of QBF, with limited number of quantifiers, have been targeted by CEGAR: computing vertex eccentricity [49], and nonmonotonic reasoning [50], [51].</paragraph><paragraph>A SAT solver was used in [52] to guide DPLL search of a QBF solver and to cut out unsatisfiable branches. A notion of abstraction was also used in QBF preprocessing [13]. This notion, however, differs from the one used in RAReQS as it means treating universally quantified variables as existentially quantified.</paragraph><paragraph>An important feature of RAReQS is the expansion of the given QBF into a propositional formula, which is then solved by a SAT solver. Expansion of quantifiers appear in number of solvers. In SAT and QBF preprocessing the technique of variable elimination[18], [12] replaces all clauses containing a certain variable with all their possible resolvents on that variable. This is in fact existential expansion in disguise. Indeed, expanding {a mathematical formula}∃x.(ϕ1∨x)∧(ϕ2∨¬x) gives us {a mathematical formula}ϕ1∨ϕ2 (assuming that {a mathematical formula}ϕ1, {a mathematical formula}ϕ2 do not contain x). If the original formula is in CNF, distributing ∨ gives us the result of all resolvents on x. Expansion of the universal quantifier is also used in preprocessing [11], [53].</paragraph><paragraph>Several existing solvers tackle QBF solving by expansion. Most notably QUBOS[54], Quantor[8], sKizzo[7] and Nenofex[9]. Quantor and Nenofex apply expansion of quantifiers inside out and then invoke a SAT solver. While Quantor maintains a CNF matrix by variable elimination, Nenofex operates on an non-CNF representation. sKizzo considers a Skolemization of the original QBF, which in fact corresponds to expansion of all universal quantifiers and introducing fresh variable for the existential ones. Specialized techniques are used in order to avoid space explosion. Just as RAReQS uses multi-games, the above-mentioned solvers employ various techniques to mitigate the blowup of the expansion (besides preprocessing). QUBOS uses miniscoping, Quantortree-like prefixes, and Nenofex uses negation normal form.</paragraph><paragraph>The way the expansion is carried out in RAReQS is significantly different. The expansion in RAReQS is careful. In the aforementioned solvers, once a variable is scheduled for expansion, both of its values are considered in the expansion.{sup:9} In contrast, RAReQS only expands by an assignment to a block of variables at a time. This is an important factor for both time and space complexity. For large formulas, the traditional expansion-based solvers are bound to generate unwieldy formulas but the use of abstraction in RAReQS enables the solver to stop before this expansion is reached. This leads to generating easier formulas for the underlying SAT solver and dramatically mitigates the problems with memory blowup. Similar careful quantifier expansion also appears in SMT solving [48], [47] and first order logic [55].</paragraph><paragraph>CNF search-based solvers can support non-CNF formulas by working on two representations of the formula: one in DNF and one in CNF [36], [56]. But dedicated solvers also exists [10], [35].</paragraph><paragraph>Since the publication of the 2-level QBF algorithm (AReQS), several similar approaches were used in specific domains [57], [58], [59], [60], [61], [62].</paragraph><section label="8.1"><section-title>Comparison to existing approaches</section-title><paragraph>While the experimental results show that CEGAR-based solving gives us an approach that is often more efficient than the existing ones, it is natural to further explore how the algorithms differ, and, ask if there is a fundamental difference between them.</paragraph><paragraph>One approach how to compare solving algorithms is through proof systems. Q-resolution[28] is the proof system that corresponds to conflict/solution driven (CSDCL) solving, e.g. as in DepQBF. Expansion was formalized as the proof system {a mathematical formula}∀Exp+Res[63]; this corresponds directly to RAReQS. Further generalizations of this proof system exist [64]. It has been shown that Q-resolution as well as its variants [65], [66] are fundamentally different from expansion-based proof systems. More particularly, separations were shown in both directions, i.e., there are families of formulas where Q-resolution gives exponentially larger proofs than {a mathematical formula}∀Exp+Res but also the other way around [67], [68]. Hence, even from a theoretical point of view, CSDCL solving is fundamentally different from expansion-based solving.</paragraph><paragraph>In the remainder of this subsection, we present two example QBF formulas that showcase strengths of RAReQS. In the first example, we compare RAReQS to the full-expansion algorithm used in Quantor. In the second example, we compare RAReQS to a generic CSDCL solver.</paragraph><section label="8.1.1"><section-title>Comparison to Quantor on a simple example</section-title><paragraph>RAReQS may seem quite similar to expansion-based solvers like Quantor and Nenofex since RAReQS also performs expansion of quantifiers and subsequently calls a SAT solver. However, there is an important difference, RAReQS performs this expansion gradually and tests whether such expansion is already sufficient. Note that in the worst case, however, it may also perform a full expansion of the formula. The following example shows how gradual expansion as done by RAReQS can be beneficial.</paragraph><paragraph>Consider the QBF formula (where ⊕ is the XOR function){a mathematical formula} where{a mathematical formula} Note that ϕ can be efficiently converted to CNF without introducing any new variables. The algorithm used by Quantor[8] has difficulty with this problem. At each step, this algorithm can take one of two actions: eliminate an innermost existential variable by resolution, or eliminate a universal variable (of the second-to-innermost block) by expansion.</paragraph><paragraph>There are two end-game scenarios: (1) all the innermost T variables are eliminated, at which point all Z variables can be dropped from all clauses by universal reduction, and the result given to a SAT solver, or (2) all universal variables Z are expanded, at which point the formula is handed off to a SAT solver. Resolving on all the innermost T variables (without expanding any of the universal variables) requires representing {a mathematical formula}z1⊕…⊕zN in CNF (without introducing new variables), which requires space exponential in N. Now let us examine what happens when universal variables get expanded.</paragraph><paragraph>Consider what the formula looks like after variables {a mathematical formula}VZ⊂Z have been expanded and variables {a mathematical formula}VT⊂T have been resolved. Let {a mathematical formula}Res(ψ,VT) denote the result of eliminating existential variables in {a mathematical formula}VT by resolution, as described in Section 3.1 of [8]. Then the formula has the following form:{a mathematical formula} except that it must be converted to prenex form, which entails making {a mathematical formula}2|VZ| copies of the variables in {a mathematical formula}T∖VT. Note that, for every assignment π to {a mathematical formula}VZ, the formula {a mathematical formula}Res(ϕ[π],VT) has an actual dependence on {a mathematical formula}Z∖VZ and {a mathematical formula}T∖VZ i.e., it does not evaluate to {a mathematical formula}true or {a mathematical formula}false or an expression involving only the X variables. Thus, the size of the formula is at least {a mathematical formula}O(2|VZ|). So, eliminating all the universal variables would require space {a mathematical formula}O(2N).</paragraph><paragraph>On the other hand, to eliminate all the innermost T variables, the algorithm must, as an intermediate step, construct a formula where {a mathematical formula}|VT|=|T|−1. In this case, each {a mathematical formula}Res(ϕ[π],VT) must represent an XOR of at least {a mathematical formula}12(|VT|−|VZ|) variables (either {a mathematical formula}{z1,…,zi}∖VZ or {a mathematical formula}{zi+1,…,zN}∖VZ, for some i), so it must have size {a mathematical formula}O(2(|VT|−|VZ|)/2), and there are {a mathematical formula}2|VZ| of them, so the total size is{a mathematical formula} So, regardless of whether all universal variables Z are eliminated or all innermost existential variables T are eliminated, the full-expansion algorithm requires time and space exponential in N.</paragraph><paragraph>In contrast to Quantor, RAReQS solves this QBF quickly. One possible run of the CEGAR algorithm proceeds as follows:</paragraph><list><list-item label="1.">Suppose we pick the candidate {a mathematical formula}x1=…=xN=false for the outermost existential block. Under this assignment, ϕ simplifies to{a mathematical formula} This formula can evaluate to {a mathematical formula}true only if {a mathematical formula}tn=z1⊕z2⊕…⊕zN and {a mathematical formula}tn=true. Accordingly, any assignment to {a mathematical formula}z1…zN in which an even number of z variables are {a mathematical formula}true is a winning move for the universal player and a counterexample to the existential candidate {a mathematical formula}x1=…=xN=false.</list-item><list-item label="2.">Now the existential player must pick a candidate for the outermost block in which at least one {a mathematical formula}xi is {a mathematical formula}true. Under this assignment, ϕ simplifies to{a mathematical formula} No universal variables occur in the above formula, so regardless of how the universal {a mathematical formula}zi variables are assigned, a winning move for the existential player is simply to assign {a mathematical formula}true to all the variables in the innermost block.</list-item></list><paragraph>Fig. 8 shows in greater detail how the recursive nature of Algorithm 4 (page 9) plays out for this example.</paragraph></section><section label="8.1.2"><section-title>Comparison to CSDCL solver on a simple example</section-title><paragraph>In contrast to RAReQS or Quantor, CSDCL solvers do not expand variables at all. As a consequence they can operate in polynomial space whereas expansion-based solvers operate in exponential space. The following example exemplifies that expansion can be beneficial ([67, Sec. 7] gives another example). Consider the QBF formula{a mathematical formula} where {a mathematical formula}hard(X) is a hard problem that evaluates to {a mathematical formula}false (such as the pigeon-hole problem with n pigeons and {a mathematical formula}n−1 holes) over the X variables and each {a mathematical formula}easyi(Y) is an easy (but not trivial) problem over the Y variables that evaluates to {a mathematical formula}false.</paragraph><paragraph>In a traditional CSDCL solver, all outermost existential variables (X) must be assigned a value before the solver can choose a decision variable from {a mathematical formula}{z} or Y. Furthermore, it is easy to see that no variables from {a mathematical formula}{z} or Y will get forced during boolean constraint propagation (BCP) by a decision to an X variable. Thus, a traditional CSDCL solver will not finish until it solves the hard problem.</paragraph><paragraph>In contrast, RAReQS, following Algorithm 4, quickly determines that the formula is false by solving the easy problem without solving the hard problem.</paragraph><list><list-item label="1.">RAReQS picks an assignment to X (line 7, with {a mathematical formula}ω=∅, so {a mathematical formula}α=1).</list-item><list-item label="2.">RAReQS finds a counterexample for z, say {a mathematical formula}z=0.</list-item><list-item label="3.">RAReQS tries to find another candidate for X. Substituting {a mathematical formula}z=0 into ϕ yields {a mathematical formula}hard(X)∧easy2(Y), which RAReQS gives to a SAT solver. The SAT solver is able to solve this by just solving the easy problem, and it quickly returns UNSAT.</list-item><list-item label="4.">Since the SAT solver returned UNSAT, there is no possible winning move for X, so RAReQS returns NULL, indicating that the universal player wins.</list-item></list></section></section></section><section label="9"><section-title>Conclusions and future work</section-title><paragraph>This article studies applications of the CEGAR paradigm in the context of QBF solving. It introduces the algorithm RAReQS, which gradually expands the given formula into a propositional one and applies a SAT solver on it. RAReQS is a recursive extension of the 2QBF algorithm AReQS, which has since its original publication inspired specialized algorithms for number of problems in the second level of polynomial hierarchy.</paragraph><paragraph>In its workings, RAReQS is close to expansion-based solvers (e.g. Quantor, Nenofex) but with the important difference that the expansion is done step-by-step, driven by counterexamples. Thus, the solver builds an abstraction of the given formula by constructing a partial expansion. The downside of this approach is that if in the end a full expansion is needed, then RAReQS performs the same expansion as a traditional expansion-based solver but with the overhead of intermediate tests.</paragraph><paragraph>However, the approach has important advantages. Whenever there is no winning move for the partial expansion, then there is no winning move for the given formula. This enables RAReQS to quickly stop for formulas with no winning moves. For formulas for which there is a winning move, RAReQS only needs to build a strong-enough partial expansion whose winning moves are also likely to be winning moves for the given formula. The experimental results demonstrate the ability of RAReQS to avoid the inherent memory blowup of expansion solvers, and, that careful expansion outperforms a traditional DPLL-based approach on a large number of practical instances.</paragraph><paragraph>We have shown that abstraction-refinement as used in RAReQS is also applicable within DPLL solvers as an additional learning mechanism. This provides a more powerful learning technique than standard clause/cube learning, although it requires more memory. Experimental evaluation indicates that this type of learning is indeed useful for DPLL-based solvers.</paragraph><paragraph>In the future we plan to further develop our DPLL solver so that it supports the full range of CEGAR learning exploited by RAReQS and to investigate how to fine-tune this learning in order to mitigate the speed penalty for the cases where the learning provides little information over the traditional learning. This can not only be done by better engineering of the solver but also devising schemata that disable the learning once deemed too costly. Conversely, in the future we plan to integrate learning techniques into RAReQS. This is likely to be important in formulas with large number of quantification levels. Techniques used in other solvers should also be considered. In particular, more aggressive preprocessing as used in Quantor and techniques for finding commonalities in formulas used in Nenofex, and dependency detection as in DepQBF[37].</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>This work is partially supported by SFI PI grant BEACON (09/IN.1/I2618), CMU-Portugal grant AMOS (CMUP-EPB/TIC/0049/2013) and the FCT grant POLARIS (PTDC/EIA-CCO/123051/2010), and multiannual PIDDAC program funds PEst-OE/EEI/LA0021/2013.</paragraph></acknowledgements><references><reference label="[1]">H. Kleine Büning, U. Bubeck, Theory of quantified Boolean formulas, in: [71], 2009, pp. 735–760.</reference><reference label="[2]"><authors>M. Benedetti,H. Mangassarian</authors><title>QBF-based formal verification: experience and perspectives</title><host>J. Satisf. Boolean Model. Comput.5 (1–4)(2008) pp.133-191</host></reference><reference label="[3]"><authors>J. Rintanen</authors><title>Asymptotically optimal encodings of conformant planning in QBF</title><host>AAAI Conference on Artificial Intelligence(2007)AAAI Press pp.1045-1050</host></reference><reference label="[4]"><authors>M. Schaefer,C. Umans</authors><title>Completeness in the polynomial-time hierarchy: a compendium</title><host>SIGACT News33 (3)(2002) pp.32-49</host></reference><reference label="[5]">E. Giunchiglia, P. Marin, M. Narizzano, Reasoning with quantified Boolean formulas, in: [71], 2009, pp. 761–780.</reference><reference label="[6]"><authors>E. Giunchiglia,P. Marin,M. Narizzano</authors><title>QuBE 7.0 system description</title><host>J. Satisf. Boolean Model. Comput.7 (2010) pp.83-88</host></reference><reference label="[7]"><authors>M. Benedetti</authors><title>Evaluating QBFs via symbolic skolemization</title><host>International Conference on Logic for Programming, Artificial Intelligence, and ReasoningLPAR(2004)Springer pp.285-300</host></reference><reference label="[8]"><authors>A. Biere</authors><title>Resolve and expand</title><host>International Conference on Theory and Applications of Satisfiability TestingSAT(2004) pp.238-246</host></reference><reference label="[9]"><authors>F. Lonsing,A. Biere</authors><title>Nenofex: expanding NNF for QBF solving</title><host>International Conference on Theory and Applications of Satisfiability TestingSAT(2008)Springer pp.196-210</host></reference><reference label="[10]"><authors>A. Goultiaeva,F. Bacchus</authors><title>Exploiting QBF duality on a circuit representation</title><host>AAAI Conference on Artificial Intelligence(2010)AAAI Press pp.71-76</host></reference><reference label="[11]"><authors>U. Bubeck,H. Kleine Büning</authors><title>Bounded universal expansion for preprocessing QBF</title><host>International Conference on Theory and Applications of Satisfiability TestingSAT(2007) pp.244-257</host></reference><reference label="[12]">E. Giunchiglia, P. Marin, M. Narizzano, sQueezeBF: an effective preprocessor for QBFs based on equivalence reasoning, in: [69], 2010, pp. 85–98.</reference><reference label="[13]">F. Lonsing, A. Biere, Failed literal detection for QBF, in: [72], 2011, pp. 259–272.</reference><reference label="[14]"><authors>H. Samulowitz,J. Davies,F. Bacchus</authors><title>Preprocessing QBF</title><host>International Conference on Principles and Practice of Constraint ProgrammingCP(2006)Springer pp.514-529</host></reference><reference label="[15]"><authors>H. Samulowitz,F. Bacchus</authors><title>Binary clause reasoning in QBF</title><host>International Conference on Theory and Applications of Satisfiability TestingSAT(2006)Springer pp.353-367</host></reference><reference label="[16]"><authors>A. Biere,F. Lonsing,M. Seidl</authors><title>Blocked clause elimination for QBF</title><host>International Conference on Automated DeductionCADE(2011) pp.101-115</host></reference><reference label="[17]"><authors>L. Zhang,S. Malik</authors><title>Conflict driven learning in a quantified Boolean satisfiability solver</title><host>International Conference on Computer-Aided DesignICCAD(2002) pp.442-449</host></reference><reference label="[18]"><authors>G. Pan,M.Y. Vardi</authors><title>Symbolic decision procedures for QBF</title><host>International Conference on Principles and Practice of Constraint ProgrammingCP(2004)Springer pp.453-467</host></reference><reference label="[19]"><authors>M. Benedetti</authors><title>sKizzo: a suite to evaluate and certify QBFs</title><host>International Conference on Automated DeductionCADE(2005) pp.369-376</host></reference><reference label="[20]"><authors>E.M. Clarke,O. Grumberg,S. Jha,Y. Lu,H. Veith</authors><title>Counterexample-guided abstraction refinement for symbolic model checking</title><host>J. ACM50 (5)(2003) pp.752-794</host></reference><reference label="[21]"><authors>R. Letz</authors><title>Lemma and model caching in decision procedures for quantified Boolean formulas</title><host>Automated Reasoning with Analytic Tableaux and Related MethodsTABLEAUX(2002) pp.160-175</host></reference><reference label="[22]">M. Janota, J. Marques-Silva, Abstraction-based algorithm for 2QBF, in: [72], 2011, pp. 230–244.</reference><reference label="[23]"><authors>M. Janota,W. Klieber,J. Marques-Silva,E.M. Clarke</authors><title>Solving QBF with counterexample guided refinement</title><host>International Conference on Theory and Applications of Satisfiability TestingSAT(2012) pp.114-128</host></reference><reference label="[24]"><authors>G.S. Tseitin</authors><title>On the complexity of derivation in propositional calculus</title><host>Stud. Constr. Math. Math. Log.2 (1970) pp.115-125</host></reference><reference label="[25]"><authors>D.A. Plaisted,S. Greenbaum</authors><title>A structure-preserving clause form translation</title><host>J. Symb. Comput.2 (3)(1986) pp.293-304</host></reference><reference label="[26]"><authors>C.H. Papadimitriou</authors><title>Computational Complexity</title><host>(1994)Addison–Wesley</host></reference><reference label="[27]"><authors>N. Narodytska,A. Legg,F. Bacchus,L. Ryzhyk,A. Walker</authors><title>Solving games without controllable predecessor</title><host>Computer Aided VerificationCAV(2014)Springer pp.533-540</host></reference><reference label="[28]"><authors>H. Kleine Büning,M. Karpinski,A. Flögel</authors><title>Resolution for quantified Boolean formulas</title><host>Inf. Comput.117 (1)(1995) pp.12-18</host></reference><reference label="[29]">C.M. Li, F. Manyà, MaxSAT, hard and soft constraints, in: [71], 2009, pp. 613–631.</reference><reference label="[30]"><authors>E.D. Rosa,E. Giunchiglia,M. Maratea</authors><title>Solving satisfiability problems with preferences</title><host>Constraints15 (4)(2010) pp.485-515</host></reference><reference label="[31]">N. Eén, N. Sörensson, An extensible SAT-solver, in: [73], 2003, pp. 502–518.</reference><reference label="[32]"><authors>L.M. de Moura,H. Rueß,M. Sorea</authors><title>Lazy theorem proving for bounded model checking over infinite domains</title><host>International Conference on Automated DeductionCADE(2002)Springer pp.438-455</host></reference><reference label="[33]"><authors>C.W. Barrett,D.L. Dill,A. Stump</authors><title>Checking satisfiability of first-order formulas by incremental translation to SAT</title><host>Computer Aided VerificationCAV(2002)Springer-Verlag pp.236-249</host></reference><reference label="[34]"><authors>M. Cadoli,A. Giovanardi,M. Schaerf</authors><title>An algorithm to evaluate quantified Boolean formulae</title><host>National Conference on Artificial Intelligence(1998)John Wiley &amp; Sons Ltd pp.262-267</host></reference><reference label="[35]">W. KlieberFormal verification using quantified Boolean formulas (QBF)Ph.D. thesis<host>(2014)Carnegie Mellon University</host><host>http://www.cs.cmu.edu/~wklieber/thesis.pdf</host></reference><reference label="[36]"><authors>L. Zhang</authors><title>Solving QBF by combining conjunctive and disjunctive normal forms</title><host>AAAI Conference on Artificial Intelligence(2006)AAAI Press pp.143-150</host></reference><reference label="[37]"><authors>F. Lonsing,A. Biere</authors><title>DepQBF: a dependency-aware QBF solver</title><host>J. Satisf. Boolean Model. Comput.7 (2–3)(2010) pp.71-76</host></reference><reference label="[38]"><title>QBF-library, The quantified Boolean formulas satisfiability library</title><host>http://www.qbflib.org/(2010)</host></reference><reference label="[39]"><title>QBF-evaluation, QBF solver evaluation portal</title><host>http://www.qbflib.org/index_eval.php(2010)</host></reference><reference label="[40]"><authors>M. Janota,G. Botterweck,R. Grigore,J. Marques-Silva</authors><title>How to complete an interactive configuration process?</title><host>International Conference on Current Trends in Theory and Practice of Computer ScienceSOFSEM(2010)Springer pp.528-539</host></reference><reference label="[41]"><authors>C. Umans</authors><title>The minimum equivalent DNF problem and shortest implicants</title><host>J. Comput. Syst. Sci.63 (4)(2001) pp.597-611</host></reference><reference label="[42]">W. Klieber, S. Sapra, S. Gao, E.M. Clarke, A non-prenex, non-clausal QBF solver with game-state learning, in: [69], 2010, pp. 128–142.</reference><reference label="[43]">F. Lonsing,M. Seidl,A. Van GelderThe QBF gallery: behind the scenesCoRR<host>arXiv:1508.01045</host></reference><reference label="[44]">M. SeidlThe qpro input formatavailable at<host>http://qbf.satisfiability.org/gallery/qpro.pdf(2009)</host></reference><reference label="[45]">A. Goultiaeva, F. Bacchus, Exploiting circuit representations in QBF solving, in: [69], 2010, pp. 333–339.</reference><reference label="[46]"><authors>C.M. Wintersteiger,Y. Hamadi,L.M. de Moura</authors><title>Efficiently solving quantified bit-vector formulas</title><host>Formal Methods in Computer-Aided DesignFMCAD(2010)IEEE pp.239-246</host></reference><reference label="[47]"><authors>C.M. Wintersteiger,Y. Hamadi,L.M. de Moura</authors><title>Efficiently solving quantified bit-vector formulas</title><host>Form. Methods Syst. Des.42 (1)(2013) pp.3-23</host></reference><reference label="[48]"><authors>D. Monniaux</authors><title>Quantifier elimination by lazy model enumeration</title><host>Computer Aided VerificationCAV(2010) pp.585-599</host></reference><reference label="[49]">M.N. Mneimneh, K.A. Sakallah, Computing vertex eccentricity in exponentially large graphs: QBF formulation and solution, in: [73], 2003, pp. 411–425.</reference><reference label="[50]"><authors>B. Browning,A. Remshagen</authors><title>A SAT-based solver for Q-ALL SAT</title><host>ACM Southeast Regional Conference(2006)ACM pp.30-33</host></reference><reference label="[51]"><authors>M. Janota,R. Grigore,J. Marques-Silva</authors><title>Counterexample guided abstraction refinement algorithm for propositional circumscription</title><host>European Conference on Logics in Artificial IntelligenceJELIA(2010) pp.195-207</host></reference><reference label="[52]"><authors>H. Samulowitz,F. Bacchus</authors><title>Using SAT in QBF</title><host>International Conference on Principles and Practice of Constraint ProgrammingCP(2005)Springer pp.578-592</host></reference><reference label="[53]">U. BubeckModel-based transformations for quantified Boolean formulasPh.D. thesis<host>(2010)University of Paderborn</host></reference><reference label="[54]"><authors>A. Ayari,D.A. Basin</authors><title>QUBOS: deciding quantified Boolean logic using propositional satisfiability solvers</title><host>Formal Methods in Computer-Aided DesignFMCAD(2002)Springer pp.187-201</host></reference><reference label="[55]"><authors>K. Korovin</authors><title>Instantiation-based automated reasoning: from theory to practice</title><host>International Conference on Automated DeductionCADE(2009)Springer pp.163-166</host></reference><reference label="[56]"><authors>A. Goultiaeva,M. Seidl,A. Biere</authors><title>Bridging the gap between dual propagation and CNF-based QBF solving</title><host>Design, Automation &amp; Test in EuropeDATE(2013)EDA Consortium pp.811-814</host></reference><reference label="[57]"><authors>W. Dvořák,M. Järvisalo,J.P. Wallner,S. Woltran</authors><title>Complexity-sensitive decision procedures for abstract argumentation</title><host>International Conference on Principles of Knowledge Representation and ReasoningKR(2012)AAAI Press pp.54-64</host></reference><reference label="[58]"><authors>H. Chen,M. Janota,J. Marques-Silva</authors><title>QBF-based Boolean function bi-decomposition</title><host>Design, Automation &amp; Test in EuropeDATE(2012)IEEE pp.816-819</host></reference><reference label="[59]"><authors>A. Morgenstern,M. Gesell,K. Schneider</authors><title>Solving games using incremental induction</title><host>Integrated Formal MethodsIFM(2013)Springer pp.177-191</host></reference><reference label="[60]">C. Jordan, Ł. Kaiser, Experiments with reduction finding, in: [70], 2013, pp. 192–207.</reference><reference label="[61]">A. Ignatiev, M. Janota, J. Marques-Silva, Quantified maximum satisfiability: a core-guided approach, in: [70], 2013, pp. 250–266.</reference><reference label="[62]"><authors>S. Jo,T. Matsumoto,M. Fujita</authors><title>SAT-based automatic rectification and debugging of combinational circuits with LUT insertions</title><host>Asian Test Symposium(2012)IEEE Computer Society pp.19-24</host></reference><reference label="[63]">M. Janota, J. Marques-Silva, On propositional QBF expansions and Q-resolution, in: [70], 2013, pp. 67–82.</reference><reference label="[64]"><authors>O. Beyersdorff,L. Chew,M. Janota</authors><title>On unification of QBF resolution-based calculi</title><host>Mathematical Foundations of Computer ScienceMFCS(2014)Springer pp.81-93</host></reference><reference label="[65]"><authors>A. Van Gelder</authors><title>Contributions to the theory of practical quantified Boolean formula solving</title><host>International Conference on Principles and Practice of Constraint ProgrammingCP(2012)Springer pp.647-663</host></reference><reference label="[66]"><authors>V. Balabanov,J.-H.R. Jiang</authors><title>Unified QBF certification and its applications</title><host>Form. Methods Syst. Des.41 (1)(2012) pp.45-65</host></reference><reference label="[67]"><authors>M. Janota,J. Marques-Silva</authors><title>Expansion-based QBF solving versus Q-resolution</title><host>Theor. Comput. Sci.577 (2015) pp.25-42</host></reference><reference label="[68]"><authors>O. Beyersdorff,L. Chew,M. Janota</authors><title>Proof complexity of resolution-based QBF calculi</title><host>International Symposium on Theoretical Aspects of Computer ScienceSTACS(2015) pp.76-89</host></reference><reference label="[69]"><host>SAT10, International Conference on Theory and Applications of Satisfiability TestingSAT(2010)Springer</host></reference><reference label="[70]"><host>SAT13, International Conference on Theory and Applications of Satisfiability TestingSAT(2013)Springer</host></reference><reference label="[71]"><host>Handbook of Satisfiabilityvol. 185 (2009)IOS Press</host></reference><reference label="[72]"><host>SAT11, International Conference on Theory and Applications of Satisfiability TestingSAT(2011)Springer</host></reference><reference label="[73]"><host>SAT03, International Conference on Theory and Applications of Satisfiability TestingSAT(2003)Springer</host></reference></references><footnote><note-para label="1">Note that in the first iteration, τ is just a random assignment. It is possible to use heuristics to find initial assignment [27].</note-para><note-para label="2">The rule of universal reduction[28] is a generalization of this property.</note-para><note-para label="3">In the SAT solver minisat2.2 this is done by the method addClause.</note-para><note-para label="4">Available from http://sat.inesc-id.pt/~mikolas/sw/areqs.</note-para><note-para label="5">In the actual implementation we relax this condition by allowing negations on expressions containing no quantifiers.</note-para><note-para label="6">The problem is usually presented for an implicant rather than implicate, which is easily convertible to the implicate problem by negating the input formula.</note-para><note-para label="7">Also used for the QBF Gallery 2014 http://qbf.satisfiability.org/gallery/.</note-para><note-para label="8">http://sat.inesc-id.pt/~mikolas/sw/areqs/qpro.html.</note-para><note-para label="9">In Quantor, eliminating a single variable gives worst-case quadratic space increase.</note-para></footnote></root>