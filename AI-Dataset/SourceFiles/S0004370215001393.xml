<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370215001393</url><title>Learning Boolean specifications</title><authors>U. Bubeck,H. Kleine Büning</authors><abstract>In this paper we consider an extended variant of query learning where the hidden concept is embedded in some Boolean circuit. This additional processing layer modifies query arguments and answers by fixed transformation functions which are known to the learner. For this scenario, we provide a characterization of the solution space and an ordering on it. We give a compact representation of the minimal and maximal solutions as quantified Boolean formulas and we adapt the original algorithms for exact learning of specific classes of propositional formulas.</abstract><keywords>Query learning;Propositional logic</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Query learning [2], [10] is a classical scenario in supervised machine learning which is used to study the problem of selecting which queries to ask to learn a target concept as quickly as possible, in a scenario where information about the target concept can be obtained by making queries. In the model of exact identification with queries[2], the learner must figure out an unknown concept using restricted queries addressed to an oracle that constitutes the teacher. Predetermined templates for different types of queries specify what the learner can ask and how the oracle will respond. It is then up to the learner to instantiate these templates with suitable concrete questions, so that the target concept is learned with a small number of question-and-answer cycles, say, polynomially many in the size of the target in some specific representation that learner and teacher have previously agreed upon. An intuitive illustration is to think that this representation of the target is hidden in a black box. The questions to the oracle and its answers allow the learner to probe that black box.</paragraph><paragraph>In this paper we consider an extended variant of the exact identification model where there is an intermediary processing layer between the learner and the oracle. This additional processing layer modifies query arguments and answers by fixed transformation functions which are known to the learner. Figuratively speaking, we place the black box with the hidden target concept inside an additional white box, so that the black box can be probed only indirectly through probing the white box. We do this for the most frequently studied case of query learning in which the target concept in the black box is a Boolean function. A natural choice for the white box is then a Boolean circuit which surrounds the black box. In total, that means we have a circuit containing a node with an unknown Boolean function. Since a Boolean function can describe the computation of a Boolean circuit, this is equivalent to having a Boolean circuit that contains an unknown subcircuit (disregarding size issues of representation as formula vs. representation as circuit).</paragraph><paragraph>In circuit design, this type of question is a specific verification task, called (Black Box) Combinational Equivalence Checking[7]. A partial implementation of a circuit has its unfinished parts combined into a black box. Early design errors can be detected, if the implementation differs from its specification for all substitutions of the black box. In this case the specification of the circuit serves as the oracle. Similarly, a faulty implementation can be handled, if a fault can be restricted to a certain area in the implementation. Replacing this area by a black box and using the faulty implementation as the oracle, the faulty behavior might be explained. Angluin's original approach of using AI techniques, especially machine learning, has to be adapted for this more general setting of Boolean circuit design.</paragraph><paragraph>The learner's task is now to find a definition of the unknown component, so that substituting the learner's solution for the unknown component results in a circuit which computes for all possible inputs exactly the same outputs as the target circuit, i.e., the original circuit with revealed black box. This is analogous to exact query learning of Boolean functions [2], which requires that the learned function must return exactly the same truth values as the target function on all inputs. In this original scenario of exact query learning, the most important standard types of queries are membership queries and equivalence queries. A membership query asks whether a particular domain object is included in the unknown target concept. In the Boolean domain, that means asking whether a particular truth assignment makes the unknown function true. An equivalence query asks whether a concrete concept proposed by the learner is the same as the target concept. For Boolean functions, this holds whenever both concepts return the same valuations for all possible arguments. A negative answer to an equivalence query is always accompanied by a counterexample. In the Boolean domain, a counterexample is a truth assignment on which the proposed function and the target function disagree. Membership and equivalence queries have in common that they reason about a single or all truth assignments to the unknown function and consider the corresponding value(s) of the unknown function. We adapt this to our scenario of learning a function in a circuit as follows: instead of reasoning about truth assignments to the unknown function, we reason about truth assignments to the inputs of the whole circuit. And instead of considering the valuation of the unknown function, we consider the output of the whole circuit. That means we do not ask queries about the unknown component in isolation, but only about the whole circuit, as in the previously outlined scenario of probing the black box only indirectly through a surrounding white box.</paragraph><paragraph>Our paper investigates how this indirection changes the character of the original query learning problem, especially the structure of solutions and the applicability of existing learning algorithms. Clever strategies have been found for exact learning of various classes of Boolean functions with a polynomial number of membership and equivalence queries. Is it possible to adapt such strategies to our indirect query learning scenario?</paragraph><paragraph>These query learning strategies typically try to verify conjectures about the hidden function by making series of membership queries in which the truth assignments are chosen according to precise sequences of, e.g., bit flips or bit vector intersections. For example, if the unknown function is known to be representable as a conjunction of variable literals, and if two membership queries for identical arguments with the last bit flipped, say, {a mathematical formula}(1,0,1) and {a mathematical formula}(1,0,0), are both acknowledged with positive answers, we can deduce that the last argument cannot occur as a literal in the hidden conjunction. In the extended scenario with a circuit being placed around the unknown function, the global circuit inputs that we assign are mapped by the circuit to different actual inputs to the unknown circuit node. The problem is not only that we need to reverse this mapping in order to know which global inputs lead to the desired arguments to the unknown function. We also need to consider that the mapping from global circuit inputs to local node inputs is generally not surjective. That means certain input values might never appear at the unknown node, which allows the learned function to be defined arbitrarily for these arguments. Similarly, there can be global circuit inputs for which the actual output of the unknown node does not matter. In circuit design and optimization, the former case is called (local) satisfiability don't care, and the latter is called (local) observability don't care[6], and it is well known that this allows different possible definitions of the respective circuit node. Driven by important applications of circuit simplification or synthesis, these observations have led to the development of various techniques for computing some or all permissible functions for a node in a Boolean circuit [6], [8], [11]. However, these techniques do not seem to be directly applicable to our query learning problem. Obviously, their iterative computation along cut lines in the circuit is different in style from query learning. But most importantly, they do not consider the representability of the permissible functions within given classes of Boolean functions, which is the key feature of the existing query learning algorithms that we wish to adapt to the circuit scenario.</paragraph><paragraph>Another line of related work is a series of papers by Scholl, Becker et al. on the partial equivalence checking problem in circuit design [7], [5], i.e., checking whether a given partial implementation of a combinational circuit can be extended to a complete design that is equivalent to a given full specification. The authors focus on detecting errors in partial implementations and not on returning implementations of black boxes. In case of a single black box, their method, which is essentially a series of different algorithms with increasing accuracy, can find all errors in the partial implementation. In a recent paper [5], Gitina et al. give a translation of the partial equivalence checking problem into a satisfiability problem for dependency quantified Boolean formulas which can be decided in {a mathematical formula}Π3P for the special case of a single black box. Seen as a composition problem, the task in [7], [5] is to find components that fit into the black boxes in a template (the surrounding white box part) such that the composition is correct with respect to the given specification. Following this approach, one could argue that a specification of the black box will be revealed implicitly. Apart from the fact that it is unknown whether a compact representation of such a specification can be given, testing candidate components against this specification is a coNP-complete problem. In our approach, we assume some knowledge about the black box to be given in form of an oracle. The question of which candidates fit into the black box of a circuit can therefore be addressed directly by a query learning approach.</paragraph><paragraph>The existence of multiple solutions is a significant modification of the original exact query learning problem, which always has exactly one solution. Even in the original scenario, one has to be very careful with overlapping conjectures, e.g., when a conjectured implicant contains two actual prime implicants. Our major contributions on this topic are the following:</paragraph><list><list-item label="1.">We provide a characterization of the solution space and an ordering on it that allows expression of minimal and maximal solutions (Section 3).</list-item><list-item label="2.">We provide a compact representation of the minimal and maximal solutions as quantified Boolean formulas (Section 4).</list-item><list-item label="3.">We adapt the original algorithms for exact learning of a term/clause or monotone DNF [2] to our circuit scenario (Sections 5 and 6).</list-item></list></section><section label="2"><section-title>Specification problem</section-title><paragraph label="Definition 1">A configuration{a mathematical formula}C(z) with input variables {a mathematical formula}z=z1,…,zr is a circuit (i.e., a directed acyclic graph) with incoming edges labeled with {a mathematical formula}z1,…,zr and one outgoing edge labeled with “out”. Inner edges that connect two nodes are also labeled with (distinct) variable names. The circuit nodes are Boolean functions over the variables attached to their incoming edges. We write {a mathematical formula}y:=f(x1,…,xn) to denote an edge which is labeled with y and coming from a node that computes f from incoming edges {a mathematical formula}x1,…,xn.</paragraph><paragraph>In practice, the nodes or gates of a Boolean circuit are typically not arbitrary Boolean functions, but can only be chosen from a given Basis Ω, e.g. {a mathematical formula}Ω={∧,∨,¬}, possibly along with additional restrictions, such as bounded indegrees or outdegrees of the nodes (bounded fan-in or fan-out). At this point, however, we make no restrictions on the nodes and assume that they are arbitrary Boolean functions with arbitrary fan-in and fan-out. Fig. 1 shows a sample circuit.</paragraph><paragraph>In the following, letters {a mathematical formula}f,g,h and their uppercase variants always denote Boolean functions. We define a concrete Boolean function not by a truth table or case distinction, but by giving one of its propositional formula representations. For example, when we write {a mathematical formula}f(x1,x2):=(x1∨x2)∧(¬x1∨¬x2) then f is not this formula itself, but the Boolean XOR function over {a mathematical formula}x1,x2 (i.e., {a mathematical formula}f(x1,x2):=1 if and only if {a mathematical formula}x1≠x2). So we can also write {a mathematical formula}f(x1,x2)=(¬x1∧x2)∨(x1∧¬x2) as an equality (“=”) instead of a weaker equivalence (“≈”), since we still mean exactly the same function and not the particular formula used to define it. Conversely, we say that functions {a mathematical formula}f(x1,…,xn) and {a mathematical formula}g(x1,…,xn) are different if and only if they have different truth tables, i.e., there is a truth value assignment {a mathematical formula}t(x)∈{0,1}n with {a mathematical formula}f(t(x))≠g(t(x)). We also define conjunction and disjunction of Boolean functions with straightforward semantics: if {a mathematical formula}h1(x1,…,xn) and {a mathematical formula}h2(x1,…,xn) are Boolean functions with arguments {a mathematical formula}x:=x1,…,xn then {a mathematical formula}h(x):=h1(x)∧h2(x) ({a mathematical formula}h(x):=h1(x)∨h2(x), resp.) is the function with {a mathematical formula}h(x):=1 if and only if {a mathematical formula}h1(x)=1 and (or, resp.) {a mathematical formula}h2(x)=1. Notice again that expressions such as {a mathematical formula}h1∧h2, {a mathematical formula}h2∧h1, {a mathematical formula}h1∧h2∧h2, etc. denote exactly the same function.</paragraph><paragraph>Inductively, we can associate with every configuration {a mathematical formula}C(z) over inputs {a mathematical formula}z=z1,…,zr a Boolean function which describes the computation of the circuit. For each input {a mathematical formula}zi, we let {a mathematical formula}Fzi(z):=zi. And for each edge {a mathematical formula}y:=f(x1,…,xn), we let {a mathematical formula}Fy(z):=f(Fx1(z),…,Fxn(z)). The whole circuit then computes the function {a mathematical formula}Fout(z). In Fig. 1, {a mathematical formula}Fout(z)=f5(Fv(z),Fy(z)). By replacing in this term {a mathematical formula}Fv(z) and {a mathematical formula}Fy(z) with their definitions, and so on, we obtain a composite function term which contains only the variables z and the node functions {a mathematical formula}f1,…,f5,h: {a mathematical formula}Fout(z)=f5(f4(z1,f1(z2,z3)),h(f1(z2,z3),f2(z4,z5),f3(z5,z6,z7))). Due to the need to duplicate subterms which have fan-out greater than 1, such as {a mathematical formula}f1(z2,z3) in the example, the length of the resulting term can in general become exponential in the circuit size. For simplicity of notation, we will identify {a mathematical formula}C(z) with {a mathematical formula}Fout(z). Accordingly, we can, e.g., write {a mathematical formula}C(z1,z2)=(z1∨z2)∧(¬z1∧¬z2) to express that circuit C computes the parity of its inputs, that means {a mathematical formula}Fout(z1,z2) is the parity function.</paragraph><paragraph>As motivated in the introduction, we now consider the problem that the configuration contains an unknown component. That means there is one circuit node with a Boolean function in a black box, and we only know its input variables and its output variable, but not its definition or truth table. For the other nodes, this information is available, that means all the other functions are known. Please keep in mind that the unknown circuit node can actually stand for a whole unknown subcircuit, since we allow each circuit node to be an arbitrary Boolean function, which can encode any Boolean (sub)circuit, as we have just discussed above. We typically use the letter h to denote the unknown function, and letters {a mathematical formula}x1,…,xn for its input variables and y for its output variable, i.e., {a mathematical formula}y:=h(x1,…,xn). We write {a mathematical formula}C(h)(z)=C(h)(z1,…,zr) for a configuration with unknown Boolean function h and call this a partial configuration. The circuit from Fig. 1 can be considered as a partial configuration {a mathematical formula}C(h)(z1,…,z7) if h is unknown and the definitions of {a mathematical formula}f1,…,f5 are available. Given a set K of concrete (i.e., known) Boolean functions and a target function{a mathematical formula}g(z) (also called specification), we want to know whether or not we can find a concrete function {a mathematical formula}H∈K which we can substitute for h, written {a mathematical formula}C(h/H)(z), so that the resulting completely defined configuration computes the same function as the target {a mathematical formula}g(z).</paragraph><paragraph label="Definition 2"><section-title>Specification problem</section-title></paragraph><list><list-item>A partial configuration {a mathematical formula}C(h)(z) and a target function {a mathematical formula}g(z) are given. Furthermore, let K be a fixed class of Boolean functions.</list-item><list-item>Does there exist {a mathematical formula}H∈K with {a mathematical formula}C(h/H)(z)=g(z)? Additionally, if such a function exists, output one.</list-item></list></section><section label="3"><section-title>Characterization of the solution space</section-title><paragraph>One way to approach a specification problem {a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉 is to consider it as a Boolean equation. As in the previous section, we can associate with the circuit {a mathematical formula}C(h)(z) a function {a mathematical formula}Fout(z) which is the composition of the function symbols written on the nodes. This function must be equal to the target function. For the example in Fig. 1, we obtain the equation{a mathematical formula} If {a mathematical formula}f1,…,f5 and g are known, we must try to find a suitable function {a mathematical formula}h∈K which satisfies the equation. But as mentioned above, this equation may have exponential size due to fan-out. And since dealing with Boolean equations is also tedious and not very intuitive anyway, we will take a different point of view.</paragraph><paragraph>We put the unknown function into the center of our attention and follow the idea from the introductory section to treat the problem as a generalization of learning a Boolean function {a mathematical formula}h(x1,…,xn) in a black box [2] with the additional difficulty that the inputs and the output of the black box are not directly accessible. We thus consider how the valuations of {a mathematical formula}x1,…,xn depend on the values of the circuit inputs z and how the output of the whole circuit depends on the output of h. Our idea is to extract these dependencies as subcircuits of C.</paragraph><paragraph label="Definition 3">In a partial configuration {a mathematical formula}C(h)(z) with unknown function {a mathematical formula}y:=h(x1,…,xn) for each {a mathematical formula}xi, {a mathematical formula}i=1,…,n we denote with {a mathematical formula}Ci(z) the upstream subcircuit of C that computes{a mathematical formula}xi. More formally, {a mathematical formula}Ci is the subgraph that is induced by the edges of C by which {a mathematical formula}xi is reachable. For a truth assignment {a mathematical formula}v(z)∈{0,1}r, we denote with {a mathematical formula}πi:=Ci(v(z)) for {a mathematical formula}i=1,…,n the value of {a mathematical formula}xi under the assignment of v to the circuit inputs {a mathematical formula}z=z1,…,zr. We use the notation {a mathematical formula}πi in particular when the actual assignment v is anonymous or arbitrary.Furthermore, we let {a mathematical formula}Cd(z,y) be the downstream subcircuit of C which processes the output y of h. That means {a mathematical formula}Cd is the subcircuit which is obtained when we remove from C those nodes and edges for which every directed path to the output of the whole circuit leads through h, including h itself, and we make y a new input in addition to the existing inputs z.</paragraph><paragraph>Fig. 2 shows the upstream and downstream subcircuits for the unknown component h in the partial configuration from Fig. 1. Notice that the node {a mathematical formula}f1(z2,z3) occurs in both {a mathematical formula}Cd and {a mathematical formula}C1 and was drawn twice to improve clarity. This also shows that the so-called downstream circuit {a mathematical formula}Cd can actually be very much around h when the circuit has lots of structure sharing by fan-out (i.e., besides using the output of h, {a mathematical formula}Cd may also provide inputs to h). To avoid case distinction, we always assume that the unknown component h is an inner node of the circuit, i.e., y is not the global output, and none of {a mathematical formula}x1,…,xn is also a global input. This is already the case in our example, but if necessary, we can obtain this normal form by surrounding h with dummy nodes that compute the identify function {a mathematical formula}f(x)=x (a buffer gate).</paragraph><paragraph>By the construction of {a mathematical formula}Cd,C1,…,Cn and the previously established definition of the functions describing the computations of circuits, it is easy to see that {a mathematical formula}C(z)=Cd(z,h(C1(z),…,Cn(z))). Of course, the notation {a mathematical formula}Ci(z) does not imply that all inputs z of the whole circuit actually need to occur as inputs of {a mathematical formula}Cd or {a mathematical formula}Ci.</paragraph><paragraph>We are now going to characterize the solution space of configuration problems by considering the interplay of the upstream and downstream subcircuits.</paragraph><paragraph label="Example 1">Let{a mathematical formula} be a partial configuration. Then {a mathematical formula}C1(z1,z2)=z1∨z2 and {a mathematical formula}C2(z1,z2)=¬z1∨¬z2 are upstream subcircuits of h, and {a mathematical formula}Cd(y)=¬y is its downstream subcircuit. Let {a mathematical formula}g(z1,z2):=z1↔z2 be the target function, and let K be the class of all Boolean functions ({a mathematical formula}K=BOOL). Then it is easy to see that one solution is {a mathematical formula}H1(x1,x2):=x1∧x2, because {a mathematical formula}Cd(H1(C1(z1,z2),C2(z1,z2)))=¬((z1∨z2)∧(¬z1∨¬z2))=z1↔z2. Interestingly, there is a second solution {a mathematical formula}H2(x1,x2):=(x1∧x2)∨(¬x1∧¬x2)=x1↔x2. In terms of {a mathematical formula}x1 and {a mathematical formula}x2, these are really different solutions, because {a mathematical formula}H1(0,0)=0 and {a mathematical formula}H2(0,0)=1, and thus {a mathematical formula}H1(x1,x2)≠H2(x1,x2). But there exists no truth value assignment v to {a mathematical formula}z1,z2 under which {a mathematical formula}x1 and {a mathematical formula}x2 evaluate both to 0, i.e., the case {a mathematical formula}π1=π2=0 (meaning {a mathematical formula}C1(v(z1,z2))=C2(v(z1,z2))=0) is not possible for any assignment v. For all other values of {a mathematical formula}π1,π2, we have {a mathematical formula}H1(π1,π2)=H2(π1,π2), which justifies that {a mathematical formula}H2 is also a solution.</paragraph><paragraph>In this example, the different behavior of {a mathematical formula}H1 and {a mathematical formula}H2 in terms of {a mathematical formula}x1,x2 is compensated for by the upstream subcircuits that compute {a mathematical formula}x1 and {a mathematical formula}x2, because these upstream parts suppress some possible valuations of {a mathematical formula}x1 and {a mathematical formula}x2. Another possibility is that the downstream part of the circuit compensates for differences in the solutions, as illustrated by the following example:</paragraph><paragraph label="Example 2">Let{a mathematical formula} be a partial configuration in a specification problem S with the target function {a mathematical formula}g(z1,z2):=z1↔z2 and {a mathematical formula}K=BOOL. The only difference to Example 1 is that the output of the whole circuit no longer depends only on h. No matter what we choose for h, the circuit will already output the correct solution for the case when {a mathematical formula}z1=1 and {a mathematical formula}z2=1. In this case, we have {a mathematical formula}π1=1 and {a mathematical formula}π2=0, so {a mathematical formula}h(1,0) becomes a don't care for the downstream subcircuit, which means either {a mathematical formula}h(1,0)=0 or {a mathematical formula}h(1,0)=1 is possible. Clearly, the solutions that we have already found in Example 1 remain solutions to the current problem. These are {a mathematical formula}H1(x1,x2):=x1∧x2 and {a mathematical formula}H2(x1,x2):=(x1∧x2)∨(¬x1∧¬x2). Both {a mathematical formula}H1 and {a mathematical formula}H2 return 0 for the argument {a mathematical formula}(1,0). When we modify {a mathematical formula}H1 so that 1 is returned for the argument {a mathematical formula}(1,0), we obtain {a mathematical formula}H1(x1,x2)∨(x1∧¬x2)=x1, and thus the additional solution {a mathematical formula}H3(x1,x2):=x1. Analogous modification of {a mathematical formula}H2 leads to {a mathematical formula}H4(x1,x2):=x1∨¬x2. It is easily checked that these are the only solutions, so we obtain a solution space {a mathematical formula}SP(S)={H1,…,H4}. In terms of {a mathematical formula}x1,x2, all four solutions are different functions, i.e., {a mathematical formula}Hi(x1,x2)≠Hj(x1,x2) for {a mathematical formula}i≠j, because each has a different truth table in {a mathematical formula}x1,x2. But for each assignment to {a mathematical formula}z1,z2, the upstream or the downstream subcircuits compensate for these differences.</paragraph><paragraph>The following lemma characterizes the general conditions for such compensation by the upstream (case 1) or downstream (case 2) subcircuits.</paragraph><paragraph label="Lemma 1">Let{a mathematical formula}H1be a solution of{a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉with unknown function{a mathematical formula}h(x1,…,xn), and let{a mathematical formula}H2be an arbitrary Boolean function in the class K over the same arguments{a mathematical formula}x1,…,xn. Then{a mathematical formula}H2is also a solution of S if and only if for all truth assignments{a mathematical formula}v(z)to the circuit inputszat least one of the following conditions holds:</paragraph><list><list-item label="1.">{a mathematical formula}H1(π1,…,πn)=H2(π1,…,πn)with{a mathematical formula}πi=Ci(v(z))being the valuation of{a mathematical formula}xiunder{a mathematical formula}v(z)for all{a mathematical formula}i=1,…,n, or</list-item><list-item label="2.">{a mathematical formula}Cd(v(z),0)=Cd(v(z),1).</list-item></list><paragraph label="Proof">If one of the conditions holds for each {a mathematical formula}v(z), we have {a mathematical formula}C(h/H1)(v(z))=C(h/H2)(v(z)) for each {a mathematical formula}v(z). Since {a mathematical formula}H1 is a solution, {a mathematical formula}g(v(z))=C(h/H1)(v(z))=C(h/H2)(v(z)), and {a mathematical formula}H2 is thus also a solution. On the other hand, if there is an assignment {a mathematical formula}v(z) that violates both conditions, {a mathematical formula}H1(π1,…,πn)≠H2(π1,…,πn) implies that one of the sides of this inequality is 0 and the other is 1. Because condition 2 does not hold, we get {a mathematical formula}C(h/H1)(v(z))≠C(h/H2)(v(z)). One of these terms is thus unequal to {a mathematical formula}g(v(z)), so {a mathematical formula}H1 and {a mathematical formula}H2 cannot both be solutions.  □</paragraph><paragraph>As we have already seen in Example 2, cases 1 and 2 of the lemma can also apply alternately for different circuit inputs {a mathematical formula}v(z), leading to more complex solution spaces. An upper bound on the size of the solution space is {a mathematical formula}22n solutions, where n is the number of input variables for the unknown function, because there are at most {a mathematical formula}22n distinct n-ary Boolean functions over n variables. A simple example for such a solution space is the following:{a mathematical formula} with target function {a mathematical formula}g(z1,…,zn):=1. Then every Boolean function over the variables {a mathematical formula}x1,…,xn is a solution, because the value of y has no effect on the output of the circuit (condition 2 of Lemma 1 is always satisfied trivially).</paragraph><paragraph>We are now going to identify some further structure in the solution space.</paragraph><paragraph label="Theorem 1">For a solvable specification problem{a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉with unknown function{a mathematical formula}h(x1,…,xn), it holds for all solutions{a mathematical formula}H1,H2∈SP(S):</paragraph><list><list-item label="1.">{a mathematical formula}(H1∧H2)∈SP(S)if and only if{a mathematical formula}(H1∧H2)∈K.Analogously,{a mathematical formula}(H1∨H2)∈SP(S)if and only if{a mathematical formula}(H1∨H2)∈K.</list-item><list-item label="2.">For every function{a mathematical formula}H∈Kover{a mathematical formula}x1,…,xn: if{a mathematical formula}H1⊨H⊨H2then{a mathematical formula}H∈SP(S).</list-item></list><paragraph label="Proof">Part 1: Let {a mathematical formula}H1 and {a mathematical formula}H2 be two solutions with input variables {a mathematical formula}x1,…,xn, and let {a mathematical formula}v(z) be an arbitrary truth assignment to the circuit input variables z. As above, let {a mathematical formula}πi denote the truth value to which the circuit edge {a mathematical formula}xi evaluates under v. By the definition of conjunction, we have {a mathematical formula}(H1∧H2)(π1,…,πn)=Hj(π1,…,πn) for some {a mathematical formula}j∈{1,2}, i.e., {a mathematical formula}C(h/(H1∧H2))(v(z))=C(h/Hj)(v(z)). With {a mathematical formula}Hj being a solution, the latter is equal to {a mathematical formula}g(v(z)). Since such equality can be obtained for any v, we have {a mathematical formula}C(h/(H1∧H2))(z)=g(z). This means {a mathematical formula}H1∧H2 is also a solution, provided that {a mathematical formula}H1∧H2 is also contained in the class K. For {a mathematical formula}H1∨H2, the disjunction operator analogously implies that {a mathematical formula}(H1∨H2)(π1,…,πn)=Hj(π1,…,πn) for some {a mathematical formula}j∈{1,2}, and the argument is the same.Part 2: Let {a mathematical formula}H∈K be a function over {a mathematical formula}x1,…,xn with {a mathematical formula}H1⊨H⊨H2. Let {a mathematical formula}v(z) be an arbitrary truth assignment to the circuit inputs z, and let {a mathematical formula}πi be the value of {a mathematical formula}xi under v. If {a mathematical formula}H(π1,…,πn)=1 then {a mathematical formula}H2(π1,…,πn)=1, since {a mathematical formula}H⊨H2. On the other hand, {a mathematical formula}H(π1,…,πn)=0 implies {a mathematical formula}H1(π1,…,πn)=0 because of {a mathematical formula}H1⊨H. That means {a mathematical formula}H(π1,…,πn)=Hj(π1,…,πn) for some {a mathematical formula}j∈{1,2}. Thus, {a mathematical formula}C(h/H)(v(z))=C(h/Hj)(v(z)), and the latter is {a mathematical formula}g(v(z)), since {a mathematical formula}Hj is a solution.  □</paragraph><paragraph>As pointed out in Section 2, expressions such as {a mathematical formula}Hi∧Hj are not considered as formulas, but as the definition of a particular Boolean function. If the solution space already contains a function with the same truth table, this conjunction does not create a new solution, so the solution space is always finite with the upper bound of {a mathematical formula}22n solutions given above. For instance, two of the solutions in Example 2 are {a mathematical formula}H2:=(x1∧x2)∨(¬x1∧¬x2) and {a mathematical formula}H3:=x1. According to the theorem, another solution is then {a mathematical formula}H2∨H3=(x1∧x2)∨(¬x1∧¬x2)∨x1, which is the same function as {a mathematical formula}H4:=x1∨¬x2∈SP(S).</paragraph><paragraph>In the following, we assume that the class of potential solution candidates K is closed under conjunction and/or disjunction, e.g. the class of all Boolean functions {a mathematical formula}K=BOOL. Then the theorem guarantees that the actual solution space is also closed under conjunction and/or disjunction, and we can talk about minimal and/or maximal solutions with respect to deduction.</paragraph><paragraph label="Definition 4">Let {a mathematical formula}SP(S)={H1,…,Hk} be the solution space of a specification problem {a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉. If K is closed under conjunction, we define the minimal solution of S to be {a mathematical formula}Hmin:=⋀1≤i≤kHi. And we call {a mathematical formula}Hmax:=⋁1≤i≤kHithe maximal solution if K is closed under disjunction.</paragraph><paragraph>By Theorem 1, {a mathematical formula}Hmin and {a mathematical formula}Hmax are themselves solutions, i.e., {a mathematical formula}Hmin,Hmax∈{H1,…,Hk} (notice that for all i, {a mathematical formula}Hmin∧Hi denotes the same function as {a mathematical formula}Hmin, so {a mathematical formula}Hmin is well defined, and the same holds for {a mathematical formula}Hmax). We call {a mathematical formula}Hmin and {a mathematical formula}Hmax minimal and maximal, because for every solution H we have {a mathematical formula}Hmin⊨H⊨Hmax (if both are defined). And conversely, every such H is a solution (Theorem 1, item 2). In Example 2, the minimal and maximal solutions are {a mathematical formula}Hmin(x1,x2)=x1∧x2 and {a mathematical formula}Hmax(x1,x2)=x1∨¬x2.</paragraph><paragraph>From the point of view of the hidden function h, the existence of multiple solutions means that there are certain input tuples to h which have no effect on the equivalence relation between the whole circuit and its specification. In Example 2, we have identified the cases {a mathematical formula}π1=π2=0 (upstream circuits never generate this case) and {a mathematical formula}π1=1,π2=0 (downstream circuit always gives correct result). For these values of {a mathematical formula}x1,x2, the solution can be defined arbitrarily. We are now going to introduce an alternative representation which focuses only on the relevant inputs to h.</paragraph><paragraph label="Definition 5">In order to express that a Boolean function {a mathematical formula}f(x) is only defined for inputs x with {a mathematical formula}g(x)=1, we use the notation {a mathematical formula}f|g(x):{a mathematical formula}</paragraph><paragraph>Intuitively, the solution of a specification problem can be arbitrary for those arguments (i.e., truth assignments) for which the minimal and the maximal solution differ from each other. Exactly in this case, the indicator function {a mathematical formula}D(S)(x) is set to 0 in the following definition.</paragraph><paragraph label="Definition 6">For the minimal solution {a mathematical formula}Hmin and the maximal solution {a mathematical formula}Hmax of a specification problem S (with K closed under conjunction and disjunction), we define {a mathematical formula}D(S)(x):=¬Hmax(x)∨Hmin(x). For every solution H, the partial function {a mathematical formula}H|D(S) is called a prime solution.</paragraph><paragraph>The specification problem of Example 2 has four solutions: {a mathematical formula}H1:=x1∧x2, {a mathematical formula}H2:=(x1∧x2)∨(¬x1∧¬x2), {a mathematical formula}H3:=x1, and {a mathematical formula}H4:=x1∨¬x2. From {a mathematical formula}Hmin=H1 and {a mathematical formula}Hmax=H4, we get {a mathematical formula}D(S)(x1,x2)=(¬x1∧x2)∨(x1∧x2)≈x2. The prime solutions are {a mathematical formula}(x1∧x2)|x2, {a mathematical formula}((x1∧x2)∨(¬x1∧¬x2))|x2, {a mathematical formula}(x1)|x2 and {a mathematical formula}(x1∨¬x2)|x2. At first glance, these seem to be different partial functions. But since the functions need only be defined for {a mathematical formula}x2=1, we have {a mathematical formula}(H1)|D(S)=…=(H4)|D(S)=x1. In other words, the prime solutions are identical when considered as partial functions.</paragraph><paragraph label="Lemma 2">Any solvable specification problem{a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉(with K closed under conjunction and disjunction) has a unique prime solution, i.e., for solutions{a mathematical formula}H1,H2we have{a mathematical formula}(H1)|D(S)=(H2)|D(S). Moreover, any extension of the prime solution to a total Boolean function in the class K is a solution.</paragraph><paragraph label="Proof">For uniqueness, consider an arbitrary truth assignment {a mathematical formula}t(x) satisfying {a mathematical formula}D(S), i.e., {a mathematical formula}D(S)(t(x))=1. Then either {a mathematical formula}Hmin(t(x))=1 or {a mathematical formula}Hmax(t(x))=0. By Definition 4, {a mathematical formula}Hmin:=⋀iHi and {a mathematical formula}Hmax:=⋁iHi over all solutions {a mathematical formula}Hi, and thus either {a mathematical formula}Hi(t(x))=1 for all solutions {a mathematical formula}Hi, or {a mathematical formula}Hi(t(x))=0 for all {a mathematical formula}Hi. Then {a mathematical formula}(Hi)|D(S)(t(x)) clearly has the same value for all {a mathematical formula}Hi.For the second part of the lemma, let {a mathematical formula}H(x) be a total Boolean function that extends the prime solution, which means {a mathematical formula}H|D(S)=(Hmax)|D(S)=(Hmin)|D(S). For any truth assignment {a mathematical formula}t(x) with {a mathematical formula}D(S)(t(x))=0, we have {a mathematical formula}Hmax(t(x))=1 and {a mathematical formula}Hmin(t(x))=0 according to the definition of {a mathematical formula}D(S). So it holds for all {a mathematical formula}t(x) with {a mathematical formula}D(S)(t(x))=0 that {a mathematical formula}Hmin(t(x))≤H(t(x))≤Hmax(t(x)). Since H extends the unique prime solution, we also have {a mathematical formula}Hmin(t(x))=H(t(x))=Hmax(t(x)) for all {a mathematical formula}t(x) satisfying {a mathematical formula}D(S)(t(x))=1, hence in the end {a mathematical formula}Hmin⊨H⊨Hmax. It follows from Theorem 1 that H is a solution.  □</paragraph><paragraph>As illustrated by the first half of the proof, the prime solution can be understood as the common part on which all solutions agree. Rather than considering all solutions in order to compute {a mathematical formula}Hmin and {a mathematical formula}Hmax, and then {a mathematical formula}D(S) from these, it is possible to give an alternate characterization of the prime solution. The idea is to identify those arguments to the hidden function h for which neither the upstream nor the downstream parts of the enclosing circuit allow different return values of h. This is in essence a negation of the conditions stated in Lemma 1.</paragraph><paragraph label="Theorem 2">Every solvable specification problem{a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉(with K closed under conjunction and disjunction) with unknown{a mathematical formula}h(x1,…,xn)has a unique prime solution{a mathematical formula}H|D(S)that can be characterized as follows:</paragraph><list><list-item label="1.">{a mathematical formula}D(S)(x1,…,xn)=1if and only if there exists a truth assignment{a mathematical formula}v(z)to the circuit inputszsuch that{a mathematical formula}xi=Ci(v(z))for all{a mathematical formula}i=1,…,nand{a mathematical formula}Cd(v(z),0)≠Cd(v(z),1).</list-item><list-item label="2.">{a mathematical formula}H|D(S)(x1,…,xn):={1if existsv(z)withxi=Ci(v(z))for alliandg(v(z))≠Cd(v(z),0),0if existsv(z)withxi=Ci(v(z))for alliandg(v(z))≠Cd(v(z),1),undef.else(i.e., ifD(S)(x1,…,xn)=0).</list-item></list><paragraph label="Proof">Part 1: As in the proof of the previous lemma, we have {a mathematical formula}D(S)(t(x))=1 for a truth assignment {a mathematical formula}t(x) if and only if {a mathematical formula}H1(t(x))=…=Hk(t(x)) for all solutions {a mathematical formula}H1,…,Hk. The latter holds if and only if there are no functions {a mathematical formula}Hi,Hj with {a mathematical formula}Hi(t(x))≠Hj(t(x)) which are both solutions of S. By Lemma 1, {a mathematical formula}Hi and {a mathematical formula}Hj are not both solutions if and only if there is a truth assignment {a mathematical formula}v(z) with {a mathematical formula}t(xi)=Ci(v(z)) for all {a mathematical formula}i=1,…,n and {a mathematical formula}Cd(v(z),0)≠Cd(v(z),1).Part 2: We first have to justify that the above definition of {a mathematical formula}H|D(S) is sound, i.e., that the “else” case applies if and only if {a mathematical formula}D(S)(x1,…,xn)=0 and that the first two cases mutually exclusively cover {a mathematical formula}D(S)(x1,…,xn)=1. At least one of the first two cases applies if and only if there exists some assignment {a mathematical formula}v(z) with {a mathematical formula}xi=Ci(v(z)), {a mathematical formula}i=1,…,n, and {a mathematical formula}g(v(z))≠Cd(v(z),0) or {a mathematical formula}g(v(z))≠Cd(v(z),1). Since the specification problem is solvable, we must also have {a mathematical formula}g(v(z))=Cd(v(z),0) or {a mathematical formula}g(v(z))=Cd(v(z),1). Altogether, the union of the first two cases applies if and only if {a mathematical formula}Cd(v(z),0)≠Cd(v(z),1), and thus if and only if {a mathematical formula}D(S)(x1,…,xn)=1 by Part 1 of the theorem, which shows the soundness of the “else” case. Let {a mathematical formula}t(x) be a truth assignment with {a mathematical formula}D(S)(t(x))=1. We now show that {a mathematical formula}H|D(S)(t(x))=1 if and only if {a mathematical formula}(Hmin)|D(S)(t(x))=1. By Lemma 2, this proves that {a mathematical formula}H|D(S) matches the unique prime solution, and at the same time, the soundness of {a mathematical formula}(Hmin)|D(S) also justifies the disjointedness of the first two cases of the definition. For any {a mathematical formula}t(x) with {a mathematical formula}D(S)(t(x))=1, it follows from Part 1 of this theorem that there exists an assignment {a mathematical formula}v(z) with {a mathematical formula}t(xi)=Ci(v(z)), {a mathematical formula}i=1,…,n, and {a mathematical formula}Cd(v(z),0)≠Cd(v(z),1). We combine this with the observation that {a mathematical formula}g(v(z))=C(h/(Hmin)|D(S))(v(z)), since {a mathematical formula}Hmin is a solution. Together, it follows that {a mathematical formula}(Hmin)|D(S)(t(x))=1 if and only if {a mathematical formula}g(v(z))≠Cd(v(z),0) for some {a mathematical formula}v(z) with {a mathematical formula}t(xi)=Ci(v(z)), and that is exactly the first case of the above definition of {a mathematical formula}H|D(S).  □</paragraph><paragraph>The characterization of the prime solution in the preceding theorem is complicated by the need to distinguish a third case “undefined”. From Lemma 2, we know that every extension of {a mathematical formula}H|D(S) to a total Boolean function is a solution. A very simple strategy to extend {a mathematical formula}H|D(S) is to return 0 whenever {a mathematical formula}H|D(S) is undefined. Then the above definition simplifies to two cases, since the “undefined” case becomes merged with the second case. Moreover, such an extension of {a mathematical formula}H|D(S) with 0 for all undefined arguments produces exactly the minimal solution {a mathematical formula}(Hmin)|D(S). Analogously, {a mathematical formula}Hmax is the extension of {a mathematical formula}H|D(S) by returning 1 for all undefined arguments. This observation, which is formalized in the next lemma, gives us the possibility to directly compute {a mathematical formula}Hmin and {a mathematical formula}Hmax, instead of constructing them by the conjunction or disjunction of all solutions as in Definition 4.</paragraph><paragraph label="Lemma 3">Every solvable specification problem{a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉(with K being closed under conjunction and disjunction) with unknown function{a mathematical formula}h(x1,…,xn)and circuit inputs{a mathematical formula}z=z1,…,zrhas a minimal solution{a mathematical formula}Hminand a maximal solution{a mathematical formula}Hmaxwith the following properties:</paragraph><list><list-item label="1.">{a mathematical formula}Hmin(x1,…,xn)=0if and only if there exists no truth assignment{a mathematical formula}v(z)such that{a mathematical formula}xi=Ci(v(z))for all{a mathematical formula}i=1,…,nand{a mathematical formula}g(v(z))≠Cd(v(z),0).</list-item><list-item label="2.">{a mathematical formula}Hmax(x1,…,xn)=1if and only if there exists no truth assignment{a mathematical formula}v(z)such that{a mathematical formula}xi=Ci(v(z))for all{a mathematical formula}i=1,…,nand{a mathematical formula}g(v(z))≠Cd(v(z),1).</list-item></list><paragraph label="Proof">Existence of {a mathematical formula}Hmin and {a mathematical formula}Hmax is guaranteed by Definition 4. It is clear from Definition 5 that {a mathematical formula}Hmin(x1,…,xn)=0 if and only if {a mathematical formula}(Hmin)|D(S)(x1,…,xn)=0 or {a mathematical formula}(Hmin)|D(S)(x1,…,xn)=undefined if and only if {a mathematical formula}(Hmin)|D(S)(x1,…,xn)≠1. By Lemma 2 and Theorem 2, {a mathematical formula}(Hmin)|D(S)(x1,…,xn)≠1 if and only if there exists no {a mathematical formula}v(z) with {a mathematical formula}xi=Ci(v(z)) for all {a mathematical formula}i=1,…,n and {a mathematical formula}g(v(z))≠Cd(v(z),0). The argument for {a mathematical formula}Hmax is analogous.  □</paragraph></section><section label="4"><section-title>Representation of solutions</section-title><paragraph>So far, we have treated the circuit nodes, the target g and the possible solutions as Boolean functions with no particular representation in mind. In the examples, we have used propositional formulas to define these functions. The choice of actual representations of the circuit {a mathematical formula}C(h)(z), the target g and the solution candidates from the class K have a direct impact on the computational complexity of a specification problem {a mathematical formula}S=〈g(z)=?C(h∈K)(z)〉 and the length of solutions. Straightforward representations of Boolean functions are well-known classes of propositional formulas, such as conjunctive normal form CNF (a conjunction of disjunctions of literals) and disjunctive normal form DNF (a disjunction of conjunctions of literals), where a literal is a positive or a negated occurrence of a propositional variable. If, e.g., the target function g is given by a propositional formula in DNF and we have a circuit consisting of only the unknown component h (possibly padded by buffer gates {a mathematical formula}f(x)=x) there clearly exists a solution in {a mathematical formula}K=BOOL that can be represented as a CNF formula, because every DNF has a logically equivalent CNF. But it is well known that this CNF may have super-polynomial size. Notice that satisfiability equivalence as provided by the Tseitin method [9] or other CNF transformations is not sufficient, because we require that the circuit with h computes exactly the same Boolean function as the target g.</paragraph><paragraph>If we want the solution to be represented as a propositional formula, the question is closely related to the problem of whether Boolean circuits with arbitrary fan-out have poly-size representations as propositional formulas. It is widely believed that this is not the case. Let {a mathematical formula}C˜(z) be a Boolean circuit with input variables z and outgoing edge {a mathematical formula}y0 where the nodes compute one of the operators {a mathematical formula}Ω={∧,∨,¬}. We construct the following specification problem: Let {a mathematical formula}C(h)(z):={x1:=z1,…,xn:=zn,y:=h(x1,…,xn),y0:=C˜(z),out:=y0↔y} with target {a mathematical formula}g(z):=1. Then {a mathematical formula}H∈BOOL represented as a propositional formula ϕ is a solution of {a mathematical formula}S=〈g(z)=?C(h∈BOOL)(z)〉 if and only if {a mathematical formula}ϕ(z) is logically equivalent to the circuit {a mathematical formula}C˜(z) (i.e., {a mathematical formula}ϕ(z1,…,zn) has the same truth table as {a mathematical formula}Fy0(z1,…,zn)). If Boolean circuits over {a mathematical formula}Ω={∧,∨,¬} with arbitrary fan-out have in worst case only super-polynomial equivalent representations as propositional formulas, any propositional representation of the solution H must have super-polynomial length.</paragraph><paragraph>A compact representation of Boolean circuits with arbitrary fan-out and nodes from the set {a mathematical formula}Ω={∧,∨,¬} (or any propositional formula over the inputs of the node) can be obtained by using quantified Boolean formulas (QBF). They extend propositional logic with quantifiers over variables. Universal quantification {a mathematical formula}∀xΦ(x) for a variable x and a propositional or quantified Boolean formula Φ is defined to be true if and only if {a mathematical formula}Φ(0) is true and{a mathematical formula}Φ(1) is true, and {a mathematical formula}∃yΦ(y) means that {a mathematical formula}Φ(0)or{a mathematical formula}Φ(1) is true. By a well-known transformation [1], [3], a circuit with arbitrary fan-out can then be encoded as existentially quantified Boolean formula: we label the edges of the circuit with new auxiliary variables and describe the gates by propositional clauses over these variables, e.g., {a mathematical formula}y↔x1∧x2 for an AND node with incoming edges {a mathematical formula}x1 and {a mathematical formula}x2 and output edge y. Finally, we add a prefix with existential quantifiers over all auxiliary variables. This makes sure that the valuation of the resulting formula depends only on the original input variables of the circuit, which remain unquantified (free), and we can achieve full logical equivalence between circuit and quantified formula, i.e., both have the same valuation for each assignment to the input variables. In the following, we write {a mathematical formula}Φ(C)(z) to denote the existentially quantified encoding of a circuit C with inputs {a mathematical formula}z=z1,…,zr. If the target function g is also given as a quantified Boolean formula, say {a mathematical formula}Φ(g)(z), the minimal and maximal solutions of a solvable specification problem {a mathematical formula}S=〈g(z)=?C(h∈BOOL)(z)〉 can be encoded in a very compact way due to Lemma 3:{a mathematical formula}{a mathematical formula} These quantified formulas are direct translations of Lemma 3 (↮ is the negation of ↔, that means XOR). Since the above transformation of circuits to existentially quantified formulas is linear in the number of edges, the size of {a mathematical formula}Φ(Hmin) and {a mathematical formula}Φ(Hmax) is at most quadratic in the size of the specification problem.</paragraph><paragraph>Contrary to guaranteeing the compactness of solution representations by applying powerful languages such as QBF, we may restrict the structure of the solutions to less complex representations which have lower computational complexity and admit only compact solutions by design (and declare the problem as unsolvable otherwise). Such restrictions are also interesting because of the fact that there exist elegant query algorithms in machine learning using this type of inductive bias, i.e., restriction of the hypothesis space, to solve the exact identification problem of learning a Boolean function in a black box that was mentioned in the introduction. Can we generalize these algorithms to the specification problems in this paper where the inputs and the output of the black box are no longer directly accessible?</paragraph></section><section label="5"><section-title>Learning terms and clauses</section-title><paragraph>We now consider the case that the unknown function can be represented as a propositional term or a clause. A term is a conjunction of literals, and a clause is a disjunction of literals. A literal is a positive or a negated occurrence of a variable, and we write a literal over a variable x as {a mathematical formula}xϵ, with {a mathematical formula}ϵ∈{0,1}, {a mathematical formula}x0:=¬x and {a mathematical formula}x1:=x. For simplicity, we consider a term or a clause also as a set of literals, as long as it is clear from the context by which connective the literals are combined. We write {a mathematical formula}K=TERM ({a mathematical formula}K=CLAUSE, respectively) to denote the class of Boolean functions which can be defined by a term (or a clause, respectively). So the problem in this section is to find {a mathematical formula}H∈TERM (resp. {a mathematical formula}H∈CLAUSE) with {a mathematical formula}C(h/H)(z)=g(z) for a given partial configuration {a mathematical formula}C(h)(z) and target function {a mathematical formula}g(z). Technically, this does not require a particular representation of the Boolean function H, as long as it can be defined by some propositional term or clause, but the algorithm that we discuss in this section will of course always work with a term or clause representation. Accordingly, we will in the following not distinguish between the actual function {a mathematical formula}H∈TERM (resp. {a mathematical formula}H∈CLAUSE) and its representation as a propositional term (resp. clause).</paragraph><paragraph>Notice that we only restrict the structure of the unknown function. The other nodes in the circuit C and the target g can be arbitrary Boolean functions. Accordingly, the specification problem can remain very difficult.</paragraph><paragraph label="Lemma 4">It is{a mathematical formula}Σ2P-complete to decide whether a specification problem{a mathematical formula}S=〈g(z)=?C(h∈TERM)(z)〉has a solution{a mathematical formula}H≠0when C is given as a circuit with arbitrary fan-out and nodes from the set{a mathematical formula}Ω={∧,∨,¬}(besides the unknown node h) and g is also given as a circuit{a mathematical formula}Cgof the same kind.</paragraph><paragraph label="Proof">{a mathematical formula}Σ2P membership is easy to see: guess a potential solution {a mathematical formula}H∈TERM represented as a conjunction of literals in nondeterministic linear time and check whether {a mathematical formula}C(h/H)(z)=Cg(z) with the help of a coNP oracle.For {a mathematical formula}Σ2P-hardness, we consider the well-known {a mathematical formula}Σ2P-complete problem of deciding whether a quantified Boolean formula {a mathematical formula}∃x1…∃xn∀y1…∀ymϕ(x1,…,ym) is true, where ϕ is an arbitrary propositional formula over variables {a mathematical formula}x=x1,…,xn and {a mathematical formula}y=y1,…,ym. Then {a mathematical formula}∃x∀yϕ(x,y)=1 if and only if there exists a truth assignment {a mathematical formula}v(x) with {a mathematical formula}∀yϕ(v(x),y)=1 if and only if there exists {a mathematical formula}H(x)∈TERM with {a mathematical formula}H(v(x))=1 and {a mathematical formula}∀x∀y[(H(x)∧ϕ(x,y))∨¬H(x)]=1 if and only if {a mathematical formula}C(h/H)(x,y)=1, where C is the obvious translation of {a mathematical formula}(h(x)∧ϕ(x,y))∨¬h(x) into a circuit with unknown component h, that means H solves the specification problem with partial configuration C and target {a mathematical formula}g=Cg=1.  □</paragraph><paragraph>We next observe that the specification problem for terms can also be applied to clause learning by a slight modification of the partial configuration, and vice versa. Let {a mathematical formula}S=〈C(h∈CLAUSE)(z)=?g(z)〉 be a specification problem that requires the solution to be a clause. Then we modify the circuit C by replacing the node {a mathematical formula}y:=h(x1,…,xn) with two nodes {a mathematical formula}y:=¬y′ and {a mathematical formula}y′:=h(x1,…,xn) and call the result {a mathematical formula}C′(h)(z). Then the new problem {a mathematical formula}〈C′(h∈TERM)(z)=?g(z)〉 has a solution {a mathematical formula}H(x1,…,xn)=xi1ϵi1∧…∧xikϵik∈TERM if and only if the clause {a mathematical formula}¬xi1ϵi1∨…∨¬xikϵik=¬H(x1,…,xn) is a solution of the original problem.</paragraph><paragraph>As shown in the following algorithm SPEC-TERM (Algorithm 1), we use suitable queries to determine those values {a mathematical formula}v(z) of the circuit inputs z for which equality with the target function cannot be achieved when the output of the hidden node h is 0. So the only option to solve the specification problem (if possible at all) is to let h be 1 for such {a mathematical formula}v(z). The corresponding values of {a mathematical formula}x1,…,xn are collected in the solution term H. The total number of equivalence queries is linear in the size of the input.</paragraph><paragraph label="Theorem 3">If a specification problem{a mathematical formula}〈g(z)=?C(h∈TERM)(z)〉is solvable then the algorithm SPEC-TERM returns a term H (completeness), which is the minimal solution{a mathematical formula}Hmin, and this answer is a valid solution (correctness). Otherwise it returns no solution.</paragraph><paragraph label="Proof">The correctness is obvious for the first branch of the surrounding if statement because of the equality check in front of the return statement. This equality check cannot be omitted, because there might exist a truth assignment {a mathematical formula}v(z) with {a mathematical formula}g(v(z))≠Cd(v(z),0) (the precondition of the first branch of the surrounding if) but also {a mathematical formula}g(v(z))≠Cd(v(z),1), in which case the specification problem is not solvable at all (even if arbitrary functions {a mathematical formula}K=BOOL were allowed as solutions). Even if there is no {a mathematical formula}v(z) for which both inequalities apply at the same time, it might still be the case that distinct assignments {a mathematical formula}v(z) for which both inequalities hold alternately are mapped by the upstream subcircuits {a mathematical formula}C1,…,Cn to the same values of {a mathematical formula}x1,…,xn, so the required behavior of h cannot be expressed as a function of {a mathematical formula}x1,…,xn. Finally, the problem might be solvable in general, but no term could represent the required behavior of h. The else branch of the surrounding if statement is only entered when {a mathematical formula}g(v(z))=Cd(v(z),0) for all assignments {a mathematical formula}v(z), so we know that {a mathematical formula}H=0 is a correct solution.For the completeness, it is clear that {a mathematical formula}H=0 is always found if it is a solution, and then also {a mathematical formula}Hmin=0. So assume that there exist solutions {a mathematical formula}H1,…,Hk with {a mathematical formula}Hi≠0 for {a mathematical formula}i=1,…,k, in which case we enter the first branch of the surrounding if. By the assumption of solvability, the assignment {a mathematical formula}v(z) that was found in the condition of the if statement must satisfy {a mathematical formula}g(v(z))=Cd(v(z),1). Then {a mathematical formula}Hi(C1(v(z)),…,Cn(v(z)))=1 for any solution {a mathematical formula}Hi, and thus {a mathematical formula}x1π1∧…∧xnπn⊨Hi. Since {a mathematical formula}Hi is a term, the latter means that {a mathematical formula}Hi must be the conjunction of all or a subset of the literals {a mathematical formula}x1π1,…,xnπn (or {a mathematical formula}Hi=1, which can be seen as the empty conjunction). Let {a mathematical formula}H⁎∈{H1,…,Hk} be the solution with the longest conjunction {a mathematical formula}xi1πi1∧…∧ximπim for pairwise different {a mathematical formula}i1,…,im∈{1,…,n}. This longest conjunction is unique and thus well-defined, since the solution space is closed under conjunction by Theorem 1. According to Definition 4, {a mathematical formula}H⁎ is {a mathematical formula}Hmin (the longest conjunction is the one with the smallest number of satisfying assignments). If there is some literal {a mathematical formula}xjπj which does not occur in {a mathematical formula}H⁎, the term {a mathematical formula}xi1πi1∧…∧ximπim∧xjπj cannot also be a solution, since that would contradict {a mathematical formula}H⁎ being the longest. By Lemma 1, {a mathematical formula}xi1πi1∧…∧ximπim∧xjπj not being a solution implies that there exists an assignment {a mathematical formula}v′(z) with {a mathematical formula}πi1=Ci1(v′(z)), …, {a mathematical formula}πim=Cim(v′(z)), {a mathematical formula}πj≠Cj(v′(z)) (that means {a mathematical formula}H⁎ is 1 and the term with additional literal {a mathematical formula}xjπj is 0), and {a mathematical formula}Cd(v′(z),1)≠Cd(v′(z),0). Since {a mathematical formula}H⁎ is a solution, we know {a mathematical formula}g(v′(z))=Cd(v′(z),1), so the latter inequality is equivalent to {a mathematical formula}g(v′(z))≠Cd(v′(z),0). Thus, we have a truth assignment {a mathematical formula}v′(z) with {a mathematical formula}πj≠Cj(v′(z)) and {a mathematical formula}g(v′(z))≠Cd(v′(z),0), and that is the condition in the algorithm under which a literal {a mathematical formula}xjπj is removed from H. On the other hand, none of the literals {a mathematical formula}xi1πi1,…,ximπim in {a mathematical formula}H⁎ will be removed: since {a mathematical formula}H⁎ is a solution, there cannot exist a truth assignment {a mathematical formula}v′(z) under which {a mathematical formula}H⁎ is 0, but {a mathematical formula}g(v′(z))≠Cd(v′(z),0). We can conclude that the algorithm removes exactly those literals from H which are not contained in {a mathematical formula}H⁎, so it will ultimately end up with {a mathematical formula}H=H⁎.  □</paragraph></section><section label="6"><section-title>Learning monotone DNF</section-title><paragraph>We finally consider the case that the unknown function belongs to the class {a mathematical formula}K=MDNF of Boolean functions which can be represented as monotone DNF formulas, i.e., disjunctions of terms with only positive literals. As before, the other nodes in the circuit C and the target g can be arbitrary Boolean functions.</paragraph><paragraph>Let {a mathematical formula}H1,H2∈MDNF be two Boolean functions which can be represented as monotone DNF formulas. Even though the conjunction of two such DNF formulas is in general no longer a DNF formula, it can always be transformed into a monotone DNF formula by distributivity, and the existence of that monotone DNF representation of {a mathematical formula}H1∧H2 is sufficient for {a mathematical formula}(H1∧H2)∈MDNF. Accordingly, the class {a mathematical formula}K=MDNF is closed under conjunction and disjunction, so we can safely use all results from Section 3.</paragraph><paragraph>{a mathematical formula}</paragraph><paragraph label="Theorem 4">If a specification problem{a mathematical formula}〈g(z)=?C(h∈MDNF)(z)〉is solvable then the algorithm SPEC-MDNF returns a monotone DNF H (completeness), which is the minimal solution{a mathematical formula}Hminrepresented as the disjunction of its prime implicants, and all such answers are valid solutions (correctness).</paragraph><paragraph label="Proof">The correctness is obvious from the fact that the while loop can only be exited successfully if {a mathematical formula}g(z)=C(h/H)(z).For the completeness, it is clear that {a mathematical formula}H=0 is always found if it is a solution, and then also {a mathematical formula}Hmin=0. So assume that the problem is solvable with {a mathematical formula}Hmin≠0, in which case we enter the body of the while loop. Notice that since the algorithm starts with {a mathematical formula}H=0, the assignment {a mathematical formula}v(z) that is found upon entering the loop also satisfies the condition {a mathematical formula}g(v(z))≠Cd(v(z),0). Then it follows from Lemma 3 that {a mathematical formula}Hmin(π1,…,πn)=1. If {a mathematical formula}π1=…=πn=0 then the only possible solution is {a mathematical formula}H=Hmin=1, which is clearly found by the algorithm (nothing happens in the second for loop). Otherwise, the monotone DNF formula representation of {a mathematical formula}Hmin must contain the term {a mathematical formula}T:=⋀{i|πi=1,1≤i≤n}xi or a subterm thereof. It contains a proper subterm if and only if there exists {a mathematical formula}j∈{1,…,n} with {a mathematical formula}πj=1 so that {a mathematical formula}Hmin(π1′,…,πn′)=1 for some assignment {a mathematical formula}π1′,…,πn′ with {a mathematical formula}πi′=0 for all {a mathematical formula}i=1,…,n with {a mathematical formula}πi=0 or {a mathematical formula}i=j. That means {a mathematical formula}Hmin is also 1 for some argument vector {a mathematical formula}(π1′,…,πn′) which is strictly smaller than {a mathematical formula}(π1,…,πn) in the usual bit-wise comparison. By Lemma 3, this is true if and only if for some {a mathematical formula}j∈{1,…,n} with {a mathematical formula}πj=1 there exists a truth assignment {a mathematical formula}v′(z) with {a mathematical formula}g(v′(z))≠Cd(v′(z),0) and {a mathematical formula}Ci(v′(z))=0 for all {a mathematical formula}i=1,…,n with {a mathematical formula}πi=0 or {a mathematical formula}i=j. This is exactly the condition which is tested in the second for loop, and any such {a mathematical formula}xj is removed from the term T under consideration. This might lead to an empty term, in which case {a mathematical formula}H=Hmin=1. If the monotone DNF representation of {a mathematical formula}Hmin contains a subterm of the original term T found at the beginning which is smaller by more than one variable, it is not difficult to see that these can be discovered with our condition in arbitrary order, because the condition does not fix the value of variables in T which have not yet been looked at. A different order could only lead to a different subterm being found if the representation of {a mathematical formula}Hmin contains two or more proper subterms of T. In any case, we ultimately find an irreducible subterm, that means a prime implicant of {a mathematical formula}Hmin. Now, the while loop is executed again, and we obtain another truth assignment for which {a mathematical formula}Hmin must be 1 and H is still 0. Since H is gradually built up from prime implicants of {a mathematical formula}Hmin, the case that H is already 1 for the new counterexample is only possible if the problem is not solvable. Otherwise, the counterexample must lead to a new prime implicant, and since the number of prime implicants of {a mathematical formula}Hmin is bounded by the number of terms in the non-redundant monotone DNF representation of {a mathematical formula}Hmin (cf [2]), the algorithm ultimately obtains the disjunction of all prime implicants of {a mathematical formula}Hmin and terminates.  □</paragraph><paragraph label="Corollary 1">The number of executions of the while loop in a successful run of the algorithm SPEC-MDNF is bounded by the number of terms in a non-redundant monotone DNF representation of the minimal solution{a mathematical formula}Hmin.</paragraph><paragraph>Let m denote the number of terms in the unknown monotone DNF and s the size of the input. Since algorithm SPEC-MDNF follows Angluin's ideas, we have that the total number of equivalence queries is bounded by {a mathematical formula}(m+1)(s+1).</paragraph></section><section label="7"><section-title>Conclusion and future work</section-title><paragraph>In this paper, an extended variant of query learning is considered where a hidden concept is located in a black box in some partial circuit. We characterized the solution space and the complexity of the solvability question for the specification problem. Restricting the domain of possible solutions allows us to construct concrete solutions using ideas from query learning. It may be interesting future work to weaken the restriction to domains that are closed under conjunction and/or disjunction or to expand the domains in other ways. When returning solutions explicitly, the size of its representation is important. Therefore, it may also be interesting future work to combine the techniques of [7], [5] for deciding solvability with our approaches to compact solution representations using nested Boolean functions as models for quantified Boolean formulas [4].</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>This work was partially supported by the German Research Foundation (DFG) within the Collaborative Research Center “On-The-Fly Computing” (CRC 901) under Grant No. SFB 901/2.</paragraph></acknowledgements><references><reference label="[1]"><authors>S. Anderaa,E. Börger</authors><title>The equivalence of Horn and network complexity for Boolean functions</title><host>Acta Inform.15 (1981) pp.303-307</host></reference><reference label="[2]"><authors>D. Angluin</authors><title>Queries and concept learning</title><host>Mach. Learn.2 (4)(1988) pp.319-342</host></reference><reference label="[3]"><authors>M. Bauer,D. Brand,M. Fischer,A. Meyer,M. Paterson</authors><title>A note on disjunctive form tautologies</title><host>SIGACT News5 (2)(1973) pp.17-20</host></reference><reference label="[4]"><authors>U. Bubeck,H. Kleine Büning</authors><title>Nested Boolean functions as models for quantified Boolean formulas</title><host>Proc. 16th Int. Conference on Theory and Applications of Satisfiability TestingSAT 2013(2013) pp.267-275</host></reference><reference label="[5]"><authors>K. Gitina,S. Reimer,M. Sauer,R. Wimmer,C. Scholl,B. Becker</authors><title>Equivalence checking for partial implementations revisited</title><host>Proc. 16th Workshop Methoden und Beschreibungssprachen zur Modellierung und Verifikation von Schaltungen und SystemenMBMV 2013(2013) pp.61-70</host></reference><reference label="[6]"><authors>H. Savoj,R. Brayton</authors><title>The use of observability and external don't cares for the simplification of multi-level networks</title><host>Proc. 27th Design Automation ConferenceDAC 1990(1990)ACM Press pp.297-301</host></reference><reference label="[7]"><authors>C. Scholl,B. Becker</authors><title>Checking equivalence for partial implementations</title><host>Proc. 38th Design Automation ConferenceDAC 2001(2001)ACM Press pp.238-243</host></reference><reference label="[8]"><authors>S. Sinha,A. Mishchenko,R. Brayton</authors><title>Topologically constrained logic synthesis</title><host>Proc. Intl. Conference on Computer Aided DesignICCAD 2002(2002)ACM Press pp.679-686</host></reference><reference label="[9]"><authors>G. Tseitin</authors><title>On the complexity of derivation in propositional calculus</title><host>A. SlisenkoStudies in Constructive Mathematics and Mathematical Logic, Part II(1970)Springer pp.115-125</host></reference><reference label="[10]"><authors>L. Valiant</authors><title>A theory of the learnable</title><host>Commun. ACM27 (11)(1984) pp.1134-1142</host></reference><reference label="[11]"><authors>Y. Watanabe,L. Guerra,R. Brayton</authors><title>Permissible functions for multioutput components in combinational logic optimization</title><host>IEEE Trans. Comput.-Aided Des. Integr. Circuits Syst.15 (7)(1996) pp.732-744</host></reference></references><footnote/></root>