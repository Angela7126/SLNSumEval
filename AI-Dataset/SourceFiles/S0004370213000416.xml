<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370213000416</url><title>Lifting integrity constraints in binary aggregation</title><authors>Umberto Grandi,Ulle Endriss</authors><abstract>We consider problems in which several individuals each need to make a yes/no choice regarding a number of issues and these choices then need to be aggregated into a collective choice. Depending on the application at hand, different combinations of yes/no may be considered rational. We describe rationality assumptions as integrity constraints using a simple propositional language and we explore the question of whether or not a given aggregation procedure will lift a given integrity constraint from the individual to the collective level, i.e., whether the collective choice will be rational whenever all individual choices are.</abstract><keywords>Collective decision making;Computational social choice;Multi-issue domains;Combinatorial vote;Judgment aggregation</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Social Choice Theory (SCT) is the study of mathematical models for collective decision making. In recent times, this discipline has received increasing attention in Artificial Intelligence (AI), as testified by a large number of papers on social choice at the major AI conferences and by the creation of an entirely new research agenda under the name of Computational Social Choice[6]. There are several good reasons for this trend. On the one hand, a number of methods developed in AI and, more generally, in Computer Science have turned out to be useful to deepen our understanding of social choice and, in some cases, can even suggest an entirely new perspective on classical problems. Examples include the complexity-theoretic analysis of optimisation problems arising in social choice [15], [16] and the creation of new choice procedures inspired by classical techniques in knowledge representation [27]. On the other hand, methods from SCT have natural important applications in AI. They can, e.g., be employed to achieve consensus amongst the autonomous software agents in a multiagent system [39], to aggregate the output of several search engines [2], or to inform the design of online recommender systems [34]. One particular problem of interest for AI is the case of social choice in combinatorial domains, in which the space of alternatives from which the individuals have to choose has a multi-attribute structure [26], [7]. Classical examples include voting in multiple referenda, where we have to decide which of a set of propositions to accept, or electing a committee, where we have to decide how to fill each seat. There have been several attempts to tackle the high complexity that arises in this context by using tools from AI, such as methods for modelling preferences inspired by knowledge representation [28], [38]. Finally, SCT provides tools for the analysis of collective choices of groups of agents, and as such is of immediate relevance to the study of multiagent systems.</paragraph><paragraph>A central problem in SCT, and, in view of our previous discussion, in all its applications to AI, is the problem of aggregation: Suppose a group of agents each supply a particular piece of information regarding a common problem and we want to aggregate this information into a collective view to obtain a summary of the individual views provided. A classical example is that of preferences [3]: each agent declares their individual preferences over a set of alternatives by providing an ordering over this set, and we are asked to amalgamate this information into a collective ranking that represents the individual preferences provided. The same methodology has also been applied more recently to a number of other types of information, such as beliefs [23], [24] and judgments [29].</paragraph><paragraph>One of the main features of the study of aggregation is the problem of collective rationality: given a rationality assumption that bounds the choices of the individuals, we ask whether the output of an aggregator still satisfies the same rationality assumption. To understand this problem better, consider the following example: three autonomous agents need to decide on whether to perform a collective action. This action is performed if two parameters are estimated to exceed a certain threshold. We can model the choice situation with a multi-attribute domain in which there are three issues at stake: “the first parameter is above the threshold” ({a mathematical formula}T1), “the second parameter is above the threshold” ({a mathematical formula}T2), and “the action should be performed” (A). The rationality assumption that links the three issues together can be modelled using a simple propositional formula, namely {a mathematical formula}T1∧T2→A. The individual views on the three issues are then aggregated using the majority rule, which accepts an issue if a majority of the individual agents do. Consider now the following situation:{a mathematical formula} In the situation described above the collective action A is not performed, even though a majority of the individuals think that the first parameter exceeds the threshold and a (different) majority agree that also the second parameter exceeds the threshold. Situations like the one above are considered paradoxical: even if each individual agent is rational (i.e., each of them satisfies the rationality assumption), the collective view derived using the majority rule is not. That is, the majority rule fails to lift the integrity constraint {a mathematical formula}T1∧T2→A from the individual to the collective level. This example shows that the majority rule violates collective rationality in certain specific cases. Similar examples can be devised for a number of different situations ranging from voting to rank aggregation, to the development of a collective judgment in court cases.</paragraph><paragraph>Classical work in SCT was restricted to particular studies of collective rationality in a given aggregation situation and for a given class of aggregation procedures. Dokow and Holzman [11], for instance, characterise binary domains of aggregation over which every procedure that satisfies certain desirable axiomatic properties, namely, independence and unanimity, is dictatorial (see Section 8). This is a good example for the use of the axiomatic method in economic theory: the aim is to identify the appropriate set of axiomatic properties (e.g., to model real-world economies, specific moral ideals, etc.) and then to prove a characterisation (or impossibility) result for those axioms. Given the wide variety of potential applications in AI, on the other hand, in this context we require instead a systematic study that, depending on the situation at hand, can give answers to the problem of collective rationality. With every new application the principles underlying a system may change; so we may be more interested in devising languages for expressing a range of different axiomatic properties rather than identifying the “right” set of axioms; and we may be more interested in developing methods that will help us to understand the dynamics of a range of different social choice scenarios rather than in technical results for a specific such scenario.</paragraph><paragraph>In this paper we put forward a general framework that encompasses most of the classical studies of collective rationality in SCT, and that can prove useful to diverse research areas in AI. We base our framework on binary aggregation, in which individuals are required to choose from a multi-issue domain where issues represent different binary choices. Classical frameworks for the study of aggregation, such as preference and judgment aggregation, can be embedded in this framework. We model rationality assumptions using a simple propositional language, and we give a precise definition of collective rationality with respect to a given rationality assumption. We classify rationality assumptions with respect to their syntactic properties, and we give a systematic treatment of the question of how to relate collective rationality with respect to a syntactically defined sublanguage to classical axiomatic properties from SCT. For instance, we have already seen that the majority rule is not collectively rational with respect to the integrity constraint {a mathematical formula}T1∧T2→A. It is also not collectively rational with respect to the 3-clause {a mathematical formula}T1∨T2∨A: to see this, consider a scenario with three agents, where each agent accepts exactly one issue, and no two agents accept the same issue. On the other hand, as we shall see, any 2-clause will always be lifted, i.e., the majority rule is collectively rational with respect to the language of 2-clauses. We will then be able to describe the majority rule in terms of classical axioms (see Proposition 2) or in terms of the subset of integrity constraints it lifts (see Theorem 28). It is results of this kind that we shall explore in depth in this paper, establishing a link between standard axiomatic requirements from SCT and collective rationality with respect to fragments of the propositional language.</paragraph><paragraph>This paper expands our initial work on this topic [20], complementing it with further results from previous work [21], [19], [18].</paragraph><paragraph>The paper is organised as follows. We begin by defining the basic notions that constitute the framework of binary aggregation with integrity constraints in Section 2. In this section, we give the crucial definition of collective rationality with respect to an integrity constraint expressed in a suitable propositional language, and we list several axiomatic properties adapted from the literature on SCT. We also provide several examples of aggregation problems that can be modelled in binary aggregation with integrity constraints, such as multi-issue elections, preference aggregation, judgment aggregation, and the problem of choosing from a set of candidates. In Section 3 we define the notion of language for integrity constraints, and we prove this to be the correct definition for the study of collective rationality (see Lemma 6). We then define classes of aggregation procedures both in terms of collective rationality and by using classical axiomatic requirements. We study the properties of these two means of defining classes of procedures, developing a theoretical machinery that enables us to provide a systematic treatment of the relation between propositional languages for integrity constraints and axiomatic properties. This is done in the two following sections. In Section 4 we characterise in axiomatic terms, for several fragments of the propositional language, the class of collectively rational procedures with respect to formulas in this fragment. In Section 5 we start from classical axiomatic properties, and we explore to what extent classes of aggregation procedures defined in these terms can be characterised as classes of collectively rational procedures for a given language. We provide negative results for three important axioms taken from the literature on SCT. These three axioms can be combined to obtain an interesting class of procedures known as quota rules, defined by the choice of an acceptance quota for every issue. In Section 6 we concentrate on this particular class. We give precise bounds on the acceptance quotas to guarantee collective rationality with respect to integrity constraints that belong to given languages of clauses, i.e., disjunctions of literals. This includes a characterisation of the set of integrity constraints that are lifted by the majority rule (see Theorem 28). We discuss the significance of our results and their relation to classical frameworks of aggregation in Section 7. Related work is discussed in Section 8 and Section 9 concludes.</paragraph></section><section label="2"><section-title>Basic definitions</section-title><paragraph>In this section we give the basic definitions that constitute the framework of binary aggregation with integrity constraints. First, we review the classical setting of binary aggregation, based on work by Wilson [40] and Dokow and Holzman [11], to which we add the notion of integrity constraint as a mean of specifying the set of individual ballots to be considered rational. We then present a list of examples from both practical applications and classical frameworks of aggregation that can be modelled in our framework. Finally, we state the crucial definition of collective rationality and we review the classical axiomatic method for binary aggregation procedures. We conclude by axiomatising the class of quota rules and the majority rule over binary combinatorial domains.</paragraph><section label="2.1"><section-title>Binary aggregation with integrity constraints</section-title><paragraph>Let {a mathematical formula}I={1,…,m} be a finite set of issues, and let {a mathematical formula}D=D1×⋯×Dm be a boolean combinatorial domain, i.e., {a mathematical formula}|Di|=2 for all {a mathematical formula}i∈I (we assume {a mathematical formula}Di={0,1}). Let {a mathematical formula}N={1,…,n} be a finite set of individuals and we assume {a mathematical formula}|N|&gt;1. A ballot B is an element of {a mathematical formula}D. A profile{a mathematical formula}B=(B1,…,Bn) is a vector of ballots, one for each individual in {a mathematical formula}N. We write {a mathematical formula}bj for the jth element of a ballot B, and {a mathematical formula}bi,j for the jth element of ballot {a mathematical formula}Bi within a profile {a mathematical formula}B=(B1,…,Bn).</paragraph><paragraph label="Definition 1">Given a finite set of issues {a mathematical formula}I and a finite set of individuals {a mathematical formula}N, an aggregation procedure is a function {a mathematical formula}F:DN→D, mapping each profile of binary ballots to an element of {a mathematical formula}D.{sup:1}</paragraph><paragraph>Let {a mathematical formula}F(B)j denote the result of the aggregation on issue j. Note that we do not put any restriction on the domain on which aggregation procedures are defined, i.e., Definition 1 includes a requirement known as universal domain.</paragraph><paragraph>If {a mathematical formula}I is a set of m issues, let {a mathematical formula}PS={p1,…,pm} be a set of propositional symbols, one for each issue, and let {a mathematical formula}LPS be the propositional language constructed by closing PS under propositional connectives. For any formula {a mathematical formula}φ∈LPS, let {a mathematical formula}Mod(φ) be the set of assignments that satisfy φ. For example, {a mathematical formula}Mod(p1∧¬p2)={(1,0,0),(1,0,1)} if {a mathematical formula}PS={p1,p2,p3}.</paragraph><paragraph label="Definition 2">An integrity constraint is any formula {a mathematical formula}ic∈LPS.</paragraph><paragraph>Integrity constraints can be used to define what tuples in {a mathematical formula}D we consider rational choices. Any ballot {a mathematical formula}B∈D is an assignment to the variables {a mathematical formula}p1,…,pm, and we call B a rational ballot if it satisfies the integrity constraint ic, i.e., if B is an element of {a mathematical formula}Mod(ic). A rational profile will be therefore an element of {a mathematical formula}Mod(ic)N. In the sequel we shall use the terms “integrity constraints” and “rationality assumptions” interchangeably.</paragraph></section><section label="2.2"><section-title>Examples</section-title><paragraph>In line with the example presented in the introduction, let us consider several other aggregation problems that can be modelled in binary aggregation by devising a suitable integrity constraint:</paragraph><paragraph label="Example 3">Multi-issue elections under constraintsA committee {a mathematical formula}N has to decide on each of the three following issues: (U) financing a new university building, (S) financing a sports centre, (C) increasing catering facilities. As an approval of both a new university building and a sports centre would bring an unsustainable demand on current catering facilities, it is considered irrational to approve both of the first two issues and to reject the third one. We can model this situation with a set of three issues {a mathematical formula}I={U,S,C}. The integrity constraint representing this rationality assumption is the following formula: {a mathematical formula}pU∧pS→pC. To see an example of a rational profile, consider the situation described in Table 1 for the case of a committee with three members. All individuals are rational, the only irrational ballot being {a mathematical formula}B=(1,1,0).Preference aggregationA set {a mathematical formula}N of individuals has to agree on a ranking of three alternatives a, b and c. Each individual submits its own ranking of the alternatives from the most preferred to the least preferred, e.g., {a mathematical formula}b&gt;a&gt;c. We can model this situation using a binary issue for every pair of alternatives: issue ab stands for “alternative a is preferred to alternative b”. The set of issues is therefore {a mathematical formula}I={aa,bb,cc,ab,ba,bc,cb,ac,ca}. However, not every binary evaluation over this set of issues corresponds to a ranking. An integrity constraint needs to be devised to encode the correct properties of the binary relation: transitivity, completeness and irreflexivity. This can be done by considering the following set of integrity constraints {a mathematical formula}ic&lt;: Irreflexivity:{a mathematical formula}¬pxx for all {a mathematical formula}x∈{a,b,c}Completeness:{a mathematical formula}pxy∨pyx for all {a mathematical formula}x,y∈{a,b,c} distinctTransitivity:{a mathematical formula}pxy∧pyz→pxz for {a mathematical formula}x,y,z∈{a,b,c} pairwise distinct These formulas can be easily modified to account for different representations of preferences that are closer to applications in AI, e.g., partially ordered preferences [36].Judgment aggregationA court composed of three judges has to decide on the liability of a defendant under the charge of breach of contract. According to the law, the individual is liable if there was a valid contract and her behaviour was such as to be considered a breach of the contract.{sup:2} The court takes three majority decisions on the following statements: there was a valid contract (α), the individual broke the contract (β), the defendant is liable ({a mathematical formula}α∧β). We can model this situation using a set of six issues {a mathematical formula}I={α,¬α,β,¬β,α∧β,¬(α∧β)} to model the decision of a judge on the three issues at stake, and create a set of integrity constraints that reflect the consistency of a possible verdict by explicitly ruling out every inconsistent set that can be created using issues in {a mathematical formula}I: Inconsistent sets of size 2:{a mathematical formula}¬(px∧p¬x) for all {a mathematical formula}x∈{α,β,α∧β}, {a mathematical formula}¬(pα∧β∧p¬α) and {a mathematical formula}¬(pα∧β∧p¬β)Inconsistent set of size 3:{a mathematical formula}¬(p¬(α∧β)∧pα∧pβ) Situations like the one described in this example are the subject of a wide literature in SCT under the name of judgment aggregation[29]. We refer to our previous work [21], [18] for more details about the correspondence between judgment aggregation and our framework of binary aggregation with integrity constraints.</paragraph><paragraph label="Example 4">Choosing from a set of candidatesA winning candidate has to be chosen from a set {a mathematical formula}C={1,…,m} by an electorate {a mathematical formula}N. Let the set of issues be {a mathematical formula}I=C. If we are using an aggregation procedure like approval voting[4], in which individuals are submitting a set of candidates they approve of, then we can model the situation without any integrity constraint, since every binary ballot over {a mathematical formula}I corresponds to a set of candidates. If instead we want to consider more restrictive ballots, like in the case of the plurality rule in which each individual submits only its favourite candidate, then we need to devise an integrity constraint that forces each individual to approve a single candidate in the list. This can be done by taking the disjunction of all possible ballots:{a mathematical formula} The voting rule known as k-approval voting, in which individuals submit a set of k approved candidates, can be modelled in a similar fashion.</paragraph></section><section label="2.3"><section-title>Collective rationality</section-title><paragraph>Consider the situation introduced in Example 1: There are three issues at stake, and the integrity constraint is represented by the formula {a mathematical formula}ic=pU∧pS→pC. Suppose there are three individuals, choosing ballots {a mathematical formula}(0,1,0), {a mathematical formula}(1,0,0) and {a mathematical formula}(1,1,1), as in Table 1. Their choices are rational (they all satisfy ic). Assume now we accept an issue j if a majority of individuals do, employing what we will call the majority rule. We would then obtain as an outcome of this profile the ballot {a mathematical formula}(1,1,0), which fails to be rational. This kind of observation, like the one presented in the introduction, is often referred to as a paradox.</paragraph><paragraph>In the literature on SCT, situations like the one above are ruled out by requiring aggregation procedures to satisfy a property called collective rationality, which forces the output of an aggregation procedure to be of the same form of the input, i.e., a rational ballot. In preference aggregation, for instance, the output of an aggregation procedure is required to be a linear (or weak) order over a set of alternatives [3]. In judgment aggregation the output is required to be a consistent judgment over a set of propositional formulas [29]. Here we give a general definition of collective rationality depending on the integrity constraint at hand:</paragraph><paragraph label="Definition 3">Given an integrity constraint {a mathematical formula}ic∈LPS, an aggregation procedure {a mathematical formula}F:DN→D is called collectively rational (CR) with respect to ic, if for all rational profiles {a mathematical formula}B∈Mod(ic)N we have that {a mathematical formula}F(B)∈Mod(ic).</paragraph><paragraph>Thus, F is CR if it lifts the rationality assumptions given by ic from the individual to the collective level. An aggregation procedure that is CR with respect to ic cannot generate a paradox with ic as integrity constraint.</paragraph><paragraph>Inspired by Definition 3, we can give a general definition of paradoxical behaviour of an aggregation procedure in terms of the violation of certain rationality assumptions:</paragraph><paragraph label="Definition 4">A paradox is a triple {a mathematical formula}(F,B,ic), where {a mathematical formula}F:DN→D is an aggregation procedure, B is a profile in {a mathematical formula}DN, ic is an integrity constraint in {a mathematical formula}LPS, and {a mathematical formula}Bi∈Mod(ic) for all {a mathematical formula}i∈N but {a mathematical formula}F(B)∉Mod(ic).</paragraph><paragraph>This notion of paradox encompasses many of the classical paradoxes of aggregation studied in SCT. A shown by the examples presented in the previous section, preference and judgment aggregation, as well as other frameworks for collective decision making, can be modelled in binary aggregation by devising suitable integrity constraints. In previous work [19] we bring this correspondence one step further by showing how paradoxical situations traditionally studied in SCT, such as the Condorcet paradox in preference aggregation [3] and the discursive dilemma in judgment aggregation [29], can be viewed as particular instances of our Definition 4.</paragraph></section><section label="2.4"><section-title>The axiomatic method</section-title><paragraph>Aggregation procedures are traditionally studied using the axiomatic method. Axioms are used to express desirable properties of a procedure, depending on the application at hand. In this section, we adapt the most important axioms familiar from standard SCT, and more specifically from judgment aggregation [29] and binary aggregation [11], to our setting. Let {a mathematical formula}X⊆DN be a subset of the set of all profiles. We start with four common axioms: Unanimity(U): For any profile {a mathematical formula}B∈X and any {a mathematical formula}x∈{0,1}, if {a mathematical formula}bi,j=x for all {a mathematical formula}i∈N, then {a mathematical formula}F(B)j=x.Issue-neutrality({a mathematical formula}NI): For any two issues {a mathematical formula}j,j′∈I and any profile {a mathematical formula}B∈X, if for all {a mathematical formula}i∈N we have that {a mathematical formula}bi,j=bi,j′, then {a mathematical formula}F(B)j=F(B)j′.Independence(I): For any issue {a mathematical formula}j∈I and any two profiles {a mathematical formula}B,B′∈X, if {a mathematical formula}bi,j=bi,j′ for all {a mathematical formula}i∈N, then {a mathematical formula}F(B)j=F(B′)j.Anonymity(A): For any profile {a mathematical formula}B∈X and any permutation {a mathematical formula}σ:N→N, we have that {a mathematical formula}F(B1,…,Bn)=F(Bσ(1),…,Bσ(n)). Unanimity postulates that, if all individuals agree on issue j, then the aggregation procedure should implement that choice for j. Anonymity requires the procedure to be symmetric with respect to individuals. Issue-neutrality (a variant of the standard axiom of neutrality introduced in the literature on judgment aggregation) asks that the procedure be symmetric with respect to issues. Finally, independence requires the outcome of aggregation on a certain issue j to depend only on the individual choices regarding that issue.</paragraph><paragraph>It is important to remark that all axioms are domain-dependent, as testified by the domain restriction given by {a mathematical formula}X. For instance, many aggregation procedures, such as the majority rule, are independent over the full set of profiles {a mathematical formula}X=DN, while others, such as the one presented in the next example, are not. With two issues, let {a mathematical formula}ic=(p2→p1) and let F be equal to the majority rule on the first issue, and accept the second issue only if the first one was accepted and the second one has the support of a majority of the individuals. This procedure is not independent on the full domain, but it is easy to see that it satisfies independence when restricted to {a mathematical formula}X=Mod(ic)N. As in the previous example, in the following sections we will specify restrictions on the domain of aggregation by means of propositional formulas.</paragraph><paragraph>As a generalisation of the axiom of neutrality introduced by May [31], we introduce the following axiom: Domain-neutrality({a mathematical formula}ND): For any two issues {a mathematical formula}j,j′∈I and any profile {a mathematical formula}B∈X, if {a mathematical formula}bi,j=1−bi,j′ for all {a mathematical formula}i∈N, then {a mathematical formula}F(B)j=1−F(B)j′. The two notions of neutrality are uncorrelated but dual: issue-neutrality requires the outcome on two issues to be the same if all individuals agree on these issues; domain-neutrality requires it to be reversed if all the individuals make opposite choices on the two issues.</paragraph><paragraph>We now introduce two axioms of monotonicity. The first, which we call independence-monotonicity, is often called positive responsiveness and is formulated as an (inter-profile) axiom for independent aggregation procedures. The second version of monotonicity is designed for neutral procedures, and it was introduced in our previous work [14]: I-monotonicity(M{sup:I}): For any {a mathematical formula}j∈I and any two profiles B and {a mathematical formula}B′ in {a mathematical formula}X, if {a mathematical formula}bi,j=1 entails {a mathematical formula}bi,j′=1 for all {a mathematical formula}i∈N, and for some {a mathematical formula}s∈N we have that {a mathematical formula}bs,j=0 and {a mathematical formula}bs,j′=1, then {a mathematical formula}F(B)j=1 entails {a mathematical formula}F(B′)j=1.N-monotonicity(M{sup:N}): For any {a mathematical formula}j,j′∈I and profile {a mathematical formula}B∈X, if for all {a mathematical formula}i∈N we have that {a mathematical formula}bi,j=1 entails {a mathematical formula}bi,j′=1 and for some {a mathematical formula}s∈N we have that {a mathematical formula}bs,j=0 and {a mathematical formula}bs,j′=1, then {a mathematical formula}F(B)j=1 entails {a mathematical formula}F(B)j′=1.</paragraph><paragraph>That is, M{sup:I} expresses that if an issue j is collectively accepted and receives additional support (from an individual i), then it should continue to be collectively accepted. Axiom M{sup:N} says that if issue j is collectively accepted and issue {a mathematical formula}j′ is accepted by a strict superset of the individuals accepting j, then {a mathematical formula}j′ should also be collectively accepted.</paragraph><paragraph>The last property for aggregation procedures that we are going to introduce is traditionally considered a negative one. We choose not to state it as an axiom, but rather as a property defining a class of functions: An aggregation procedure is called a dictatorship if it copies the ballot of the same individual in every profile. This notion is in clear contrast with the axiom of anonymity previously introduced. In Definition 9 we will generalise this notion by defining the class of generalised dictatorships as those procedures that copy the ballot of a possibly different individual in every profile.</paragraph></section><section label="2.5"><section-title>Quota rules</section-title><paragraph>An aggregation procedure F for n individuals is a quota rule if for every issue j there exists a quota {a mathematical formula}0≤qj≤n+1 such that, if we denote by {a mathematical formula}NjB={i|Bi,j=1}, then {a mathematical formula}F(B)j=1 if and only if {a mathematical formula}|NjB|≥qj. The class of quota rules, which we denote {a mathematical formula}QR, was introduced by Dietrich and List [10] in the framework of judgment aggregation. Adapting a result by Dietrich and List [10, Theorem 1] we obtain the following axiomatisation of the class of quota rules{sup:3}:</paragraph><paragraph label="Proposition 1">An aggregation procedure F satisfies A, I, and{a mathematical formula}MIon the full domain{a mathematical formula}DNif and only if it is a quota rule.</paragraph><paragraph>A quota rule is called uniform if the quota is the same for all issues. By adding the axiom of issue-neutrality to Proposition 1 we immediately get an axiomatisation of this class.</paragraph><paragraph>A particular quota rule, which we study in detail in Section 6.2, is the majority rule. This rule, in case the number of individuals is odd, is the uniform quota rule with quota {a mathematical formula}q=n+12. It is interesting to link these results with Mayʼs Theorem [31] on the axiomatic characterisation of the majority rule in voting theory. We can complement his result (which deals with the case of a single issue) by adding the axioms of domain-neutrality and issue-neutrality to Proposition 1 and considering the case of multiple binary issues. Under these assumptions, by issue-neutrality the quota must be the same for all issues, and by domain-neutrality the two sets {a mathematical formula}NjB and {a mathematical formula}N∖NjB must be treated symmetrically. Hence, the only possibility is to have a uniform quota of {a mathematical formula}n+12.</paragraph><paragraph label="Proposition 2">If the number of individuals is odd and{a mathematical formula}|I|≥2, an aggregation procedure F satisfies A,{a mathematical formula}NI,{a mathematical formula}ND, I and{a mathematical formula}MIon the full domain{a mathematical formula}DNif and only if it is the majority rule.</paragraph></section></section><section label="3"><section-title>Classes of aggregation procedures</section-title><paragraph>In this section we introduce two definitions for classes of aggregation procedures on binary combinatorial domains. Given a restriction on the propositional language in which integrity constraints can be expressed, we first define the class of procedures that are collectively rational with respect to all integrity constraints in the given restricted language. On the other hand, we consider a list of classical axiomatic properties and define the class of procedures that satisfy such axioms on domains defined by formulas in the given language. We study the properties of these two definitions, preparing the ground for characterisation results that will establish a strong link between requirements of collective rationality and classical axiomatic properties.</paragraph><section label="3.1"><section-title>Collective rationality and axiomatic properties</section-title><paragraph>Recall that a binary aggregation problem is given by a set of agents {a mathematical formula}N having to take a decision on which combination of binary issues in {a mathematical formula}I to choose. Depending on the situation at hand, a subset of such combinations is designated as the set of rational choices, and this is specified by means of a propositional formula in the language {a mathematical formula}LPS associated with {a mathematical formula}I. We call language any subset {a mathematical formula}L of {a mathematical formula}LPS. Examples include the set of atoms PS, or the set of formulas of a given size, as well as more classical fragments obtained by restricting the set of connectives that can be employed in the construction of formulas, like the set of clauses obtained from the set of literals using only disjunctions. In Section 2.3 we called an aggregation procedure collectively rational with respect to a formula {a mathematical formula}ic∈LPS if the outcome on every rational profile satisfies the same integrity constraint ic. We now extend this definition to collectively rational procedures with respect to a given language {a mathematical formula}L:</paragraph><paragraph label="Definition 5">Given a language {a mathematical formula}L⊆LPS, call {a mathematical formula}CR[L] the class of aggregation procedures that lift all {a mathematical formula}ic∈L:{a mathematical formula}</paragraph><paragraph>Note that in this definition we do not fix the number of individuals, making {a mathematical formula}I the only parameter that is fixed in advance. This choice is arguably a natural one, as a decision problem is usually defined before specifying the number of individuals that are going to take part in the decision process. However, its appeal does not only reside in its practical use; rather it is a mathematical assumption that allows us to gain more clarity in some of the results that follow.{sup:4}</paragraph><paragraph>The next step is to introduce notation for defining classes of aggregation procedures in terms of classical axioms like the ones we listed in Section 2.4. Recall from Section 2.4 that an axiom may be satisfied on a specific subdomain of interest {a mathematical formula}X, but not on the full domain {a mathematical formula}DN. Here, we are interested in domains defined by means of integrity constraints (i.e., propositional formulas), as this is interpreted as the domain of rational ballots. We therefore need some notation to identify procedures that satisfy an axiom on the subdomain {a mathematical formula}Mod(ic)N induced by a given integrity constraint ic. We give the following definition:</paragraph><paragraph label="Definition 6">An aggregation procedure F satisfies a set of axioms AX wrt. a language {a mathematical formula}L⊆LPS, if F satisfies the axioms in AX on {a mathematical formula}Mod(ic)N for all constraints {a mathematical formula}ic∈L. This defines the following class:{a mathematical formula}</paragraph><paragraph>In particular, {a mathematical formula}F={F:DN→D|N is finite} is the class of all aggregation procedures for a given set of issues {a mathematical formula}I. In the sequel we shall omit mentioning explicitly that {a mathematical formula}N is finite, keeping it as a general underlying assumption.</paragraph></section><section label="3.2"><section-title>Languages for integrity constraints</section-title><paragraph>In this section we study the behaviour of the classes defined in the previous section with respect to set-theoretic and logical operations performed on the languages and on the axioms. In particular, we give a definition of language for integrity constraints that is specific to the study of collectively rational procedures.</paragraph><paragraph>Let {a mathematical formula}L be a language. Define {a mathematical formula}L∧ to be the closure of {a mathematical formula}L under conjunction, i.e., the set of finite conjunctions of formulas in {a mathematical formula}L. We now prove that the class of collectively rational procedures is invariant under closing the language under conjunction, i.e., that the set of collectively rational procedures for {a mathematical formula}L and for {a mathematical formula}L∧ coincide:</paragraph><paragraph label="Lemma 3">{a mathematical formula}CR[L∧]=CR[L]for all{a mathematical formula}L⊆LPS.</paragraph><paragraph label="Proof">{a mathematical formula}CR[L∧] is clearly included in {a mathematical formula}CR[L], since {a mathematical formula}L⊆L∧.{sup:5} It is then straightforward to observe that if an aggregation procedure F lifts every constraint in {a mathematical formula}L, then it lifts any conjunction of formulas in {a mathematical formula}L.  □</paragraph><paragraph>This lemma entails that different languages for integrity constraints can define the same class of CR procedures. For instance, we have that the language of cubes (conjunctions of literals) generates the same class as the language of literals, i.e., {a mathematical formula}CR[cubes]=CR[literals], since the former is obtained from the latter by closing it under conjunction. Another interesting fact is that procedures that are CR with respect to clauses (disjunctions of literals) are CR with respect to any integrity constraint in {a mathematical formula}LPS, i.e., {a mathematical formula}CR[clauses]=CR[LPS]. This holds because every propositional formula is equivalent to a formula in conjunctive normal form (CNF), where it is expressed precisely as a conjunction of clauses.</paragraph><paragraph>We have just proven that the class {a mathematical formula}CR[L] is invariant under closing the language under conjunction. Another such property is the closure under logical equivalence. Recall that two formulas are logically equivalent when they share the same set of models. Let us indicate with {a mathematical formula}L≡ the set of formulas in {a mathematical formula}LPS that are equivalent to a formula in {a mathematical formula}L. It is important to stress the fact that we consider logical equivalence inside the language {a mathematical formula}LPS, not allowing the use of additional propositional variables. We have the following lemma:</paragraph><paragraph label="Lemma 4">{a mathematical formula}CR[L≡]=CR[L]for all{a mathematical formula}L⊆LPS.</paragraph><paragraph>The proof of the lemma is straightforward from our definitions. It is sufficient to observe that an equivalent formulation of our definition of collective rationality can be given by substituting formulas with the set of rational ballots given by their models. Two formulas that are logically equivalent have the same set of models, giving rise to the same requirement of collective rationality.{sup:6}</paragraph><paragraph>Bringing together the results of Lemma 3, Lemma 4, we can now give the following definition:</paragraph><paragraph label="Definition 7">A language for integrity constraints{a mathematical formula}L is a subset of {a mathematical formula}LPS that is closed under conjunction and logical equivalence.</paragraph><paragraph>In the following sections we characterise languages for integrity constraints by means of syntactic properties, without mentioning explicitly the closure under conjunction and logical equivalence. For instance, the language of 2-clauses (i.e., disjunctions of size at most two) denotes the language of formulas that are equivalent to a conjunction of clauses of size at most two.{sup:7} The language of literals and that of cubes coincide, as well as the language of clauses and the full language {a mathematical formula}LPS, as we have previously remarked.</paragraph><paragraph>Tautologies and contradictions play a special role in languages for integrity constraints. First, observe that if a language {a mathematical formula}L includes a tautology (or a contradiction, respectively), then by closure under logical equivalence {a mathematical formula}L contains all tautologies (all contradictions, respectively). Thus, we indicate with {a mathematical formula}⊤∈L the fact that {a mathematical formula}L contains all tautologies, and with {a mathematical formula}⊥∈L the fact that {a mathematical formula}L contains all contradictions. Second, not all languages for integrity constraints include both tautologies and contradictions, or either of them. For instance, the language of literals includes the contradiction {a mathematical formula}p∧¬p but it does not contain any tautology. On the other hand, the language of positive clauses, consisting of clauses in which all literals occur positively, does not include either tautologies or contradictions.</paragraph><paragraph>Nevertheless, it is easy to see that collective rationality with respect to tautologies and contradictions corresponds to a vacuous requirement: In the first case, the outcome of a procedure will always satisfy a tautology, and in the second case the set of rational ballots is empty. These remarks constitute a proof of the following lemma.</paragraph><paragraph label="Lemma 5">{a mathematical formula}CR[L∪{⊤}]=CR[L∪{⊥}]=CR[L]for all{a mathematical formula}L⊆LPS.</paragraph><paragraph>We now move to answering the question of whether the operations that we have included in Definition 7 are all the operations that we can perform on {a mathematical formula}L leaving the set {a mathematical formula}CR[L] invariant. The following result provides a positive answer to this question, provided that a language include tautologies and contradictions:</paragraph><paragraph label="Lemma 6">Given two languages for integrity constraints{a mathematical formula}L1and{a mathematical formula}L2containing ⊤ and ⊥, if it is the case that{a mathematical formula}L1≠L2, then{a mathematical formula}CR[L1]≠CR[L2].</paragraph><paragraph label="Proof">As the two languages both contain tautologies and contradictions, they must differ on a contingent formula φ. Without loss of generality we can consider a formula {a mathematical formula}φ∈L2 such that {a mathematical formula}φ∉L1. We want to prove that there exists an aggregation procedure {a mathematical formula}F∈CR[L1] that is not CR with respect to φ. This in turn implies that F is not in {a mathematical formula}CR[L2], and that the two classes {a mathematical formula}CR[L1] and {a mathematical formula}CR[L2] are different.Let {a mathematical formula}|N|=n where {a mathematical formula}n=|Mod(φ)| and let F be a procedure in {a mathematical formula}CR[L1] defined for {a mathematical formula}N.{sup:8} We claim that it is possible to modify the behaviour of F on a single profile B in order to create another procedure {a mathematical formula}F′ that is still CR with respect to {a mathematical formula}L1 but sends the profile B of φ-rational ballots to an outcome that does not satisfy φ. To do so it is sufficient to find a profile {a mathematical formula}B=(B1,…,Bn) of models of φ and a ballot {a mathematical formula}Bc outside {a mathematical formula}Mod(φ) such that whenever each of {a mathematical formula}B1,…,Bn satisfies any formula {a mathematical formula}ψ∈L1 then also {a mathematical formula}Bc⊨ψ. If we can find such a B and {a mathematical formula}Bc, then by setting {a mathematical formula}F′(B)=Bc and {a mathematical formula}F′(B′)=F(B′) for all remaining {a mathematical formula}B′≠B we obtain an aggregation procedure that is in {a mathematical formula}CR[L1] but not in {a mathematical formula}CR[L2].Suppose for the sake of contradiction that such a profile does not exist, i.e., that for every choice of n ballots in {a mathematical formula}Mod(φ) and ballot {a mathematical formula}Bc outside {a mathematical formula}Mod(φ), there is a formula {a mathematical formula}ψ∈L1 that separates them: for all i we have that {a mathematical formula}Bi⊨ψ but {a mathematical formula}Bc⊭ψ. Note that {a mathematical formula}|Mod(φ)|=n, as well as the size of the profile B we are looking for. This entails that we can construct a profile {a mathematical formula}Bφ that contains all distinct models of φ, and that for every {a mathematical formula}Bc⊭φ there is a formula in {a mathematical formula}L1, that we shall call {a mathematical formula}ψc, that separates the set {a mathematical formula}Mod(φ) from {a mathematical formula}Bc.We have assumed that {a mathematical formula}φ∉L1, i.e., φ is not equivalent to a conjunction of formulas in {a mathematical formula}L1. Let us now consider the conjunction {a mathematical formula}⋀ψc for {a mathematical formula}Bc⊭φ. We claim that {a mathematical formula}φ≡⋀ψc, in contradiction with our assumption, since all {a mathematical formula}ψc are in {a mathematical formula}L1. By construction we know that {a mathematical formula}Mod(φ)⊆Mod(⋀ψc), as all models of φ are individual ballots in the profile {a mathematical formula}Bφ. We need to prove the other inclusion. Assume for the sake of contradiction that there exists a {a mathematical formula}B⁎ in {a mathematical formula}Mod(⋀ψc)∖Mod(φ). By construction, there exists a formula {a mathematical formula}ψ⁎∈L1 that separates {a mathematical formula}B⁎ from {a mathematical formula}Mod(φ), and this formula is included in {a mathematical formula}⋀ψc. But by construction {a mathematical formula}B⁎⊭ψ⁎, therefore it cannot be included in {a mathematical formula}Mod(⋀ψc).The proof is now concluded: it is possible to modify F on the profile B that contains all models of φ to output a ballot that is not a model of φ but respects all integrity constraints in {a mathematical formula}L1. That is, {a mathematical formula}F′ so defined is in {a mathematical formula}CR[L1] but not in {a mathematical formula}CR[φ].  □</paragraph><paragraph>We conclude this section by establishing some easy properties of {a mathematical formula}CR[L] and of {a mathematical formula}FL[AX] that shall be useful in the next sections. Let {a mathematical formula}L1 and {a mathematical formula}L2 be languages for integrity constraints.</paragraph><paragraph label="Lemma 7">The following facts hold:</paragraph><list><list-item label="(i)">If{a mathematical formula}L1⊆L2, then{a mathematical formula}CR[L1]⊇CR[L2];</list-item><list-item label="(ii)">{a mathematical formula}CR[L1∪L2]=CR[L1]∩CR[L2]for all{a mathematical formula}L1,L2⊆LPS.</list-item></list><paragraph>The proof is straightforward from our definitions. Lemma 7 still holds if {a mathematical formula}L1 and {a mathematical formula}L2 are arbitrary sets of propositional formulas (e.g., in the proof of Lemma 3 we are implicitly making use of point (i) of Lemma 7). Similar properties can be proved for classes of procedures defined in terms of axioms. We write {a mathematical formula}F[AX] as a shorthand for {a mathematical formula}F{⊤}[AX], the class of procedures that satisfy the axioms in AX over the full domain {a mathematical formula}D. It is easy to see that the following lemma holds:</paragraph><paragraph label="Lemma 8">The following facts hold:</paragraph><list><list-item label="(i)">if{a mathematical formula}L1⊆L2then{a mathematical formula}FL1[AX]⊇FL2[AX];</list-item><list-item label="(ii)">in particular, if{a mathematical formula}⊤∈L, then{a mathematical formula}F[AX]⊇FL[AX];</list-item><list-item label="(iii)">{a mathematical formula}FL[AX1,AX2]=FL[AX1]∩FL[AX2].</list-item></list><paragraph>Observe that for most axioms an additional fact holds: if the axiomatic property AX is satisfied on the full domain {a mathematical formula}D, then AX is also satisfied on every subdomain of {a mathematical formula}D. This is true in particular for all the axioms we considered in Section 2.4. Thus, for most axioms AX the following additional property holds: {a mathematical formula}F[AX]⊆FL[AX] for all {a mathematical formula}L⊆LPS. By (ii) of Lemma 8 this entails that if {a mathematical formula}⊤∈L then {a mathematical formula}F[AX]=FL[AX] for all {a mathematical formula}L⊆LPS. This observation will allow us in Section 5 to obtain stronger characterisation results by dropping the subscript in the definition of the class {a mathematical formula}FL[AX].</paragraph></section><section label="3.3"><section-title>From aggregation procedures to integrity constraints and back</section-title><paragraph>In the first part of Section 3 we have associated with any language for integrity constraints {a mathematical formula}L a class of aggregation procedures that are collectively rational with respect to all formulas in {a mathematical formula}L. Once a set of issues {a mathematical formula}I is fixed, {a mathematical formula}CR[−] can therefore be viewed as an operator from the set of languages for integrity constraints (i.e., subsets of {a mathematical formula}LPS closed under conjunction and logical equivalence and containing ⊤ and ⊥) to subsets of the class {a mathematical formula}F of all aggregation procedures for {a mathematical formula}I. In this section we introduce an inverse operation, that we shall call {a mathematical formula}LF[−], which, given a class of procedures, outputs the set of integrity constraints that are lifted by all procedures in that class. As we will see, {a mathematical formula}LF is the left inverse of {a mathematical formula}CR, but on the other hand the two operators do not commute. The relation between the two operators is shown in Fig. 1.</paragraph><paragraph label="Definition 8">Given a class of aggregation procedures {a mathematical formula}G⊆F, call {a mathematical formula}LF[G] the set of integrity constraints that are lifted by all {a mathematical formula}F∈G:{a mathematical formula}</paragraph><paragraph>{a mathematical formula}LF[G] is the intersection of all {a mathematical formula}LF[{F}] for {a mathematical formula}F∈G. We now prove the following:</paragraph><paragraph label="Proposition 9">Let{a mathematical formula}Ibe a set of issues,{a mathematical formula}La language for integrity constraints containing ⊤ and ⊥, and{a mathematical formula}G⊆Fa class of aggregation procedures on{a mathematical formula}I. Then the following facts are true:</paragraph><list><list-item label="(i)">{a mathematical formula}LF[CR[L]]=L;</list-item><list-item label="(ii)">{a mathematical formula}CR[LF[G]]⊇Gand this inclusion is strict for some classes.</list-item></list><paragraph label="Proof">(i) We start by proving that {a mathematical formula}LF is a left inverse of {a mathematical formula}CR. A direct consequence of our definitions is that {a mathematical formula}L⊆LF[CR[L]], and we now prove the other inclusion. We want to show that if an integrity constraint φ is lifted by all procedures that are CR with respect to {a mathematical formula}L, then φ belongs to {a mathematical formula}L. This is a straightforward consequence of Lemma 6. Assume for the sake of contradiction that {a mathematical formula}φ∉L. By Lemma 6, there exists a procedure F which is collectively rational for {a mathematical formula}L but not for φ, in contradiction to our assumption that all procedures in {a mathematical formula}CR[L] are CR with respect to φ. Therefore φ is in {a mathematical formula}L.(ii) It is straightforward from our definitions that {a mathematical formula}CR[LF[G]]⊇G. Recall that a generalised dictatorship is a procedure that copies the ballot of a possibly different individual in every profile. It can be easily observed that such a procedure is collectively rational for every integrity constraint, and in Section 2.2 we will give a formal proof of this fact (cf. Theorem 16). Let us therefore consider a class of procedures {a mathematical formula}G not containing any generalised dictatorship. In view of our previous observation we know that all generalised dictatorships are contained in {a mathematical formula}CR[LF[G]], as they are collectively rational for any integrity constraint. As we assumed that {a mathematical formula}G does not contain any generalised dictatorship, we infer that {a mathematical formula}CR[LF[G]]⊋G.  □</paragraph></section></section><section label="4"><section-title>Characterisation results for propositional languages</section-title><paragraph>Once a language for integrity constraints is fixed, e.g., by means of a syntactic restriction on the integrity constraints, we may be interested in the problem of how to guarantee collective rationality with respect to all the integrity constraints that can be expressed in the given language. The aim of this section is to explore the relationship between the two definitions of classes of aggregation procedures introduced in Section 3: collectively rational procedures on one side, and procedures defined by axiomatic requirements on the other. In particular, we look for results of the following form:{a mathematical formula} for languages {a mathematical formula}L and axioms AX. We call such findings characterisation results: they provide necessary and sufficient axiomatic conditions for an aggregation procedure to be collectively rational with respect to a language for integrity constraints. Given the importance of collective rationality in many classical studies of aggregation and for a number of practical applications, such results are central to our study.</paragraph><paragraph>The focus of this section is on languages: We provide complete characterisation for some basic classes of languages defined in a syntactic fashion, proving the correspondence with some of the main classical axioms from the literature on SCT. We shift the focus to axioms in Section 5.</paragraph><paragraph>Definitions of all the axiomatic properties we refer to in this section can be found in Section 2.4. Axioms will be denoted with the capital letter associated with them, e.g., we will write U for unanimity and I for independence.</paragraph><section label="4.1"><section-title>Characterisation results</section-title><paragraph>Recall that a procedure is unanimous if it shares the view of the individuals in case they all agree, either all accepting or rejecting a certain issue. The first characterisation result shows that the set of aggregation procedures that lift all rationality constraints expressible in terms of literals is precisely the class of unanimous procedures:</paragraph><paragraph label="Theorem 10">{a mathematical formula}CR[literals]=Fliterals[U].</paragraph><paragraph label="Proof">The first direction {a mathematical formula}(⊇) is easy: If {a mathematical formula}X:=Mod(ℓ) is a domain defined by a literal ℓ, then every individual ballot must agree with it, either positively or negatively depending on its sign. This entails, by unanimity, that the collective outcome agrees with the individual ballots. Thus, F is collectively rational for ℓ.For the other direction {a mathematical formula}(⊆), suppose that {a mathematical formula}F∈CR[literals]. Fix an issue {a mathematical formula}j∈I. Pick a profile {a mathematical formula}B∈Dn such that {a mathematical formula}bi,j=1 (or 0) for all {a mathematical formula}i∈N. That is, {a mathematical formula}B∈Mod(pj)N (or {a mathematical formula}¬pj, respectively). Since F is collectively rational for every literal, including {a mathematical formula}pj and {a mathematical formula}¬pj, it must be the case that {a mathematical formula}F(B)j=1 (or 0, respectively), proving unanimity of the aggregator.  □</paragraph><paragraph>As remarked in Section 3, the language generated from literals is the same as the language of cubes, i.e., finite conjunctions of literals. We can therefore state the following corollary:</paragraph><paragraph label="Corollary 11">{a mathematical formula}CR[cubes]=Fcubes[U].</paragraph><paragraph>An equivalence is a bi-implication of literals where the literals are both positive (or both negative, which amounts to the same thing). Call {a mathematical formula}L↔ the language for integrity constraints generated by equivalences, i.e., the set {a mathematical formula}{pj↔pk|pj,pk∈PS} closed under conjunctions and logical equivalence. This language allows us to characterise issue-neutral aggregators, i.e., procedures that treat distinct issues in the same way:</paragraph><paragraph label="Theorem 12">{a mathematical formula}CR[L↔]=FL↔[NI].</paragraph><paragraph label="Proof">To prove the first inclusion (⊇), pick an equivalence {a mathematical formula}pj↔pk. This defines a domain in which issues j and k share the same pattern of acceptance/rejection, and since the procedure is neutral over issues, we get {a mathematical formula}F(B)j=F(B)k. Therefore, the constraint given by the initial equivalence is lifted.For the other direction (⊆), suppose that a profile B is such that {a mathematical formula}bi,j=bi,k for every {a mathematical formula}i∈N. This implies that {a mathematical formula}B∈Mod(pj↔pk)N, and since F is in {a mathematical formula}CR[L↔], {a mathematical formula}F(B)j must be equal to {a mathematical formula}F(B)k. This holds for every such B, proving that F is neutral over issues.  □</paragraph><paragraph>With an analogous proof we can obtain a characterisation result involving the axiom of domain-neutrality. Recall that a procedure is domain-neutral if it symmetric with respect to any two issues. An XOR formula is a bi-implication of one negative and one positive literal. Call {a mathematical formula}LXOR the language for integrity constraints generated from {a mathematical formula}{pj↔¬pk|pj,pk∈PS}.</paragraph><paragraph label="Theorem 13">{a mathematical formula}CR[LXOR]=FLXOR[ND].</paragraph><paragraph label="Proof">The first inclusion {a mathematical formula}(⊇) is straightforward: When every individual ballot in a profile satisfies the same XOR formula, then this means that there are two issues the behaviour of which is symmetrical. By domain-neutrality, the outcome of the aggregation is also symmetrical, and therefore the constraint is lifted.To prove the remaining inclusion (⊆), suppose that a profile B is such that {a mathematical formula}bi,j=1−bi,k for every {a mathematical formula}i∈N. This implies that {a mathematical formula}B∈Mod(pj↔¬pk)N. As before, since F is in {a mathematical formula}CR[LXOR], it must be the case that {a mathematical formula}F(B)j=1−F(B)k and F is domain-neutral.  □</paragraph><paragraph>Consider now the language {a mathematical formula}L→+ of positive implications, generated from formulas of the form {a mathematical formula}pj→pk, or, equivalently, {a mathematical formula}¬pj→¬pk, for {a mathematical formula}pj,pk∈PS. Since {a mathematical formula}L→+⊇L↔, we know that {a mathematical formula}CR[L→+]⊆CR[L↔]=FL↔[NI]. Therefore, a characterisation of the language of positive implications must involve the axiom of neutrality in combination with others. The right combination is the following:</paragraph><paragraph label="Theorem 14">{a mathematical formula}CR[L→+]=FL→+[NI,MN].</paragraph><paragraph label="Proof">{a mathematical formula}(⊇) Let us first consider the case of individual ballots all satisfying a certain positive implication {a mathematical formula}pj→pk. We want to prove that F lifts this integrity constraint. We note that if an individual accepts issue j then she also accepts issue k. Therefore, the first part of the antecedent forming the axiom of N-monotonicity is satisfied. We now have to consider two cases: if for all {a mathematical formula}i∈N we have that {a mathematical formula}bi,j=bi,k=1, then by issue-neutrality we have that {a mathematical formula}F(B)j=F(B)k. The constraint is therefore satisfied, as the only way to falsify it is by accepting j and rejecting k. If on the other hand there is an individual i such that {a mathematical formula}bi,j=0 while {a mathematical formula}bi,k=1, then B fully satisfies the antecedent of M{sup:N} and therefore the constraint will be lifted.For the remaining inclusion (⊆), suppose that a profile B is such that whenever {a mathematical formula}bi,j=1 then {a mathematical formula}bi,k=1 for every {a mathematical formula}i∈N. This implies that {a mathematical formula}B∈Mod(pj→pk)N. Since we assumed F to be in {a mathematical formula}CR[L→+], {a mathematical formula}F(B)j=1 entails {a mathematical formula}F(B)k=1, for the initial constraint has to be lifted. Therefore F is N-monotonic. We have already remarked that, due to Proposition 12, all procedures in {a mathematical formula}CR[L→+] are also issue-neutral.  □</paragraph><paragraph>This last result seems to suggest that a characterisation of the language of negative implications (i.e., when exactly one of the two literals is negative) might be proved by considering the axiom of domain-neutrality combined with N-monotonicity. Unfortunately, in the absence of a suitable richness condition on the profile this characterisation does not hold. A partial characterisation result for this class, i.e., a list of sufficient axiomatic conditions for collective rationality with respect to negative implications, involves the axiom of independence, and can be found in our previous work [18].</paragraph><paragraph>We conclude this section by characterising the classes of collectively rational procedures for languages at the extremes of the spectrum: the full language {a mathematical formula}LPS, the language of tautologies, and that of contradictions. For the last two classes the characterisation is straightforward. Recall that {a mathematical formula}F={F:DN→D} is the class of all aggregation procedures (for fixed {a mathematical formula}I). We have already stated in Lemma 5 that tautologies and contradictions are vacuous requirements for what concerns collective rationality, and here we use these arguments to give a characterisation result for this trivial class of formulas. Let {a mathematical formula}{⊤} be the language of all tautologies, and {a mathematical formula}{⊥} be the language of all contradictions:</paragraph><paragraph label="Proposition 15">{a mathematical formula}CR[{⊤}]=CR[{⊥}]=F.</paragraph><paragraph label="Definition 9">If on the other hand we turn to study the class of procedures that lift any integrity constraint in {a mathematical formula}LPS we discover an interesting class of procedures. Let us give the following definition, which generalises the notion of dictatorship{sup:9}: An aggregation procedure {a mathematical formula}F:DN→D is a generalised dictatorship, if there exists a map {a mathematical formula}g:DN→N such that {a mathematical formula}F(B)=Bg(B) for every {a mathematical formula}B∈DN.</paragraph><paragraph>That is, a generalised dictatorship copies the ballot of a (possibly different) individual in every profile. Call this class GDIC. This class fully characterises the class of collectively rational aggregators for the full propositional language {a mathematical formula}LPS:</paragraph><paragraph label="Theorem 16">{a mathematical formula}CR[LPS]=GDIC.</paragraph><paragraph label="Proof">Clearly, every generalised dictatorship lifts any arbitrary integrity constraint {a mathematical formula}ic∈LPS. To prove the other direction, suppose that {a mathematical formula}F∉F[GDIC]. Hence, there exists a profile {a mathematical formula}B∈DN such that {a mathematical formula}F(B)≠Bi for all {a mathematical formula}i∈N. This means that for every i there exists an issue {a mathematical formula}ji such that {a mathematical formula}F(B)ji≠bi,ji. We now want to build a propositional formula that is satisfied by all individuals and not by the collective outcome, proving that F is not CR with respect to the full propositional language. Define a literal {a mathematical formula}ℓji to be equal to {a mathematical formula}pji if {a mathematical formula}bi,ji=1, and to {a mathematical formula}¬pji otherwise. Consider as integrity constraint ic the following formula: {a mathematical formula}⋁iℓji. Clearly, {a mathematical formula}Bi⊨ic for every {a mathematical formula}i∈N, i.e., B is a rational profile for the integrity constraint ic. But by construction, {a mathematical formula}F(B)⊭ic, as {a mathematical formula}F(B) differs from the individual ballots on all literals in ic. Therefore, F is not collectively rational for ic and does not belong to the class {a mathematical formula}CR[LPS].  □</paragraph><paragraph>As a concluding remark, recall that the language generated by clauses coincides with the full propositional language, as every propositional formula is equivalent to a conjunction of clauses by taking its conjunctive normal form. We therefore obtain the following:</paragraph><paragraph label="Corollary 17">{a mathematical formula}CR[clauses]=GDIC.</paragraph><paragraph>We analyse restricted languages of clauses in Section 6.</paragraph></section><section label="4.2"><section-title>How to combine characterisation results</section-title><paragraph>Most of the characterisation results presented thus far characterise a class of procedures determined by a single axiom and by a uniform description of the language. We now briefly explain to what extent such results can be combined to allow us to make predictions regarding the collective rationality of procedures satisfying several such axioms, or in the case where the integrity constraints can be chosen from a more complex language.</paragraph><paragraph>Consider the case of two characterisation results {a mathematical formula}CR[L1]=FL1[AX1] and {a mathematical formula}CR[L2]=FL2[AX2]. By part (ii) of Lemma 7 and by {a mathematical formula}FL1∪L2[AX1,AX2]⊆FL1[AX1]∩FL2[AX2] we can infer that:{a mathematical formula} (But note that the other inclusion is not always true.) This entails that if we express constraints in the language {a mathematical formula}L1∪L2 or in any of its sublanguages, then picking procedures from {a mathematical formula}FL1∪L2[AX1,AX2] is a sufficient condition for collective rationality. If, instead, we start from a class of procedures satisfying axioms AX1 and AX2 on the language {a mathematical formula}L1∪L2 then we can infer that these procedures lift any language {a mathematical formula}L⊆L1∪L2, since as we previously observed {a mathematical formula}FL1∪L2[AX1,AX2] is included in {a mathematical formula}CR[L1∪L2], which in turn is included in {a mathematical formula}CR[L].</paragraph></section></section><section label="5"><section-title>Characterisation results for classical axioms</section-title><paragraph>In the previous section we proved several characterisation results for various simple fragments of the propositional language associated with an aggregation problem. In this section we shift our focus from syntactic descriptions of languages to axiomatic properties of aggregation procedures, having the axioms as variables when exploring the possibility for a characterisation result. We first show that for most characterisation results proved in the previous section the domain restriction given by the language {a mathematical formula}L can be dropped, thus obtaining characterisation results for classical axioms from SCT. Then, we prove a negative result involving the axioms of anonymity, independence, and both forms of monotonicity, showing that a characterisation result cannot be proved for these axioms.</paragraph><section label="5.1"><section-title>Characterisation of axioms</section-title><paragraph>Consider the class {a mathematical formula}F[AX], dropping the subscript {a mathematical formula}L, as representing the class of procedures that defines an axiom. For every domain restriction, we know that {a mathematical formula}F[AX]⊆FL[AX]. As anticipated at the end of Section 3.2, most of the characterisation results presented in the previous section can be proved without the restriction on {a mathematical formula}L on the right-hand side, becoming therefore characterisations of classical axioms:</paragraph><paragraph label="Corollary 18">The following equivalences hold:</paragraph><list><list-item label="(i)">{a mathematical formula}F[U]=CR[literals].</list-item><list-item label="(ii)">{a mathematical formula}F[NI]=CR[L↔].</list-item><list-item label="(iii)">{a mathematical formula}F[ND]=CR[LXOR].</list-item></list><paragraph label="Proof">Refer to Theorem 10, Theorem 12, Theorem 13. For all three classes we prove that {a mathematical formula}FL[AX]=F[AX], for the relevant axiom and language. This can be seen by observing that, in the three cases under consideration, the condition required by the axiom is a vacuous requirement outside domains defined by formulas in {a mathematical formula}L. Therefore, if a procedure satisfies an axiom on domains defined by {a mathematical formula}L then it also satisfies the same axiom on the full domain.  □</paragraph></section><section label="5.2"><section-title>Negative results</section-title><paragraph>Results such as the one proved in the previous section cannot be proved for other important axioms, for which it is not possible to obtain a characterisation result. In this section we prove a negative result for the axioms of independence, anonymity and both formulations of monotonicity. We first prove the following proposition. Recall that {a mathematical formula}LF[G] is the set of integrity constraints lifted by all the aggregation procedures in {a mathematical formula}G, and let {a mathematical formula}L⊤,⊥ be the language for integrity constraints generated by {a mathematical formula}{⊤,⊥}.</paragraph><paragraph label="Proposition 19">The following hold:{a mathematical formula}</paragraph><paragraph label="Proof">We prove this proposition by constructing for any contingent formula φ (i.e., such that both φ and ¬φ are satisfiable) an independent, anonymous and monotonic procedure that is not collectively rational with respect to φ. Let φ be such a formula, and let {a mathematical formula}B⋆∈D be a ballot such that {a mathematical formula}B⋆⊭φ. Consider now the constant procedure {a mathematical formula}F(B)=B⋆ for all profiles B: this procedure is independent, anonymous and monotonic, but it is not collectively rational with respect to φ.  □</paragraph><paragraph>An immediate corollary of this result is that it is not possible to obtain a characterisation of these axioms in terms of collective rationality:</paragraph><paragraph label="Corollary 20">There is no language for integrity constraints{a mathematical formula}L⊆LPSsuch that{a mathematical formula}CR[L]=F[I]. The same holds for{a mathematical formula}F[A],{a mathematical formula}F[MI]and{a mathematical formula}F[MN].</paragraph><paragraph label="Proof">By Proposition 9, in the presence of a characterisation result the set of integrity constraints lifted by a class of procedures is uniquely determined. Suppose then that {a mathematical formula}CR[L]=F[AX] for {a mathematical formula}AX∈{I,A,MI,MN} and for a certain {a mathematical formula}L. Proposition 19 forces {a mathematical formula}L to be equal to {a mathematical formula}L⊤,⊥, but we have already proven that this class characterises the whole set of procedures {a mathematical formula}F (cf. Proposition 15 combined with Lemma 7). Therefore, such a characterisation cannot exist.  □</paragraph><paragraph>Note that this argument can be generalised to prove that the class {a mathematical formula}FL[I] (and the same holds for A, M{sup:I} and MN) cannot be characterised for any restriction given by a language {a mathematical formula}L. It is sufficient to note that the constant procedure employed in the proof of Proposition 19 is defined regardless of the domain restriction.</paragraph><paragraph>Our interest in these axioms does not cease here. On the contrary, the last two results showed that the classes of monotone, independent and anonymous procedures behave in the same way as the full class {a mathematical formula}F of all aggregation procedures for what concerns collective rationality. This suggests that interesting characterisations can be studied inside those classes, replacing the set {a mathematical formula}F with, e.g., the class {a mathematical formula}F[I]. We are going to pursue a similar approach in the following section by focusing on the class {a mathematical formula}F[A,I,MI], i.e., the class of quota rules.</paragraph></section></section><section label="6"><section-title>Quota rules and languages of clauses</section-title><paragraph>This section is devoted to a thorough exploration of the classes of collectively rational procedures for several languages of clauses inside the class of quota rules. In Section 6.1 we begin by characterising quota rules that are collectively rational with respect to positive or negative clauses, i.e., clauses in which literals are either all positive or all negative. Then in Section 6.2 we focus on arbitrary clauses of size 2, showing that this class coincides with the set of integrity constraints that are lifted by the majority rule. Finally, in Section 6.3 we provide a general result which characterises quota rules that are collectively rational with respect to an arbitrary clause of a given size.</paragraph><paragraph>We introduced quota rules in Section 2.5 as procedures assigning a quota {a mathematical formula}qj to every issue j so that {a mathematical formula}F(B)j=1⇔|{i|bi,j=1}|≥qj. In the same section we also proved that quota rules are axiomatised as the class of independent, anonymous and monotone procedures. If we denote with {a mathematical formula}QR the set of quota rules, then we can write {a mathematical formula}QR=F[A,I,MI]. Recall that if {a mathematical formula}|N|=n, quotas {a mathematical formula}qj are integers between 0 and {a mathematical formula}n+1, the two extreme cases of {a mathematical formula}qj=0 and {a mathematical formula}qj=n+1 being the two constant rules that output, respectively, 1 and 0.</paragraph><paragraph>There are several reasons why the choice of quota rules and languages of clauses constitutes an interesting combination. First, since we have proven in Section 5 that no characterisation result is possible neither for independent, nor for anonymous, nor for monotonic procedures, it is important to explore classes of collectively rational procedures inside those classes. As remarked earlier, by combining all three axioms together we obtain the set of quota rules. Second, languages of clauses are the most expressive ones, ranging from literals, to implications, to the full expressivity of {a mathematical formula}LPS. By Corollary 17 we know that to obtain interesting results it is necessary to limit either the size or the shape of the clauses that build up a language for integrity constraints. In this section we concentrate on languages defined by bounding the size of clauses, and quota rules seem a perfect candidate to deal with such restrictions, as they allow us to play with quotas and constrain them with equations. Clauses of limited size are of interest in the modelling of several applications, e.g., for limiting cluster size in graph aggregation [13], or for bounding the number of premises in Horn formulas.</paragraph><paragraph>We will assume for the rest of this section that the number of issues is always strictly bigger than the limitation on the size of a clause. This is because in case the number of issues is smaller or equal than the bound on clauses this limitation is fictitious. For {a mathematical formula}k≥1, we define an exact k-clause as a clause of length k, i.e., a clause in which exactly k propositional symbols occur either positively or negatively but not both.{sup:10} A k-clause is a clause of size at most k. A k-pclause is a positive k-clause, i.e., a disjunction where all literals are positive, and a k-nclause is a negative k-clause, where all literals are negative. Given a clause {a mathematical formula}φ=ℓ1∨⋯∨ℓk, we say that an issue j occurs in φ if one and only one of {a mathematical formula}pj and {a mathematical formula}¬pj is one of the literals of φ. For instance, the following formula {a mathematical formula}p∨q∨¬p∨¬r∨¬r is a 2-clause in which two propositional symbols q and r occur, while p occurs in a spurious way and does not add to the length of the clause.</paragraph><section label="6.1"><section-title>Positive and negative clauses</section-title><paragraph>We start by studying the special case of positive and negative clauses of arbitrary size, obtaining necessary and sufficient conditions for quota rules to lift such constraints, and exploring characterisation results inside these classes.</paragraph><paragraph label="Proposition 21">A quota rule is CR for an exact k-pclauseicif and only if{a mathematical formula}∑jqj&lt;n+k, with j ranging over all issues that occur inicand n being the number of individuals, or{a mathematical formula}qj=0for at least one issue j that occurs inic.</paragraph><paragraph label="Proof">Suppose {a mathematical formula}ic=p1∨⋯∨pk and call {a mathematical formula}i1,…,ik the corresponding issues. Given that ic is a positive clause, the only way to generate a paradox is by rejecting all issues {a mathematical formula}i1,…,ik. It is easy to see that this cannot occur if the quota for one of these issues is 0. We can therefore assume that all quotas are positive.Suppose now that we can create a paradoxical profile B. Every individual ballot {a mathematical formula}Bi must accept at least one issue to satisfy the integrity constraint; therefore the profile B contains at least n acceptances concerning issues {a mathematical formula}i1,…,ik. On the other hand, since {a mathematical formula}F(B)j=0 for all {a mathematical formula}j=1,…,k, we have that the number of individuals accepting an issue j is strictly lower than {a mathematical formula}qj. As previously remarked, there are at least n acceptances on the profile B and the maximal number of acceptances that allows rejection on all issues is {a mathematical formula}∑j(qj−1). Hence {a mathematical formula}n≤∑j(qj−1). This is equivalent to {a mathematical formula}n+k≤∑jqj, since all j are distinct, thus we can construct a paradox with our ic if and only if this inequality holds. By taking the contrapositive we obtain the statement of Proposition 21.  □</paragraph><paragraph>With a similar proof we get an analogous result for negative clauses. Both Proposition 21, Proposition 22 can be obtained as corollaries of a general result we shall prove in Section 6.3 (see Theorem 30). For a more detailed proof of the following proposition we refer to our previous work [18].</paragraph><paragraph label="Proposition 22">A quota rule is CR for an exact k-nclauseicif and only if{a mathematical formula}∑jqj&gt;(k−1)n, with j ranging over all issues that occur inicand n being the number of individuals, or{a mathematical formula}qj=n+1for at least one issue j that occurs inic.</paragraph><paragraph>In case {a mathematical formula}k=1, i.e., the case of aggregators lifting both literals {a mathematical formula}pj and {a mathematical formula}¬pj, we obtain {a mathematical formula}qj&lt;n+1 from Proposition 21 and {a mathematical formula}qj&gt;0 from Proposition 22, thus forcing the rule to be unanimous on issue j (quota rules satisfying {a mathematical formula}1≤qj≤n for all j are unanimous). This is consistent with our Theorem 10.</paragraph><paragraph>We now want to turn these results into characterisation results in the line of those proved in Section 4. We first have to define languages of clauses from our definition of clauses of a limited size. Let {a mathematical formula}k-pclauses and {a mathematical formula}k-nclauses denote, respectively, the language for integrity constraints generated from positive (negative) clauses of size ≤k. Denote by {a mathematical formula}QRe(qj) the set of quota rules such that all quotas {a mathematical formula}qj for {a mathematical formula}j∈I satisfy the equation in the subscript. The function {a mathematical formula}⌈x⌉ is defined as the smallest integer greater than or equal than x. We prove the following corollary of Proposition 21, Proposition 22:</paragraph><paragraph label="Corollary 23">The following inclusions are true:</paragraph><list><list-item label="(i)">{a mathematical formula}QRqj≤⌈nk⌉⊆CR[k-pclauses].</list-item><list-item label="(ii)">{a mathematical formula}QRqj≥n−⌈nk⌉+1⊆CR[k-nclauses].</list-item></list><paragraph label="Proof">The first result is a consequence of Proposition 21 and the fact that {a mathematical formula}⌈nk⌉&lt;nk+1. If all quotas {a mathematical formula}qj≤⌈nk⌉ then for any subset of k issues that might occur in a k-pclause we have that {a mathematical formula}∑jqj≤∑j⌈nk⌉&lt;∑j(nk+1)=n+k.Analogously, referring this time to Proposition 22, we have that for any set of k issues {a mathematical formula}∑jqj≥∑j(n−⌈nk⌉+1)&gt;∑j(n−nk−1+1)=(k−1)n.  □</paragraph><paragraph>The significance of the previous result resides in the fact that the bounds given by those equations are the lowest uniform bounds we can give to quotas to guarantee collective rationality, as we prove in the following corollary:</paragraph><paragraph label="Corollary 24">A uniform quota rule is CR with respect to:</paragraph><list><list-item label="(i)">a k-pclause if and only if{a mathematical formula}q≤⌈nk⌉;</list-item><list-item label="(ii)">a k-nclause if and only if{a mathematical formula}q≥n−⌈nk⌉+1.</list-item></list><paragraph label="Proof">(i) In the case of uniform quota rules the equation in Proposition 21 takes the following form: {a mathematical formula}∑jq=kq&lt;n+k. This holds if and only if {a mathematical formula}q&lt;nk+1, which is equivalent, as remarked in the proof of the previous corollary, to {a mathematical formula}q≤⌈nk⌉.(ii) In the same way, using a single quota in the equation of Proposition 22 we obtain {a mathematical formula}kq&gt;(k−1)n, i.e., {a mathematical formula}q&gt;n−nk which is equivalent to {a mathematical formula}q≥n−⌈nk⌉+1.  □</paragraph><paragraph>Note that the two equations in the previous proposition are incompatible, except for the cases of {a mathematical formula}k=1, as observed after Proposition 22, and {a mathematical formula}k=2 with n being odd, in which case {a mathematical formula}q=n+12. This proves that no uniform quota rule is collectively rational on both positive and negative clauses of a given size larger than 2, except for the case of n odd and {a mathematical formula}q=n+12. This quota rule is known as the majority rule, and it is now time to study this procedure in more detail.</paragraph></section><section label="6.2"><section-title>Clauses of size 2: the majority rule</section-title><paragraph>The majority rule is the uniform quota rule that accepts an issue whenever there are more individuals accepting the issue than rejecting it. The majority rule is perhaps one of the most natural aggregation rules. It is arguably the one that is used most in practical applications, but as we noted in Section 1, it also generates a plethora of paradoxical situations that have been widely studied in the literature.</paragraph><paragraph>In case the number of individuals is odd, the majority rule has a unique definition by setting the quota to {a mathematical formula}q=n+12. As we have seen in Section 2.5, in this case the majority rule is axiomatised by A, I, M{sup:I}, {a mathematical formula}NI and {a mathematical formula}ND for the case of more than two issues. The case of an even number of individuals is more problematic, to account for profiles in which exactly half of the individuals accept an issue and exactly half reject it. We give two different definitions. The weak majority rule with quota {a mathematical formula}q=n2 accepts an issue if and only if at least half of the individuals accepts it. The strict majority rule accept an issue if and only if a strict majority of the individuals accept it, i.e., it is the uniform quota rule with quota {a mathematical formula}q=n+22. The first rule favours acceptance, while the second favours rejection of an issue. In the following sections we will characterise for each of the two cases the set of integrity constraints that are lifted by the corresponding definition of the majority rule.</paragraph><section label="6.2.1"><section-title>Odd number of individuals: the majority rule</section-title><paragraph>In this section we make the assumption that the number of individuals is odd, and we indicate with Maj the uniform quota rule with quota {a mathematical formula}q=n+12. We make the additional assumption that there are at least 3 individuals. The majority rule in the case of 1 individual is the identity function that outputs the ballot received by the only individual.</paragraph><paragraph>Let us begin with a base-line result that proves collective rationality of the majority rule in case the integrity constraint is equivalent to a conjunction of 2-clauses:</paragraph><paragraph label="Proposition 25">The majority rule is in{a mathematical formula}CR[2-clauses].</paragraph><paragraph label="Proof">Let us first consider the case of a single 2-clause {a mathematical formula}ic=ℓj∨ℓk, where {a mathematical formula}ℓj and {a mathematical formula}ℓk are two literals, i.e., atoms or negated atoms. A paradoxical profile for the majority rule with respect to this integrity constraint features a first majority of individuals not satisfying literal {a mathematical formula}ℓj, and a second majority of individuals not satisfying literal {a mathematical formula}ℓk. By the pigeonhole principle these two majorities must have a non-empty intersection, i.e., there exists one individual that does not satisfy both literals {a mathematical formula}ℓj and {a mathematical formula}ℓk, but this is incompatible with the requirement that all individual ballots satisfy ic. To conclude the proof, it is sufficient to observe that if ic is equivalent to a conjunction of two clauses, then all individuals satisfy each of these clauses, and by the previous discussion all these clauses will also be satisfied by the outcome of the majority rule.  □</paragraph><paragraph>An easy corollary of this proposition covers the case of just 2 issues:</paragraph><paragraph label="Corollary 26">If{a mathematical formula}|I|≤2, then the majority rule is in{a mathematical formula}CR[LPS].</paragraph><paragraph label="Proof">This follows immediately from Proposition 25 and Lemma 3. Every given ic for two issues can be put in conjunctive normal form. Since the domain features at most two issues there are only two propositional symbols in the propositional language and thus the normal form consists of a conjunction of clauses of size at most 2.  □</paragraph><paragraph>Many of the classical paradoxes involving the majority rule can be formalised in our framework by means of an integrity constraint that consists of (or is equivalent to) one or more clauses with size bigger than two [19]. As an example, consider the requirement of transitivity in preference aggregation, that in our framework is the integrity constraint {a mathematical formula}pab∧pbc→pac, which is equivalent to a clause of size 3. The paradoxical situation we described in the introduction constitutes another example, in which by using an exact 3-clause {a mathematical formula}¬T1∨¬T2∨A as a rationality assumption we derived a paradoxical situation using the majority rule. We now generalise this observation to a theorem that completes the characterisation of the integrity constraints lifted by the majority rule, proving that these are all and only those formulas that are expressible as conjunctions of 2-clauses. We need some preliminary definitions and a lemma.</paragraph><paragraph>Call a minimally falsifying partial assignment (mifap-assignment) for an integrity constraint ic an assignment to some of the propositional variables that cannot be extended to a satisfying assignment, although each of its proper subsets can.</paragraph><paragraph>We first prove a crucial lemma about mifap-assignments. Given a propositional formula φ, associate with each mifap-assignment ρ for φ a conjunction {a mathematical formula}Cρ=ℓ1∧⋯∧ℓk, where {a mathematical formula}ℓi=pi if {a mathematical formula}ρ(pi)=1 and {a mathematical formula}ℓi=¬pi if {a mathematical formula}ρ(pi)=0 for all propositional symbols {a mathematical formula}pi on which ρ is defined. The conjunction {a mathematical formula}Cρ represents the mifap-assignment ρ and it is clearly inconsistent with φ.{sup:11}</paragraph><paragraph label="Lemma 27">Every non-tautological formula φ is equivalent to{a mathematical formula}(⋀ρ¬Cρ)with ρ ranging over all mifap-assignments of φ.</paragraph><paragraph label="Proof">Let A be a total assignment for φ. Suppose {a mathematical formula}A⊭φ, i.e., A is a falsifying assignment for φ. Since φ is not a tautology there exists at least one such A. By sequentially deleting propositional symbols from the domain of A we eventually find a mifap-assignment {a mathematical formula}ρA for φ included in A. Hence, A falsifies the conjunct associated with {a mathematical formula}ρA, and thus the whole formula {a mathematical formula}(⋀ρ¬Cρ).Assume now {a mathematical formula}A⊨φ but {a mathematical formula}A⊭(⋀ρ¬Cρ). Then there exists a ρ such that {a mathematical formula}A⊨Cρ. This implies that {a mathematical formula}ρ⊆A, as {a mathematical formula}Cρ is a conjunction. Since ρ is a mifap-assignment for φ, i.e., it is a falsifying assignment for φ, this contradicts the assumption that {a mathematical formula}A⊨φ.  □</paragraph><paragraph>We are now able to provide a full characterisation of the set of integrity constraints that are lifted by the majority rule in case the set of individuals is odd{sup:12}:</paragraph><paragraph label="Theorem 28">{a mathematical formula}LF[Maj]=2-clauses.</paragraph><paragraph label="Proof">One direction is entailed by Proposition 25: the majority rule is CR with respect to conjunctions of 2-clauses.For the opposite direction assume that {a mathematical formula}ic∉2-clauses, i.e., that ic is not equivalent to a conjunction of 2-clauses. We now build a paradoxical profile for the majority rule. By Lemma 27 we know that ic is equivalent to the conjunction {a mathematical formula}⋀ρ¬Cρ of all mifap-assignments ρ for ic. We can therefore infer that at least one mifap-assignment {a mathematical formula}ρ⁎ has size &gt;2, for otherwise ic would be equivalent to a conjunction of 2-clauses.Consider now the following profile. Let {a mathematical formula}y1, {a mathematical formula}y2, {a mathematical formula}y3 be three propositional variables that are fixed by {a mathematical formula}ρ⁎. Assume that there are at least 3 individuals. Let the first individual {a mathematical formula}i1 accept the issue associated with {a mathematical formula}y1 if {a mathematical formula}ρ(y1)=0, and reject it otherwise, i.e., let {a mathematical formula}b1,1=1−ρ⁎(y1). Furthermore, let {a mathematical formula}i1 agree with {a mathematical formula}ρ⁎ on the remaining propositional variables. By minimality of {a mathematical formula}ρ⁎, this partial assignment can be extended to a satisfying assignment for ic, and let {a mathematical formula}Bi1 be such an assignment. Repeat the same construction for individual {a mathematical formula}i2, this time changing the value of {a mathematical formula}ρ⁎ on {a mathematical formula}y2 and extending it to a satisfying assignment to obtain {a mathematical formula}Bi2. The same construction for {a mathematical formula}i3, changing the value of {a mathematical formula}ρ⁎ on issue {a mathematical formula}y3 and extending it to a satisfying assignment {a mathematical formula}Bi3. If there are other individuals in {a mathematical formula}N, let individuals {a mathematical formula}i3s+1 have the same ballot {a mathematical formula}Bi1, individuals {a mathematical formula}i3s+2 ballot {a mathematical formula}Bi2 and individuals {a mathematical formula}i3s+3 ballot {a mathematical formula}Bi3. The basic profile for 3 issues and 3 individuals is shown in Table 2.As can be seen from the table, and easily generalised to the case of more than 3 individuals, there is a majority supporting {a mathematical formula}ρ⁎ on every variable on which {a mathematical formula}ρ⁎ is defined. Since {a mathematical formula}ρ⁎ is a mifap-assignment and therefore cannot be extended to an assignment satisfying ic, the majority rule in this profile is not collectively rational with respect to ic.  □</paragraph><paragraph>Recall that this result does not give rise to a characterisation result, i.e., it does not imply that {a mathematical formula}CR[2-clauses]={Maj} (cf. Proposition 9). On the contrary, the class {a mathematical formula}CR[2-clauses] includes all generalised dictatorships. We will provide a characterisation of this class inside the class of quota rules in Section 6.3.</paragraph></section><section label="6.2.2"><section-title>Even number of individuals: weak majority and strict majority</section-title><paragraph>If the aggregation problem features an even number of individuals the majority rule can take two forms, as we have observed at the beginning of Section 6.2. Recall that the weak majority rule (W-Maj) is the uniform quota rule with quota {a mathematical formula}q=n2 while the strict majority rule (S-Maj) has quota {a mathematical formula}q=n+22.</paragraph><paragraph>The main difference to an odd number of individuals is that both the weak and the strict majority rule do not satisfy the axiom of domain-neutrality {a mathematical formula}ND.{sup:13} For what concerns the behaviour with respect to collective rationality, we can prove the following proposition:</paragraph><paragraph label="Proposition 29">W-Maj and S-Maj are CR with respect to{a mathematical formula}L→+ (i.e., 2-clauses in which one literal is negative and one is positive). W-Maj is CR with respect to 2-pclauses. S-Maj is CR with respect to 2-nclauses.</paragraph><paragraph label="Proof">A closer inspection of the proof of Proposition 25 reveals that the case for mixed clauses is also applicable for an even number of individuals. Equivalently, we could get the same result from Theorem 14, since both W-Maj and S-Maj satisfy issue-neutrality and neutrality-monotonicity. The second part of the proposition is a direct consequence of Corollary 24.  □</paragraph><paragraph>Unfortunately, a result analogous to Theorem 28 for the case of an even number of individuals cannot be proved. We therefore refer to the more general result about uniform quota rules proved in the following section (Corollary 31).</paragraph></section></section><section label="6.3"><section-title>General clauses</section-title><paragraph>In this section we present a general result for the collective rationality of an arbitrary quota rule with respect to an arbitrary k-clause. This result generalises our previous results concerning positive and negative clauses, and clauses of size 2. At the end of the section we prove some conclusive characterisations for collectively rational procedures inside the class of quota rules. We prove the following general result for arbitrary k-clauses{sup:14}:</paragraph><paragraph label="Theorem 30">A quota rule is CR with respect to an exact k-clauseicif and only if{a mathematical formula}for issues j that occur positively or negatively inic, or{a mathematical formula}qj=0for some issue j that occurs positively inic, or{a mathematical formula}qj=n+1for issue j that occurs negatively inic.</paragraph><paragraph label="Proof">The case of quota rules being constant on one of the issues (i.e., the case {a mathematical formula}qj=0,n+1) is straightforward. We can therefore assume that all quotas are {a mathematical formula}0&lt;qj&lt;n+1. Suppose now that we can generate a paradoxical profile B for the k-clause ic. The only way to falsify the integrity constraint is to output an assignment {a mathematical formula}F(B) that rejects all issues that occur positively in ic and accepts all the ones that are negative. We therefore concentrate our attention to the subprofile {a mathematical formula}Bk defined by restricting the individual ballots to the k issues occurring in ic.Since individual ballots are rational, there are at least n “correct” symbols in this subprofile, i.e., a 1 for a positive issue or a 0 for a negative one. We refer to such entries with a C in Table 3. We now want to count how many “wrong” symbols are present in this subprofile. As B is a paradoxical profile, all issues that occur negatively in ic have to be accepted. Therefore, for each of those issues at least {a mathematical formula}qj individuals have the wrong symbol, in this case a 1. For the same reason, every issue that occurs positively in ic is rejected, so the profile {a mathematical formula}Bk contains at least {a mathematical formula}n−qj+1 individuals rejecting such issue.Summing up, since the number of cells in this subprofile is nk, we can generate a paradoxical profile if and only if there are enough cells in {a mathematical formula}Bk to account for the minimal number of correct and wrong symbols to generate a paradox. This turns into the equation {a mathematical formula}n+∑jpos(n−qj+1)+∑jnegqj≤nk. By taking the contrapositive of the last statement we get Eq. (1).  □</paragraph><paragraph>It is easy to see that the special cases of positive and negative clauses, i.e., our Proposition 21, Proposition 22, can be obtained as corollaries of Theorem 30. The special case of uniform quota rules is particularly interesting:</paragraph><paragraph label="Corollary 31">A uniform quota rule with{a mathematical formula}q≠0,n+1is CR with respect to a k-clauseicif and only if{a mathematical formula}where{a mathematical formula}k1 (respectively{a mathematical formula}k2) is the number of positive (negative) issues inic.</paragraph><paragraph>Our Corollary 24 can be proved as the special case of {a mathematical formula}k1=k and {a mathematical formula}k1=0, respectively. The other special case of {a mathematical formula}k1=k2 leads to a satisfiable equation only in case of {a mathematical formula}k=2, proving two important facts: First, every uniform quota rule lifts a 2-clause in which one issue is positive and the other is negative, for the equation in this case is always true (it reduces to {a mathematical formula}0&gt;−1). More importantly, it implies that {a mathematical formula}CR[k-clauses] does not contain any uniform quota rule for {a mathematical formula}k&gt;3 when the number of issues is even, since this language includes also k-clauses where exactly half of the issues are negative and half are positive, in which case the equation does not have any solutions.</paragraph><paragraph>We are now ready to prove a characterisation analogous to that of Theorem 28 for uniform (non-constant) quota rules:</paragraph><paragraph label="Proposition 32">Let q be different from{a mathematical formula}0,n+1, and let{a mathematical formula}Fqbe the corresponding uniform quota rule. Then,{a mathematical formula}LF[Fq]is the language for integrity constraints generated from all k-clauses that satisfy Eq.(2).</paragraph><paragraph label="Proof">Let ic be an integrity constraint. By Lemma 27, ic is equivalent to the conjunction of the negation of its mifap-assignments {a mathematical formula}⋀ρ¬Cρ. Hence, {a mathematical formula}Fq is CR with respect to ic if and only if {a mathematical formula}Fq lifts each clause {a mathematical formula}Cρ, and by Corollary 31 this holds if and only if each {a mathematical formula}Cρ satisfies Eq. (2). Thus, {a mathematical formula}Fq is CR with respect to ic if and only if ic is equivalent to a conjunction of clauses satisfying Eq. (2).  □</paragraph><paragraph>Using the equations introduced in this section we are able to prove some interesting results about the characterisation of collectively rational procedures inside the class of quota rules. We have already seen some partial inclusion in Section 6.1 for the language of positive and negative clauses, and we can now prove the following:</paragraph><paragraph label="Proposition 33">If the number of individuals is odd, then{a mathematical formula}CR[2-clauses]∩QR={Maj}.</paragraph><paragraph label="Proof">Let {a mathematical formula}q1 and {a mathematical formula}q2 be two quotas for two distinct issues. Since we assume that every 2-clause is lifted, these two quotas satisfy the following system of equations, obtained by instantiating Eq. (1) to the case of positive, negative, and mixed 2-clauses:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}From the first two equations we obtain {a mathematical formula}q1+q2=n+1, since quotas are integers. From the other equations we obtain {a mathematical formula}|q1−q2|&lt;1, which for integer values entails {a mathematical formula}q1=q2. We can then conclude that {a mathematical formula}q1=q2=⌈n+12⌉, thus obtaining the majority rule.  □</paragraph><paragraph label="Proposition 34">We end this section by proving an expected negative result for the characterisation of general languages of clauses inside the class of quota rules: {a mathematical formula}CR[k-clauses]∩QR=∅for all{a mathematical formula}k&gt;2.</paragraph><paragraph label="Proof">A quota rule in {a mathematical formula}CR[k-clauses] must be CR with respect to both positive and negative clauses, therefore both equations in Proposition 21, Proposition 22 have to be satisfied. But these are unsolvable for {a mathematical formula}k&gt;2. To see this, consider the first equation, which forces {a mathematical formula}∑qj&lt;n+k for any subsets of issues of size k, and the second equation requiring {a mathematical formula}∑qj&gt;(k−1)n on the same subsets. These two equations are compatible only if {a mathematical formula}(k−1)n&lt;n+k, from which we obtain {a mathematical formula}n&lt;kk−2. This in turn is true only if {a mathematical formula}n&lt;3, in contradiction to our assumption that there are at least 3 individuals.  □</paragraph><paragraph>Observe that the equations involved in this proof do not assume that clauses have size strictly smaller than k, hence this result can be strengthened to the language of clauses of size exactly k.</paragraph></section></section><section label="7"><section-title>Discussion</section-title><paragraph>In this section we shall discuss the impact of the results of the present paper on both SCT and AI, summarising also some of the results presented in our previous work [21], [19], [18].</paragraph><paragraph>Preference aggregation [3] and judgment aggregation [29] are amongst the main frameworks for aggregation that are studied in SCT and AI, and the relation between these two frameworks is the object of study of several publications [9], [22], [37]. As previously shown in Examples 1 and 2, both frameworks can be interpreted as instances of binary aggregation by devising suitable integrity constraints. This fact already constitutes a contribution in itself, showing that our setting is a truly general framework for the study of collective rationality in aggregation theory.</paragraph><paragraph>Classical studies in these frameworks have focused on the observation of paradoxical situations and on proving so-called impossibility results, aimed at showing the impossibility of non-paradoxical aggregation under seemingly natural axiomatic conditions. It can be easily seen that classical paradoxes, such as the Condorcet paradox in preference aggregation and the discursive dilemma in judgment aggregation [25], can be viewed as instances of our Definition 4, which stands out as a general definition of paradox in aggregation theory [19]. Moreover, as we shall explain next, the generality of our framework enables us to develop a new proof method for (im)possibility results in SCT. Classical work in SCT studies the existence of aggregation procedures in a given framework for aggregation, once a set of desirable conditions have been identified in a list of axiomatic properties. By translating such aggregation problems into binary aggregation, we are able to identify the source of impossibilities in a clash between the integrity constraint that defines the framework and the axiomatic properties that are being required, making use of characterisation results such as those we presented in this paper. The results that can be obtained by using this proof method may share similarities or may be weaker than known results from the literature on SCT, especially for the case of independent aggregation rules. However, the focus is not on the novelty or strength of specific results, but rather on the generality and flexibility of the proof method we put forward. By unifying proofs in aggregation theory we gain a deeper understanding of the common problem behind many classical results: impossibilities arise from clashes between axiomatic properties and requirements of collective rationality.</paragraph><paragraph>We provided several examples of the use of this method in previous work [21], [18], and we now sketch one such finding for the case of preference aggregation. Recall that aggregation procedures in preference aggregation are called social welfare functions[3], and that they associate a collective preference with every profile of individual orders over a set of alternatives {a mathematical formula}X. Axiomatic properties such as those presented in Section 2.4 can be devised for social welfare functions, and we refer to the relevant literature for their precise definition [17]. We call a social welfare function imposed if for some pair of distinct alternatives a and b we have that a is always collectively preferred to b in every profile. We show the following proposition (a more detailed proof can be found in our previous work [21], [18]):</paragraph><paragraph label="Proposition 35">If{a mathematical formula}|X|≥3and{a mathematical formula}|N|≥2, then any anonymous, independent and monotonic social welfare function for{a mathematical formula}Xand{a mathematical formula}Nis imposed.</paragraph><paragraph label="Proof">Finally, going back to the initial problem, we can conclude that every anonymous, independent and monotonic social welfare function for more than 3 alternatives and 2 individuals is imposed.  □</paragraph><paragraph>Similar results can be obtained in the framework of judgment aggregation. In previous work we were able to strengthen a known characterisation of safe agendas [14] by moving to the realm of binary aggregation and by developing syntactic analogues of the conditions that guarantee consistent aggregation of judgments on a given set of propositional formulas [21], [18].</paragraph><paragraph>One further reason supporting the use of binary aggregation with integrity constraints in applications related to AI has to do with considerations of computational complexity. In recent years the framework of judgment aggregation has received increasing attention in the AI community, especially in its applications to the modelling of multiagent systems. In previous work we presented a preliminary comparison of the computational complexity of both frameworks for a number of basic tasks, showing that binary aggregation is at most as hard as classical judgment aggregation, and it is significantly easier in some situations [18]. The most simple example is the problem of checking the rationality of a given ballot: While for binary aggregation this problem can be solved in polynomial time using model checking, in judgment aggregation the same problem corresponds to the satisfiability of the set of propositional formulas accepted by one of the agents, a much harder problem which is known to be NP-complete.</paragraph><paragraph>Another interesting application is suggested by our Theorem 16. This result identifies an attractive class of aggregation procedures in the class of generalised dictatorships, obtaining procedures that lift all integrity constraints expressible in the language of propositional logic. Interesting procedures can therefore be defined by deciding which of the individual ballots best represent the ballots submitted in a given profile. Inspired by related work in the literature on belief merging [23], in previous work we introduced a new aggregation rule which given a profile B selects those individual ballots that minimise the sum of the Hamming distances from the other individual ballots in B. Formally, the average-voter rule{sup:15} (AVR) is the following non-resolute{sup:16} aggregation procedure:{a mathematical formula} where {a mathematical formula}H(B,B′)=∑j∈I|bj−bj′| is the Hamming distance between binary ballots. Besides being collectively rational for every rationality assumption, this rule also enjoys interesting axiomatic and computational properties [21], [18]. This rule adds to a growing literature on the development of aggregation procedures for binary and judgment aggregation inspired by AI techniques [35], [27].</paragraph></section><section label="8"><section-title>Related work</section-title><paragraph>While the framework of binary aggregation is well-known in the literature on SCT, this paper is the first systematic study of collective rationality with respect to languages for integrity constraints in this setting. Moreover, classical approaches concentrate on Arrovian aggregation procedures, i.e., procedures that are both unanimous and independent, while most of our characterisation results do not make such restrictive assumptions. As we have argued before, while the restriction to Arrovian aggregators is in line with standard assumptions in economics, those assumptions are not always justified in AI applications. In this section we review some of the classical approaches to the problem of collective rationality that can be found in the literature.</paragraph><paragraph>Wilson [40] has been the first to define and study the framework of binary aggregation, in order to obtain an impossibility result for independent aggregation procedures that generalises the more famous result by Arrow [3]. This setting has been investigated more recently by Dokow and Holzman [11] and Nehring and Puppe [33]. In the former work, the authors study the existence of independent, unanimous and non-dictatorial procedures that are collectively rational with respect to certain domain restrictions. As we have remarked at the beginning of this section, our work differs in that we do not concentrate on independent aggregation procedures. Moreover, we exploit our representation of constraints as propositional formulas by defining languages for integrity constraints in a syntactic way, while Nehring and Puppe [11] use a model-based approach: they assume that the set of rational ballots is specified explicitly.</paragraph><paragraph>Results in line with our work of Section 6 can be obtained by restricting the set of aggregation procedures to independent rules alone, focusing on the study of winning coalitions, i.e., those subsets of {a mathematical formula}N that can force acceptance on a given issue. Results in this setting have been proven in the case of judgment aggregation by Nehring and Puppe [32] and generalised by Dietrich and List [10], giving conditions on the structure of winning coalitions to guarantee collective rationality.</paragraph><paragraph>As we already remarked in several places throughout the paper, many of the results on quota rules proved in Section 6 are analogous to those proved by Dietrich and List [10] in the framework of judgment aggregation. The use of integrity constraints, however, enables us to use syntax to analyse possible sources of impossibility, resulting in a flexible framework that is arguably easier to implement.</paragraph><paragraph>A related field of research is that of belief merging [23], [24], in which sets of propositional formulas are aggregated into a collective set. The two frameworks share interesting features, but study different (although related) problems. While binary aggregation imposes an integrity constraint as a rationality assumption for both individual and collective outcomes, in belief merging integrity constraints are enforced only on the outcome. This reflects the view that the integrity constraint is a feasibility requirement rather than a rationality assumption, and should not be enforced on individual preferences or beliefs. Nevertheless, exploring possible ways of combining the two settings constitutes an interesting direction for future work.</paragraph></section><section label="9"><section-title>Conclusions and perspectives</section-title><paragraph>In this paper we have presented a general framework for the study of collective rationality in aggregation theory. Our framework is based on binary aggregation, in which a group of individuals each express a ballot in a binary multi-issue domain, and these ballots are then aggregated into a collective one. The generality of this setting allowed us to model important problems in multiagent systems such as multi-issue elections, preference aggregation, judgment aggregation, and the problem of choosing from a set of candidates. We have formalised rationality assumptions using a simple propositional language, which enables us to classify such formulas in a syntactic way. Depending on the syntactic properties of the rationality assumptions at hand we have then investigated the problem of collective rationality: how can we guarantee, by means of classical axiomatic properties, that the outcome of the aggregation satisfies the same rationality assumption as the individual ballots? We have also studied the opposite problem: we have characterised, given a classical axiomatic requirement for aggregation procedures, the set of integrity constraints that are lifted by all procedures satisfying such properties. In the last part of the paper we have concentrated on quota rules, i.e., procedures defined by means of acceptance quotas for every issue, and especially on the majority rule, obtaining complete characterisations of the set of integrity constraints lifted by such procedures. Our results provide a systematic answer to the question of recognising domains of aggregation over which paradoxes can be avoided, reducing this problem to the syntactical analysis of the propositional formulas that define rationality assumptions. Not only does this allow for a uniform analysis of such diverse problems as preference aggregation, judgment aggregation and multi-issue elections in general, but it also has the advantage of expressing properties in a computation-friendly language such as propositional logic.</paragraph><paragraph>This paper constitutes a first step towards a general application-oriented theory of aggregation, a topic that is crucial to the development of several AI applications and, above all, to the design of multiagent systems. The main achievements of this paper are twofold: First, this work constitutes the first systematic study of collective rationality for non-independent aggregation procedures in binary aggregation. While the literature in SCT has traditionally focused on independent aggregation procedures for preferences or judgments, we provided a truly general setting in which classical frameworks can be interpreted and new results can be provided. Second, to achieve these results we introduced the novel concept of languages for integrity constraints. By developing a complex theoretical machinery around this notion we were able to build a link between classical axiomatic properties and collective rationality, proving interesting characterisations and laying the basis for further investigations of aggregation theory.</paragraph><paragraph>We conclude by pointing out at some possible directions for future work. The framework we developed in this paper can be employed to deepen the current analysis of voting in multi-issue domains, e.g., by developing new voting methods based on preferential dependencies. In this respect, partial achievements have been made by Lang and Xia [28], Conitzer et al. [8], Xia et al. [41] and, in a similar setting, in our previous work [1]. The generality of the framework we proposed in this paper may also suggest that the aggregation of logical structures represents a promising area for future work. We have recently made an initial step in this direction by providing a first study of graph aggregation [13]. A similar problem is that of extending our definitions to cover the case of non-binary issues, e.g. by allowing individuals to abstain on certain issues. Related work has been done in this respect by Dokow and Holzman [12]. The results proved in the present paper should not be interpreted as limiting the possibility of consistent aggregation, but rather as specifying for each application at hand the right conditions that make it possible. Perhaps the most intriguing direction for future research is to employ the machinery developed in this paper to design collectively rational aggregation procedures to tackle complex problems of aggregation that occur in AI applications.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>We wish to thank Daniele Porello and the whole COMSOC group at the University of Amsterdam for fruitful and enthusiastic discussions. We would also like to thank the anonymous reviewers for AAAI-2010, IJCAI-2011 and the Artificial Intelligence journal, as well as the audiences of workshop and seminar talks we have given in Amsterdam, Bucharest, Dagstuhl, Delft, Estoril, Freudenstadt, Groningen, Kraków, Milan, Paris and Venice for their useful comments.</paragraph></acknowledgements><references><reference label="[1]"><authors>S. Airiau,U. Endriss,U. Grandi,D. Porello,J. Uckelman</authors><title>Aggregating dependency graphs into voting agendas in multi-issue elections</title><host>Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI-2011)(2011)</host></reference><reference label="[2]"><authors>A. Altman,M. Tennenholtz</authors><title>Axiomatic foundations for ranking systems</title><host>Journal of Artificial Intelligence Research31 (2008) pp.473-495</host></reference><reference label="[3]"><authors>K.J. Arrow</authors><title>Social Choice and Individual Values</title><host>2nd edition(1963)John Wiley &amp; Sons</host></reference><reference label="[4]"><authors>S.J. Brams,P.C. Fishburn</authors><title>Approval Voting</title><host>2nd edition(2007)Springer</host></reference><reference label="[5]"><authors>F. Cariani,M. Pauly,J. Snyder</authors><title>Decision framing in judgment aggregation</title><host>Synthese163 (2008) pp.1-24</host></reference><reference label="[6]"><authors>Y. Chevaleyre,U. Endriss,J. Lang,N. Maudet</authors><title>A short introduction to computational social choice</title><host>Proceedings of the 33rd Conference on Current Trends in Theory and Practice of Computer Science (SOFSEM-2007)(2007)</host></reference><reference label="[7]"><authors>Y. Chevaleyre,U. Endriss,J. Lang,N. Maudet</authors><title>Preference handling in combinatorial domains: From AI to social choice</title><host>AI Magazine29 (2008) pp.37-46</host></reference><reference label="[8]"><authors>V. Conitzer,J. Lang,L. Xia</authors><title>Hypercubewise preference aggregation in multi-issue domains</title><host>Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI-2011)(2011)</host></reference><reference label="[9]"><authors>F. Dietrich,C. List</authors><title>Arrowʼs theorem in judgment aggregation</title><host>Social Choice and Welfare29 (2007) pp.19-33</host></reference><reference label="[10]"><authors>F. Dietrich,C. List</authors><title>Judgment aggregation by quota rules: Majority voting generalized</title><host>Journal of Theoretical Politics19 (2007) pp.391-424</host></reference><reference label="[11]"><authors>E. Dokow,R. Holzman</authors><title>Aggregation of binary evaluations</title><host>Journal of Economic Theory145 (2010) pp.495-511</host></reference><reference label="[12]"><authors>E. Dokow,R. Holzman</authors><title>Aggregation of binary evaluations with abstentions</title><host>Journal of Economic Theory145 (2010) pp.544-561</host></reference><reference label="[13]"><authors>U. Endriss,U. Grandi</authors><title>Graph aggregation</title><host>Proceedings of the 4th International Workshop on Computational Social Choice (COMSOC-2012)(2012)</host></reference><reference label="[14]"><authors>U. Endriss,U. Grandi,D. Porello</authors><title>Complexity of judgment aggregation: Safety of the agenda</title><host>Proceedings of the 9th International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS-2010)(2010)</host></reference><reference label="[15]"><authors>P. Faliszewski,E. Hemaspaandra,L.A. Hemaspaandra,J. Rothe</authors><title>A richer understanding of the complexity of election systems</title><host>S. RaviS. ShuklaFundamental Problems in Computing: Essays in Honor of Professor Daniel J. Rosenkrantz(2009)Springer</host></reference><reference label="[16]"><authors>P. Faliszewski,A.D. Procaccia</authors><title>AIʼs war on manipulation: Are we winning?</title><host>AI Magazine31 (2010) pp.53-64</host></reference><reference label="[17]"><authors>W. Gaertner</authors><title>A Primer in Social Choice Theory</title><host>(2006)Oxford University Press</host></reference><reference label="[18]">U. GrandiBinary aggregation with integrity constraintsPhD thesis<host>(2012)ILLC, University of Amsterdam</host></reference><reference label="[19]"><authors>U. Grandi</authors><title>The common structure of paradoxes in aggregation theory</title><host>Proceedings of the 4th International Workshop on Computational Social Choice (COMSOC-2012)(2012)</host></reference><reference label="[20]"><authors>U. Grandi,U. Endriss</authors><title>Lifting rationality assumptions in binary aggregation</title><host>Proceedings of the 24th AAAI Conference on Artificial Intelligence (AAAI-2010)(2010)</host></reference><reference label="[21]"><authors>U. Grandi,U. Endriss</authors><title>Binary aggregation with integrity constraints</title><host>Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI-2011)(2011)</host></reference><reference label="[22]"><authors>D. Grossi</authors><title>Unifying preference and judgment aggregation</title><host>Proceedings of the 8th International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS-2009)(2009)</host></reference><reference label="[23]"><authors>S. Konieczny,R. Pino Pérez</authors><title>Merging information under constraints: A logical framework</title><host>Journal of Logic and Computation12 (2002) pp.773-808</host></reference><reference label="[24]"><authors>S. Konieczny,R. Pino Pérez</authors><title>Logic based merging</title><host>Journal of Philosophical Logic40 (2011) pp.239-270</host></reference><reference label="[25]"><authors>L.A. Kornhauser,L.G. Sager</authors><title>Unpacking the court</title><host>Yale Law Journal96 (1986) pp.82-117</host></reference><reference label="[26]"><authors>J. Lang</authors><title>Logical preference representation and combinatorial vote</title><host>Annals of Mathematics and Artificial Intelligence42 (2004) pp.37-71</host></reference><reference label="[27]"><authors>J. Lang,G. Pigozzi,M. Slavkovik,L. van der Torre</authors><title>Judgment aggregation rules based on minimization</title><host>Proceedings of the 13th Conference on Theoretical Aspects of Rationality and Knowledge (TARK-2011)(2011)</host></reference><reference label="[28]"><authors>J. Lang,L. Xia</authors><title>Sequential composition of voting rules in multi-issue domains</title><host>Mathematical Social Sciences57 (2009) pp.304-324</host></reference><reference label="[29]"><authors>C. List,C. Puppe</authors><title>Judgment aggregation: A survey</title><host>Handbook of Rational and Social Choice(2009)Oxford University Press</host></reference><reference label="[30]"><authors>P. Marquis</authors><title>Consequence finding algorithms</title><host>D. GabbayP. SmetsHandbook on Defeasible Reasoning and Uncertainty Management Systems(2000)Kluwer Academic PublishersDordrecht</host></reference><reference label="[31]"><authors>K.O. May</authors><title>A set of independent necessary and sufficient conditions for simple majority decision</title><host>Econometrica20 (1952) pp.680-684</host></reference><reference label="[32]"><authors>K. Nehring,C. Puppe</authors><title>The structure of strategy-proof social choice. Part I: General characterization and possibility results on median spaces</title><host>Journal of Economic Theory135 (2007) pp.269-305</host></reference><reference label="[33]"><authors>K.D. Nehring,C. Puppe</authors><title>Abstract Arrowian aggregation</title><host>Journal of Economic Theory145 (2010) pp.467-494</host></reference><reference label="[34]"><authors>D.M. Pennock,E. Horvitz,C.L. Giles</authors><title>Social choice theory and recommender systems: Analysis of the axiomatic foundations of collaborative filtering</title><host>Proceedings of the 17th National Conference on Artificial Intelligence (AAAI-2000)(2000)</host></reference><reference label="[35]"><authors>G. Pigozzi,M. Slavkovik,L. van der Torre</authors><title>A complete conclusion-based procedure for judgment aggregation</title><host>Proceedings of the First International Conference on Algorithmic Decision Theory (ADT-2009)(2009)</host></reference><reference label="[36]"><authors>M.S. Pini,F. Rossi,K.B. Venable,T. Walsh</authors><title>Aggregating partially ordered preferences</title><host>Journal of Logic and Computation19 (2009) pp.475-502</host></reference><reference label="[37]"><authors>D. Porello</authors><title>Ranking judgments in Arrowʼs setting</title><host>Synthese173 (2010) pp.199-210</host></reference><reference label="[38]"><authors>F. Rossi,K. Venable,T. Walsh</authors><title>mCP Nets: Representing and reasoning with preferences of multiple agents</title><host>Proceedings of the 19th AAAI Conference on Artificial Intelligence (AAAI-2004)(2004)</host></reference><reference label="[39]"><authors>Y. Shoham,K. Leyton-Brown</authors><title>Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations</title><host>(2009)Cambridge University Press</host></reference><reference label="[40]"><authors>R.B. Wilson</authors><title>On the theory of aggregation</title><host>Journal of Economic Theory10 (1975) pp.89-99</host></reference><reference label="[41]"><authors>L. Xia,V. Conitzer,J. Lang</authors><title>Strategic sequential voting in multi-issue domains and multiple-election paradoxes</title><host>Proceedings of the 12th ACM Conference on Electronic Commerce (EC-2011)(2011)</host></reference></references><footnote><note-para label="1">In this definition we represent profiles as functions from the set of individuals {a mathematical formula}N to the domain {a mathematical formula}D, indicating the set of all profiles with {a mathematical formula}DN. Given that in this paper the set of individuals is finite, profiles can also be represented as tuples of binary ballots. However, we decided to use the functional notation to facilitate an eventual generalisation of the framework to allow for infinite sets of individuals.</note-para><note-para label="2">This example is due to Kornhauser and Sager [25].</note-para><note-para label="3">Detailed proofs of Proposition 1 and Proposition 2 can be found in our previous work [18].</note-para><note-para label="4">Many of our results, e.g. Theorems 10 and Corollary 20, still hold if we fix the number of individuals in Definition 5, as shown in our previous work [20].</note-para><note-para label="5">This fact will be later formalised in Lemma 7.</note-para><note-para label="6">This is the standard approach in the literature on binary aggregation (see, e.g., [11]). Our choice of using formulas rather than sets is motivated by the compactness of this representation and by the possibility of using syntax to classify rationality assumptions.</note-para><note-para label="7">The language of 2-clauses can be equivalently defined by closing the set of 2-CNF under logical equivalence.</note-para><note-para label="8">In Section 4 we prove that {a mathematical formula}CR[L] can never be empty for any language {a mathematical formula}L and any set of agents {a mathematical formula}N (see Theorem 16). For the sake of this proof it is sufficient to consider a dictatorship of the first individual.</note-para><note-para label="9">An analogous definition was given by Cariani et al. [5] in the context of judgment aggregation, under the name of rolling dictatorships.</note-para><note-para label="10">This is to exclude from the count redundant subformulas of a clause like {a mathematical formula}pj∨pj or {a mathematical formula}pj∨¬pj.</note-para><note-para label="11">The notion of mifap-assignment corresponds to what are called minimally inconsistent sets in the judgment aggregation literature [29]. For a detailed discussion of the relationship between binary aggregation and judgment aggregation, we refer to our previous work [21], [18]. Formulas {a mathematical formula}¬Cρ associated with mifap-assignments ρ for ic are also known as the prime implicates of ic[30]. Lemma 27 is a reformulation of the known result that a formula is equivalent to the conjunction of its prime implicates.</note-para><note-para label="12">This result may be considered a “syntactic counterpart” of a result by Nehring and Puppe [32], in which it is proved that in the framework of judgment aggregation the majority rule will output a consistent outcome if and only if the set of formulas under consideration satisfies what is called the median property, i.e., that no minimally inconsistent subsets of size ≥3 can be constructed from such formulas.</note-para><note-para label="13">Since they are both uniform quota rules, they still satisfy I, A, {a mathematical formula}NI and {a mathematical formula}MI.</note-para><note-para label="14">This proposition corresponds to a result proved by Dietrich and List [10, Theorem 2c] for quota rules in the framework of judgment aggregation.</note-para><note-para label="15">This rule is called distance-based generalised dictatorship in our previous work [21].</note-para><note-para label="16">That is, it associates with every profile a set of binary ballots rather than a single one. Non-resolute aggregators can be made resolute by the introduction of a tie-breaking rule, e.g., a lexicographic ordering over the domain {a mathematical formula}D.</note-para></footnote></root>