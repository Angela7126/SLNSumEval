<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370216300121</url><title>Broken triangles: From value merging to a tractable class of general-arity constraint satisfaction problems</title><authors>Martin C. Cooper,Aymeric Duchein,Achref El Mouelhi,Guillaume Escamocher,Cyril Terrioux,Bruno Zanuttini</authors><abstract>A binary CSP instance satisfying the broken-triangle property (BTP) can be solved in polynomial time. Unfortunately, in practice, few instances satisfy the BTP. We show that a local version of the BTP allows the merging of domain values in arbitrary instances of binary CSP, thus providing a novel polynomial-time reduction operation. Extensive experimental trials on benchmark instances demonstrate a significant decrease in instance size for certain classes of problems. We show that BTP-merging can be generalised to instances with constraints of arbitrary arity and we investigate the theoretical relationship with resolution in SAT. A directional version of general-arity BTP-merging then allows us to extend the BTP tractable class previously defined only for binary CSP. We investigate the complexity of several related problems including the recognition problem for the general-arity BTP class when the variable order is unknown, finding an optimal order in which to apply BTP merges and detecting BTP-merges in the presence of global constraints such as AllDifferent.</abstract><keywords>CSP;Constraint satisfaction;Domain reduction;Tractable class;Hybrid tractability;NP-completeness;Global constraints</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>At first sight one could assume that the discipline of constraint programming has come of age. On the one hand, efficient solvers are regularly used to solve real-world problems in diverse application domains while, on the other hand, a rich theory has been developed concerning, among other things, global constraints, tractable classes, reduction operations and symmetry. However, there often remains a large gap between theory and practice, which is perhaps most evident when we look at the large number of deep results concerning tractable classes which have yet to find any practical application. The research reported in this paper is part of a long-term project to bridge the gap between theory and practice. Our aim is not only to develop new tools but also to explain why present tools work so well.</paragraph><paragraph>Most research on tractable classes has been based on classes defined by placing restrictions either on the types of constraints [1], [2] or on the constraint hyper-graph whose vertices are the variables and whose hyper-edges are the constraint scopes [3], [4]. Another way of defining classes of binary CSP instances consists of imposing conditions on the microstructure, a graph whose vertices are the possible variable-value assignments with an edge linking each pair of compatible assignments [5], [6]. If each vertex of the microstructure, corresponding to a variable-value assignment {a mathematical formula}〈x,a〉, is labelled (or coloured) by the variable x, then this so-called coloured microstructure retains all information from the original instance. The broken-triangle property (BTP) is a simple local condition on the coloured microstructure which defines a tractable class of binary CSP [7]. The BTP corresponds to forbidding a simple pattern, known as a broken triangle, in the coloured microstructure for a given variable order. Inspired by the BTP, investigation of other forbidden patterns in the coloured microstructure has led to the discovery of new tractable classes [8], [9], [10] as well as new reduction operations based on variable or value elimination [11], [12]. The BTP itself has also been directly generalised in several different ways. For example, it has been shown that under an assumption of strong path consistency, the BTP can be considerably relaxed since not all broken triangles need be forbidden to define a tractable class [13], [14], [15]. Indeed, even without any assumptions of consistency, it is not necessary to forbid all broken triangles [12]. Imposing the BTP in the dual problem leads directly to a tractable class of general-arity CSPs [16]. The BTP has also been generalised to the Broken Angle Property which defines a tractable class of Quantified Constraint Satisfaction Problems [17].</paragraph><paragraph>In this paper we show that the absence of broken triangles on a pair of values in a domain allows us to merge these two values while preserving the satisfiability of the instance. Furthermore, given a solution to the reduced instance, it is possible to find a solution to the original instance in linear time (Section 3). We then investigate the interactions between arc consistency and BTP-merging operations (Section 4) and show that it is NP-hard to find the best sequence of BTP-merging (and arc consistency) operations (Section 5). The effectiveness of BTP-merging in reducing domains in binary CSP benchmark problems is investigated in Section 6. In the second half of the paper we consider general-arity CSPs. Section 7 shows how to generalise BTP-merging to instances containing constraints of any arity (where all constraints are given in the form of either tables, lists of compatible tuples or lists of incompatible tuples). We then go on to consider global constraints, and in particular the AllDifferent constraint, in Section 8. Finally, a directional version of the general-arity BTP allows us to define a tractable class of general-arity CSP instances which is incomparable with the tractable class obtained by directly imposing the BTP in the dual [16] (Section 9). However, on the negative side, we then show that it is NP-complete to determine the existence of a variable order for which an instance falls into this tractable class. The results of Sections 3, 7, 9 and Sections 4, 5 first appeared in two conference papers (respectively [18] and [19]).</paragraph></section><section label="2"><section-title>The Constraint Satisfaction Problem</section-title><paragraph>For simplicity of presentation we use two different representations of constraint satisfaction problems. In the binary case, our notation is fairly standard, whereas in the general-arity case we use a notation close to the representation of SAT instances. This is for presentation only, though, and our algorithms do not need instances to be represented in this manner.</paragraph><paragraph label="Definition 1">A binary CSP instance I consists of</paragraph><list><list-item label="•">a set X of n variables,</list-item><list-item label="•">a domain {a mathematical formula}D(x) of possible values for each variable {a mathematical formula}x∈X,</list-item><list-item label="•">a relation {a mathematical formula}Rxy⊆D(x)×D(y), for each pair of distinct variables {a mathematical formula}x,y∈X, which consists of the set of compatible pairs of values {a mathematical formula}(a,b) for variables {a mathematical formula}(x,y).</list-item></list><paragraph>For simplicity of presentation, Definition 1 assumes that there is exactly one constraint relation for each pair of variables. The number of constraints e is the number of pairs of variables {a mathematical formula}x,y such that {a mathematical formula}Rxy≠D(x)×D(y). An instance I is arc consistent if for each pair of distinct variables {a mathematical formula}x,y∈X, each value {a mathematical formula}a∈D(x) has an AC-support at y, i.e. a value {a mathematical formula}b∈D(y) such that {a mathematical formula}(a,b)∈Rxy.</paragraph><paragraph>In our representation of general-arity CSP instances, we require the notion of tuple which is simply a set of variable-value assignments. For example, in the binary case, the tuple {a mathematical formula}{〈x,a〉,〈y,b〉} is compatible if {a mathematical formula}(a,b)∈Rxy and incompatible otherwise.</paragraph><paragraph label="Definition 2">A (general-arity) CSP instance I consists of</paragraph><list><list-item label="•">a set X of n variables,</list-item><list-item label="•">a domain {a mathematical formula}D(x) of possible values for each variable {a mathematical formula}x∈X,</list-item><list-item label="•">a set NoGoods(I) consisting of incompatible tuples.</list-item></list></section><section label="3"><section-title>Value merging in binary CSP based on the BTP</section-title><paragraph>In this section we consider a method, based on the BTP, for reducing domain size while preserving satisfiability. Instead of eliminating a value, as in classic reduction operations such as arc consistency or neighbourhood substitution, we merge two values. We show that the absence of broken-triangles [7] on two values for a variable x in a binary CSP instance allows us to merge these two values in the domain of x while preserving satisfiability. This rule generalises the notion of virtual interchangeability [20] as well as neighbourhood substitution [21].</paragraph><paragraph>It is known that if for a given variable x in an arc-consistent binary CSP instance I, the set of (in)compatibilities (known as a broken-triangle) shown in Fig. 1 occurs for no two values {a mathematical formula}a,b∈D(x) and no two assignments to two other variables, then the variable x can be eliminated from I without changing the satisfiability of I[7], [11]. In figures, each bullet represents a variable-value assignment, assignments to the same variable are grouped together within the same oval and compatible pairs of assignments are linked by solid lines. In Fig. 1 (and in other figures illustrating forbidden patterns) incompatible pairs of assignments are linked by broken lines. Even when this variable-elimination rule cannot be applied, it may be the case that for a given pair of values {a mathematical formula}a,b∈D(x), no broken triangle occurs. We will show that if this is the case, then we can perform a domain-reduction operation which consists in merging the values a and b.</paragraph><paragraph label="Definition 3">Merging values {a mathematical formula}a,b∈D(x) in a binary CSP consists in replacing {a mathematical formula}a,b in {a mathematical formula}D(x) by a new value c which is compatible with all variable-value assignments compatible with at least one of the assignments {a mathematical formula}〈x,a〉 or {a mathematical formula}〈x,b〉. A value-merging condition is a polytime-computable property {a mathematical formula}P(x,a,b) of assignments {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉 in a binary CSP instance I such that when {a mathematical formula}P(x,a,b) holds, the instance {a mathematical formula}I′ obtained from I by merging {a mathematical formula}a,b∈D(x) is satisfiable if and only if I is satisfiable.</paragraph><paragraph>We now formally define the value-merging condition based on the BTP.</paragraph><paragraph label="Definition 4">A broken triangle on the pair of variable-value assignments {a mathematical formula}a,b∈D(x) consists of a pair of assignments {a mathematical formula}d∈D(y), {a mathematical formula}e∈D(z) to distinct variables {a mathematical formula}y,z∈X∖{x} such that {a mathematical formula}(a,d)∉Rxy, {a mathematical formula}(b,d)∈Rxy, {a mathematical formula}(a,e)∈Rxz, {a mathematical formula}(b,e)∉Rxz and {a mathematical formula}(d,e)∈Ryz. The pair of values {a mathematical formula}a,b∈D(x) is BT-free if there is no broken triangle on {a mathematical formula}a,b.</paragraph><paragraph label="Proposition 5">In a binary CSP instance, being BT-free is a value-merging condition. Furthermore, given a solution to the instance resulting from the merging of two values, we can find a solution to the original instance in linear time.</paragraph><paragraph label="Proof">Let I be the original instance and {a mathematical formula}I′ the new instance in which {a mathematical formula}a,b have been merged into a new value c. Clearly, if I is satisfiable then so is {a mathematical formula}I′. It suffices to show that if {a mathematical formula}I′ has a solution s which assigns c to x, then I has a solution. Let {a mathematical formula}sa, {a mathematical formula}sb be identical to s except that {a mathematical formula}sa assigns a to x and {a mathematical formula}sb assigns b to x. Suppose that neither {a mathematical formula}sa nor {a mathematical formula}sb are solutions to I. Then, there are variables {a mathematical formula}y,z∈X∖{x} such that {a mathematical formula}〈a,s(y)〉∉Rxy and {a mathematical formula}〈b,s(z)〉∉Rxz. By definition of the merging of {a mathematical formula}a,b to produce c, and since s is a solution to {a mathematical formula}I′ containing {a mathematical formula}〈x,c〉, we must have {a mathematical formula}(b,s(y))∈Rxy and {a mathematical formula}(a,s(z))∈Rxz. Finally, {a mathematical formula}(s(y),s(z))∈Ryz since s is a solution to {a mathematical formula}I′. Hence, {a mathematical formula}〈y,s(y)〉, {a mathematical formula}〈z,s(z)〉, {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉 forms a broken-triangle, which contradicts our assumption. Hence, the absence of broken triangles on assignments {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉 allows us to merge these assignments while preserving satisfiability.Reconstructing a solution to I from a solution s to {a mathematical formula}I′ simply requires checking which of {a mathematical formula}sa or {a mathematical formula}sb is a solution to I. Checking if {a mathematical formula}sa or {a mathematical formula}sb is a solution only requires checking the (at most) {a mathematical formula}n−1 binary constraints that include x. Thus finding a solution to the original instance can be achieved in linear time.  □</paragraph><paragraph>We can see that the BTP-merging rule, given by Proposition 5, generalises neighbourhood substitution [21]: if b is neighbourhood substitutable by a, then no broken triangle occurs on {a mathematical formula}a,b and merging a and b produces a CSP instance which is identical (except for the renaming of the value a as c) to the instance obtained by simply eliminating b from {a mathematical formula}D(x). BTP-merging also generalises the merging rule proposed by Likitvivatanavong and Yap [20]. The basic idea behind their rule is that if the two assignments {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉 have identical compatibilities with all assignments to all other variables except concerning at most one other variable, then we can merge a and b. This is clearly subsumed by BTP-merging.</paragraph><paragraph>The BTP-merging operation is not only satisfiability-preserving but, from Proposition 5, we know that we can also reconstruct a solution in polynomial time to the original instance I from a solution to an instance {a mathematical formula}Im to which we have applied a sequence of merging operations until convergence. It is known that for the weaker operation of neighbourhood substitutability, all solutions to the original instance can be generated in {a mathematical formula}O(N(de+n2)) time, where N is the number of solutions to the original instance, n is the number of variables, d the maximum domain size and e the number of constraints [22]. We now show that a similar result also holds for the more general rule of BTP-merging.</paragraph><paragraph label="Proposition 6">Let I be a binary CSP instance and suppose that we are given</paragraph><list><list-item label="•">a sequence of m triples of the form{a mathematical formula}(xi,ai,bi)i=0m−1, implicitly defining a sequence of instances{a mathematical formula}I0=I,I1,⋯,Imsuch that{a mathematical formula}Ii+1is obtained from{a mathematical formula}Iiby BTP-merging values{a mathematical formula}ai,bifor{a mathematical formula}xi({a mathematical formula}i=0,…,m−1),</list-item><list-item label="•">the set of all N solutions to the instance{a mathematical formula}Im.</list-item></list><paragraph label="Proof">We start by computing, for each constraint {a mathematical formula}Rxy in the original instance I, its successive versions {a mathematical formula}Rxyt1,…,Rxytmxy, where {a mathematical formula}t1,…,tmxy∈{1,…,m} record by which BTP-merging operation this version was produced. Since each BTP-merging operation can change only {a mathematical formula}O(n) constraints (those involving {a mathematical formula}xi), this preprocessing step requires time {a mathematical formula}O(mnd2).Now given a solution s to {a mathematical formula}Ii we proceed inductively as follows. If {a mathematical formula}i=0 then we output s, otherwise we test whether {a mathematical formula}sa or {a mathematical formula}sb (or both) are solutions to {a mathematical formula}Ii−1, where {a mathematical formula}sa (resp. {a mathematical formula}sb) is obtained from s by setting {a mathematical formula}xi to {a mathematical formula}ai (resp. to {a mathematical formula}bi), as in the proof of Proposition 5. For each of them found to be a solution to {a mathematical formula}Ii−1, we recurse with {a mathematical formula}Ii−1. This requires {a mathematical formula}O(n) time per step, since again there are at most {a mathematical formula}n−1 constraints to be checked (those involving {a mathematical formula}xi) and these have been precomputed. Finally, since at each step either {a mathematical formula}sa or {a mathematical formula}sb is guaranteed to be a solution to {a mathematical formula}Ii−1, we indeed generate solutions to I with delay {a mathematical formula}O(mn). □</paragraph><paragraph>The weaker operation of neighbourhood substitution has the property that two different convergent sequences of eliminations by neighbourhood substitution necessarily produce isomorphic instances {a mathematical formula}I1m, {a mathematical formula}I2m[22]. This is not the case for BTP-merging. Firstly, and perhaps rather surprisingly, BTP-merging can have as a side-effect to eliminate broken triangles. This is illustrated in the 3-variable instance shown in Fig. 2. In order to avoid cluttering up figures with broken lines linking each pair of incompatible assignments, in all figures illustrating binary CSP instances, we use the convention that those pairs of assignments which are not explicitly linked with a solid line are incompatible. The instance in Fig. 2(a) contains a broken triangle on values {a mathematical formula}a′, {a mathematical formula}b′ for variable z, but after BTP-merging of values {a mathematical formula}a,b∈D(x) into a new value c, as shown in Fig. 2(b), there are no broken triangles in the instance. Secondly, BTP-merging of two values in {a mathematical formula}D(x) can introduce a broken triangle on a variable {a mathematical formula}z≠x, as illustrated in Fig. 3. The instance in Fig. 3(a) contains no broken triangle, but after the BTP-merging of {a mathematical formula}a,b∈D(x) into a new value c, a broken triangle has been created on values {a mathematical formula}a′,b′∈D(z).</paragraph></section><section label="4"><section-title>Mixing arc consistency and BTP-merging</section-title><paragraph>Given the omnipresence of arc consistency in constraint solvers, it is natural to investigate its relationship and interaction with BTP-merging. Values which can be BTP-merged may or may not be arc consistent. Trivially, two values {a mathematical formula}a,b∈D(x) which are compatible with all assignments to all other variables can be BTP-merged, but cannot be eliminated by arc consistency. Conversely, if {a mathematical formula}a∈D(x) has no AC-support at y but otherwise is compatible with all assignments to all other variables, {a mathematical formula}b∈D(x) has no AC-support at {a mathematical formula}z≠y but otherwise is compatible with all assignments to all other variables, and {a mathematical formula}Ryz≠∅, then {a mathematical formula}a,b can both be eliminated by arc consistency but {a mathematical formula}a,b cannot be BTP-merged. Having established the incomparability of arc consistency and BTP-merging, we now investigate their possible interactions.</paragraph><paragraph>We have already observed that BTP-merging is a generalisation of neighbourhood substitutability, since if {a mathematical formula}a∈D(x) is neighbourhood substitutable for {a mathematical formula}b∈D(x) then {a mathematical formula}a,b can be BTP-merged. The possible interactions between arc consistency (AC) and neighbourhood substitution (NS) are relatively simple and can be summarised as follows [22]:</paragraph><list><list-item label="1.">The fact that {a mathematical formula}a∈D(x) is AC-supported or not at variable y remains invariant after the elimination of any other value b (in {a mathematical formula}D(x)∖{a} or in the domain {a mathematical formula}D(z) of any variable {a mathematical formula}z≠x) by neighbourhood substitution.</list-item><list-item label="2.">An arc-consistent value {a mathematical formula}a∈D(x) that is neighbourhood substitutable remains neighbourhood substitutable after the elimination of any other value by arc consistency.</list-item><list-item label="3.">On the other hand, a value {a mathematical formula}a∈D(x) may become neighbourhood substitutable after the elimination of a value {a mathematical formula}c∈D(y) ({a mathematical formula}y≠x) by arc consistency.</list-item></list><paragraph> Indeed, it has been shown that the maximum cumulated number of eliminations by arc consistency and neighbourhood substitution can be achieved by first establishing arc consistency and then applying any convergent sequence of NS eliminations (i.e. any valid sequence of eliminations by neighbourhood substitution until no more NS eliminations are possible) [22].</paragraph><paragraph>The interaction between arc consistency and BTP-merging is not so simple and can be summarised as follows:</paragraph><list><list-item label="1.">The fact that {a mathematical formula}a∈D(x) is AC-supported or not at variable y remains invariant after the BTP-merging of any other pair of other values {a mathematical formula}b,c (in {a mathematical formula}D(x)∖{a} or in the domain {a mathematical formula}D(z) of any variable {a mathematical formula}z≠x). However, after the BTP-merging of two arc-inconsistent values the resulting merged value may be arc consistent. An example is given in Fig. 4(a). In this 3-variable instance, the two values {a mathematical formula}a,b∈D(x) can be eliminated by arc consistency (which in turn leads to the elimination of all values), or alternatively they can be BTP-merged (to produce the new value c) resulting in the instance shown in Fig. 4(b) in which no more eliminations are possible by AC or BTP-merging.</list-item><list-item label="2.">A single elimination by AC may prevent one or more BTP-mergings. An example is given in Fig. 5(a). In this 4-variable instance, if the value b is eliminated by AC, then no other eliminations are possible by AC or BTP-merging in the resulting instance (shown in Fig. 5(b)), whereas if a and b are BTP-merged into a new value d (as shown in Fig. 5(c)) this destroys a broken triangle thus allowing c to be BTP-merged with d (as shown in Fig. 5(d)).</list-item><list-item label="3.">On the other hand, two values in the domain of a variable x may become BTP-mergeable after an elimination of a value {a mathematical formula}d∈D(z) ({a mathematical formula}z≠x) by arc consistency. An example is given in Fig. 6. In this 4-variable instance, initially a and b cannot be BTP-merged (Fig. 6(a)), but after value d is eliminated from {a mathematical formula}D(z) by AC, the broken triangle has disappeared and {a mathematical formula}a,b can be BTP merged (Fig. 6(b)).</list-item></list></section><section label="5"><section-title>The order of BTP-mergings</section-title><paragraph>We saw in Section 3 that BTP-merging can both create and destroy broken triangles. This implies that the choice of the order in which BTP-mergings are applied may affect the total number of merges that can be performed. Unfortunately, maximising the total number of merges in a binary CSP instance turns out to be NP-hard, even when bounding the maximum size of the domains d by a constant as small as 3. For simplicity of presentation, we first prove this for the case in which the instance is not necessarily arc consistent. We will then prove a tighter version, namely NP-hardness of maximising the total number of merges even in arc-consistent instances.</paragraph><paragraph label="Theorem 7">The problem of determining if it is possible to perform k BTP-mergings in a boolean binary CSP instance is NP-complete.</paragraph><paragraph label="Proof">For a given sequence of k BTP-mergings, verifying if this sequence is correct can be performed in {a mathematical formula}O(kn2d2) time because looking for broken triangles for a given couple of values takes {a mathematical formula}O(n2d2). As we can verify a solution in polynomial time, the problem of determining if it is possible to perform k BTP-mergings in a binary CSP instance is in NP. So to complete the proof of NP-completeness it suffices to give a polynomial-time reduction from the well-known 3-SAT problem. Let {a mathematical formula}I3SAT be an instance of 3-SAT (SAT in which each clause contains exactly 3 literals) with variables {a mathematical formula}X1,…,XN and clauses {a mathematical formula}C1,…,CM. We will create a boolean binary CSP instance {a mathematical formula}ICSP which has a sequence of {a mathematical formula}k=3×M mergings if and only if {a mathematical formula}I3SAT is satisfiable.For each variable {a mathematical formula}Xi of {a mathematical formula}I3SAT, we add a new variable {a mathematical formula}zi to {a mathematical formula}ICSP. For each occurrence of {a mathematical formula}Xi in the clause {a mathematical formula}Cj of {a mathematical formula}I3SAT, we add two more variables {a mathematical formula}xij and {a mathematical formula}yij to {a mathematical formula}ICSP. Each {a mathematical formula}D(zi) contains only one value {a mathematical formula}ci and each {a mathematical formula}D(xij) (resp. {a mathematical formula}D(yij)) contains only two values {a mathematical formula}ai and {a mathematical formula}bi (resp. {a mathematical formula}ai′ and {a mathematical formula}bi′). The roles of variables {a mathematical formula}xij and {a mathematical formula}yij are the following:{a mathematical formula}{a mathematical formula}In order to prevent the possibility of merging both {a mathematical formula}(ai,bi) and {a mathematical formula}(ai′,bi′), we define the following constraints for {a mathematical formula}zi, {a mathematical formula}xij and {a mathematical formula}yij: ∀j{a mathematical formula}Rxijzi={(bi,ci)} and {a mathematical formula}Ryijzi={(bi′,ci)}; ∀j ∀k{a mathematical formula}Rxijyik={(ai,ai′)}. These constraints are shown in Fig. 7(a) for a single j (where a pair of points not joined by a solid line are incompatible). By this gadget, we create a broken triangle on each {a mathematical formula}yij when merging values in the {a mathematical formula}xij and vice versa.The idea is that BTP-merging {a mathematical formula}ai and {a mathematical formula}bi in any {a mathematical formula}D(xij) ({a mathematical formula}1≤j≤N) prevents us from BTP-merging {a mathematical formula}ai′ and {a mathematical formula}bi′ in any {a mathematical formula}D(yik) ({a mathematical formula}1≤k≤N), thus ensuring that the value of {a mathematical formula}Xi is the same in each clause in which it occurs. If {a mathematical formula}Xi is prevented from being assigned either false or true according to the rules (1) and (2) (because of the clause gadgets described below), then {a mathematical formula}I3SAT will be detected as unsatisfiable since the total number of merges will be less than {a mathematical formula}3×M.For each clause {a mathematical formula}Ci=(Xj,Xk,Xl), we add the following constraints in order to have at least one of the literals {a mathematical formula}Xj, {a mathematical formula}Xk, {a mathematical formula}Xl true: {a mathematical formula}Ryijyik={(aj′,bk′)}, {a mathematical formula}Ryikyil={(ak′,bl′)} and {a mathematical formula}Ryilyij={(al′,bj′)}. This construction, shown in Fig. 7(b), is such that it allows two mergings on the variables {a mathematical formula}yij, {a mathematical formula}yik, {a mathematical formula}yil before a broken triangle is created. For example, merging {a mathematical formula}aj′, {a mathematical formula}bj′ and then {a mathematical formula}ak′, {a mathematical formula}bk′ creates a broken triangle on {a mathematical formula}ai′, {a mathematical formula}bi′. So a third merging is not possible.If the clause {a mathematical formula}Ci contains a negated literal {a mathematical formula}Xj‾ instead of {a mathematical formula}Xj, it suffices to replace {a mathematical formula}yij by {a mathematical formula}xij. Indeed, Fig. 8 shows the construction for the clause ({a mathematical formula}Xj‾∨Xk∨Xl‾) together with the gadgets for each variable.The maximum number of mergings that can be performed are one per occurrence of each variable in a clause, which is exactly {a mathematical formula}3×M. Given a sequence of {a mathematical formula}3×M mergings in the CSP instance, there is a corresponding solution to {a mathematical formula}I3SAT given by (1) and (2). To give a concrete example, consider the gadget shown in Fig. 8 representing the clause {a mathematical formula}Xj‾∨Xk∨Xl‾. This gadget is made up of three triangles of the type shown in Fig. 7(a). To perform three merges in this gadget, we must perform exactly one merging in each of these triangles. For example, if we merge the pairs of values {a mathematical formula}(aj,bj), {a mathematical formula}(ak,bk) and {a mathematical formula}(al,bl), then this sequence of merges corresponds to the assignment {a mathematical formula}(Xj,Xk,Xl)=(true,true,true) which satisfies the clause. On the other hand, the assignment {a mathematical formula}(Xj,Xk,Xl)=(true,false,true), which does not satisfy the clause, is impossible due to the central triangle of variables (of the type shown in Fig. 7(b)) which prevents us from simultaneously merging the three pairs of values {a mathematical formula}(aj,bj), {a mathematical formula}(ak′,bk′) and {a mathematical formula}(al,bl).The above reduction allows us to code {a mathematical formula}I3SAT as the problem of testing the existence of a sequence of {a mathematical formula}k=3×M mergings in the corresponding instance {a mathematical formula}ICSP. This reduction being polynomial, we have proved the NP-completeness of the problem of determining whether k BTP merges are possible in a boolean binary CSP instance.  □</paragraph><paragraph>The reduction in the proof of Theorem 7 supposes that no arc-consistency operations are used. We will now show that it is possible to modify the reduction so as to prevent the elimination of any values in the instance {a mathematical formula}ICSP by arc-consistency, even when the maximum size of the domains d is bounded by a constant as small as 3. Recall that an arc-consistent instance remains arc-consistent after any number of BTP-mergings.</paragraph><paragraph label="Theorem 8">The problem of determining if it is possible to perform k BTP-mergings in an arc-consistent binary CSP instance is NP-complete, even when only considering binary CSP instances where the size of the domains is bounded by 3.</paragraph><paragraph label="Proof">In order to ensure arc-consistency of the instance {a mathematical formula}ICSP, we add a new value {a mathematical formula}di to the domain of each of the variables {a mathematical formula}xij, {a mathematical formula}yij, {a mathematical formula}zi. However, we cannot simply make {a mathematical formula}di compatible with all values in all other domains, because this would allow all values to be merged with {a mathematical formula}di, destroying in the process the semantics of the reduction.In the three binary constraints concerning the triple of variables {a mathematical formula}xij, {a mathematical formula}yij, {a mathematical formula}zi, we make {a mathematical formula}di compatible with all values in the other two domains except{a mathematical formula}di. In other words, we add the following tuples to constraint relations, as illustrated in Fig. 9:<list>{a mathematical formula}∀i∀j, {a mathematical formula}(ai,di), {a mathematical formula}(bi,di), {a mathematical formula}(di,ci)∈Rxijzi{a mathematical formula}∀i∀j, {a mathematical formula}(ai′,di), {a mathematical formula}(bi′,di), {a mathematical formula}(di,ci)∈Ryijzi{a mathematical formula}∀i∀j, {a mathematical formula}(ai,di), {a mathematical formula}(bi,di), {a mathematical formula}(di,ai′), {a mathematical formula}(di,bi′)∈RxijyijWe can then simply make </list><paragraph>{a mathematical formula}di compatible with all values in the domain of all variables outside this triple of variables. With these constraints we ensure arc consistency without changing any of the properties of {a mathematical formula}ICSP used in the reduction from 3-SAT described in the proof of Theorem 7. For each pair of values {a mathematical formula}ai,bi∈D(xij) and {a mathematical formula}ai′,bi′∈D(yij), no new broken triangle is created since these two values always have the same compatibility with all the new values {a mathematical formula}dk. As we have seen, the constraints shown in Fig. 9 prevent any merging of the new values {a mathematical formula}dk.  □</paragraph></paragraph><paragraph label="Corollary 9">The problem of determining if it is possible to perform k value eliminations by arc consistency and BTP-merging in a binary CSP instance is NP-complete, even when only considering binary CSP instances where the size of the domains is bounded by 3.</paragraph><paragraph>A related question concerns the complexity of finding the optimal order of BTP-mergings within the domain of a single variable. It turns out that this too is NP-complete. The proof of this theorem [19] is based on a similar technique to that used in the proof of Theorem 7.</paragraph><paragraph label="Theorem 10">The problem of determining if it is possible to perform k BTP-mergings within a same domain in a binary CSP instance is NP-complete.</paragraph></section><section label="6"><section-title>Experimental trials</section-title><paragraph>In this section, we study BTP-merging from a practical viewpoint.</paragraph><section label="6.1"><section-title>Experimental protocol</section-title><paragraph>To test the utility of BTP-merging we performed extensive experimental trials on CSP benchmark instances available from the International CP Competition.{sup:1} Among the 7272 CSP benchmark instances, we consider all the instances including only binary constraints (namely 3795 instances). For each of these instances, we performed BTP-mergings until convergence with a time-out of one hour. In total, we obtained results for 2944 instances out of 3795 benchmark instances. In the other instances, the search for all BTP-mergings did not terminate within the time-out. Note that some of the considered instances have constraints defined by predicates. In such cases, these constraints are first expressed in extension before applying the BTP-merging algorithm. The runtime of this transformation is included in the reported runtime.</paragraph><paragraph>BTP-mergings are performed by checking first for virtual interchangeability and then by looking for BTP-mergeable pairs of values. These two steps are repeated until a fixed point is reached. By so doing, the virtual interchangeability step allows us to merge more quickly some pairs of values since the virtual interchangeability rule is easier to check than the BTP rule. Our experiments (not reported here) have shown that this version of BTP-merging is significantly faster than one presented in [18] while leading to a similar number of mergings.</paragraph><paragraph>For the BTP-merging step, we consider the variables according to a given ordering. Among the different variable orderings we tried, we opted in our experimental trials for one which orders the variables according to increasing degree (the degree of a variable being the number of constraints whose scope contains the variable). Note that this ordering differs from the one used in [18] which corresponds to a lexicographical ordering. In practice, we obtain a similar number of mergings with these two orderings but the algorithm is significantly faster with the first one. In general, we observed that the different variable orderings we tried had more impact on runtime than on the number of mergings performed.</paragraph><paragraph>For a given variable x, we check for each pair of values {a mathematical formula}a,b∈D(x) whether {a mathematical formula}a,b are BTP-mergeable. If a broken triangle on {a mathematical formula}a,b is found, we save it in a data structure. Then if, later, we have to check again the BTP-mergeability of {a mathematical formula}a,b, we start with this saved broken triangle. If this triangle is still broken, we can immediately deduce that {a mathematical formula}a,b are not BTP-mergeable, thus avoiding some useless checks. On the other hand, if this triangle is no longer broken, we check whether {a mathematical formula}a,b are BTP-mergeable. If no broken triangle occurs on {a mathematical formula}a,b (that is {a mathematical formula}a,b are BTP-mergeable), we immediately merge {a mathematical formula}a,b. This greedy algorithm is a natural choice since by Theorem 8 it is NP-hard to optimise the order of BTP-merges. For efficiency reasons, when merging {a mathematical formula}a,b, we keep one value (assume without loss of generality that a is this value) and delete the other one instead of creating a new value c and removing a and b as evoked in Definition 3. Then a is made compatible with each variable-value assignment compatible with the assignment {a mathematical formula}〈x,b〉.</paragraph><paragraph>We also implemented the deletion of values by neighbourhood substitution, by virtual interchangeability or by arc-consistency (which is enforced by the AC-2001 algorithm [23]). In the remainder of this section, we denote AC+P the application of AC followed by merging according to the property P where P may be BTP-merging, neighbourhood substitution (NS) or virtual interchangeability (VI). For solving, we use MAC (for Maintaining Arc-Consistency [24]) based on AC-2001 together with the variable ordering heuristic dom/wdeg [25]. The choice of MAC is a natural choice since most state-of-the-art solvers rely on it. All the algorithms are implemented in C++.</paragraph><paragraph>The experimentations were performed on 8 Dell PowerEdge M820 blade servers with two processors (Intel Xeon E5-2609 v2 2.5 GHz and 32 GB of memory) under Linux Ubuntu 14.04.</paragraph></section><section label="6.2"><section-title>Comparisons between BTP-merging and AC+BTP-merging</section-title><paragraph>We compare in this subsection the results obtained by BTP-merging and by AC+BTP-merging. First, as shown in Fig. 10, AC+BTP-merging is able to process (i.e. find a fixed point in which no more BTP-mergings are possible) more instances within the time-out than BTP-merging alone. More precisely, AC+BTP-merging succeeds in terminating within the time-out for 2944 instances against 2856 for BTP-merging. In both cases, for more than one third of these instances, some mergings occur. Fig. 11 compares the percentages of values removed by BTP-merging and AC+BTP-merging for the instances for which both BTP-merging and AC+BTP-merging terminate. Clearly, AC+BTP-merging outperforms BTP-merging since the percentage of values removed by AC+BTP-merging is always greater than or equal to the number of values removed by BTP-merging. We can see that for certain types of problem, (AC+)BTP-merging is very effective (more than 90% of deleted values), whereas for others hardly any merging of values occurred. In particular, we have observed that often the instances for which no merging is possible have some disequality constraints (which makes sense, since even a conjunction of disequality constraints as simple as {a mathematical formula}(x≠y)∧(x≠z)∧(y≠z) with {a mathematical formula}a,b∈D(x),a∈D(y),b∈D(z), induces a broken triangle on {a mathematical formula}a,b). For instance, for the graph colouring instances, (AC+)BTP-mergings only occur when the instances have variables with degree 0 or 1. In contrast, (AC+)BTP-merging is very effective for some real-world instances from frequency assignment problems (fapp*, graph* or scen*) or for some patterned instances (like BlackHole* or os-taillard*). Note that at best, BTP-merging reduces all variable domains to singletons (and so cannot remove all the values in a domain). For example, this is the case for all instances hanoi* which satisfy the broken-triangle property [26]. Table 1, Table 2 provide some detailed results for some selected instances. These instances have been selected in such a way that all observed trends are represented.</paragraph><paragraph>Regarding runtime, BTP-merging and AC+BTP-merging are often close as shown in Fig. 12. However, for a few instances, such as langford-4-14, AC+BTP-merging requires more time than BTP-merging. Such a result is often explained by the fact that the values used to quickly find broken triangles in BTP-merging have been removed by AC in AC+BTP-merging. In contrast, in most cases, achieving an AC preprocessing is useful since it saves time. Moreover, sometimes, it turns out to be very useful since it makes it possible to process more instances. For example, for the instance fapp25-2230-8, the values removed by AC make it possible for the BTP-merging step to terminate. Finally, we can note that a large part of the considered instances are processed quickly. Indeed, for about 57% of instances, achieving (AC+)BTP-merging requires less than one second.</paragraph></section><section label="6.3"><section-title>Comparisons with neighbourhood substitution and virtual interchangeability</section-title><paragraph>As shown in Section 3, the BTP-merging rule generalises the notion of neighbourhood substitution as well as virtual interchangeability. Hence, when we compare the percentage of values removed by BTP-merging with the number of values removed by neighbourhood substitution or virtual interchangeability, BTP-merging is always better than or equivalent to neighbourhood substitution or virtual interchangeability. The same trend is observed when the instances are preprocessed by AC. Fig. 13, Fig. 14 compare the percentage of values removed by BTP-merging and by neighbourhood substitution or virtual interchangeability after having enforced AC. Nevertheless, even when the percentages are equal, we have no guarantee that BTP-merging removes the same values as neighbourhood substitution or virtual interchangeability. So, in order to make a finer comparison, we check, for each BTP-mergeable pair of values, whether neighbourhood substitution or virtual interchangeability may also hold. Table 1 gives these results for a selection of the considered instances. For a few instances, all the values removed by BTP-merging can also be deleted by neighbourhood substitution or virtual interchangeability. In most cases (e.g. for the instances inithx-i-2-28 or mulsol-i-4-31), the removed values belong to domains of variables having a degree 0 or 1. At the opposite extreme, for some instances, such as ehi-85-297-33_ext, none of the values removed by BTP-merging can be removed by neighbourhood substitution or virtual interchangeability. For the majority of instances, BTP-merging removes some values which are removed neither by neighbourhood substitution nor by virtual interchangeability. We observe the same trends when the instances are preprocessed by AC (Table 2).</paragraph></section><section label="6.4"><section-title>Impact on solving</section-title><paragraph>In this subsection, we investigate the impact of removed values on the solving performed by MAC. For these experiments, we only consider those 828 instances which are arc-consistent and for which AC+BTP-merging removes at least one value. First, we observe that MAC with AC+BTP-merging solves 697 instances against 688 for MAC alone within the time-out of one hour. Note that the runtime of MAC with AC+BTP-merging includes the runtime of the solving and the AC+BTP-merging. Fig. 15 provides a comparison of the runtimes of MAC and MAC with AC+BTP-merging for the selected instances. Clearly, for most instances, MAC outperforms MAC with AC+BTP-merging with respect to runtime. This result is clearly due to the cost of achieving AC+BTP-merging which sometimes turns out to be too expensive with respect to the runtime of solving. However, in some cases, MAC with AC+BTP-merging is faster than MAC alone and, overall, is able to solve more instances.</paragraph><paragraph>In order to better assess the impact on solving, we now consider the number of nodes developed by MAC and MAC with AC+BTP-merging. We can see in Fig. 16 that solving by MAC with AC+BTP-merging turns out to be more efficient than we would have thought by just studying the total runtime. Indeed, thanks to the values removed by AC+BTP-merging, MAC with AC+BTP-merging is often able to develop less nodes than MAC alone. The total number of nodes developed by MAC with AC+BTP-merging is 27% less than the total number of nodes developed by MAC (32 millions compared to 44 millions). These preliminary results concerning solving are promising. However, in order to make MAC with AC+BTP-merging competitive, we have now to look for better algorithms for achieving AC+BTP-merging or techniques for identifying which instances could best profit from BTP-merging during preprocessing. Note that the cost of searching for broken triangles precludes using BTP-merging during search.</paragraph><paragraph>An interesting phenomenon which is worthy of further investigation is that the number of nodes in the search tree may actually increase due to merging (since it tends to make constraints less tight) even though domain size has decreased. Likitvivatanavong and Yap [20] mention that search runtime may increase after merging virtual interchangeable values and indeed they observed that the number of instances for which search runtime increased was approximately the same as the number of instances in which search runtime decreased. An open theoretical question concerning the performance of MAC with or without BTP-merging is the existence of conditions under which BTP-merging is guaranteed not to increase the number of nodes in the search tree. Similarly, further experimental trials would be necessary to uncover relationships between the expected gain by BTP-merging and parameters such as average domain size, constraint density and constraint tightness.</paragraph></section></section><section label="7"><section-title>Generalising BTP-merging to constraints of arbitrary arity</section-title><paragraph>In the remainder of the paper, we assume that the constraints of a general-arity CSP instance I are given in the form described in Definition 2, i.e. as a set of incompatible tuples NoGoods(I), where a tuple is a set of variable-value assignments. For simplicity of presentation, we use the predicate Good({a mathematical formula}I,t) which is true iff the tuple t is a partial solution, i.e. t does not contain any pair of distinct assignments to the same variable and {a mathematical formula}∄t′⊆t such that {a mathematical formula}t′∈ NoGoods(I). We first generalise the notion of broken triangle and merging to the general-arity case, before showing that absence of broken triangles allows merging.</paragraph><paragraph label="Definition 11">A general-arity broken triangle (GABT) on values {a mathematical formula}a,b∈D(x) consists of a pair of tuples {a mathematical formula}t,u (containing no assignments to variable x) satisfying the following conditions:</paragraph><list><list-item label="1.">Good({a mathematical formula}I,t∪u) ∧ Good({a mathematical formula}I,t∪{〈x,a〉}) ∧ Good({a mathematical formula}I,u∪{〈x,b〉})</list-item><list-item label="2.">{a mathematical formula}t∪{〈x,b〉}∈ NoGoods(I) ∧ {a mathematical formula}u∪{〈x,a〉}∈ NoGoods(I)</list-item></list><paragraph>A general-arity broken triangle is illustrated in Fig. 17. This figure is identical to Fig. 1 except that {a mathematical formula}Y,Z are now sets of variables and {a mathematical formula}t,u are tuples. Note that the sets Y and Z may overlap. As in the binary case, a dashed line represents a nogood (i.e. a tuple not in the constraint relation on its variables). A solid line now represents a partial solution.</paragraph><paragraph>If the constraints are represented by nogoods, as in our Definition 2, then to decide whether there is a GABT on {a mathematical formula}a,b in a CSP instance, one can use the second condition in Definition 11 and explore all pairs {a mathematical formula}t∪{〈x,b〉},u∪{〈x,a〉}∈ NoGoods(I). On the other hand, if the constraints are represented as lists of allowed tuples, then one can use the first condition in Definition 11 and explore all pairs {a mathematical formula}t∪{〈x,a〉},u∪{〈x,b〉} of tuples explicitly allowed by the constraints in I (since the second condition implies that under this representation, there is a constraint over the variables of t and x, and one over the variables of u and x). Whatever the representation, a pair {a mathematical formula}t,u can be checked to be a GABT on {a mathematical formula}a,b by evaluating the properties of Definition 11, all of which involve only constraint checks. Hence deciding whether a pair {a mathematical formula}a,b is GABT-free is polytime for constraints given in extension (as the set of satisfying assignments) as well as for those given by nogoods (the set of assignments violating the constraint).</paragraph><paragraph label="Definition 12">Merging values {a mathematical formula}a,b∈D(x) in a general-arity CSP instance I consists of replacing {a mathematical formula}a,b in {a mathematical formula}D(x) by a new value c which is compatible with all variable-value assignments compatible with at least one of the assignments {a mathematical formula}〈x,a〉 or {a mathematical formula}〈x,b〉, thus producing an instance {a mathematical formula}I′ with the new set of nogoods defined as follows:{a mathematical formula} A value-merging condition is a polytime-computable property {a mathematical formula}P(x,a,b) of assignments {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉 in a CSP instance I such that when {a mathematical formula}P(x,a,b) holds, the instance {a mathematical formula}I′ is satisfiable if and only if I is satisfiable.</paragraph><paragraph>This merging operation can be performed in polynomial time whether constraints are represented positively in extension or negatively as nogoods. For representations using nogoods this is clear from Definition 12. For representations in extension, simply observe that as in the binary case, the operation amounts to gathering together tuples which satisfy Good({a mathematical formula}I,⋅) and containing {a mathematical formula}〈x,a〉 or {a mathematical formula}〈x,b〉, and setting x to c in them.</paragraph><paragraph label="Proposition 13">In a general-arity CSP instance, being GABT-free is a value-merging condition. Furthermore, given a solution to the instance resulting from the merging of two values, we can find a solution to the original instance in linear time.</paragraph><paragraph label="Proof">In order to prove that satisfiability is preserved by this merging operation, it suffices to show that if s is a solution to {a mathematical formula}I′ containing {a mathematical formula}〈x,c〉, then either {a mathematical formula}sa=(s∖{〈x,c〉})∪{〈x,a〉} or {a mathematical formula}sb=(s∖{〈x,c〉})∪{〈x,b〉} is a solution to I. Suppose, for a contradiction that this is not the case. Then there are tuples {a mathematical formula}t,u⊆s∖{〈x,c〉} such that {a mathematical formula}t∪{〈x,b〉}∈ NoGoods(I) and {a mathematical formula}u∪{〈x,a〉}∈ NoGoods(I). Since {a mathematical formula}t,u are subsets of the solution s to {a mathematical formula}I′ and {a mathematical formula}t,u contain no assignments to x, we have Good({a mathematical formula}I,t∪u). Since {a mathematical formula}t∪{〈x,c〉} is a subset of the solution s to {a mathematical formula}I′, we have {a mathematical formula}t∪{〈x,c〉}∉ NoGoods({a mathematical formula}I′). By the definition of NoGoods({a mathematical formula}I′) given in Definition 12, and since {a mathematical formula}t∪{〈x,b〉}∈ NoGoods(I), we know that {a mathematical formula}∄t′∈ NoGoods(I) such that {a mathematical formula}t′⊆t∪{〈x,a〉}. But then {a mathematical formula}Good(I,t∪{〈x,a〉}). By a symmetric argument, we can deduce {a mathematical formula}Good(I,u∪{〈x,b〉}). This provides the contradiction we were looking for, since we have shown that a general-arity broken triangle occurs on t, u, {a mathematical formula}〈x,a〉, {a mathematical formula}〈x,b〉.Reconstructing a solution to the original instance can be achieved in linear time, since it suffices to verify which (or both) of {a mathematical formula}sa or {a mathematical formula}sb is a solution to I.  □</paragraph><section label="7.1"><section-title>Relationship with resolution in SAT</section-title><paragraph>We now show that in the case of Boolean domains, there is a close relationship between merging two values {a mathematical formula}a,b on which no GABT occurs and a common preprocessing operation used by SAT solvers. Given a propositional CNF formula φ in the form of a set of clauses (each clause {a mathematical formula}Ci being represented as a set of literals) and a variable x occurring in φ, recall that resolution is the process of inferring the clause {a mathematical formula}(C0∪C1) from the two clauses {a mathematical formula}({x¯}∪C0),({x}∪C1). Define the formula {a mathematical formula}Res(x,φ) to be the result of performing all such resolutions on φ, removing all clauses containing x or {a mathematical formula}x¯, and removing subsumed clauses:{a mathematical formula} It is a well-known fact that {a mathematical formula}Res(x,φ) is satisfiable if and only if φ is.</paragraph><paragraph>Eliminating variables in this manner from SAT instances, to get an equisatisfiable formula with less variables, is a common preprocessing step in SAT solving, and is typically performed provided it does not increase the size of the formula [27]. A particular case is when it amounts to simply removing all occurrences of x, which is the case, for instance, if x or {a mathematical formula}x¯ is unit or pure in φ, or if all resolutions on x yield a tautological clause.</paragraph><paragraph label="Definition 14">A variable x is said to be erasable from a CNF φ if{a mathematical formula}</paragraph><paragraph>A CNF φ can be seen as the CSP instance {a mathematical formula}Iφ on the set X of variables occurring in φ, with {a mathematical formula}D(x)={⊤,⊥} for all {a mathematical formula}x∈X, and NoGoods({a mathematical formula}Iφ) {a mathematical formula}={C‾|C∈φ}, where {a mathematical formula}({x1,⋯xp,x¯p+1,⋯,x¯q})‾={〈x1,⊥〉,…,〈xp,⊥〉,〈xp+1,⊤〉,…,〈xq,⊤〉}.</paragraph><paragraph label="Proposition 15">Assume that no GABT occurs on values{a mathematical formula}⊥,⊤for x in{a mathematical formula}Iφ. Assume moreover that no clause in φ is subsumed by another one.{sup:2}Then x is erasable from φ.</paragraph><paragraph label="Proof">Rephrasing Definition 11 (1) in terms of clauses, for any two clauses {a mathematical formula}({x¯}∪C0),({x}∪C1)∈φ we have one of (i) {a mathematical formula}∃C∈φ,C⊆(C0∪C1), (ii) {a mathematical formula}∃C′∈φ,C′⊆(C0∪{x}), or (iii) {a mathematical formula}∃C″∈φ,C″⊆(C1∪{x¯}). Moreover, in Case (ii) {a mathematical formula}C′ must contain x, for otherwise the clause {a mathematical formula}({x¯}∪C0) would be subsumed in φ, contradicting our assumption. Similarly, in Case (iii) {a mathematical formula}C″ must contain {a mathematical formula}x¯.In Case (i) the resolvent {a mathematical formula}(C0∪C1) of {a mathematical formula}({x¯}∪C0),({x}∪C1) is subsumed by C in {a mathematical formula}Res(x,φ), and hence does not occur in it. Similarly, in the second case {a mathematical formula}(C0∪C1) is subsumed by the resolvent of {a mathematical formula}({x¯}∪C0) and {a mathematical formula}C′, which is precisely {a mathematical formula}C0. The third case is dual. We finally have that the only resolvents added are of the form {a mathematical formula}C0 (resp. {a mathematical formula}C1) for some clause {a mathematical formula}({x¯}∪C0) (resp. {a mathematical formula}({x}∪C1)) of φ, as required.  □</paragraph><paragraph>We can show the converse is also true provided that a very reasonable property holds.</paragraph><paragraph label="Proposition 16">Assume that φ satisfies:{a mathematical formula}∀({x}∪C)∈φ,∄C′⊆C,({x¯}∪C′)∈φand dually{a mathematical formula}∀({x¯}∪C)∈φ,∄C′⊆C,({x}∪C′)∈φ. If x is erasable from φ, then no GABT occurs on values{a mathematical formula}⊥,⊤for x in{a mathematical formula}Iφ.</paragraph><paragraph label="Proof">Assume for a contradiction that there is a GABT on values {a mathematical formula}⊥,⊤ for x in {a mathematical formula}Iφ, let {a mathematical formula}t,u be witnesses to this, and write {a mathematical formula}t∪{〈x,⊤〉}=({x¯}∪C0)‾, {a mathematical formula}u∪{〈x,⊥〉}=({x}∪C1)‾. Then the clause {a mathematical formula}(C0∪C1) is produced by resolution on x. Since x is erasable, {a mathematical formula}(C0∪C1) is equal to or subsumed by a clause {a mathematical formula}C∈Res(x,φ), where (applying Definition 14 in reverse) either C, or {a mathematical formula}({x}∪C), or {a mathematical formula}({x¯}∪C) is in φ. The first case contradicts Good({a mathematical formula}Iφ,t∪u), so assume by symmetry {a mathematical formula}({x}∪C)∈φ. From {a mathematical formula}C∉φ and {a mathematical formula}C∈Res(x,φ) we get {a mathematical formula}∃C′⊆C,({x¯}∪C′)∈φ. But then the pair of clauses {a mathematical formula}({x}∪C),({x¯}∪C′)∈φ violates the assumption of the claim.  □</paragraph></section></section><section label="8"><section-title>BTP-merging in the presence of global constraints</section-title><paragraph>Global constraints are an important feature of constraint programming. They not only facilitate modelling of complex problems but many global constraints also have dedicated efficient filtering algorithms [28]. In the presence of global constraints there are specific questions which need to be addressed to know whether BTP-merging is useful. The first thing to verify is that mergings are possible in the presence of one or more global constraints. A second important point is whether these BTP-mergings can be detected in polynomial time. A third point is to determine whether the semantics of the global constraint(s) are preserved by the operation of merging two values. For those global constraints that are decomposable into the conjunction of low-arity constraints, we can also ask whether BTP-merging applied to the decomposed version is equivalent to BTP-merging applied to the original global constraint(s). The answers to these questions depend on the global constraints. This section presents results concerning the important global constraint AllDifferent. These results are both negative and positive.</paragraph><paragraph label="Proposition 17">Determining whether two values can be GABTP-merged in a CSP instance consisting of two AllDifferent constraints is coNP-complete.</paragraph><paragraph label="Proof">It suffices to show that the problem of testing the existence of a general-arity broken triangle (GABT) in a CSP instance consisting of two AllDifferent constraints is NP-complete. We denote this problem by ∃GABT(2AllDiff). Clearly, the validity of a GABT can be checked in polynomial time. Testing the satisfiability of a CSP instance consisting of two AllDifferent constraints (a problem which we denote by CSP(2AllDiff)) is known to be NP-complete [29]. Thus to complete the proof it suffices to exhibit a polynomial reduction from CSP(2AllDiff) to ∃GABT(2AllDiff).Let I be an instance, over variables X, consisting of two AllDifferent constraints with scopes {a mathematical formula}S1,S2. Without loss of generality, we suppose that {a mathematical formula}S1∪S2=X. Let {a mathematical formula}x,y,z be three variables not in X with domains containing only values not occurring in the domains of the variables in X, including {a mathematical formula}a,b∈D(x) with {a mathematical formula}a∈D(y), {a mathematical formula}a∉D(z), {a mathematical formula}b∈D(z), {a mathematical formula}b∉D(z). We construct a new instance {a mathematical formula}I′ with variables {a mathematical formula}X∪{x,y,z}, with domains as in I for variables in X and the domains of variables {a mathematical formula}x,y,z as just described. The instance {a mathematical formula}I′ has just two constraints: AllDifferent constraints with scopes {a mathematical formula}S1∪{y,x} and {a mathematical formula}S2∪{z,x}. We will show that {a mathematical formula}I′ has a GABT on {a mathematical formula}a,b∈D(x) if and only if I has a solution. A GABT on {a mathematical formula}a,b∈D(x) consists of tuples {a mathematical formula}t,u (containing no assignments to variable x) satisfying the following conditions: Good({a mathematical formula}I′,t∪u), Good({a mathematical formula}I′,t∪{〈x,a〉}), Good({a mathematical formula}I′,u∪{〈x,b〉}), {a mathematical formula}t∪{〈x,b〉}∈ NoGoods({a mathematical formula}I′) and {a mathematical formula}u∪{〈x,a〉}∈ NoGoods({a mathematical formula}I′). Since {a mathematical formula}u∪{〈x,a〉}∈ NoGoods({a mathematical formula}I′), but Good({a mathematical formula}I′,u), we must have {a mathematical formula}〈y,a〉∈u, since y is the only variable other than x containing a in its domain. Similarly, we can deduce that {a mathematical formula}〈z,b〉∈t. Now Good({a mathematical formula}I′,t∪u) implies that {a mathematical formula}(t∖{〈z,b〉})∪(u∖{〈y,a〉}) is a solution to I. On the other hand, suppose that s is a solution to I. Let {a mathematical formula}u=s[S1]∪{〈y,a〉} and {a mathematical formula}t=s[S2]∪{〈z,b〉} (where {a mathematical formula}s[S] represents the subset of s corresponding to assignments to variables in S). Then the tuples t and u satisfy the conditions: Good({a mathematical formula}I′,t∪u), Good({a mathematical formula}I′,t∪{〈x,a〉}), Good({a mathematical formula}I′,u∪{〈x,b〉}), {a mathematical formula}t∪{〈x,b〉}∈ NoGoods({a mathematical formula}I′) and {a mathematical formula}u∪{〈x,a〉}∈ NoGoods({a mathematical formula}I′). Thus {a mathematical formula}t,u form a GABT on {a mathematical formula}a,b∈D(x).We have shown that {a mathematical formula}I′ has a GABT on {a mathematical formula}a,b∈D(x) if and only if I has a solution. Since the reduction from CSP(2AllDiff) to ∃GABT(2AllDiff) is clearly polynomial, this completes the proof.  □</paragraph><paragraph>Another problem with merging values in the presence of global constraints is that the global constraint may lose its semantics when values are merged. To give an example, consider an instance I in which a variable x (with domain {a mathematical formula}D(x)=A) occurs in the scope of a single constraint, an AllDifferent constraint on variables X. Since there is only one constraint on variable x, there can be no GABT on any pair of values in {a mathematical formula}D(x). It is easy to see that we can, in fact, GABTP-merge all the values in {a mathematical formula}D(x). When the domain of x becomes a singleton, we can clearly eliminate x. However, the resulting constraint on the variables {a mathematical formula}X∖{x} combines both an AllDifferent constraint on {a mathematical formula}X∖{x} and a constraint which says that the set of values assigned to these variables does not contain all of A. This constraint clearly does not have the same semantics as an AllDifferent constraint. In general, merging values can transform global constraints which have efficient filtering algorithms into new global constraints which do not have efficient filtering algorithms.</paragraph><paragraph>After these negative results, we now give some positive results. It turns out that we can take advantage of the semantics of (global) constraints to reduce the complexity of searching for broken triangles. Suppose that instance I contains only AllDifferent constraints. Instead of looking for GABTP-merges, we can decompose the AllDifferent constraints into binary constraints and look for BTP-merges in the resulting instance {a mathematical formula}Ibin. The presence of a general-arity broken triangle on {a mathematical formula}a,b∈D(x) in I implies the presence of a broken triangle on {a mathematical formula}a,b∈D(x) in {a mathematical formula}Ibin, but the converse is not true. Thus BT-merging in {a mathematical formula}Ibin is a strictly weaker operation than GABT-merging in I. The advantages of BT-merging in {a mathematical formula}Ibin is that (1) it can be detected in linear time, and (2) it conserves the semantics of the AllDifferent constraints, as we will now show.</paragraph><paragraph label="Lemma 18">Suppose that instance I contains only binary difference constraints{a mathematical formula}x≠y. For each variable x, let{a mathematical formula}Sxdenote the set of variables constrained by x. Two distinct values{a mathematical formula}a,bin the domain of a variable x can be BTP-merged if and only if one of the following conditions holds:</paragraph><list><list-item label="1.">there is at most one variable{a mathematical formula}y∈Sxsuch that{a mathematical formula}{a,b}∩Dy≠∅</list-item><list-item label="2.">either{a mathematical formula}∀y∈Sx,{a mathematical formula}a∉Dyor{a mathematical formula}∀y∈Sx,{a mathematical formula}b∉Dy.</list-item></list><paragraph label="Proof">Since I contains only difference constraints, if {a mathematical formula}y,z are two distinct variables in {a mathematical formula}Sx, then the pair of assignments {a mathematical formula}〈y,a〉, {a mathematical formula}〈z,b〉 are necessarily compatible. Furthermore, from Definition 4, a broken triangle on {a mathematical formula}a,b∈D(x) necessarily consists of assignments {a mathematical formula}〈y,a〉, {a mathematical formula}〈z,b〉 where {a mathematical formula}x,y,z are distinct variables. Absence of a broken triangle on {a mathematical formula}a,b∈D(x) is thus equivalent to there being at most one variable {a mathematical formula}y∈Sx such that {a mathematical formula}{a,b}∩Dy≠∅, or {a mathematical formula}∀y∈Sx, {a mathematical formula}a∉Dy or {a mathematical formula}∀y∈Sx, {a mathematical formula}b∉Dy.  □</paragraph><paragraph label="Lemma 19">Suppose that instance I contains only binary difference constraints and that{a mathematical formula}a,b∈D(x)are BT-free. After BT-merging of{a mathematical formula}a,b∈D(x), the variable x can be eliminated without the introduction of new constraints, producing an instance{a mathematical formula}I′which is satisfiable if and only if I is satisfiable.</paragraph><paragraph label="Proof">If {a mathematical formula}y≠x, then {a mathematical formula}∀d∈D(y), {a mathematical formula}〈y,d〉 is either compatible with {a mathematical formula}〈x,a〉 or {a mathematical formula}〈x,b〉, since the only possible constraint between y and x is {a mathematical formula}y≠x. Hence, once {a mathematical formula}a,b∈D(x) are merged, the resulting new value c is compatible with all assignments to all other variables. It follows immediately that x and all binary constraints with x in their scope can be eliminated while preserving the satisfiability of the instance.  □</paragraph><paragraph label="Proposition 20">If I is an instance containing only binary difference constraints, then the result of applying BTP-merges (and eliminating the corresponding variables) until convergence is unique and can be found in{a mathematical formula}O(n2d2)time and{a mathematical formula}O(nd2)space, where d is the maximum domain size.</paragraph><paragraph label="Proof">For each variable x and for each pair of distinct values {a mathematical formula}a,b∈D(x), we can establish in {a mathematical formula}O(n) time three counters {a mathematical formula}N{a}x, {a mathematical formula}N{b}x, {a mathematical formula}N{ab}x, where {a mathematical formula}NAx=|{y|y∈Sx∧A∩D(y)≠∅}|.By Lemma 18, to determine whether {a mathematical formula}a,b can be BTP-merged, it suffices to check whether {a mathematical formula}N{a,b}x≤1 or {a mathematical formula}N{a}x=0 or {a mathematical formula}N{b}x=0. After each BTP-merge, and the elimination of the corresponding variable, the constraints on the remaining variables remain unchanged. Thus, when a variable y is eliminated, due to the BT-merging of two values in its domain, for each variable {a mathematical formula}x∈Sy: for each {a mathematical formula}a∈D(y)∩D(x), we decrement the counter {a mathematical formula}N{a}x and for each pair {a mathematical formula}a,b∈D(x) such that {a mathematical formula}a∈D(y) or {a mathematical formula}b∈D(y), we decrement the counter {a mathematical formula}N{ab}x. Updating these data structures can be achieved in {a mathematical formula}O(nd2) each time a variable y is eliminated. Since at most n variables can be eliminated, the total time complexity is {a mathematical formula}O(n2d2). The space complexity required to store the counters is {a mathematical formula}O(nd2).We now show that all maximal sequences of BTP-merges result in the same instance. For this we observe that if {a mathematical formula}a,b∈D(x) can be BTP-merged in an instance I, and {a mathematical formula}c,d can also be BTP-merged in I, then {a mathematical formula}a,b can be BTP-merged in the instance {a mathematical formula}I′ obtained from I by BTP-merging {a mathematical formula}c,d∈D(y). Indeed, by Lemma 19, the BTP-merge of {a mathematical formula}c,d∈D(y) leads immediately to the elimination of the variable y, and clearly, such elimination cannot invalidate the characterisation of Lemma 18. By symmetry it also holds that {a mathematical formula}c,d can be BTP-merged in the instance obtained from I by BTP-merging {a mathematical formula}a,b, hence the order of BTP-merges does not matter.  □</paragraph><paragraph>We have seen that applying the definition of GABT-merging to CSP instances containing AllDifferent constraints is coNP-complete and can also alter the semantics of the global constraints. However, Lemma 18 provides a weaker form of merging (which is equivalent to BT-merging if the instance contains only AllDifferent constraints that have been decomposed into an equivalent set of binary difference constraints) which can be applied in {a mathematical formula}O(n2d2) time. It is worth pointing out that this is much more efficient than a brute-force application of the definition of BT-merging in a binary CSP instance until convergence, which has worst-case time complexity {a mathematical formula}O(n4d5).</paragraph></section><section label="9"><section-title>A tractable class of general-arity CSP</section-title><paragraph>In binary CSP, the broken-triangle property defines an interesting tractable class when broken triangles are forbidden according to a given variable ordering. Unfortunately, this tractable class was limited to binary CSPs [7]. Section 7 described a general-arity version of the broken-triangle property whose absence on two values allows these values to be merged while preserving satisfiability. An obvious question is whether GABT-freeness can be adapted to define a tractable class. In this section we show that this is possible for a fixed variable ordering, but not if the ordering is unknown.</paragraph><paragraph>Definition 11 defined a general-arity broken triangle (GABT). What happens if we forbid GABTs according to a given variable ordering? Absence of GABTs on two values {a mathematical formula}a,b for the last variable x in the variable ordering allows us to merge a and b while preserving satisfiability. It is possible to show that if GABTs are absent on all pairs of values for x, then we can merge all values in the domain {a mathematical formula}D(x) of x to produce a singleton domain. This is because (as we will show later) merging a and b, to produce a merged value c, cannot introduce a GABT on {a mathematical formula}c,d for any other value {a mathematical formula}d∈D(x). Once the domain {a mathematical formula}D(x) becomes a singleton {a mathematical formula}{a}, we can clearly eliminate x from the instance, by deleting {a mathematical formula}〈x,a〉 from all nogoods, without changing its satisfiability. It is at this moment that GABTs may be introduced on other variables, meaning that forbidding GABTs according to a variable ordering does not define a tractable class.</paragraph><paragraph>Nevertheless, we will show that strengthening the general-arity BTP allows us to avoid this problem. The resulting directional general-arity version of BTP (for a known variable ordering) then defines a tractable class which includes the binary BTP tractable class as a special case.</paragraph><paragraph>Note that the set of general-arity CSP instances whose dual instance satisfies the BTP also defines a tractable class which can be recognised in polynomial time even if the ordering of the variables in the dual instance is unknown [16]. This DBTP class is incomparable with the class we present in the present paper (which is equivalent to BTP in binary CSP) since DBTP is known to be incomparable with the BTP class already in the special case of binary CSP [16]. A general-arity broken triangle can be said to be centred on a pair of values in the domain of a variable whereas a broken triangle in the dual instance is centred on a pair of tuples in a constraint relation. One consequence of this is that eliminating tuples from constraint relations cannot introduce broken triangles in the dual instance, whereas the (directional) GABTP is only invariant under elimination of domain values. On the other hand, the (directional) GABTP is invariant under adding a complete constraint (i.e. whose relation is the direct product of the domains of the variables in its scope) whereas this operation can introduce broken triangles in the dual instance. Another important difference is that directional GABTP depends on an order on the variables whereas DBTP depends on an order on the constraints.</paragraph><section label="9.1"><section-title>Directional general-arity BTP</section-title><paragraph>Recall that we assume that a CSP instance I is given in the form of a set of incompatible tuples NoGoods(I), where a tuple is a set of variable-value assignments, and that the predicate Good({a mathematical formula}I,t) is true iff the tuple t does not contain any pair of distinct assignments to the same variable and {a mathematical formula}∄t′⊆t such that {a mathematical formula}t′∈ NoGoods(I). We suppose given a total ordering &lt; of the variables of a CSP instance I. We write {a mathematical formula}t&lt;x to represent the subset of the tuple t consisting of assignments to variables occurring before x in the order &lt;, and {a mathematical formula}Vars(t) to denote the set of all variables assigned by t.</paragraph><paragraph label="Definition 21">A directional general-arity (DGA) broken triangle on assignments {a mathematical formula}a,b to variable x in a CSP instance I is a pair of tuples {a mathematical formula}t,u (containing no assignments to variable x) satisfying the following conditions:</paragraph><list><list-item label="1.">{a mathematical formula}t&lt;x and {a mathematical formula}u&lt;x are non-empty</list-item><list-item label="2.">Good({a mathematical formula}I,t&lt;x∪u&lt;x) ∧ Good({a mathematical formula}I,t&lt;x∪{〈x,a〉}) ∧ Good({a mathematical formula}I,u&lt;x∪{〈x,b〉})</list-item><list-item label="3.">{a mathematical formula}∃t′ s.t. {a mathematical formula}Vars(t′)=Vars(t)∧(t′)&lt;x=t&lt;x∧{a mathematical formula}t′∪{〈x,a〉}∉ NoGoods(I)</list-item><list-item label="4.">{a mathematical formula}∃u′ s.t. {a mathematical formula}Vars(u′)=Vars(u)∧(u′)&lt;x=u&lt;x∧u′∪{〈x,b〉}∉ NoGoods(I)</list-item><list-item label="5.">{a mathematical formula}t∪{〈x,b〉}∈ NoGoods(I) ∧ {a mathematical formula}u∪{〈x,a〉}∈ NoGoods(I)</list-item></list><paragraph>Points (1), (2) and (5) of Definition 21 are illustrated by Fig. 18. The two important differences compared to a general-arity broken triangle (Fig. 17) are that there is now a variable ordering &lt;, with {a mathematical formula}y&lt;x for all variables {a mathematical formula}y∈Y∪Z, and the two dashed lines now represent nogoods {a mathematical formula}u∪{〈x,a〉} and {a mathematical formula}t∪{〈x,b〉} which possibly involve assignments to variables {a mathematical formula}w&gt;x.</paragraph><paragraph>We will show that any instance I satisfying the DGABTP can be solved in polynomial time by repeatedly alternating the following two operations: (i) merge all values in the last remaining variable (according to the order &lt;); (ii) eliminate this variable when its domain becomes a singleton. We will give the two operations (merging and variable-elimination) and show that both operations preserve satisfiability and that neither of them can introduce DGA broken triangles. Moreover, as for GABT-freeness, the DGABTP can be tested in polynomial time for a given order whether constraints are given as tables of satisfying assignments or as nogoods. Indeed, in the former case, using items (3) and (4) in Definition 21 we can restrict the search for a DGA broken triangle to pairs of tuples satisfying some constraint (there must be a constraint with scope {a mathematical formula}Vars(t′∪{x}) since there is a nogood on these variables by item (5), and similarly for {a mathematical formula}u′). This is sufficient to define a tractable class.</paragraph></section><section label="9.2"><section-title>Merging</section-title><paragraph>Let x be the last variable according to the variable order &lt;. When values {a mathematical formula}a,b in the domain of variable x do not belong to any DGA broken triangle, we can replace {a mathematical formula}a,b by a new value c to produce an instance {a mathematical formula}I′ with the new set of nogoods given by Definition 12. Since x is the last variable in the ordering &lt;, DGA broken triangles on {a mathematical formula}a,b∈D(x) are GA broken triangles (and vice versa). Thus, from Proposition 13 we can deduce that satisfiability is preserved by this merging operation. What remains to be shown is that merging two values in the domain of the last variable cannot introduce the forbidden pattern.</paragraph><paragraph label="Lemma 22">Merging two values{a mathematical formula}a,binto a value c in the domain of the last variable x (according to a DGABTP variable order &lt;) in an instance I cannot introduce a directional general-arity broken triangle (DGABT) in the resulting instance{a mathematical formula}I′.</paragraph><paragraph label="Proof">We first claim that this operation cannot introduce a DGABT on a variable {a mathematical formula}y&lt;x. Indeed, assume there is a DGABT on {a mathematical formula}d,e∈D(y) in {a mathematical formula}I′, that is, that there are tuples {a mathematical formula}v,w such that<list>{a mathematical formula}v&lt;y and {a mathematical formula}w&lt;y are non-emptyGood({a mathematical formula}I′,v&lt;y∪w&lt;y) ∧ Good({a mathematical formula}I′,v&lt;y∪{〈y,d〉}) ∧ Good({a mathematical formula}I′,w&lt;y∪{〈y,e〉}){a mathematical formula}∃v′Vars(v′)=Vars(v)∧(v′)&lt;y=v&lt;y∧{a mathematical formula}v′∪{〈y,d〉}∉ NoGoods({a mathematical formula}I′){a mathematical formula}∃w′Vars(w′)=Vars(w)∧(w′)&lt;y=w&lt;y∧{a mathematical formula}w′∪{〈y,e〉}∉ NoGoods({a mathematical formula}I′){a mathematical formula}v∪{〈y,e〉}∈ NoGoods({a mathematical formula}I′) ∧ {a mathematical formula}w∪{〈y,d〉}∈ NoGoods({a mathematical formula}I′)We now show that a broken triangle cannot be introduced on </list><paragraph>Since in each of the three possible cases, we produced a contradiction, this completes the proof.  □</paragraph></paragraph></section><section label="9.3"><section-title>Tractability of DGABTP for a known variable ordering</section-title><paragraph>We are now in a position to give a new tractable class of general-arity CSP instances based on the DGABTP.</paragraph><paragraph label="Theorem 23">A CSP instance I satisfying the DGABTP on a given variable ordering can be solved in polynomial time.</paragraph><paragraph label="Proof">Suppose that I satisfies the DGABTP for variable ordering &lt; and that x is the last variable according to this ordering. Lemma 22 tells us that DGA broken triangles cannot be introduced by merging all elements in {a mathematical formula}D(x) to form a singleton domain {a mathematical formula}{a}. At this point it may be that {a mathematical formula}{〈x,a〉} is a nogood. In this case the instance is clearly unsatisfiable and the algorithm halts returning this result. If not then we simply delete {a mathematical formula}〈x,a〉 from all nogoods in which it occurs. This operation of variable elimination clearly preserves satisfiability. It is polynomial time to recursively apply this merging and variable elimination algorithm until a nogood corresponding to a singleton domain is discovered or until all variables have been eliminated (in which case I is satisfiable).To complete the proof of correction of this algorithm, it only remains to show that elimination of the last variable x cannot introduce a DGA broken triangle on another variable y. For all tuples {a mathematical formula}t,u and all values {a mathematical formula}c,d∈D(y), none of Good({a mathematical formula}I,t&lt;y∪u&lt;y), Good({a mathematical formula}I,t&lt;y∪{〈y,c〉}) and Good({a mathematical formula}I,u&lt;y∪{〈y,d〉}) can become true due to the variable elimination operation described above. On the other hand it is possible that {a mathematical formula}t∪{〈y,d〉} or {a mathematical formula}u∪{〈y,c〉} becomes a nogood due to variable elimination. Without loss of generality, suppose that {a mathematical formula}t∪{〈y,d〉} becomes a nogood and that {a mathematical formula}t′∪{〈y,d〉} is not a nogood for some {a mathematical formula}t′ such that {a mathematical formula}Vars(t′)=Vars(t) and {a mathematical formula}(t′)&lt;y=t&lt;y. Then by construction there was a nogood {a mathematical formula}t∪{〈y,d〉}∪{〈x,a〉} before the variable x (with singleton domain {a mathematical formula}{a}) was eliminated, and {a mathematical formula}t′∪{〈y,d〉}∪{〈x,a〉} was not a nogood. But then there was a DGA broken triangle (given by tuples {a mathematical formula}t∪{〈x,a〉}, u on values {a mathematical formula}c,d∈D(y)) before elimination of x. This contradiction shows that variable elimination cannot introduce DGA broken triangles.  □</paragraph></section><section label="9.4"><section-title>Finding a DGABTP variable ordering is NP-hard</section-title><paragraph>An important question is the tractability of the recognition problem of the class DGABTP when the variable order is not given, i.e. testing the existence of a variable ordering for which a given instance satisfies the DGABTP. In the case of binary CSP, this test can be performed in polynomial time [7]. Unfortunately, as the following theorem shows, the problem becomes NP-complete in the general-arity case.</paragraph><paragraph>When a DGABTP ordering exists, there is at least one variable x such that all pairs of values {a mathematical formula}a,b∈D(x) are GABT-free. In fact there may be several such variables which are all candidates for being the last variable in the DGABTP ordering. For any such variable x, after merging all values in the domain {a mathematical formula}D(x) so that it becomes a singleton {a mathematical formula}{a}, we can eliminate x from the instance, by deleting {a mathematical formula}〈x,a〉 from all nogoods, without changing its satisfiability. It is at this moment that DGABTs may be introduced on other variables. In the binary case, we can eliminate all such variables without the risk of introducing broken triangles. This is because deleting {a mathematical formula}〈x,a〉 from a binary nogood, such as {a mathematical formula}{〈x,a〉,〈y,b〉}, produces the unary nogood {a mathematical formula}〈y,b〉 corresponding to the elimination of b from {a mathematical formula}D(y) and the DGABTP cannot be destroyed by such domain reductions. In the general-arity case, on the other hand, we cannot use such a greedy algorithm since the elimination of such a variable x may destroy the DGABTP for the as-yet-unknown variable ordering &lt; if x is not the last variable according to &lt;.</paragraph><paragraph label="Theorem 24">Testing the existence of a variable ordering for which a CSP instance satisfies the DGABTP is NP-complete (even if the arity of constraints is at most 5).</paragraph><paragraph label="Proof">The problem is in NP since verifying the DGABTP is polytime for a given order, so it suffices to give a polynomial-time reduction from the well-known NP-complete problem 3SAT. Let {a mathematical formula}I3SAT be an instance of 3SAT with variables {a mathematical formula}X1,…,XN and clauses {a mathematical formula}C1,…,CM. We will create a CSP instance {a mathematical formula}ICSP which has a DGABTP variable-ordering if and only if {a mathematical formula}I3SAT is satisfiable. For each variable {a mathematical formula}Xi of {a mathematical formula}I3SAT, we add two variables {a mathematical formula}xi,yi to {a mathematical formula}ICSP. To complete the set of variables in {a mathematical formula}ICSP, we add three special variables {a mathematical formula}v,w,z. We add constraints to {a mathematical formula}ICSP in such a way that each DGABTP ordering of its variables corresponds to a solution to {a mathematical formula}I3SAT (and vice versa). The role of the variable z is critical: a DGABTP ordering &gt; of the variables of {a mathematical formula}ICSP corresponds to a solution to {a mathematical formula}I3SAT in which {a mathematical formula}Xi=true⇔xi&gt;z. The variables {a mathematical formula}yi are used to code {a mathematical formula}Xi‾: {a mathematical formula}yi&gt;z in a DGABTP ordering if and only if {a mathematical formula}Xi=false in the corresponding solution to {a mathematical formula}I3SAT. The variables {a mathematical formula}v,w are necessary for our construction and will necessarily satisfy {a mathematical formula}v,w&lt;z in a DGABTP ordering. Each clause {a mathematical formula}C=l1∨l2∨l3, where {a mathematical formula}l1,l2,l3 are literals in {a mathematical formula}I3SAT, is imposed in {a mathematical formula}ICSP by adding constraints which force one of {a mathematical formula}l1‾, {a mathematical formula}l2‾, {a mathematical formula}l3‾ to be false. To give a concrete example, if {a mathematical formula}C=X1∨X2∨X3, then constraints are added to {a mathematical formula}ICSP to force {a mathematical formula}y1&lt;z or {a mathematical formula}y2&lt;z or {a mathematical formula}y3&lt;z in a DGABTP ordering. If the clause C contains a negated variable {a mathematical formula}Xi‾ instead of {a mathematical formula}Xi, it suffices to replace {a mathematical formula}yi by {a mathematical formula}xi.We now give in detail the necessary gadgets in {a mathematical formula}ICSP to enforce each of the following properties in a DGABTP ordering:<list>{a mathematical formula}v,w&lt;z{a mathematical formula}yi&lt;z⇔xi&gt;z{a mathematical formula}yi&lt;z or {a mathematical formula}yj&lt;z or {a mathematical formula}yk&lt;zWe give the details of the three types of gadget:</list><list><list-item label="1.">The gadget to force {a mathematical formula}v,w&lt;z in a DGABTP ordering consists of values {a mathematical formula}a0∈D(z), {a mathematical formula}b0,b1∈D(v), {a mathematical formula}c0,c1∈D(w) and three nogoods {a mathematical formula}{〈z,a0〉,〈v,b0〉}, {a mathematical formula}{〈z,a0〉,〈w,c0〉}, {a mathematical formula}{〈v,b1〉,〈w,c1〉}. The only way to satisfy the DGABTP on this triple of variables is to have {a mathematical formula}v,w&lt;z since there are broken triangles on variables v and w.</list-item><list-item label="2.">To force {a mathematical formula}yi&lt;z⇔xi&gt;z in a DGABTP ordering we use two gadgets, the first to force {a mathematical formula}yi&gt;z∨xi&gt;z and the second to force {a mathematical formula}yi&lt;z∨xi&lt;z.The first gadget is a broken triangle consisting of values {a mathematical formula}a1,a2∈D(z), {a mathematical formula}d0∈D(xi), {a mathematical formula}e0∈D(yi) and two nogoods {a mathematical formula}{〈z,a1〉,〈xi,d0〉}, {a mathematical formula}{〈z,a2〉,〈yi,e0〉}. In a DGABTP ordering we must have {a mathematical formula}yi&gt;z∨xi&gt;z.The second gadget consists of values {a mathematical formula}a3,a4∈D(z), {a mathematical formula}b2∈D(v), {a mathematical formula}c2∈D(w), {a mathematical formula}d1∈D(xi), {a mathematical formula}e1∈D(yi) and four nogoods {a mathematical formula}{〈z,a3〉,〈v,b2〉,〈xi,d1〉}, {a mathematical formula}{〈z,a4〉, {a mathematical formula}〈v,b2〉, {a mathematical formula}〈xi,d1〉}, {a mathematical formula}{〈z,a4〉,〈w,c2〉,〈yi,e1〉}, {a mathematical formula}{〈z,a3〉,〈w,c2〉,〈yi,e1〉}. We assume that we have forced {a mathematical formula}v,w&lt;z using the gadget described in point (1). The tuples {a mathematical formula}t={〈v,b2〉,〈xi,d1〉}, {a mathematical formula}u={〈w,c2〉,〈yi,e1〉} then form a DGA broken triangle on assignments {a mathematical formula}a3,a4∈D(z) if {a mathematical formula}xi,yi&gt;z. If either {a mathematical formula}xi&lt;z or {a mathematical formula}yi&lt;z then there is no DGA broken triangle; for example, if {a mathematical formula}xi&lt;z, then we no longer have Good({a mathematical formula}ICSP,t&lt;z∪{〈z,a3〉}) since {a mathematical formula}t&lt;z∪{〈z,a3〉 is precisely the nogood {a mathematical formula}{〈z,a3〉,〈v,b2〉,〈xi,d1〉}. Thus this gadget forces {a mathematical formula}yi&lt;z∨xi&lt;z in a DGABTP ordering.</list-item><list-item label="3.">The gadget to force {a mathematical formula}yi&lt;z or {a mathematical formula}yj&lt;z or {a mathematical formula}yk&lt;z in a DGABTP ordering consists of values {a mathematical formula}a5,a6∈D(z), {a mathematical formula}b3∈D(v), {a mathematical formula}c3∈D(w), {a mathematical formula}e2∈D(yi), {a mathematical formula}e3∈D(yj), {a mathematical formula}e4∈D(yk) and five nogoods: {a mathematical formula}{〈z,a6〉,〈v,b3〉,〈yi,e2〉,〈yj,e3〉,〈yk,e4〉}, {a mathematical formula}{〈z,a5〉,〈w,c3〉}, {a mathematical formula}{〈z,a5〉,〈yi,e2〉}, {a mathematical formula}{〈z,a5〉,〈yj,e3〉}, {a mathematical formula}{〈z,a5〉,〈yk,e4〉}. The tuples {a mathematical formula}t={〈v,b3〉,〈yi,e2〉,〈yj,e3〉,〈yk,e4〉}, {a mathematical formula}u={〈w,c3〉} form a DGA broken triangle on {a mathematical formula}a5,a6∈D(a) if {a mathematical formula}yi,yj,yk&gt;z. If {a mathematical formula}yi&lt;z or {a mathematical formula}yj&lt;z or {a mathematical formula}yk&lt;z, then there is no DGA broken triangle; for example, if {a mathematical formula}yi&lt;z, then we no longer have Good({a mathematical formula}ICSP,t&lt;z∪{〈z,a5〉}) since {a mathematical formula}{〈z,a5〉,〈yi,e2〉} is a nogood. Thus this gadget forces {a mathematical formula}yi&lt;z or {a mathematical formula}yj&lt;z or {a mathematical formula}yk&lt;z in a DGABTP ordering.</list-item></list><paragraph>The above gadgets allow us to code {a mathematical formula}I3SAT as the problem of testing the existence of a DGABTP ordering in the corresponding instance {a mathematical formula}ICSP. To complete the proof it suffices to observe that this reduction is clearly polynomial.  □</paragraph></paragraph><paragraph>Our proof of Theorem 24 used large domains. The question still remains whether it is possible to detect in polynomial time whether a DGABTP variable ordering exists in the case of domains of bounded size, and in particular in the important case of SAT.</paragraph></section></section><section label="10"><section-title>Conclusion</section-title><paragraph>This paper described a novel reduction operation for binary CSP, called BTP-merging, which is strictly stronger than neighbourhood substitution. Experimental trials have shown that in several benchmark-domains, applying BTP-merging until convergence can significantly reduce the total number of variable-value assignments. We gave a general-arity version of BTP-merging and demonstrated a theoretical link with resolution in SAT. From a theoretical point of view, we then went on to define a general-arity version of the tractable class defined by the broken-triangle property for a known variable ordering. Our investigation of the interaction of BTP-merging and AllDifferent constraints has shown that the semantics of binary difference constraints can allow us to speed up the search for BTP-merges. An interesting avenue of future research is to try to take advantage of the semantics of other types of constraints to speed up the search for BTP-merges.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>This research was supported by ANR Project ANR-10-BLAN-0210. Martin Cooper was also supported by EPSRC grant EP/L021226/1.</paragraph></acknowledgements><references><reference label="[1]"><authors>D.A. Cohen,P.G. Jeavons</authors><title>The complexity of constraint languages</title><host>F. RossiP. van BeekT. WalshHandbook of Constraint Programming(2006)Elsevier pp.245-280</host></reference><reference label="[2]"><host>N. CreignouP.G. KolaitisH. VollmerComplexity of Constraints – An Overview of Current Research Themes [Result of a Dagstuhl Seminar]Lect. Notes Comput. Sci.vol. 5250 (2008)Springer</host><host>http://dx.doi.org/10.1007/978-3-540-92800-3</host></reference><reference label="[3]"><authors>M. Grohe</authors><title>The complexity of homomorphism and constraint satisfaction problems seen from the other side</title><host>J. ACM54 (1)(2007)</host><host>http://doi.acm.org/10.1145/1206035.1206036</host></reference><reference label="[4]"><authors>D. Marx</authors><title>Tractable hypergraph properties for constraint satisfaction and conjunctive queries</title><host>J. ACM60 (6)(2013) pp.42-</host><host>http://doi.acm.org/10.1145/2535926</host></reference><reference label="[5]"><authors>P. Jégou</authors><title>Decomposition of domains based on the micro-structure of finite constraint-satisfaction problems</title><host>R. FikesW.G. LehnertProceedings of the 11th National Conference on Artificial IntelligenceWashington, DC, USA, July 11–15, 1993(1993)AAAI Press/The MIT Press pp.731-736</host><host>http://www.aaai.org/Library/AAAI/1993/aaai93-109.php</host></reference><reference label="[6]"><authors>A.Z. Salamon,P.G. Jeavons</authors><title>Perfect constraints are tractable</title><host>P.J. StuckeyPrinciples and Practice of Constraint Programming, Proceedings of the 14th International ConferenceCP 2008, Sydney, Australia, September 14–18, 2008Lect. Notes Comput. Sci.vol. 5202 (2008)Springer pp.524-528</host><host>http://dx.doi.org/10.1007/978-3-540-85958-1_35</host></reference><reference label="[7]"><authors>M.C. Cooper,P.G. Jeavons,A.Z. Salamon</authors><title>Generalizing constraint satisfaction on trees: hybrid tractability and variable elimination</title><host>Artif. Intell.174 (9–10)(2010) pp.570-58410.1016/j.artint.2010.03.002</host></reference><reference label="[8]"><authors>D.A. Cohen,M.C. Cooper,P. Creed,D. Marx,A.Z. Salamon</authors><title>The tractability of CSP classes defined by forbidden patterns</title><host>J. Artif. Intell. Res.45 (2012) pp.47-7810.1613/jair.3651</host></reference><reference label="[9]"><authors>M.C. Cooper,G. Escamocher</authors><title>Characterising the complexity of constraint satisfaction problems defined by 2-constraint forbidden patterns</title><host>Discrete Appl. Math.184 (2015) pp.89-11310.1016/j.dam.2014.10.035</host></reference><reference label="[10]"><authors>M.C. Cooper,S. Živný</authors><title>Tractable triangles and cross-free convexity in discrete optimisation</title><host>J. Artif. Intell. Res.44 (2012) pp.455-49010.1613/jair.3598</host></reference><reference label="[11]"><authors>D.A. Cohen,M.C. Cooper,G. Escamocher,S. Živný</authors><title>Variable and value elimination in binary constraint satisfaction via forbidden patterns</title><host>J. Comput. Syst. Sci.81 (7)(2015) pp.1127-114310.1016/j.jcss.2015.02.001</host></reference><reference label="[12]">M.C. CooperBeyond consistency and substitutabilityin: O'Sullivan [31], pp. 256–271<host>http://dx.doi.org/10.1007/978-3-319-10428-7_20</host></reference><reference label="[13]"><authors>P. Jégou,C. Terrioux</authors><title>The extendable-triple property: a new CSP tractable class beyond BTP</title><host>B. BonetS. KoenigProceedings of the Twenty-Ninth AAAI Conference on Artificial IntelligenceAustin, TX, USA, January 25–30, 2015(2015)AAAI Press pp.3746-3754</host><host>http://www.aaai.org/ocs/index.php/AAAI/AAAI15/paper/view/9939</host></reference><reference label="[14]">M.C. Cooper,P. Jégou,C. TerriouxA microstructure-based family of tractable classes for CSPsin: Pesant [30], pp. 74–88<host>http://dx.doi.org/10.1007/978-3-319-23219-5_6</host></reference><reference label="[15]"><authors>W. Naanaa</authors><title>Unifying and extending hybrid tractable classes of CSPs</title><host>J. Exp. Theor. Artif. Intell.25 (4)(2013) pp.407-42410.1080/0952813X.2012.721138</host></reference><reference label="[16]"><authors>A.E. Mouelhi,P. Jégou,C. Terrioux</authors><title>A hybrid tractable class for non-binary CSPs</title><host>Constraints20 (4)(2015) pp.383-41310.1007/s10601-015-9185-y</host></reference><reference label="[17]"><authors>J. Gao,M. Yin,J. Zhou</authors><title>Hybrid tractable classes of binary quantified constraint satisfaction problems</title><host>W. BurgardD. RothProceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence, AAAI 2011San Francisco, CA, USA, August 7–11, 2011(2011)AAAI Press</host><host>http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/view/3507</host></reference><reference label="[18]">M.C. Cooper,A. El Mouelhi,C. Terrioux,B. ZanuttiniOn broken trianglesin: O'Sullivan [31], pp. 9–24<host>http://dx.doi.org/10.1007/978-3-319-10428-7_5</host></reference><reference label="[19]">M.C. Cooper,A. Duchein,G. EscamocherBroken triangles revisitedin: Pesant [30], pp. 58–73<host>http://dx.doi.org/10.1007/978-3-319-23219-5_5</host></reference><reference label="[20]"><authors>C. Likitvivatanavong,R.H. Yap</authors><title>Eliminating redundancy in CSPs through merging and subsumption of domain values</title><host>ACM SIGAPP Appl. Comput. Rev.13 (2)(2013)</host></reference><reference label="[21]"><authors>E.C. Freuder</authors><title>Eliminating interchangeable values in constraint satisfaction problems</title><host>T.L. DeanK. McKeownProceedings of the 9th National Conference on Artificial IntelligenceAnaheim, CA, USA, July 14–19, 1991vol. 1 (1991)AAAI Press/MIT Press pp.227-233</host><host>http://www.aaai.org/Library/AAAI/1991/aaai91-036.php</host></reference><reference label="[22]"><authors>M.C. Cooper</authors><title>Fundamental properties of neighbourhood substitution in constraint satisfaction problems</title><host>Artif. Intell.90 (1–2)(1997) pp.1-2410.1016/S0004-3702(96)00018-5</host></reference><reference label="[23]"><authors>C. Bessière,J. Régin</authors><title>Refining the basic constraint propagation algorithm</title><host>B. NebelProceedings of the Seventeenth International Joint Conference on Artificial Intelligence, IJCAI 2001Seattle, Washington, USA, August 4–10, 2001(2001)Morgan Kaufmann pp.309-315</host></reference><reference label="[24]"><authors>D. Sabin,E.C. Freuder</authors><title>Contradicting conventional wisdom in constraint satisfaction</title><host>A. BorningPrinciples and Practice of Constraint Programming, Proceedings of the Second International Workshop, PPCP'94Rosario, Orcas Island, Washington, USA, May 2–4, 1994Lect. Notes Comput. Sci.vol. 874 (1994)Springer pp.10-20</host><host>http://dx.doi.org/10.1007/3-540-58601-6_86</host></reference><reference label="[25]"><authors>F. Boussemart,F. Hemery,C. Lecoutre,L. Saïs</authors><title>Boosting systematic search by weighting constraints</title><host>R.L. de MántarasL. SaittaProceedings of the 16th European Conference on Artificial Intelligence, ECAI'2004, Including Prestigious Applicants of Intelligent SystemsPAIS 2004, Valencia, Spain, August 22–27, 2004(2004)IOS Press pp.146-150</host></reference><reference label="[26]"><authors>A. El Mouelhi,P. Jégou,C. Terrioux</authors><title>Hidden tractable classes: from theory to practice</title><host>26th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2014Limassol, Cyprus, November 10–12, 2014(2014)IEEE Computer Society pp.437-445</host><host>http://dx.doi.org/10.1109/ICTAI.2014.73</host></reference><reference label="[27]"><authors>N. Eén,A. Biere</authors><title>Effective preprocessing in SAT through variable and clause elimination</title><host>F. BacchusT. WalshTheory and Applications of Satisfiability Testing, Proceedings of the 8th International Conference, SAT 2005St. Andrews, UK, June 19–23, 2005Lect. Notes Comput. Sci.vol. 3569 (2005)Springer pp.61-75</host><host>http://dx.doi.org/10.1007/11499107_5</host></reference><reference label="[28]"><authors>W.-J. van Hoeve,I. Katriel</authors><title>Global constraints</title><host>F. RossiP. van BeekT. WalshHandbook of Constraint Programming(2006)Elsevier pp.169-208</host></reference><reference label="[29]"><authors>M. Kutz,K.M. Elbassioni,I. Katriel,M. Mahajan</authors><title>Simultaneous matchings: hardness and approximation</title><host>J. Comput. Syst. Sci.74 (5)(2008) pp.884-89710.1016/j.jcss.2008.02.001</host></reference><reference label="[30]"><host>G. PesantPrinciples and Practice of Constraint Programming – Proceedings of the 21st International Conference, CP 2015Cork, Ireland, August 31–September 4, 2015Lect. Notes Comput. Sci.vol. 9255 (2015)Springer</host><host>http://dx.doi.org/10.1007/978-3-319-23219-5</host></reference><reference label="[31]"><host>B. O'SullivanPrinciples and Practice of Constraint Programming – Proceedings of the 20th International Conference, CP 2014Lyon, France, September 8–12, 2014Lect. Notes Comput. Sci.vol. 8656 (2014)Springer</host><host>http://dx.doi.org/10.1007/978-3-319-10428-7</host></reference></references><footnote><note-para label="1">http://www.cril.univ-artois.fr/CPAI08.</note-para><note-para label="2">This is without loss of generality since such clauses can be removed in polytime and such removal preserves logical equivalence.</note-para></footnote></root>