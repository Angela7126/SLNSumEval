<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S000437021400054X</url><title>FLP answer set semantics without circular justifications for general logic programs</title><authors>Yi-Dong Shen,Kewen Wang,Thomas Eiter,Michael Fink,Christoph Redl,Thomas Krennwallner,Jun Deng</authors><abstract>The answer set semantics presented by Faber et al. [27] has been widely used to define so called FLP answer sets for different types of logic programs. However, it was recently observed that when being extended from normal to more general classes of logic programs, this approach may produce answer sets with circular justifications that are caused by self-supporting loops. The main reason for this behavior is that the FLP answer set semantics is not fully constructive by a bottom up construction of answer sets. In this paper, we overcome this problem by enhancing the FLP answer set semantics with a level mapping formalism such that every answer set I can be built by fixpoint iteration of a one-step provability operator (more precisely, an extended van Emden–Kowalski operator for the FLP reduct fΠI). This is inspired by the fact that under the standard answer set semantics, each answer set I of a normal logic program Π is obtainable by fixpoint iteration of the standard van Emden–Kowalski one-step provability operator for the Gelfond–Lifschitz reduct ΠI, which induces a level mapping. The enhanced FLP answer sets, which we call well-justified FLP answer sets, are thanks to the level mapping free of circular justifications. As a general framework, the well-justified FLP answer set semantics applies to logic programs with first-order formulas, logic programs with aggregates, description logic programs, hex-programs etc., provided that the rule satisfaction is properly extended to such general logic programs. We study in depth the computational complexity of FLP and well-justified FLP answer sets for general classes of logic programs. Our results show that the level mapping does not increase the worst-case complexity of FLP answer sets. Furthermore, we describe an implementation of the well-justified FLP answer set semantics, and report about an experimental evaluation, which indicates a potential for performance improvements by the level mapping in practice.</abstract><keywords>Answer set programming;Knowledge representation;Nonmonotonic reasoning;Logic programs with first-order formulas;Level mappings;Circular justifications</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Answer set programming (ASP) is a major logic programming paradigm rooted in knowledge representation and reasoning [47], [50], [43]. It is an emerging approach to modeling and solving search and optimization problems arising in many application areas of AI including planning, reasoning about actions, diagnosis, abduction, and beyond [3], [9]. In ASP, the semantics of a logic program is given by a set of intended models, called stable models or answer sets [33], [34]. In fact, answer sets can be equivalently defined in many different ways (which indicates intrinsic richness of the concept); Lifschitz [44] listed 13 of them, and yet more exist.</paragraph><paragraph>In this paper, we focus on one of the equivalent definitions of answer sets, called FLP answer sets [26], [27], which is widely used. Like the seminal definition by Gelfond and Lifschitz [33], it uses a program reduct, but in contrast it does not modify the rules of a logic program. Informally, given an interpretation I of a logic program Π, its FLP reduct w.r.t. I, denoted {a mathematical formula}fΠI, consists of all ground instances of rules in Π whose bodies are satisfied by I; in analogy to Gelfond and Lifschitz [33], I is then an FLP answer set of Π if I is a minimal model of {a mathematical formula}fΠI.</paragraph><paragraph>This definition has been motivated by giving an answer set semantics to logic programs with aggregates, and due to its simplicity and attractive properties (minimality of models is guaranteed), it can be easily deployed to other extensions of logic programs, provided that rule satisfaction is properly defined. This has been exploited for a variety of logic programs, including logic programs with aggregates or abstract constraint atoms (c-atoms) [26], [27], description logic programs (dl-programs) [25], [24], hex-programs [25], tightly coupled dl-programs [46], modular logic programs [12], and logic programs with first-order formulas [4]. For convenience, we refer to all such extensions of normal logic programs in the unifying framework of the FLP answer set semantics as general logic programs.</paragraph><paragraph>However, it was recently observed that for general logic programs, the FLP answer set semantics may produce answer sets with circular justifications that are caused by self-supporting loops [58], [45]. The following two examples well illustrate this behavior.</paragraph><paragraph label="Example 1">Consider the following logic program with aggregates (borrowed from [60]):{a mathematical formula} For any interpretation I of {a mathematical formula}Π1, the aggregate function {a mathematical formula}SUM〈X:p(X)〉 yields the sum S of all {a mathematical formula}X∈{−1,1,2} such that {a mathematical formula}p(X) is true in I. The aggregate {a mathematical formula}SUM〈X:p(X)〉≥1 is satisfied by I if {a mathematical formula}S≥1. Let {a mathematical formula}I={p(1),p(−1),p(2)}. Since {a mathematical formula}p(X) is true in I for each {a mathematical formula}X∈{−1,1,2}, the aggregate {a mathematical formula}SUM〈X:p(X)〉≥1 is satisfied by I. The FLP reduct of {a mathematical formula}Π1 w.r.t. I is {a mathematical formula}Π1 itself; i.e., {a mathematical formula}fΠ1I=Π1. It is easy to check that I is a minimal model of {a mathematical formula}fΠ1I, so I is an answer set of {a mathematical formula}Π1 under the FLP answer set semantics [27]. Observe that this FLP answer set has a circular justification caused by the following self-supporting loop:{a mathematical formula} That is, {a mathematical formula}p(2) being in I is due to {a mathematical formula}p(−1) being in I (via {a mathematical formula}r2), while {a mathematical formula}p(−1) being in I is due to I satisfying the aggregate {a mathematical formula}SUM〈X:p(X)〉≥1 (via {a mathematical formula}r3). Since the domain of X in the aggregate function is {a mathematical formula}{−1,1,2}, I satisfying {a mathematical formula}SUM〈X:p(X)〉≥1 is due to {a mathematical formula}p(2) being in I (i.e., without {a mathematical formula}p(2), I would not satisfy this aggregate). As a result, {a mathematical formula}p(2) is circularly supported (justified) in I by itself.</paragraph><paragraph label="Example 2">Consider the following logic program with classical logic formulas{sup:1}:{a mathematical formula} Note that the body and head of each rule in {a mathematical formula}Π2 are classical logic formulas. Consider the interpretation {a mathematical formula}I={p(−1),p(1)}. Since the body of rule {a mathematical formula}r1 is not satisfied by I, the FLP reduct of {a mathematical formula}Π2 w.r.t. I is {a mathematical formula}fΠ2I={r2,r3}. I is a minimal model of {a mathematical formula}fΠ2I and thus is an answer set of {a mathematical formula}Π2 under the FLP answer set semantics [4]. Observe that this FLP answer set has a circular justification caused by the following self-supporting loop:{a mathematical formula} That is, {a mathematical formula}p(1) being in I is due to {a mathematical formula}p(−1) being in I (via {a mathematical formula}r3), which in turn is due to I satisfying {a mathematical formula}¬p(−1)∨p(1)∨p(2) (via {a mathematical formula}r2). Since both {a mathematical formula}¬p(−1) and {a mathematical formula}p(2) are false in I, I satisfying {a mathematical formula}¬p(−1)∨p(1)∨p(2) is due to {a mathematical formula}p(1) being in I. Therefore, {a mathematical formula}p(1) is circularly justified in I by itself.</paragraph><paragraph>Our careful study reveals that the fundamental reason behind the circular justification problem for general logic programs is that FLP answer sets can not always be constructed in a bottom up fashion by iterated applications of rules; that is, they might lack a level mapping such that atoms in an answer set at upper levels are derived from atoms at lower levels by iterated applications of rules. We would like to stress that it is such a level mapping on answer sets that makes each if-then rule {a mathematical formula}H←B in a logic program essentially different from an implication {a mathematical formula}B⊃H in classical logic. In fact, for normal logic programs Fages [28] showed that the standard answer set semantics of Gelfond and Lifschitz [33] has a level mapping on its answer sets. Since the FLP answer set semantics agrees with the standard answer set semantics for normal logic programs, answer sets of normal logic programs under the FLP answer set semantics are free of circular justifications.</paragraph><paragraph>In this paper, we remedy the circular justification problem of FLP answer sets for general logic programs by enhancing them with a level mapping formalism. Observe that for a normal logic program Π, each standard answer set I is obtained by fixpoint iteration of the van Emden and Kowalski [64] one-step provability operator for the well-known Gelfond and Lifschitz [33] reduct {a mathematical formula}ΠI; this process naturally induces a level mapping on I. Inspired by this, we define for a general logic program Π answer sets I by fixpoint iteration in a similar way such that a level mapping on I is induced. We first extend the van Emden–Kowalski operator from positive to general logic programs, and then adapt the fixpoint construction of the standard answer set semantics from normal to general logic programs. To this end, we replace the Gelfond–Lifschitz reduct {a mathematical formula}ΠI with the FLP reduct {a mathematical formula}fΠI and iterate the extended van Emden–Kowalski operator on {a mathematical formula}fΠI to obtain its least fixpoint; I is then an answer set if it coincides with this fixpoint.</paragraph><paragraph>We show that such defined answer sets are in fact FLP answer sets which, due to the naturally induced level mapping, are free of circular justifications; furthermore, such answer sets exclude only those FLP answer sets that have circular justifications. For this reason, we call such answer sets well-justified FLP answer sets and the according semantics the well-justified FLP answer set semantics.</paragraph><paragraph>The main contributions of this paper are summarized as follows:</paragraph><list><list-item label="(1)">We define the well-justified FLP answer set semantics for logic programs with first-order formulas. To the best of our knowledge, this is the first answer set semantics that is free of circular justifications for logic programs of this kind. We further extend the well-justified FLP answer set semantics to logic programs with aggregates or c-atoms, i.e. logic programs with rules of the form {a mathematical formula}H←B, where H and B are first-order formulas extended with aggregate atoms or c-atoms. This is also the first answer set semantics that is free of circular justifications for such general logic programs. For logic programs whose rule heads are atoms, in [16], [53] a three-valued fixpoint semantics was introduced, which defines answer sets (called two-valued stable models) that are free of circular justifications. We show that for this class of logic programs the two-valued stable models are well-justified FLP answer sets, but the converse is not true. This means that the two-valued stable models may exclude some FLP answer sets that are free of circular justifications. For normal programs with aggregates or c-atoms, in [60], [59] a conditional satisfaction based answer set semantics was presented that agrees with the three-valued fixpoint semantics. We show that for this particular class of logic programs, the well-justified FLP answer set semantics agrees with the conditional satisfaction based semantics and thus agrees with the three-valued fixpoint semantics.</list-item><list-item label="(2)">We apply the well-justified FLP answer set semantics to dl-programs, which were introduced in [24] as a framework for combining answer set programming with description logics (DLs) [2] for the Semantic Web. A dl-program can be viewed as a normal logic program enhanced with an interface to query an external DL knowledge base. Weak, strong and FLP answer sets are three increasingly restrictive notions of answer sets for dl-programs in [25], [24] that incorporate increasing levels of foundedness. As weak answer sets may be unfounded due to circular justifications by self-supporting positive loops, Eiter et al. [24] introduced strong answer sets which eliminate such unfoundedness. However, strong answer sets might not be minimal models in general, which motivated Eiter et al. to consider FLP answer sets [25]. However, both strong and FLP answer sets admit circular justifications in general, which might be undesired. We therefore introduce well-justified FLP answer sets for dl-programs; this is the first notion of answer sets for dl-programs that are free of circular justifications.</list-item><list-item label="(3)">We study in depth the computational complexity of the ordinary FLP and the well-justified FLP answer set semantics on the problems of answer set existence, cautious reasoning and brave reasoning. Since first-order logic is undecidable, it is clearly undecidable whether an arbitrary general logic program has an ordinary resp. a well-justified FLP answer set, even in absence of function symbols. We focus here on propositional logic programs and consider aggregates that are computable in polynomial time. For dl-programs, we consider three expressive DLs: {a mathematical formula}SHIF(D), {a mathematical formula}SHOIN(D) and {a mathematical formula}SROIQ(D), which are the logical underpinnings of the Web ontology languages OWL Lite, OWL DL [40] and OWL 2 [38], [36], respectively. Our results show that the level mapping of well-justified FLP answer sets does not increase the worst-case complexity.</list-item><list-item label="(4)">We describe an implementation of the well-justified FLP answer set semantics and report about an experimental evaluation which compares the ordinary and the well-justified FLP answer set semantics on a benchmark suite. The results indicate an interesting potential of the well-justified FLP-answer set semantics for performance improvements in practice. Indeed, in a number of cases well-justified FLP answer sets are computed faster than ordinary FLP answer sets; in some cases, few well-justified FLP answer sets exist while in others they coincide with all FLP answer sets. Intuitively, this is connected to the number of iterations in the deterministic fixpoint construction of well-justified FLP answer sets, compared to the non-constructive minimality check for ordinary FLP answer sets. This suggests to search for well-justified FLP answer sets first, and then fall back to ordinary FLP answer sets if no well-justified ones have been found.</list-item></list><paragraph>As a general framework, the well-justified FLP answer set semantics can be easily deployed to other kinds of logic programs, such as hex-programs, tightly coupled dl-programs, modular logic programs, etc., provided that the satisfaction relation is extended to these general logic programs.</paragraph><paragraph>Structure The rest of this paper is organized as follows. In Section 2, we introduce logic programs with first-order formulas and define the ordinary FLP answer set semantics for them. In Section 3, we define level mappings for logic programs with first-order formulas. In Section 4, we introduce the well-justified FLP answer set semantics for such logic programs, while in Sections 5 and 6, we extend the well-justified FLP answer set semantics to logic programs with aggregates and to dl-programs, respectively. In Section 7, we study the computational complexity of the ordinary and the well-justified FLP answer set semantics. We describe in Section 8 our implementation and present an experimental evaluation. In Section 9, we review related work, while in Section 10 we give a summary and present issues for future work. For clarity and in order not to distract from reading, proofs of the results have been moved to Appendix A.</paragraph></section><section label="2"><section-title>A first-order logic language</section-title><paragraph>In this section, we first recall concepts and fix notation for first-order logic under the standard names assumptions, and then introduce logic programs with first-order formulas and their FLP answer set semantics.</paragraph><section label="2.1"><section-title>First-order logic</section-title><paragraph>We denote by {a mathematical formula}LΣ the first-order logic language with equality over signature{a mathematical formula}Σ=(P,F), where {a mathematical formula}P,F are countable sets of predicate and function symbols of arities ≥0, respectively; {a mathematical formula}C⊆F denotes the set of 0-ary function symbols, which are called constants. Given a countable set {a mathematical formula}V of variables, terms and atoms are defined as usual, and formulas are constructed from atoms with connectives ¬, ∧, ∨, ⊃, ≡ and quantifiers ∃ and ∀. Literals are atoms A or their negation ¬A.</paragraph><paragraph>A term, atom or formula is ground if no variable occurs in it; we denote by {a mathematical formula}NΣ and {a mathematical formula}HΣ the sets of all ground terms and ground atoms of Σ, respectively. A formula is closed if it has no free variables (i.e., all variables are in the scope of a quantifier). A (first-order) theory is a set of closed formulas.</paragraph><paragraph>An interpretation of {a mathematical formula}LΣ is a pair {a mathematical formula}I=〈U,.I〉, where U is a domain, and {a mathematical formula}.I is a mapping which assigns to each n-ary predicate symbol {a mathematical formula}p∈P a relation {a mathematical formula}pI⊆Un, and each m-ary function symbol {a mathematical formula}f∈F a function {a mathematical formula}fI:Um→U. A variable assignment B for I is a mapping which assigns an element {a mathematical formula}XB∈U to each variable {a mathematical formula}X∈V. The interpretation of a term t, denoted {a mathematical formula}tI,B, is defined as usual, where B is omitted when t is ground. Satisfaction of a formula F in I relative to B is defined as usual; I is a model of F if I satisfies F for every variable assignment B, and is a model of (or satisfies) a theory O if I is a model of every formula in O. A theory is satisfiable (or consistent) if it has some model. The entailment relation is defined in terms of satisfaction as usual; i.e., a theory O entails a formula F, or F is true in O, denoted {a mathematical formula}O⊨F, if every model of O is a model of F.</paragraph><section label="2.1.1"><section-title>Standard Names Assumption (SNA)</section-title><paragraph>In order to access in {a mathematical formula}I=〈U,.I〉 all elements of the domain U by name, we employ the standard names assumption, cf. [49], [14], i.e., (1) Σ includes a countably infinite set of constants and the binary equality predicate symbol ≈, (2) {a mathematical formula}U=NΣ and {a mathematical formula}tI=t for each {a mathematical formula}t∈NΣ, and (3) {a mathematical formula}≈I is a congruence relation over U, i.e., a reflexive, symmetric and transitive relation that allows replacement of equals by equals.</paragraph><paragraph>In such interpretations I, which are called SNA interpretations, every variable assignment over the domain U amounts to a substitution of variables over {a mathematical formula}NΣ. Moreover, since {a mathematical formula}pI⊆NΣn for each n-ary predicate symbol {a mathematical formula}p∈P, the SNA interpretations of {a mathematical formula}LΣ are in 1–1 correspondence with the subsets of {a mathematical formula}HΣ. We thus view each SNA interpretation I as a subset of {a mathematical formula}HΣ, such that I satisfies a ground atom A if {a mathematical formula}A∈I, and satisfies ¬A if {a mathematical formula}A∉I.</paragraph><paragraph>It is well-known that SNA interpretations preserve satisfiability, i.e., a first-order formula is satisfiable if and only if it is satisfiable in a model employing the standard name assumption, cf. [32]. Therefore, in the sequel we consider only SNA interpretations {a mathematical formula}I⊆HΣ; for convenience, we let {a mathematical formula}I−=HΣ∖I and {a mathematical formula}¬I−={¬A|A∈I−} and refer with “function symbols” tacitly to function symbols of positive arity ({a mathematical formula}m&gt;0).</paragraph></section></section><section label="2.2"><section-title>Logic programs with first-order formulas</section-title><paragraph>We extend the language {a mathematical formula}LΣ with rules of the form {a mathematical formula}H←B, where H and B are first order formulas. Such a rule r expresses an if-then statement, saying that if the logic property B holds, then infer H. We then define:</paragraph><paragraph label="Definition 1">A logic program with first-order formulas (briefly, logic program) is a finite set of rules. It is a normal logic program if each rule is of the form{a mathematical formula} where each {a mathematical formula}Ai is an atom without equality and function symbols, and a positive logic program if moreover {a mathematical formula}m=n.</paragraph><paragraph>For a rule r of the form {a mathematical formula}H←B, we use {a mathematical formula}body(r) to refer to B, which may be empty (in that case, we omit ←), and {a mathematical formula}head(r) to refer to H; if r is of the form (1), we use {a mathematical formula}pos(r) and {a mathematical formula}neg(r) to denote the conjunctions {a mathematical formula}A1∧⋯∧Am and {a mathematical formula}¬Am+1∧⋯∧¬An of positive and negative literals, respectively.</paragraph><paragraph>Rules in a logic program Π may have free variables. In ASP, these free variables will be instantiated over an application specific domain {a mathematical formula}CΠ which is a non-empty, finite subset of {a mathematical formula}C and includes all constants occurring in Π. A closed instance of a rule r over {a mathematical formula}CΠ is obtained by replacing every free variable in r with some constant in {a mathematical formula}CΠ. The grounding of a rule r w.r.t. {a mathematical formula}CΠ is the set {a mathematical formula}ground(r,CΠ) of all closed instances of r over {a mathematical formula}CΠ, and the grounding of Π is {a mathematical formula}ground(Π,CΠ)=⋃r∈Πground(r,CΠ). Note that {a mathematical formula}ground(Π,CΠ) is finite.</paragraph><paragraph>With no loss in generality, we assume that the domain {a mathematical formula}CΠ consists of all constants in Π (in case that some constant a of the domain does not appear in Π, we may have it by adding to Π a dummy rule {a mathematical formula}p(a)←p(a)). Then for any logic program Π, {a mathematical formula}CΠ is unique, and for convenience we omit {a mathematical formula}CΠ from {a mathematical formula}ground(r,CΠ) and {a mathematical formula}ground(Π,CΠ).</paragraph><paragraph label="Remark">In a logic program Π, each rule {a mathematical formula}H←B with the set S of free variables may also be viewed as a globally universally quantified rule {a mathematical formula}∀S(H←B), where the domain of each variable in S is {a mathematical formula}CΠ while the domain of the other (locally quantified) variables is {a mathematical formula}NΣ. Only globally universally quantified variables will be instantiated over their domain {a mathematical formula}CΠ for the grounding {a mathematical formula}ground(Π).</paragraph><paragraph>An interpretation I satisfies a closed instance r of a rule if it either satisfies {a mathematical formula}head(r) or it does not satisfy {a mathematical formula}body(r); I is a model of a logic program Π if I satisfies every {a mathematical formula}r∈ground(Π). Moreover, a model I is minimal if Π has no model J that is a proper subset of I.</paragraph><paragraph>Thus semantically, we may view a logic program Π as shorthand for {a mathematical formula}ground(Π), where each free variable in Π is viewed as shorthand for constants in {a mathematical formula}CΠ and each rule {a mathematical formula}r∈Π is viewed as shorthand for {a mathematical formula}ground(r).</paragraph><paragraph>A propositional theory/formula is a special first-order theory/formula that contains no variables and no function symbols. A propositional logic program is a logic program whose rule heads and bodies are propositional formulas. A normal logic program Π can be viewed as a special propositional logic program by grounding, i.e., {a mathematical formula}ground(Π) is a propositional logic program.</paragraph><paragraph>The Herbrand base of a propositional logic program Π w.r.t. the domain {a mathematical formula}CΠ, denoted {a mathematical formula}HBΠ, is the set of ground atoms {a mathematical formula}p(a1,…,an), where p occurs in Π and each {a mathematical formula}ai is in {a mathematical formula}CΠ. Any {a mathematical formula}I⊆HBΠ is a Herbrand interpretation of Π. Herbrand models are defined as usual, where the equality ≈ is interpreted as identity under the unique name assumption (UNA); i.e., for all distinct {a mathematical formula}ai,aj∈CΠ we assume UNA axioms of the form {a mathematical formula}¬(ai≈aj) to be implicitly present in Π. For a Herbrand interpretation I, we denote {a mathematical formula}I− for {a mathematical formula}HBΠ∖I and {a mathematical formula}¬I− for {a mathematical formula}{¬A|A∈I−}.</paragraph><paragraph>We now define the ordinary FLP answer set semantics (briefly, the FLP answer set semantics) for logic programs as follows.</paragraph><paragraph label="Definition 2">Let Π be a logic program and I an interpretation. The FLP-reduct of Π w.r.t. I is {a mathematical formula}fΠI={r∈ground(Π)|I satisfies body(r)}, and I is an FLP answer set of Π if I is a minimal model of {a mathematical formula}fΠI.</paragraph><paragraph label="Example 3">Consider the logic program {a mathematical formula}Π2 in Example 2. By Definition 2, the interpretation {a mathematical formula}I={p(−1),p(1)} is an FLP answer set of {a mathematical formula}Π2, where {a mathematical formula}ground(Π2)=Π2 and {a mathematical formula}fΠ2I={r2,r3}.</paragraph></section></section><section label="3"><section-title>Level mappings for logic programs with first-order formulas</section-title><paragraph>As mentioned in the introduction, if-then rules {a mathematical formula}H←B in a logic program essentially differ from material implications {a mathematical formula}B⊃H in classical logic because rules induce a level mapping on each answer set such that answers at upper levels are derived from answers at lower levels by applying the rules in the way that if the body of a rule is true in answers at lower levels then infer its head. A typical example is that the formula {a mathematical formula}¬A⊃A is equivalent to A in classical logic, but the rule {a mathematical formula}A←¬A fundamentally differs from A in logic programs because we can never infer A by applying the rule {a mathematical formula}A←¬A unless we are given ¬A.</paragraph><paragraph>For a normal logic program Π, Fages [28] introduced a notion of well-supportedness. An interpretation I is well-supported if there exists a strict well-founded partial order ≺ on I such that for any {a mathematical formula}A∈I there is a rule {a mathematical formula}A←body(r) in {a mathematical formula}ground(Π), where I satisfies {a mathematical formula}body(r) and {a mathematical formula}B≺A for every positive literal B in {a mathematical formula}body(r). A binary relation ≤ is well-founded if there is no infinite decreasing chain {a mathematical formula}A0≥A1≥⋯. Clearly, a well-supported interpretation I induces a level mapping via the partial order ≺, i.e., for any {a mathematical formula}A∈I, there is a rule {a mathematical formula}A←body(r) in {a mathematical formula}ground(Π) such that I satisfies {a mathematical formula}body(r) and for every positive literal B in {a mathematical formula}body(r), B is at a lower level than A.</paragraph><paragraph>Fages' definition of well-supportedness cannot be applied to general logic programs whose rule heads or bodies are arbitrary first-order formulas. For instance, the well-supportedness is not applicable to the logic program {a mathematical formula}Π={A←A∨¬A}, where A is a ground atom and {a mathematical formula}A∨¬A is a tautology that is always true in first-order logic. Intuitively, {a mathematical formula}I={A} should be a well-supported interpretation of Π, where A is supported by the tautological body {a mathematical formula}A∨¬A of the rule. However, I is not well-supported under Fages' definition since {a mathematical formula}A≺A does not hold for any strict well-founded partial order ≺ on I.</paragraph><paragraph>In this section, we define level mappings of interpretations for logic programs with first-order formulas. We first introduce a notion of partitioning of an interpretation.</paragraph><paragraph label="Definition 3">A partitioning of an interpretation I is of the form {a mathematical formula}〈S0,S1,⋯,Sm〉, where {a mathematical formula}S0=¬I−, {a mathematical formula}⋃1≤i≤mSi=I, {a mathematical formula}Si≠∅ for every {a mathematical formula}i&gt;0, and {a mathematical formula}Si∩Sj=∅ for every {a mathematical formula}i≠j.</paragraph><paragraph>Note that {a mathematical formula}¬I− is included in every partitioning of I since it is the negative half of I. We then define level mappings over such partitionings.</paragraph><paragraph>For logic programs whose rule heads are atoms, level mappings of an interpretation can be formalized as follows.</paragraph><paragraph label="Definition 4">Let Π be a logic program whose rule heads are atoms, I an interpretation of Π, and {a mathematical formula}S=〈S0,S1,⋯,Sm〉 a partitioning of I. S is a level mapping of I if for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, there is a rule {a mathematical formula}A←body(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si (i.e., {a mathematical formula}⋃0≤i≤k−1Si⊨body(r), where ⊨ is the entailment relation).</paragraph><paragraph>For a level mapping {a mathematical formula}〈S0,S1,⋯,Sm〉, the atoms in {a mathematical formula}Si are said to be at a higher (resp. lower) level than the atoms in {a mathematical formula}Sj if {a mathematical formula}i&gt;j (resp. {a mathematical formula}i&lt;j). When an interpretation I has such a level mapping, every {a mathematical formula}A∈I with {a mathematical formula}A∈Sk is supported/justified by the body of a rule r in {a mathematical formula}ground(Π), where {a mathematical formula}head(r)=A and {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si. Since all atoms in {a mathematical formula}⋃0≤i≤k−1Si are at lower levels than A, A is non-circularly justified. Thus I is non-circularly justified.</paragraph><paragraph label="Example 4">Consider the logic program {a mathematical formula}Π={A←A∨¬A} and let {a mathematical formula}I={A}. I has a level mapping {a mathematical formula}〈¬I−,{A}〉, where A is justified by the tautology {a mathematical formula}A∨¬A that is true in {a mathematical formula}¬I−. This justification is clearly non-circular.Consider another logic program {a mathematical formula}Π={A←¬C,B←A∧¬C} and let {a mathematical formula}I={A,B}, where A, B, C are ground atoms. Then, ¬C is in {a mathematical formula}¬I−. I has a level mapping {a mathematical formula}〈¬I−,{A},{B}〉. Note that B is justified (via the second rule) by A and ¬C at lower levels, while A is justified (via the first rule) by {a mathematical formula}¬C∈¬I−. These justifications are non-circular.</paragraph><paragraph>When I has no level mapping, for any partitioning {a mathematical formula}〈S0,S1,⋯,Sm〉, there must be some {a mathematical formula}A∈I with {a mathematical formula}A∈Sk for which we cannot find a rule {a mathematical formula}r∈ground(Π) to non-circularly support A under the partitioning (i.e., {a mathematical formula}head(r)=A and {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si). For instance, consider a logic program {a mathematical formula}Π={A←¬A} and let {a mathematical formula}I={A}. The only partitioning of I is {a mathematical formula}〈¬I−,{A}〉. Since ¬A is not in {a mathematical formula}¬I−, Π has no rule to support A under the partitioning. Hence I has no level mapping.</paragraph><paragraph>For a logic program whose rule bodies and heads are arbitrary first-order formulas, the definition of a level mapping is a bit more complicated. The key idea of our approach is: to define level mappings of an interpretation I, we first define level mappings of rule heads w.r.t. I in a way similar to Definition 4 by viewing each rule head as a macro-atom; then level mappings of I are defined in terms of the level mappings of rule heads w.r.t. I.</paragraph><paragraph label="Definition 5">Let Π be a logic program. A partitioning of rule heads of Π is of the form {a mathematical formula}S′=〈S1′,⋯,Sn′〉, where each {a mathematical formula}Si′ is a nonempty set of rule heads in {a mathematical formula}ground(Π) and {a mathematical formula}Si′∩Sj′=∅ for every {a mathematical formula}i≠j.</paragraph><paragraph>For a given interpretation I, let {a mathematical formula}S0′=¬I−. Then for a partitioning {a mathematical formula}S′ of rule heads of Π to be a level mapping w.r.t. I, we expect that for each {a mathematical formula}k&gt;0 the rule heads in {a mathematical formula}Sk′ are obtainable from {a mathematical formula}⋃0≤i≤k−1Si′ by applying rules in {a mathematical formula}ground(Π).</paragraph><paragraph label="Definition 6">Let Π be a logic program, I an interpretation of Π, and {a mathematical formula}S′=〈S1′,⋯,Sn′〉 a partitioning of rule heads of Π. Let {a mathematical formula}S0′=¬I−. Then {a mathematical formula}S′ is a level mapping of rule heads of Π w.r.t. I if for every {a mathematical formula}H∈Sk′ where {a mathematical formula}k&gt;0, there is a rule {a mathematical formula}H←body(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si′. Furthermore, {a mathematical formula}S′ is called a total level mapping if in addition {a mathematical formula}⋃1≤i≤nSi′ consists of all rule heads {a mathematical formula}head(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤nSi′; otherwise, {a mathematical formula}S′ is called a partial level mapping.</paragraph><paragraph>When {a mathematical formula}S′=〈S1′,⋯,Sn′〉 is a level mapping of rule heads w.r.t. I, then every rule head {a mathematical formula}H∈Sk′ where {a mathematical formula}k&gt;0 is supported by the body of a rule r in {a mathematical formula}ground(Π) such that {a mathematical formula}head(r)=H and {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si′. Note that all rule heads in {a mathematical formula}⋃1≤i≤k−1Si′ are at lower levels than H (at level k) unless H is a negative literal from {a mathematical formula}¬I− (hence it is also in {a mathematical formula}S0′). This means H is non-circularly justified.</paragraph><paragraph>Since all rule heads in {a mathematical formula}⋃1≤i≤nSi′ are non-circularly justified under the level mapping {a mathematical formula}S′ w.r.t. I, all atoms in I that are entailed by {a mathematical formula}⋃0≤i≤nSi′ are non-circularly justified. This leads us to defining level mappings of an interpretation I for arbitrary logic programs in terms of level mappings of rule heads w.r.t. I.</paragraph><paragraph label="Definition 7">Let Π be a logic program, I an interpretation of Π, and {a mathematical formula}S=〈S0,S1,⋯,Sm〉 a partitioning of I. Let {a mathematical formula}S0′=¬I−. Then S is a level mapping of I if there is a total level mapping {a mathematical formula}S′=〈S1′,⋯,Sn′〉 of rule heads of Π w.r.t. I and integers {a mathematical formula}l1,⋯,lm, where {a mathematical formula}1≤l1&lt;⋯&lt;lm≤n, such that for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, {a mathematical formula}⋃0≤i≤lkSi′⊨A but {a mathematical formula}⋃0≤i≤lk−1Si′⊭A.</paragraph><paragraph>Note that the level index {a mathematical formula}lk where {a mathematical formula}1≤k≤m is used to connect {a mathematical formula}Sk with the atoms that are entailed by {a mathematical formula}⋃0≤i≤lkSi′ but not entailed by {a mathematical formula}⋃0≤i≤lk−1Si′. Obviously when {a mathematical formula}m=n, {a mathematical formula}lk=k.</paragraph><paragraph label="Example 5">Consider the following propositional logic program:{a mathematical formula} Let {a mathematical formula}I={C,D} be an interpretation of Π; then ¬A, ¬B are in {a mathematical formula}¬I−. Consider a partitioning {a mathematical formula}S=〈¬I−,S1,S2〉 of I, where {a mathematical formula}S1={C} and {a mathematical formula}S2={D}. Let {a mathematical formula}S′=〈S1′,S2′〉 be a partitioning of rule heads of Π, where {a mathematical formula}S1′={A∨(¬B∧C)} and {a mathematical formula}S2′={D}. Since {a mathematical formula}¬I−⊨body(r1) and {a mathematical formula}¬I−∪S1′⊨body(r2), {a mathematical formula}S′ is a total level mapping of rule heads of Π w.r.t. I. Let {a mathematical formula}l1=1 and {a mathematical formula}l2=2. {a mathematical formula}C∈S1 is entailed by {a mathematical formula}¬I−∪S1′ but not by {a mathematical formula}¬I− and {a mathematical formula}D∈S2 is entailed by {a mathematical formula}¬I−∪S1′∪S2′ but not by {a mathematical formula}¬I−∪S1′. By Definition 7S is a level mapping of I.</paragraph><paragraph>For logic programs whose rule heads are atoms, Definition 7 coincides with Definition 4.</paragraph><paragraph label="Proposition 1">Let Π be a logic program whose rule heads are atoms, I a model of Π, and{a mathematical formula}S=〈S0,S1,⋯,Sm〉a partitioning of I. Then S is a level mapping of I underDefinition 4if and only if it is a level mapping underDefinition 7.</paragraph><paragraph>The following characterization is useful in determining whether an interpretation of a logic program has a level mapping.</paragraph><paragraph label="Proposition 2">An interpretation I of a logic program Π has a level mapping as inDefinition 7if and only if there is a total level mapping{a mathematical formula}S′=〈S1′,⋯,Sn′〉of rule heads of Π w.r.t. I such that{a mathematical formula}⋃0≤i≤nSi′⊨Afor every{a mathematical formula}A∈I, where{a mathematical formula}S0′=¬I−.</paragraph></section><section label="4"><section-title>Well-justified FLP answer sets for logic programs with first-order formulas</section-title><paragraph>For logic programs with first-order formulas, the FLP answer set semantics from Definition 2 does not induce a level mapping for its answer sets. For an interpretation I to be an answer set of a logic program Π, the FLP answer set semantics only requires I to be a minimal model of the FLP reduct {a mathematical formula}fΠI. This amounts to treating all rules {a mathematical formula}H←B in {a mathematical formula}fΠI as material implications {a mathematical formula}B⊃H in classical logic, because I is a model of the rules {a mathematical formula}H←B in {a mathematical formula}fΠI if and only if I is a model of the corresponding implications {a mathematical formula}B⊃H in classical logic. As classical logic does not induce level mappings for its models, an FLP answer set (i.e., a minimal model of {a mathematical formula}fΠI) may not have a level mapping.</paragraph><paragraph label="Example 6">Consider {a mathematical formula}Π2 in Example 2. Let {a mathematical formula}I={p(−1),p(1)} be an interpretation; then {a mathematical formula}¬p(2) is in {a mathematical formula}¬I−. I is an FLP answer set of {a mathematical formula}Π2 since it is a minimal model of the FLP reduct {a mathematical formula}fΠ2I={r2,r3}, where {a mathematical formula}r2 is {a mathematical formula}p(−1)←¬p(−1)∨p(1)∨p(2) and {a mathematical formula}r3 is {a mathematical formula}p(1)←p(−1). I has in total three partitionings: {a mathematical formula}〈¬I−,{p(−1)},{p(1)}〉, {a mathematical formula}〈¬I−,{p(1)}, {a mathematical formula}{p(−1)}〉 and {a mathematical formula}〈¬I−,{p(−1),p(1)}〉. It turns out that none of these partitionings is a level mapping as in Definition 4. Therefore, the FLP answer set I has no level mapping.</paragraph><paragraph>A way to overcome the circular justification problem of FLP answer sets is thus to enhance the FLP answer set semantics with level mappings for the FLP reduct, treating the reduct as a set of rules instead of a set of classical implications. To this end, let us first review how the standard answer set semantics induces a level mapping for answer sets of a normal logic program.</paragraph><paragraph>The seminal definition of an answer set I of a normal logic program Π involves three steps [33]:</paragraph><list><list-item label="1.">Eliminate all rules from {a mathematical formula}ground(Π) whose bodies contain a negative literal that is not satisfied by I.</list-item><list-item label="2.">Eliminate from the bodies of the remaining rules in {a mathematical formula}ground(Π) all negative literals. Note that these negative literals are satisfied by I and thus belong to {a mathematical formula}¬I−.The rule set resulting from the two steps is called the Gelfond–Lifschitz reduct of Π w.r.t. I and is denoted by {a mathematical formula}ΠI; note that {a mathematical formula}ΠI is a positive logic program.</list-item><list-item label="3.">Check whether I is the least model of {a mathematical formula}ΠI. To this end, compute the latter as the least fixpoint {a mathematical formula}lfp(TΠI(∅)) of the operator {a mathematical formula}TΠI by iteration via the sequence {a mathematical formula}〈TΠIi(∅)〉i=0∞, where {a mathematical formula}TΠI0(∅)=∅ and for {a mathematical formula}i≥0, {a mathematical formula}TΠIi+1(∅)=TΠI(TΠIi(∅)). Here {a mathematical formula}TP(S), where P is a positive logic program and S is a set of ground atoms, is the van Emden–Kowalski one-step provability operator [64] defined by{a mathematical formula}</list-item></list><paragraph>Summarizing, an interpretation I is an answer set of a normal logic program Π under the standard answer set semantics if {a mathematical formula}I=lfp(TΠI(∅)).</paragraph><paragraph>This process naturally induces a level mapping on each answer set I, which assigns a level {a mathematical formula}k&gt;0 to each {a mathematical formula}A∈I if {a mathematical formula}A∈TΠIk(∅) but {a mathematical formula}A∉TΠIk−1(∅). Let {a mathematical formula}S=〈S0,S1,⋯,Sm〉 be a partitioning of I, where {a mathematical formula}S0=¬I−, for {a mathematical formula}i&gt;0{a mathematical formula}Si=TΠIi(∅)∖TΠIi−1(∅), and {a mathematical formula}⋃1≤i≤mSi=lfp(TΠI(∅))=I. Note that for any {a mathematical formula}k&gt;0, {a mathematical formula}⋃1≤i≤kSi=TΠIk(∅). Then, for every {a mathematical formula}A∈I at level {a mathematical formula}k&gt;0, there exists some rule {a mathematical formula}r∈ground(Π) with {a mathematical formula}head(r)=A such that all negative literals in {a mathematical formula}body(r) are in {a mathematical formula}¬I− and all positive literals in {a mathematical formula}body(r) are in {a mathematical formula}TΠIk−1(∅). This means {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si. By Definition 4, S is a level mapping of I. This leads to the following immediate result.</paragraph><paragraph label="Theorem 1">Under the standard answer set semantics, every answer set of a normal logic program has a level mapping as inDefinition 4and thus is free of circular justifications.</paragraph><paragraph>For logic programs with first-order formulas, the above three step definition of answer sets is not applicable in general, since rule heads and bodies of such general logic programs can be arbitrary first-order formulas. For example, consider again the logic program {a mathematical formula}Π={A←A∨¬A}, where A is a ground atom. Since the rule body {a mathematical formula}A∨¬A is a tautology that is always true in first-order logic, {a mathematical formula}I={A} is supposed to be an answer set of Π. Apparently, this answer set cannot be obtained following literally the three steps above.</paragraph><paragraph>In order to handle arbitrary first-order formulas in rule heads and bodies of a general logic program, we propose to extend the first two steps of the Gelfond–Lifschitz definition of answer sets as follows:</paragraph><list><list-item label="1.">Instead of eliminating all rules whose bodies contain some negative literal that is not satisfied by I, we extend the first step by eliminating from {a mathematical formula}ground(Π) all rules whose bodies are not satisfied by I. This yields the FLP reduct {a mathematical formula}fΠI.</list-item><list-item label="2.">Instead of directly eliminating from {a mathematical formula}fΠI all negative literals that appear in {a mathematical formula}¬I−, we adapt the second step to first-order formulas by adding the negative literals in {a mathematical formula}¬I− as constraints on {a mathematical formula}fΠI.</list-item></list><paragraph>To extend the third step of the Gelfond–Lifschitz definition to first-order formulas, we first extend the van Emden–Kowalski operator {a mathematical formula}TP(S), which is applicable only to a positive logic program P parameterized with a set S of ground atoms, to a new operator {a mathematical formula}TΠ(O,N) that is applicable to a general logic program Π parameterized with two first-order theories O and N. As shall be seen below, the first parameter O of the extended operator {a mathematical formula}TΠ(O,N) is used to express a set of rule heads in {a mathematical formula}ground(Π), while the second parameter N used to express some constrains. Intuitively, by applying {a mathematical formula}TΠ(O,N) we infer all heads of rules from {a mathematical formula}ground(Π) whose bodies are true in O under the constraints N, i.e., {a mathematical formula}O∪N⊨body(r). Formally, we have</paragraph><paragraph label="Definition 8">Let Π be a logic program, and O and N be two first-order theories. Define the following one-step provability operator:{a mathematical formula}</paragraph><paragraph>When the constraints N are fixed, the entailment relation ⊨ is monotone in O, so {a mathematical formula}TΠ(O,N) is monotone w.r.t. O. That is, for any first-order theories {a mathematical formula}O1,O2 with {a mathematical formula}O1⊆O2, {a mathematical formula}TΠ(O1,N)⊆TΠ(O2,N). Therefore, the sequence {a mathematical formula}〈TΠi(∅,N)〉i=0∞, where {a mathematical formula}TΠ0(∅,N)=∅ and for {a mathematical formula}i≥0{a mathematical formula}TΠi+1(∅,N)=TΠ(TΠi(∅,N),N), will converge to a least fixpoint, denoted {a mathematical formula}lfp(TΠ(∅,N)).</paragraph><paragraph>Thus, when replacing the constraints N with {a mathematical formula}¬I−, we obtain a fixpoint {a mathematical formula}lfp(TΠ(∅,¬I−)); and when further replacing Π with the FLP reduct {a mathematical formula}fΠI, we obtain a fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)).</paragraph><paragraph>With the new operator {a mathematical formula}TΠ(O,N), we then extend the third step of the Gelfond–Lifschitz definition of answer sets to first-order formulas as follows:</paragraph><list><list-item label="3.">Compute the least fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)) of the operator {a mathematical formula}TfΠI via the sequence {a mathematical formula}〈TfΠIi(∅,¬I−)〉i=0∞, where {a mathematical formula}TfΠI0(∅,¬I−)=∅ and for {a mathematical formula}i≥0, {a mathematical formula}TfΠIi+1(∅,¬I−)=TfΠI(TfΠIi(∅,¬I−),¬I−).</list-item></list><paragraph>The following example illustrates the above extension to the Gelfond–Lifschitz three step definition.</paragraph><paragraph label="Example 7">Consider again the logic program {a mathematical formula}Π={r1,r2} from Example 5, where {a mathematical formula}r1 is {a mathematical formula}A∨(¬B∧C)←¬A∧(¬C∨C) and {a mathematical formula}r2 is {a mathematical formula}D←C. Let {a mathematical formula}I={C,D} be an interpretation of Π; then ¬A, ¬B are in {a mathematical formula}¬I−. Since I satisfies the bodies of the two rules, the FLP reduct {a mathematical formula}fΠI of Π w.r.t. I is Π itself. Let {a mathematical formula}TfΠI0(∅,¬I−)=∅. Since the body of {a mathematical formula}r1 is entailed by {a mathematical formula}TfΠI0(∅,¬I−)∪¬I−, {a mathematical formula}TfΠI1(∅,¬I−)={A∨(¬B∧C)}. Since the bodies of {a mathematical formula}r1 and {a mathematical formula}r2 are entailed by {a mathematical formula}TfΠI1(∅,¬I−)∪¬I−, {a mathematical formula}TfΠI2(∅,¬I−)={A∨(¬B∧C),D}. It is easy to check that {a mathematical formula}TfΠI3(∅,¬I−)=TfΠI2(∅,¬I−); thus we have the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−))={A∨(¬B∧C),D}.</paragraph><paragraph>The first important result about the extended van Emden–Kowalski operator {a mathematical formula}TΠ(O,N) is that when I is a model of a logic program Π, applying the operator to Π and {a mathematical formula}fΠI derives the same rule heads. This justifies the above first step extension to the Gelfond–Lifschitz answer set definition, where the FLP reduct {a mathematical formula}fΠI is used as a simplified form of Π.</paragraph><paragraph label="Theorem 2">Let I be a model of a logic program Π. For every{a mathematical formula}i≥0,{a mathematical formula}TΠi(∅,¬I−)=TfΠIi(∅,¬I−)and thus{a mathematical formula}lfp(TΠ(∅,¬I−))=lfp(TfΠI(∅,¬I−)).</paragraph><paragraph>The proof of this theorem is based on the following lemma.</paragraph><paragraph label="Lemma 1">If I is a model of a logic program Π, then for every{a mathematical formula}i≥0, I is a model of{a mathematical formula}TΠi(∅,¬I−).</paragraph><paragraph>The next result shows that {a mathematical formula}TΠ(O,N) is a proper generalization of the original van Emden–Kowalski operator {a mathematical formula}TP(S).</paragraph><paragraph label="Theorem 3">Let I be a model of a normal logic program Π and{a mathematical formula}ΠIbe the Gelfond–Lifschitz reduct of Π. Then for every{a mathematical formula}i≥0,{a mathematical formula}TΠIi(∅)=TΠi(∅,¬I−), and thus{a mathematical formula}lfp(TΠI(∅))=lfp(TΠ(∅,¬I−)).</paragraph><paragraph>The following characterization of the standard answer set semantics follows immediately from Theorem 2, Theorem 3.</paragraph><paragraph label="Corollary 1">A model I of a normal logic program Π is an answer set under the standard answer set semantics if and only if{a mathematical formula}I=lfp(TΠI(∅))if and only if{a mathematical formula}I=lfp(TΠ(∅,¬I−))if and only if{a mathematical formula}I=lfp(TfΠI(∅,¬I−)).</paragraph><paragraph>The conditions listed in Corollary 1 for an answer set of a normal logic program do not apply to a logic program with first-order formulas, because in the latter case the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)) (resp. {a mathematical formula}lfp(TΠ(∅,¬I−))) would be a first-order theory instead of a set of ground atoms (e.g., see Example 7). However, these conditions suggest that instead of requiring each {a mathematical formula}A∈I be included in {a mathematical formula}lfp(TfΠI(∅,¬I−)), answer sets of a logic program Π with first-order formulas can be defined by requiring that each{a mathematical formula}A∈Iis true in the fixpoint{a mathematical formula}lfp(TfΠI(∅,¬I−))under the constraints{a mathematical formula}¬I−; i.e., for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A. This leads to the following principal definition.</paragraph><paragraph label="Definition 9">well-justified answer setLet I be a model of a logic program Π. Then I is an answer set of Π if {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A for every {a mathematical formula}A∈I.</paragraph><paragraph label="Example 8">In Example 7, {a mathematical formula}I={C,D} is a model of Π and the fixpoint is {a mathematical formula}lfp(TfΠI(∅,¬I−))={A∨(¬B∧C),D}. Obviously, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨D. Since {a mathematical formula}¬A,¬B are in {a mathematical formula}¬I−, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨C. Thus, I is an answer set of Π under Definition 9.</paragraph><paragraph label="Example 9">In Example 2, {a mathematical formula}I={p(−1),p(1)} is an FLP answer set of {a mathematical formula}Π2 and {a mathematical formula}fΠ2I={r2,r3}. Since neither of the bodies of {a mathematical formula}r2 and {a mathematical formula}r3 is entailed by {a mathematical formula}¬I−, {a mathematical formula}TfΠ2I1(∅,¬I−)=TfΠ2I0(∅,¬I−)=∅; thus we have the fixpoint {a mathematical formula}lfp(TfΠ2I(∅,¬I−))=∅. Neither {a mathematical formula}p(−1) nor {a mathematical formula}p(1) can be proved true in {a mathematical formula}lfp(TfΠ2I(∅,¬I−)) under the constraints {a mathematical formula}¬I−; therefore, I is not an answer set of {a mathematical formula}Π2 under Definition 9.</paragraph><paragraph>By Theorem 2, it is immediate that a model I of a logic program Π is an answer set of Π if and only if for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TΠ(∅,¬I−))∪¬I−⊨A. The next result shows such answer sets are minimal models.</paragraph><paragraph label="Theorem 4">Every answer set I of a logic program Π is a minimal model of Π and furthermore, a minimal model of the FLP reduct{a mathematical formula}fΠI.</paragraph><paragraph>It is immediate from Theorem 4 and Definition 2:</paragraph><paragraph label="Corollary 2">Every answer set I of a logic program Π is an FLP answer set of Π.</paragraph><paragraph>Like the standard answer set semantics, answer sets of Definition 9 induce a level mapping from the FLP reduct {a mathematical formula}fΠI via the sequence {a mathematical formula}〈TfΠIi(∅,¬I−)〉i=0∞. The following result extends Theorem 1 from normal logic programs to logic programs with first-order formulas.</paragraph><paragraph label="Theorem 5">Every answer set of a logic program has a level mapping as inDefinition 7and thus is free of circular justifications.</paragraph><paragraph>By Proposition 1 the following corollary is immediate.</paragraph><paragraph label="Corollary 3">For a logic program Π whose rule heads are atoms, every answer set of Π has a level mapping as inDefinition 4.</paragraph><paragraph>Hence, answer sets of Definition 9 are FLP answer sets (by Corollary 2) enhanced with a level mapping, which makes them free of circular justifications (by Theorem 5). For this reason, we call answer sets of Definition 9well-justified FLP answer sets and the associated semantics the well-justified FLP answer set semantics.</paragraph><paragraph>In the well-justified FLP answer set semantics, we treat an FLP reduct {a mathematical formula}fΠI as if-then rules {a mathematical formula}H←B, instead of classical implications {a mathematical formula}B⊃H, by iteratively applying these rules to compute the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)). This process induces a level mapping as in Definition 7 on well-justified FLP answer sets (Theorem 5). In contrast, the FLP answer set semantics (Definition 2) identifies {a mathematical formula}fΠI with a set of classical implications by computing minimal models of these implications; this process does not induce a level mapping on FLP answer sets. The following example further illustrates the essential difference.</paragraph><paragraph label="Example 10">Consider the following two logic programs:{a mathematical formula} Note that Π is a logic program with first-order formulas, instead of a disjunctive logic program as introduced in [34], since {a mathematical formula}p∨q is a classical disjunction instead of an epistemic disjunction.{sup:2}{a mathematical formula}I={p,q} is the only minimal model of the two programs. {a mathematical formula}fΠI=Π and {a mathematical formula}fΠ′I=Π′. Under the FLP answer set semantics, Π is identified with {a mathematical formula}Π′ and I is an FLP answer set of Π if and only if it is a minimal model of {a mathematical formula}Π′. Consequently, I is both an FLP answer set of Π and of {a mathematical formula}Π′.Under the well-justified FLP answer set semantics, however, the two logic programs function rather differently. For Π, {a mathematical formula}I={p,q} is a well-justified FLP answer set if and only if the two rules {a mathematical formula}r2,r3 are applicable if and only if one of the two rule bodies is entailed by {a mathematical formula}r1, i.e. {a mathematical formula}p∨q⊨q or {a mathematical formula}p∨q⊨p. This condition, if satisfied, will induce a level mapping on I. The condition is precisely conveyed by the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−))={p∨q} which entails neither p nor q, meaning that {a mathematical formula}I={p,q} is not a well-justified FLP answer set of Π. For {a mathematical formula}Π′, since all rules {a mathematical formula}r1′,r2′,r3′ are first-order formulas, {a mathematical formula}I={p,q} is a well-justified FLP answer set if and only if {a mathematical formula}Π′⊨q and {a mathematical formula}Π′⊨p. This condition is precisely captured by the fixpoint {a mathematical formula}lfp(TfΠ′I(∅,¬I−))=Π′ which entails both p and q, meaning that {a mathematical formula}I={p,q} is a well-justified FLP answer set of {a mathematical formula}Π′.</paragraph><paragraph>The following result shows that the well-justified FLP answer set semantics excludes only those FLP answer sets that have no level mapping.</paragraph><paragraph label="Theorem 6">Let I be an FLP answer set of a logic program Π. I is a well-justified FLP answer set of Π if and only if it has a level mapping as inDefinition 7.</paragraph><paragraph>The proof of this theorem is based on the following lemma.</paragraph><paragraph label="Lemma 2">Let I be a model of a logic program Π and{a mathematical formula}S′=〈S1′,⋯,Sm′〉be a total level mapping of rule heads of Π w.r.t. I. Then{a mathematical formula}lfp(TfΠI(∅,¬I−))=⋃1≤i≤mSi′.</paragraph><paragraph>Note that for a model I of a normal logic program Π, {a mathematical formula}lfp(TfΠI(∅,¬I−)) is a set of ground atoms; by Definition 9I is a well-justified FLP answer set of Π if and only if {a mathematical formula}I=lfp(TfΠI(∅,¬I−)). Then, by Corollary 1 the well-justified FLP answer set semantics coincides with the standard answer set semantics and thus coincides with the FLP answer set semantics. The following result shows that a similar coincidence holds for logic programs whose rule bodies are all empty.</paragraph><paragraph label="Theorem 7">Let Π be a logic program whose rule bodies are all empty. Then a model I of Π is a well-justified FLP answer set of Π if and only if I is a minimal model of Π if and only if I is an FLP answer set of Π.</paragraph></section><section label="5"><section-title>Well-justified FLP answer sets for logic programs with aggregates</section-title><paragraph>We first extend the first-order language {a mathematical formula}LΣ defined in Section 2 to aggregate functions, such as COUNT(), SUM(), TIMES(), MIN() and MAX(). An aggregate function maps a finite set of elements in a domain to a value in a range. For simplicity, we assume the range of each aggregate function is a set of (positive and negative) integers and the signature Σ of {a mathematical formula}LΣ contains all integers (as constants).</paragraph><paragraph>Aggregates involve comparison operators, such as {a mathematical formula}=,≤,≥,&lt;,&gt;, etc., which define binary relations over integers. We assume that aggregate function symbols and comparison operators are not included in Σ.</paragraph><paragraph>Aggregate atoms An aggregate atom (aggregate for short) in {a mathematical formula}LΣ is of the form{a mathematical formula} where (1) OP is an aggregate function symbol; (2) {a mathematical formula}D⊆NΣ is the domain of OP; (3) X is an aggregate variable, which takes on values from D; (4) {a mathematical formula}F(X) is a first-order formula; (5) ⪰ is a comparison operator; and (6) b is an integer.</paragraph><paragraph>Note that only one aggregate variable X is used in an aggregate atom; it can easily be extended to a list of aggregate variables. X is bounded by the domain D; we may omit D when it is clear from context. {a mathematical formula}F(X) may contain the aggregate variable X or other variables; if {a mathematical formula}F(X) contains no variable, the aggregate atom is called a ground aggregate atom.</paragraph><paragraph label="Definition 10">A logic program Π with aggregate atoms is a finite set of rules of the form {a mathematical formula}H←B, where H and B are first-order formulas extended with aggregate atoms.</paragraph><paragraph>The grounding {a mathematical formula}ground(Π) of a logic program Π with aggregate atoms is obtained by replacing every free variable except aggregate variables in Π with a constant in {a mathematical formula}CΠ. We assume that the domain D of each aggregate function consists of constants from {a mathematical formula}CΠ, and for each aggregate atom {a mathematical formula}OP〈(D,X):F(X)〉⪰b in {a mathematical formula}ground(Π), except X all variables in {a mathematical formula}F(X) are in the scope of a quantifier in {a mathematical formula}F(X).</paragraph><paragraph>For an interpretation I, satisfaction of an aggregate atom {a mathematical formula}A=OP〈(D,X):F(X)〉⪰b in {a mathematical formula}ground(Π) w.r.t. I is defined as follows. Let{a mathematical formula} Then I satisfies A if {a mathematical formula}OP(SAI)⪰b holds, and I satisfies ¬A if I does not satisfy A.{sup:3}</paragraph><paragraph>Now that the satisfaction relation of {a mathematical formula}LΣ is extended to aggregate atoms, the entailment relation ⊨ is extended accordingly. Thus the operator {a mathematical formula}TΠ(O,N) (Definition 8) can be applied to logic programs with aggregate atoms in the same way as logic programs with first-order formulas, and Definition 9 directly extends to such logic programs, i.e., a model I of a logic program Π with aggregate atoms is a well-justified FLP answer set of Π if for every {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A. All results (Theorems, Lemmas, and Corollaries) obtained in Section 4 for logic programs with first-order formulas hold with the same proofs for logic programs with aggregate atoms. By Corollary 2 and Theorem 6, well-justified FLP answer sets of logic programs with aggregate atoms are FLP answer sets enhanced with a level mapping as in Definition 7 and thus are free of circular justifications.</paragraph><paragraph label="Example 11">Consider the following logic program with aggregate atoms (borrowed from [4]):{a mathematical formula}{a mathematical formula}SUM〈({−1,1,2},X):p(X)〉 is an aggregate function, where X is an aggregate variable with the domain {a mathematical formula}{−1,1,2}, which sums up all X in the domain such that {a mathematical formula}p(X) is true. For simplicity, let {a mathematical formula}A1 and {a mathematical formula}A2 represent the two aggregate atoms {a mathematical formula}SUM〈({−1,1,2},X):p(X)〉&lt;2 and {a mathematical formula}SUM〈({−1,1,2},X):p(X)〉≥0 respectively. For an interpretation {a mathematical formula}I={p(−1),p(1)},{a mathematical formula} and{a mathematical formula} so I satisfies {a mathematical formula}A1 and {a mathematical formula}A2. Then the FLP reduct is {a mathematical formula}fΠ3I={r2,r3}.We have {a mathematical formula}lfp(TfΠ3I(∅,¬I−))=∅. Since {a mathematical formula}lfp(TfΠ3I(∅,¬I−))∪¬I−⊭p(−1) and {a mathematical formula}lfp(TfΠ3I(∅,¬I−))∪¬I−⊭p(1), {a mathematical formula}I={p(−1),p(1)} is not a well-justified FLP answer set of {a mathematical formula}Π3.As {a mathematical formula}I={p(−1),p(1)} is a minimal model of {a mathematical formula}fΠ3I, it is an FLP answer set of {a mathematical formula}Π3 (by Definition 2). This FLP answer set has a circular justification similar to that of {a mathematical formula}Π2 in Example 2. Observe that {a mathematical formula}Π3 represents the same knowledge as {a mathematical formula}Π2 because the aggregate atom {a mathematical formula}¬SUM〈({−1,1,2},X):p(X)〉&lt;2 in {a mathematical formula}Π3 can be interpreted as the first-order formula {a mathematical formula}p(2)∧(¬p(−1)∨p(1)) in {a mathematical formula}Π2, while {a mathematical formula}SUM〈({−1,1,2},X):p(X)〉≥0 interpreted as {a mathematical formula}¬p(−1)∨p(1)∨p(2).</paragraph><paragraph label="Example 12">Consider again the logic program {a mathematical formula}Π1 in Example 1. The aggregate function {a mathematical formula}SUM〈X:p(X)〉 has an aggregate variable X whose domain is implicitly assumed to be {a mathematical formula}{−1,1,2}. Let A represent the aggregate atom {a mathematical formula}SUM〈X:p(X)〉≥1 in {a mathematical formula}Π1. For an interpretation {a mathematical formula}I={p(1),p(−1),p(2)},{a mathematical formula} and {a mathematical formula}SUM(SAI)=2, so I satisfies A and the FLP reduct of {a mathematical formula}Π1 w.r.t. I is {a mathematical formula}Π1 itself. I is an FLP answer set of {a mathematical formula}Π1, but it is not a well-justified FLP answer set. The fixpoint is {a mathematical formula}lfp(TfΠ1I(∅,¬I−))={p(1)}; neither {a mathematical formula}p(−1) nor {a mathematical formula}p(2) in I is true in the fixpoint under the constraints {a mathematical formula}¬I−.</paragraph><paragraph>Many aggregate atoms can be represented in an abstract form as abstract constraint atoms (or c-atoms) [48]. Next we further extend the first-order language {a mathematical formula}LΣ to encompass c-atoms.</paragraph><paragraph>Constraint atoms A c-atom is a pair {a mathematical formula}(V,C), where V, the domain of the c-atom, is a finite subset of {a mathematical formula}HΣ, and C, the admissible solutions of the c-atom, is a collection of sets of atoms in V. For instance, the aggregate atom {a mathematical formula}SUM〈({−1,1,2},X):p(X)〉&lt;2 in {a mathematical formula}Π3 can be represented as a c-atom {a mathematical formula}(V,C), where {a mathematical formula}V={p(−1),p(1),p(2)} and {a mathematical formula}C={∅,{p(−1)},{p(1)},{p(−1),p(1)}, {a mathematical formula}{p(−1),p(2)}}. The first solution ∅ in C means that none of {a mathematical formula}p(−1), {a mathematical formula}p(1), {a mathematical formula}p(2) in the domain is true, while the last solution {a mathematical formula}{p(−1),p(2)} in C means that only {a mathematical formula}p(−1) and {a mathematical formula}p(2) are true. Clearly, in all such cases {a mathematical formula}SUM〈({−1,1,2},X):p(X)〉&lt;2 holds.</paragraph><paragraph label="Definition 11">A logic program Π with c-atoms is a finite set of rules of the form {a mathematical formula}H←B, where H and B are first-order formulas extended with c-atoms.</paragraph><paragraph>An interpretation I satisfies a c-atom {a mathematical formula}(V,C) if {a mathematical formula}I∩V∈C; I satisfies{a mathematical formula}¬(V,C) if I does not satisfy {a mathematical formula}(V,C); the entailment relation ⊨ and the operator {a mathematical formula}TΠ(O,N) extend accordingly to logic programs with c-atoms. All definitions and results from above for aggregate atoms, including the notion of well-justified FLP answer sets, carry over to logic programs with c-atoms.</paragraph><paragraph>As far as we can determine, the well-justified FLP answer set semantics is the first answer set semantics that is free of circular justifications for logic programs with first-order formulas as well as aggregate atoms or c-atoms. Two notable exceptions are the three-valued fixpoint semantics of Pelov et al. [53] for the class of logic programs whose rule heads are atoms and the conditional satisfaction-based semantics of Son et al. [60] for a special class of logic programs with aggregate atoms resp. c-atoms called positive basic logic programs. (The latter semantics is essentially a reformulation of the former.) Since answer sets under the two semantics are free of circular justifications, we next study their relationship with the well-justified FLP answer set semantics.</paragraph><section label="5.1">Relation to the three-valued fixpoint semantics of Pelov et al. [53]<paragraph>For simplicity of presentation, in this subsection we consider only propositional logic programs and disregard aggregate atoms, which will be addressed in Section 5.2.</paragraph><paragraph>For a logic program Π whose rule heads are atoms, in [16], [53] a three-valued fixpoint semantics was introduced based on a three-valued fixpoint operator {a mathematical formula}ΦΠ. Answer sets under this semantics are called two-valued stable models.</paragraph><paragraph>A three-valued (Herbrand) interpretation of Π is {a mathematical formula}Iˆ=(I1,I2), where {a mathematical formula}I1⊆I2⊆HBΠ. Intuitively, atoms in {a mathematical formula}I1 are assigned the truth value t, atoms in {a mathematical formula}I2∖I1 assigned u, and atoms in {a mathematical formula}HBΠ∖I2 assigned f. These truth values are ordered by the truth order{a mathematical formula}≤t with {a mathematical formula}f≤tu≤tt. Negation on these truth values is defined as {a mathematical formula}¬f=t,¬u=u and {a mathematical formula}¬t=f. The truth value of a propositional formula F under {a mathematical formula}Iˆ, denoted {a mathematical formula}Iˆ(F), is defined recursively as follows:{a mathematical formula} Note that {a mathematical formula}F1⊃F2 is an abbreviation for {a mathematical formula}¬F1∨F2. Then {a mathematical formula}Iˆsatisfies F if {a mathematical formula}Iˆ(F)=t.</paragraph><paragraph>Given a three-valued interpretation {a mathematical formula}Iˆ=(I1,I2), the three-valued operator {a mathematical formula}ΦΠ(I1,I2)=(I1′,I2′) is defined such that{a mathematical formula}</paragraph><paragraph>Let {a mathematical formula}ΦΠ1(I1,I2) denote the first element of {a mathematical formula}ΦΠ(I1,I2), i.e. {a mathematical formula}I1′, and {a mathematical formula}ΦΠ2(I1,I2) denote the second element {a mathematical formula}I2′. When {a mathematical formula}I2 is fixed, we compute a sequence {a mathematical formula}x0=∅,x1=ΦΠ1(x0,I2),⋯,xi+1=ΦΠ1(xi,I2),⋯ , until a fixpoint, denoted {a mathematical formula}StΦ↓(I2), is reached. Similarly, when {a mathematical formula}I1 is fixed, we compute a sequence {a mathematical formula}x0=I1,x1=ΦΠ2(I1,x0),⋯,xi+1=ΦΠ2(I1,xi),⋯ , until a fixpoint {a mathematical formula}StΦ↑(I1) is reached. The stable revision operator{a mathematical formula}StΦ on {a mathematical formula}Iˆ=(I1,I2) is defined as{a mathematical formula}</paragraph><paragraph>By iteratively applying {a mathematical formula}StΦ such that {a mathematical formula}StΦ0(I1,I2)=(I1,I2) and for {a mathematical formula}i&gt;0, {a mathematical formula}StΦi(I1,I2)=StΦStΦi−1(I1,I2), we obtain a fixpoint {a mathematical formula}lfp(StΦ(I1,I2)) of {a mathematical formula}StΦ.</paragraph><paragraph>The three-valued fixpoint semantics of Denecker et al. [16] and of Pelov et al. [53] is then defined in terms of the fixpoint {a mathematical formula}lfp(StΦ). Let I be a two-valued model of Π (as defined in Section 2.2). I is called a two-valued stable model of Π if {a mathematical formula}lfp(StΦ(I,I))=(I,I).</paragraph><paragraph>We observe that there are at least three significant differences between the three-valued fixpoint semantics and the well-justified FLP answer set semantics. First, the three-valued fixpoint semantics is defined over three-valued interpretations, while the well-justified FLP answer set semantics is defined over two-valued interpretations. Second, the three-valued fixpoint semantics is applicable only to logic programs whose rule heads are atoms, while the well-justified FLP answer set semantics applies to logic programs whose rule heads are arbitrary first-order formulas. Third, as shown below the three-valued fixpoint semantics is more conservative than the well-justified FLP answer set semantics in the sense that two-valued stable models of the three-valued fixpoint semantics are well-justified FLP answer sets, which by Corollary 2 are also FLP answer sets, but the converse does not hold.</paragraph><paragraph label="Theorem 8">Let Π be a propositional logic program whose rule heads are atoms and let I be a two-valued stable model of Π under the three-valued fixpoint semantics. Then I is also a well-justified FLP answer set of Π.</paragraph><paragraph>However, a well-justified FLP answer set is not necessarily a two-valued stable model. As an example, consider the logic program {a mathematical formula}Π={p←¬p∨p}. {a mathematical formula}I={p} is a two-valued model of Π. Since the rule body {a mathematical formula}¬p∨p is a tautology in classical logic, I is a well-justified FLP answer set of Π. However, I is not a two-valued stable model under the three-valued fixpoint semantics since {a mathematical formula}lfp(StΦ({p},{p}))=(∅,{p}).</paragraph><paragraph>Recall that the well-justified FLP answer set semantics excludes only those FLP answer sets that have no level mapping (Theorem 6). The above example shows that the three-valued fixpoint semantics eliminates some FLP answer sets that have level mappings.</paragraph></section><section label="5.2">Relation to conditional satisfaction-based semantics of Son et al. [60]<paragraph>Son et al. [60] defined an answer set semantics for a special class of logic programs with c-atoms called positive basic logic programs.</paragraph><paragraph label="Definition 12">A positive basic logic program is a finite set of function and equality free rules of the form {a mathematical formula}A←A1∧⋯∧Am, where A is a ground atom and each {a mathematical formula}Ai is a c-atom.</paragraph><paragraph>Note that any ground atom A can be represented as an elementary c-atom{a mathematical formula}({A},{{A}}), and ¬A represented as a c-atom {a mathematical formula}({A},{∅}). For any c-atom {a mathematical formula}(V,C), {a mathematical formula}¬(V,C) can be represented as a c-atom {a mathematical formula}(V,2V∖C), where {a mathematical formula}2V is the power set of V. Therefore, for any normal logic program Π with c-atoms, its grounding {a mathematical formula}ground(Π) can be represented in this way by an equivalent positive basic logic program.</paragraph><paragraph>Son et al. [60] defined answer sets for positive basic logic programs based on a notion of conditional satisfaction. Let R and S be two sets of ground atoms with {a mathematical formula}R⊆S. For a c-atom {a mathematical formula}A=(V,C), R conditionally satisfies A w.r.t. S, denoted {a mathematical formula}R⊨SA, if for every F with {a mathematical formula}R∩V⊆F⊆S∩V, {a mathematical formula}F∈C; for a ground atom A, {a mathematical formula}R⊨SA if {a mathematical formula}R⊨S({A},{{A}}).</paragraph><paragraph>For a positive basic logic program Π, define the following one-step provability operator:{a mathematical formula} Son et al. proved that if the second argument S of {a mathematical formula}ΓΠ(R,S) is a model of Π, then the sequence {a mathematical formula}〈ΓΠi(∅,S)〉i=0∞, where {a mathematical formula}ΓΠ0(∅,S)=∅ and for {a mathematical formula}i&gt;0{a mathematical formula}ΓΠi(∅,S)=ΓΠ(ΓΠi−1(∅,S),S), is monotone and will converge to a fixpoint {a mathematical formula}lfp(ΓΠ(∅,S)). Based on this, a model I of Π is a conditional satisfaction based answer set of Π if {a mathematical formula}I=lfp(ΓΠ(∅,I)).</paragraph><paragraph>It is not hard to see that conditional satisfaction of a c-atom is closely related to our notion of entailment as follows.</paragraph><paragraph label="Lemma 3">Let I be a model of a positive basic logic program Π. For every{a mathematical formula}R⊆Iand c-atom A occurring in Π,{a mathematical formula}R⊨IAif and only if{a mathematical formula}R∪¬I−⊨A.</paragraph><paragraph>Consequently, the stages {a mathematical formula}lfp(TΠ(∅,¬I−)) and {a mathematical formula}lfp(ΓΠ(∅,I)) of the operators {a mathematical formula}TΠ and {a mathematical formula}ΓΠ, respectively, coincide for models I of Π; we thus obtain:</paragraph><paragraph label="Theorem 9">A model of a positive basic logic program is a well-justified FLP answer set if and only if it is a conditional satisfaction based answer set.</paragraph><paragraph>As positive basic logic programs are a class of logic programs with c-atoms, this result suggests that (1) the well-justified FLP answer set semantics is a proper extension of the conditional satisfaction-based answer set semantics, and (2) answer sets according to the latter are free of circular justifications.</paragraph><paragraph>For positive basic logic programs, Son et al. [60] showed that the conditional satisfaction-based answer set semantics agrees with the three-valued fixpoint semantics of Denecker et al. [16] and of Pelov et al. [53]. By Theorem 9, for such logic programs the well-justified FLP answer set semantics also agrees with the three-valued fixpoint semantics and thus can be also regarded as an extension of the latter to logic programs with c-atoms.{sup:4}</paragraph></section></section><section label="6"><section-title>Well-justified FLP answer sets for description logic programs</section-title><paragraph>In principle, the above method of defining well-justified FLP answer sets can be applied to different types of logic programs, provided that the satisfaction relation of {a mathematical formula}LΣ is extended to those logic programs. As another important application, in this section we define well-justified FLP answer sets for dl-programs [25], [24]. Other well-known types of logic programs, such as hex-programs [25], tightly coupled dl-programs [46], and modular logic programs [12], can be handled in a similar way.</paragraph><paragraph>A dl-program can be viewed as a normal logic program enhanced with an interface to access an external DL knowledge base, so we begin by briefly introducing DL knowledge bases.</paragraph><section label="6.1"><section-title>DL knowledge bases</section-title><paragraph>We assume familiarity with the basics of description logics [2], and for simplicity consider {a mathematical formula}SHOIN, a DL underlying the Web ontology language OWL DL [40]. The approach presented in this paper can easily be extended to other more expressive DLs such as {a mathematical formula}SROIQ (a logical underpinning for OWL 2) [38], [36], and to DLs with datatypes such as {a mathematical formula}SHOIN(D) and {a mathematical formula}SROIQ(D). As well, it can be adjusted for light-weight description logics such as DL-Lite [10] or {a mathematical formula}EL++[1].</paragraph><paragraph>Consider a signature {a mathematical formula}Ψ=(A∪R,I), where A, R and I are pairwise disjoint (denumerable) sets of atomic concepts, atomic roles and individuals, respectively. A role is either an atomic role R from R or its inverse, denoted {a mathematical formula}R−. General concepts C are formed from atomic concepts, roles and individuals, according to the following syntax:{a mathematical formula} where A is an atomic concept from A, R is a role, a is an individual from I, C and D are concepts, and n is a non-negative integer. An axiom is of the form {a mathematical formula}C⊑D (concept inclusion axiom), {a mathematical formula}R⊑R1 (role inclusion axiom), {a mathematical formula}Trans(R) (transitivity axiom), {a mathematical formula}C(a) (concept membership axiom), {a mathematical formula}R(a,b) (role membership axiom), {a mathematical formula}a≈b (equality axiom), or {a mathematical formula}a≉b (inequality axiom), where R, {a mathematical formula}R1 are atomic roles in R, and {a mathematical formula}a,b are individuals in I. We use {a mathematical formula}C≡D to denote {a mathematical formula}C⊑D and {a mathematical formula}D⊑C.</paragraph><paragraph>Note that for a concept inclusion axiom {a mathematical formula}C⊑D, we can express its negation {a mathematical formula}¬(C⊑D) by a concept membership axiom {a mathematical formula}(C⊓¬D)(b), where b is a fresh individual in I.</paragraph><paragraph>A DL knowledge base L is a finite set of axioms. Since DLs are fragments of first-order logic with equality, where atomic concepts (resp. roles) are unary (resp. binary) predicate symbols, and individuals are constants, L has first-order semantics. Therefore, L is consistent (or satisfiable) if L has a first-order model. For an axiom F, the entailment relation {a mathematical formula}L⊨F is defined as in first-order logic. Note that if L is inconsistent, then {a mathematical formula}L⊨F for every formula F. When we say ‘predicate symbols in L’, we refer to atomic concepts or atomic roles in L.</paragraph></section><section label="6.2"><section-title>Dl-programs</section-title><paragraph>Let L be a DL knowledge base built over a signature {a mathematical formula}Ψ=(A∪R,I). Let {a mathematical formula}Φ=(P,C) be a signature built from the signature Σ of the first-order language {a mathematical formula}LΣ of Section 2, where {a mathematical formula}P⊆P is a finite set of predicate symbols and {a mathematical formula}C⊆C a nonempty finite set of constants, such that {a mathematical formula}P∩(A∪R)=∅ and {a mathematical formula}C⊆I. Terms and atoms are defined only using constants in C, variables in {a mathematical formula}V, and predicate symbols in P. An equality (resp. inequality) is of the form {a mathematical formula}t1≈t2 (resp. {a mathematical formula}t1≉t2), where {a mathematical formula}t1 and {a mathematical formula}t2 are terms.</paragraph><paragraph>A dl-query is built over the signatures Ψ and Φ, which is either (i) a concept inclusion axiom F or its negation ¬F; or (ii) of the form {a mathematical formula}C(t) or {a mathematical formula}¬C(t), where C is a concept, and t is a term; or (iii) of the form {a mathematical formula}R(t1,t2) or {a mathematical formula}¬R(t1,t2), where R is a role, and {a mathematical formula}t1 and {a mathematical formula}t2 are terms; or (iv) of the form {a mathematical formula}t1≈t2 or {a mathematical formula}t1≉t2, where {a mathematical formula}t1 and {a mathematical formula}t2 are terms. For convenience, we denote a dl-query by {a mathematical formula}Q(t), where t is all terms of the dl-query (e.g., {a mathematical formula}t1 and {a mathematical formula}t2 in (iii)), and Q is the other part (e.g., R or ¬R in (iii)).</paragraph><paragraph>A dl-atom is of the form {a mathematical formula}DL[S1op1p1,…,Smopmpm;Q](t), where each {a mathematical formula}Si is a concept or role built from {a mathematical formula}A∪R, or an equality/inequality symbol; {a mathematical formula}opi∈{⊎,{an inline-figure},{an inline-figure}} is an operator; {a mathematical formula}pi∈P is a unary predicate symbol if {a mathematical formula}Si is a concept, and a binary predicate symbol otherwise; and {a mathematical formula}Q(t) is a dl-query. Note that each {a mathematical formula}Siopipi maps a predicate symbol {a mathematical formula}pi in P to a concept or role {a mathematical formula}Si over {a mathematical formula}A∪R via a special interface operator {a mathematical formula}opi. Each {a mathematical formula}pi, {a mathematical formula}1≤i≤m, is called an input predicate symbol, and each atom with a predicate symbol {a mathematical formula}pi called an input atom.</paragraph><paragraph>A dl-rule (or rule) is of the form{a mathematical formula} where H is an atom, each {a mathematical formula}Ai is either an atom, an equality/inequality or a dl-atom, and each {a mathematical formula}Bi is an atom or a dl-atom. Each {a mathematical formula}¬Bi is also called a negative literal.</paragraph><paragraph label="Definition 13">(See [25], [24].) A dl-program Π relative to an external DL knowledge base L is a finite set of dl-rules.</paragraph><paragraph>A ground instance of a rule r is obtained by first replacing every variable in r with a constant from C, then removing all valid equalities and inequalities (under the unique name assumption). A ground instance of r is consistent if it contains no equalities or inequalities. Let {a mathematical formula}ground(Π) denote the set of all consistent ground instances of rules in Π.</paragraph></section><section label="6.3"><section-title>The well-justified FLP answer set semantics</section-title><paragraph>The semantics of a dl-program Π relative to L is defined in terms of Herbrand interpretations, where the Herbrand base {a mathematical formula}HBΠ of Π is the set of ground atoms {a mathematical formula}p(a1,…,an) such that {a mathematical formula}p∈P occurs in Π and each {a mathematical formula}ai is in C.</paragraph><paragraph>The satisfaction relation is extended to dl-atoms in the following way. Let I be a Herbrand interpretation of Π and {a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c) be a dl-atom occurring in {a mathematical formula}ground(Π). Then I satisfies the dl-atom A if {a mathematical formula}L∪⋃i=1mAi(I){a mathematical formula}⊨Q(c), where for {a mathematical formula}1≤i≤m, {a mathematical formula}Ai(I) is defined by the predicate mapping {a mathematical formula}Siopipi such that{a mathematical formula}</paragraph><paragraph>This extended satisfaction relation to dl-atoms is called satisfaction under L, denoted {a mathematical formula}⊨L, in [24]. Therefore, a Herbrand interpretation I is a model of a dl-program Π relative to L if I satisfies all rules in {a mathematical formula}ground(Π).</paragraph><paragraph>A ground dl-atom A is monotonic relative to Π and L if for every {a mathematical formula}I⊆J⊆HBΠ, it holds that I satisfies A implies J satisfies A; otherwise, A is nonmonotonic. A dl-program Π is positive if it has no negative literals in rule bodies and every dl-atom occurring in {a mathematical formula}ground(Π) is monotonic. Note that a positive dl-program Π has a least model.</paragraph><paragraph>For a Herbrand interpretation I, let {a mathematical formula}sΠLI be the (strong) reduct obtained from {a mathematical formula}ground(Π) by deleting (i) every rule r whose body is not satisfied by I, and (ii) from the remaining rules all negative literals and all nonmonotonic dl-atoms. Furthermore, let {a mathematical formula}wΠLI be the reduct defined like {a mathematical formula}sΠLI except that in (ii) all negative literals and all dl-atoms are deleted.</paragraph><paragraph>Eiter et al. [24] defined the weak answer set semantics in terms of the reduct {a mathematical formula}wΠLI. A Herbrand interpretation I is a weak answer set of Π relative to L if I is the least model of {a mathematical formula}wΠLI.</paragraph><paragraph>However, Eiter et al. noted as an obvious disadvantage of the weak answer set semantics that it may produce “unfounded” answer sets with circular justifications by self-supporting loops, which they illustrated on the following example.</paragraph><paragraph label="Example 13">Consider the dl-program {a mathematical formula}Π={p(a)←DL[c⊎p;c](a)} relative to a DL knowledge base {a mathematical formula}L=∅. Π has two weak answer sets: {a mathematical formula}I1=∅ and {a mathematical formula}I2={p(a)}. The atom {a mathematical formula}p(a) is circularly justified in {a mathematical formula}I2 by the self-supporting loop: {a mathematical formula}p(a)⇐DL[c⊎p;c](a)⇐p(a).</paragraph><paragraph>To overcome the circular justification problem, Eiter et al. defined the answer set semantics in terms of the reduct {a mathematical formula}sΠLI. A Herbrand interpretation I is a strong answer set of Π relative to L if I is the least model of {a mathematical formula}sΠLI.</paragraph><paragraph>In general, strong answer sets are not minimal models of the underlying dl-programs. To handle this, Eiter et al. [25] considered the FLP answer set semantics in terms of the FLP reduct {a mathematical formula}fΠLI, which consists of all rules {a mathematical formula}r∈ground(Π) such that I satisfies {a mathematical formula}body(r). A Herbrand interpretation I is an FLP answer set of Π relative to L if I is a minimal model of {a mathematical formula}fΠLI.</paragraph><paragraph>However, we observe that the problem of circular justifications persists in both the strong answer set semantics and the FLP answer set semantics. The next two dl-programs well illustrate this.</paragraph><paragraph label="Example 14">Let {a mathematical formula}Π={p(a)←DL[c⊎p,b{an inline-figure}q;c⊓¬b](a)} be a dl-program relative to {a mathematical formula}L=∅. The dl-atom {a mathematical formula}DL[c⊎p,b{an inline-figure}q;c⊓¬b](a) in Π queries L whether a is an instance of the concept c but not of the concept b, under the assumption that for any x, if {a mathematical formula}p(x) is true,then x is in c, and if {a mathematical formula}q(x) is false, then x is not in b. This dl-atom is nonmonotonic, so both {a mathematical formula}I1=∅ and {a mathematical formula}I2={p(a)} are strong answer sets of Π. Observe that {a mathematical formula}p(a) is circularly justified in {a mathematical formula}I2 by the self-supporting loop: {a mathematical formula}p(a)⇐DL[c⊎p,b{an inline-figure}q;c⊓¬b](a)⇐p(a)∧¬q(a).</paragraph><paragraph label="Example 15">Let {a mathematical formula}L=∅ and Π consist of two rules: {a mathematical formula}p(a)←q(a) and {a mathematical formula}q(a)←DL[c⊎p,b{an inline-figure}q;c⊔¬b](a). Π has only one model {a mathematical formula}I={p(a),q(a)}. The FLP reduct {a mathematical formula}fΠLI of Π w.r.t. I is {a mathematical formula}fΠLI=Π. Therefore, I is an FLP answer set of Π. We see that {a mathematical formula}p(a) is circularly justified in I by the self-supporting loop: {a mathematical formula}p(a)⇐q(a)⇐DL[c⊎p,b{an inline-figure}q;c⊔¬b](a)⇐p(a)∨¬q(a)⇐p(a).</paragraph><paragraph>The intuitive reason behind the circular justification problem of the above three answer set semantics for dl-programs is that these semantics do not induce a level mapping on their answer sets. Therefore we overcome the circular justification problem by extending our well-justified FLP answer set semantics from logic programs with first-order formulas to dl-programs.</paragraph><paragraph>Since dl-programs are logic programs extended with dl-atoms, given the above extension of the satisfaction relation to dl-atoms, the entailment relation ⊨ and the operator {a mathematical formula}TΠ(O,N) extend accordingly to dl-programs. Furthermore, the notion of well-justified FLP answer sets for logic programs with first-order formulas, as well as the properties in Section 4, carries over to dl-programs. In particular, Definition 9 is extended as follows.</paragraph><paragraph label="Definition 14">A Herbrand model I of a dl-program Π relative to an external DL knowledge base L is a well-justified FLP answer set if for every {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨A.</paragraph><paragraph>By Corollary 2 and Theorem 6, such well-justified FLP answer sets for dl-programs are FLP answer sets enhanced with a level mapping and thus are free of circular justifications.</paragraph><paragraph>As the head of each rule in the grounding of a dl-program Π is a ground atom, the fixpoint {a mathematical formula}lfp(TfΠLI(∅,¬I−)) is a set of ground atoms. Thus for each A in a Herbrand model I, {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨A if and only if {a mathematical formula}A∈lfp(TfΠLI(∅,¬I−)). This immediately leads to the following result.</paragraph><paragraph label="Corollary 4">A Herbrand model I of a dl-program Π relative to a DL knowledge base L is a well-justified FLP answer set if and only if{a mathematical formula}I=lfp(TfΠLI(∅,¬I−)).</paragraph><paragraph label="Example 16">For the two dl-programs Π in Example 13, Example 14, {a mathematical formula}I1=∅ is a well-justified FLP answer set, but {a mathematical formula}I2={p(a)} is not. For the dl-program Π in Example 15, {a mathematical formula}I={p(a),q(a)} is not a well-justified FLP answer set.</paragraph><paragraph>As it turns out, the weak, the strong, the FLP and the well-justified FLP answer set semantics constitute a hierarchy of more restrictive notions of answer sets.</paragraph><paragraph label="Theorem 10">Every well-justified FLP answer set of a dl-program Π is an FLP answer set of Π, which in turn is a strong answer set of Π which in turn is a weak answer set of Π.</paragraph><paragraph>While this hierarchy is strict in general, for fragments of dl-programs some of its classes may coincide, and in particular well-justified FLP answer sets coincide with other notions of answer sets. We present some important classes with this property.</paragraph><paragraph>A rich such fragment is the class of dl-programs in which only monotonic dl-atoms occur in the rules. Note that a sufficient condition for this property is that no {an inline-figure} operators occurs in dl-atoms (which can be efficiently checked). Three out of the four answer set semantics coincide in this case.</paragraph><paragraph label="Theorem 11">Let Π be a dl-program relative to a DL knowledge base L such that Π contains no nonmonotonic dl-atoms. Then{a mathematical formula}I⊆HBΠis a well-justified FLP answer set of Π if and only if I is an FLP answer set of Π if and only if I is a strong answer set of Π.</paragraph><paragraph>Theorem 11 does not extend to weak answer sets. In Example 13, relative to {a mathematical formula}L=∅ the dl-atom in {a mathematical formula}Π={p(a)←DL[c⊎p;c](a)} is monotonic; while {a mathematical formula}{p(a)} is a weak answer set of Π, the program has no strong answer set.</paragraph><paragraph>Theorem 11 can be extended to another well-known class of dl-programs, called stratified dl-programs [24]. The notion of a stratification for dl-programs defines an ordered partition of the set of all ground atoms and ground dl-atoms as follows.</paragraph><paragraph label="Definition 15">Let Π be a dl-program relative to a DL knowledge base L. Let S be the set of dl-atoms occurring in {a mathematical formula}ground(Π). A stratification of Π is a mapping {a mathematical formula}μ:HBΠ∪S→{0,1,…,k} such that</paragraph><list><list-item label="1.">For each rule {a mathematical formula}H←A1∧⋯∧Am∧¬B1∧⋯∧¬Bn in {a mathematical formula}ground(Π), {a mathematical formula}μ(H)≥μ(Ai) for {a mathematical formula}1≤i≤m, and {a mathematical formula}μ(H)&gt;μ(Bi) for {a mathematical formula}1≤i≤n, and</list-item><list-item label="2.">{a mathematical formula}μ(D)≥μ(l) (resp. {a mathematical formula}μ(D)&gt;μ(l)) for each input atom {a mathematical formula}l∈HBΠ of each monotonic (resp. nonmonotonic) dl-atom D in S.</list-item></list><paragraph>We call k the length of the stratification μ. {a mathematical formula}ground(Π) is then partitioned into {a mathematical formula}k+1 dl-programs {a mathematical formula}Π0,…,Πk relative to L (called strata), where for each {a mathematical formula}i∈{0,…,k}, {a mathematical formula}Πi={r∈ground(Π)|μ(head(r))=i} with {a mathematical formula}HBΠi={l∈HBΠ|μ(l)=i}. Note that {a mathematical formula}Π0 is a positive dl-program.</paragraph><paragraph label="Definition 16">(See [24].) A dl-program Π is stratified if it has some stratification μ of some length {a mathematical formula}k≥0.</paragraph><paragraph>For a stratified dl-program Π, recursions occur only within each stratum {a mathematical formula}Πi; no recursion occurs across two strata. This makes the inference of answers of predicates in lower strata independent of answers of predicates in higher strata. Therefore, for every nonmonotonic dl-atom A (resp. every negative literal ¬B) occurring in a rule body of stratum {a mathematical formula}Πi, since all input atoms of A (resp. B) are defined in lower strata than {a mathematical formula}Πi, the truth of A (resp. ¬B) is determined by the answers {a mathematical formula}Ii−1 derived from the first {a mathematical formula}i−1 strata. This leads to the following transformation.</paragraph><paragraph>For a stratum {a mathematical formula}Πi and a Herbrand interpretation {a mathematical formula}Ii−1, let {a mathematical formula}Πi(Ii−1) be the set of rules obtained from {a mathematical formula}Πi by deleting</paragraph><list><list-item label="(1)">every rule {a mathematical formula}H←A1∧⋯∧Am∧¬B1∧⋯∧¬Bn such that either some {a mathematical formula}Aj is a nonmonotonic dl-atom not satisfied by {a mathematical formula}Ii−1, or some {a mathematical formula}Bj is satisfied by {a mathematical formula}Ii−1, and</list-item><list-item label="(2)">from the remaining rules all negative literals and all nonmonotonic dl-atoms.</list-item></list><paragraph> Note that {a mathematical formula}Πi(Ii−1) is a positive dl-program.</paragraph><paragraph>The following result is immediate from [24, Theorems 5.6 and 4.14].</paragraph><paragraph label="Theorem 12">Let Π be a stratified dl-program relative to a DL knowledge base L with{a mathematical formula}k+1strata{a mathematical formula}Π0,…,Πk. Then{a mathematical formula}I⊆HBΠis a strong answer set of Π if and only if{a mathematical formula}I=Ik, where{a mathematical formula}I0is the least model of{a mathematical formula}Π0and for each{a mathematical formula}1≤i≤k,{a mathematical formula}Iiis the least model of{a mathematical formula}Πi(Ii−1)∪Ii−1.</paragraph><paragraph>Observe that for each {a mathematical formula}i∈{0,…,k}, {a mathematical formula}Ii is unique and thus I is unique, i.e., a stratified dl-program Π has a unique strong answer set. On the other hand, it is immediate from Theorem 12 that for every strong answer set I of Π, we have {a mathematical formula}I−=Ik−, where {a mathematical formula}Ii−=(⋃0≤j≤iHBΠj)∖Ii, for {a mathematical formula}i=0,…,k. Based on this, the next result shows that for stratified dl-programs, all notions of answer sets that we consider except weak answer sets coincide.</paragraph><paragraph label="Theorem 13">Let Π be a stratified dl-program relative to a DL knowledge base L. Then{a mathematical formula}I⊆HBΠis a well-justified FLP answer set of Π if and only if I is an FLP answer set of Π if and only if I is a strong answer set of Π.</paragraph><paragraph>Furthermore, all semantics in Theorem 13 are canonical in the sense that they yield a single answer set.</paragraph><paragraph>Theorem 13 can be extended to weak answer sets using a stronger notion of stratification, which requires that in item 2 of Definition 15, {a mathematical formula}μ(D)&gt;μ(l) for each input atom l of each (monotonic or nonmonotonic) dl-atom D. This ensures that there is no cycle through any dl-atoms. In such a dl-acyclic stratified program Π, the truth values of dl-atoms in rule bodies are completely known when the rules should be applied. Therefore, for a stratum {a mathematical formula}Πi of Π and a Herbrand interpretation {a mathematical formula}Ii−1, we can transform {a mathematical formula}Πi to {a mathematical formula}Πi(Ii−1) by deleting</paragraph><list><list-item label="(1)">every rule {a mathematical formula}H←A1∧⋯∧Am∧¬B1∧⋯∧¬Bn such that either some {a mathematical formula}Aj is a dl-atom not satisfied by {a mathematical formula}Ii−1, or some {a mathematical formula}Bj is satisfied by {a mathematical formula}Ii−1, and</list-item><list-item label="(2)">from the remaining rules all negative literals and all dl-atoms.</list-item></list><paragraph> Then using the same proof techniques for strong answer sets we can extend Theorem 12, Theorem 13 to weak answer sets.</paragraph></section></section><section label="7"><section-title>Complexity of the well-justified FLP semantics</section-title><paragraph>Observe that a first-order theory amounts to a special logic program in which all rules have an empty body. As it is undecidable to determine whether a given arbitrary first-order theory is satisfiable, it is thus undecidable to determine whether a logic program has an FLP answer set resp. a well-justified FLP answer set. Therefore, we concentrate in this paper on the complexity of propositional logic programs (which are at the core of richer languages) and consider only aggregates that are computable in polynomial time (i.e., for any Herbrand interpretation I, checking whether I satisfies an aggregate atom is feasible in polynomial time).</paragraph><paragraph>Recall that NP are the decision problems solvable by a nondeterministic Turing machine in polynomial time, and that {a mathematical formula}Σ2p=NPNP is likewise but with the help of an NP oracle. Furthermore, for every complexity class {a mathematical formula}C, the class co-{a mathematical formula}C is the class of complementary problems (with yes-no answers reversed); in particular, {a mathematical formula}Π2p=co-Σ2p. We encounter in addition the complexity classes NEXP (nondeterministic time {a mathematical formula}2poly(n)) and N2EXP (nondeterministic time {a mathematical formula}22poly(n)), where {a mathematical formula}poly(n)=⋃k≥1O(nk), and {a mathematical formula}PNEXP and {a mathematical formula}PN2EXP, which contain all decision problems solvable in polynomial time with an NEXP resp. N2EXP oracle. As shown by Hemachandra [37], {a mathematical formula}PNEXP coincides with its nondeterministic counterpart {a mathematical formula}NPNEXP; with his proof technique, the same is easily established for {a mathematical formula}PN2EXP and {a mathematical formula}NPN2EXP.</paragraph><paragraph>We consider the following canonical reasoning problems:</paragraph><list><list-item label="1.">Answer set existence: The problem of deciding whether a given logic program Π has an answer set.</list-item><list-item label="2.">Cautious reasoning: The problem of deciding whether a ground atom is in all answer sets of Π.</list-item><list-item label="3.">Brave reasoning: The problem of deciding whether a ground atom is in some answer set of Π.</list-item></list><section label="7.1"><section-title>Complexity of propositional logic programs</section-title><paragraph>For a propositional logic program Π, we consider the FLP and the well-justified FLP semantics defined over Herbrand models of Π. Our main complexity results are summarized in Table 1. It is interesting to note that for all of the three reasoning tasks, the FLP and the well-justified FLP answer set semantics fall in the same complexity classes. This means that the well-justified FLP answer set semantics enhances the FLP answer set semantics with a level mapping formalism without affecting the worst-case complexity.</paragraph><paragraph>The following theorem shows that for propositional logic programs, deciding the existence of ordinary and well-justified FLP answer sets is complete for {a mathematical formula}NPNP.</paragraph><paragraph label="Theorem 14">Given a propositional logic program Π, deciding whether Π has an FLP answer set or a well-justified FLP answer set is both{a mathematical formula}Σ2p-complete.</paragraph><paragraph>The next theorem shows that for propositional logic programs, deciding whether a ground atom is in every (resp. some) FLP/well-justified FLP answer set is complete for {a mathematical formula}co-NPNP (resp. {a mathematical formula}NPNP).</paragraph><paragraph label="Theorem 15">Given a propositional logic program Π and an atom{a mathematical formula}l∈HBΠ, deciding whether l is in every (resp. some) FLP answer set of Π is{a mathematical formula}Π2p-complete (resp.{a mathematical formula}Σ2p-complete). The same holds for well-justified FLP answer sets.</paragraph><paragraph>The {a mathematical formula}Σ2p- resp. {a mathematical formula}Π2p-hardness of the FLP and the well-justified FLP answer set semantics for propositional logic programs is inherited to some particular fragments, e.g., to propositional logic programs with rules {a mathematical formula}H←B with an atomic head H. On the other hand, for some natural fragments the FLP answer set semantics still remains {a mathematical formula}Σ2p- resp. {a mathematical formula}Π2p-hard, while the well-justified FLP answer semantics has presumably lower complexity; for example, for propositional logic programs with rules {a mathematical formula}H←B, where H is a disjunction of atoms and B a conjunction of literals, it is easily seen that the well-justified FLP answer semantics for this fragment is NP- resp. {a mathematical formula}co-NP-complete for the above reasoning tasks.</paragraph><paragraph>The results for propositional logic programs are easily lifted to logic programs with quantifier-free rules, i.e., rules of the form {a mathematical formula}H←B where H and B are quantifier-free formulas. The complexity in Theorem 14, Theorem 15 increases by one exponential to {a mathematical formula}NEXPNP resp. co-{a mathematical formula}NEXPNP; intuitively, like for normal logic programs this increase is due to the exponentially more succinct representation using variables, whose elimination by grounding causes a blowup, cf. [11].</paragraph></section><section label="7.2"><section-title>Complexity of propositional logic programs with aggregates</section-title><paragraph>When propositional logic programs are extended with polynomially computable aggregates, the complexity under the FLP and the well-justified FLP answer set semantics falls in the same classes as that of propositional logic programs without aggregates.</paragraph><paragraph label="Theorem 16">Given a propositional logic program Π with polynomially computable aggregate atoms, deciding (i) whether Π has some FLP answer set is{a mathematical formula}Σ2p-complete; (ii) whether a given atom{a mathematical formula}l∈HBΠis in every (resp. some) FLP answer set of Π is{a mathematical formula}Π2p-complete (resp.{a mathematical formula}Σ2p-complete). The same holds for well-justified FLP answer sets.</paragraph><paragraph>The {a mathematical formula}Σ2p- resp. {a mathematical formula}Π2p-hardness holds even for particular fragments such as ground normal and ground Horn logic programs with polynomially computable aggregates. A ground normal logic program Π with aggregate atoms consists of rules of the form {a mathematical formula}H←B1∧⋯∧Bm∧¬C1∧⋯∧¬Cn, where H is a ground atom, and each {a mathematical formula}Bi and {a mathematical formula}Ci is either a ground atom or a ground aggregate atom; Π is a ground Horn logic program with aggregate atoms if {a mathematical formula}n=0 for every rule in Π.</paragraph><paragraph>Faber et al. [27] showed that determining whether a given ground normal or Horn logic program with polynomially computable aggregates has an FLP answer set is both {a mathematical formula}Σ2p-complete. This result also holds for the well-justified FLP answer set semantics.</paragraph><paragraph label="Theorem 17">For a ground normal logic program Π with polynomially computable aggregate atoms, deciding whether Π has some well-justified FLP answer set is{a mathematical formula}Σ2p-complete. Furthermore,{a mathematical formula}Σ2p-hardness holds already for ground Horn logic programs Π with polynomially computable aggregates.</paragraph><paragraph>It is immediate that the complexity classes of cautious and brave reasoning for ground normal or Horn logic programs with polynomially computable aggregates are the same as those classes for propositional logic programs with polynomially computable aggregates; i.e., {a mathematical formula}Π2p-complete for cautious reasoning and {a mathematical formula}Σ2p-complete for brave reasoning.</paragraph><paragraph>It is worth noting that while the results are analogous to those in [27], the setting of aggregates is different. In [27]'s formalism, ground aggregate atoms are essentially of the form{a mathematical formula} where {a mathematical formula}ai is a constant and each {a mathematical formula}Fi is a conjunction of ground atoms; an interpretation I satisfies A if {a mathematical formula}OP{ai|I satisfies Fi,1≤i≤m}⪰b evaluates to true. Thus A amounts in our framework to an aggregate atom{a mathematical formula}[27] showed that {a mathematical formula}Σ2p-hardness of the FLP answer set semantics is present already for a ground normal logic program Π with polynomially computable ground aggregate atoms of form A, where m and the size of each {a mathematical formula}Fi are bounded by a constant k. However, for {a mathematical formula}Π′ that is Π with all aggregate atoms A replaced by {a mathematical formula}A′, deciding the existence of a well-justified answer set of {a mathematical formula}Π′ lies in NP. Informally, this holds because in this case, in the fixpoint computation {a mathematical formula}TfΠ′Ii(∅,¬I−) all possible values of aggregation sets {a mathematical formula}SA′J for all interpretations J that satisfy {a mathematical formula}TfΠ′Ii(∅,¬I−)∪¬I− can be determined in polynomial time (in the bound k).</paragraph><paragraph>As the semantics of a nonground normal logic program Π with aggregates is defined in terms of its grounding {a mathematical formula}ground(Π), it is natural to view a nonground aggregate atom A as polynomially computable if each ground instance of A is polynomially computable. Intuitively, since grounding causes an exponential blowup, the complexity of nonground normal logic programs with polynomially computable aggregates is exponentially higher than in the ground case, and thus complete for {a mathematical formula}NEXPNP resp. {a mathematical formula}co-NEXPNP.</paragraph><paragraph>Although it is interesting to study in what cases an aggregate atom is polynomially computable, the topic is beyond the scope of the current paper. As a showcase, however, we mention a class of aggregate atoms of the form{a mathematical formula} where {a mathematical formula}X=X1,…,Xn is a list of aggregate variables with corresponding domains {a mathematical formula}D1,…,Dn, and {a mathematical formula}F(X) is a formula with no quantifiers, no function symbols, and no variables other than the {a mathematical formula}Xis. Note that aggregate atoms of form {a mathematical formula}A′ above are in this class. Such an aggregate atom {a mathematical formula}A″ is polynomially computable if deciding whether a given (Herbrand) interpretation I satisfies {a mathematical formula}A″ can be done in time polynomial in the size of I and {a mathematical formula}A″; this is ensured if the number n of aggregate variables is bounded by a constant and OP can be calculated in polynomial time.</paragraph></section><section label="7.3"><section-title>Complexity of Dl-programs</section-title><paragraph>The complexity of the FLP and the well-justified FLP answer set semantics for a dl-program Π relative to a DL knowledge base L depends on the class of DL that L belongs to. Table 2 summarizes the complexity results when L is in {a mathematical formula}SHIF(D), {a mathematical formula}SHOIN(D) and {a mathematical formula}SROIQ(D), respectively.</paragraph><paragraph>We first prove the following two theorems for the well-justified FLP answer set semantics.</paragraph><paragraph label="Theorem 18">Given a dl-program Π relative to a DL knowledge base L, deciding whether Π has some well-justified FLP answer set is (i) NEXP-complete if L is in{a mathematical formula}SHIF(D), (ii){a mathematical formula}PNEXP-complete if L is in{a mathematical formula}SHOIN(D), and (iii){a mathematical formula}PN2EXP-complete if L is in{a mathematical formula}SROIQ(D).</paragraph><paragraph label="Theorem 19">Given a dl-program Π relative to a DL knowledge base L and an atom{a mathematical formula}l∈HBΠ, deciding whether l is in every (resp. some) well-justified FLP answer set of Π is complete for (i){a mathematical formula}co-NEXP(resp. NEXP) if L is in{a mathematical formula}SHIF(D), (ii){a mathematical formula}PNEXP(resp.{a mathematical formula}PNEXP) if L is in{a mathematical formula}SHOIN(D), and (iii){a mathematical formula}PN2EXP(resp.{a mathematical formula}PN2EXP) if L is in{a mathematical formula}SROIQ(D).</paragraph><paragraph>The next theorem shows that the FLP answer set semantics has the same complexity classes on the problem of answer set existence as the well-justified FLP answer set semantics.</paragraph><paragraph label="Theorem 20">Given a dl-program Π relative to a DL knowledge base L, deciding whether Π has some FLP answer set is (i) NEXP-complete if L is in{a mathematical formula}SHIF(D), (ii){a mathematical formula}PNEXP-complete if L is in{a mathematical formula}SHOIN(D), and (iii){a mathematical formula}PN2EXP-complete if L is in{a mathematical formula}SROIQ(D).</paragraph><paragraph>Since cautious (resp. brave) reasoning for dl-programs falls in the same complexity classes as the non-existence (resp. existence) of FLP answer sets, it immediately follows from Theorem 20 that the complexity classes of cautious (resp. brave) reasoning under the FLP answer set semantics is the same as those classes under the well-justified FLP answer set semantics.</paragraph><paragraph>We finally note that analogous upper bounds (i.e., membership results) to those in Table 2 hold for dl-programs over description logics where knowledge base satisfiability has the same complexity as for {a mathematical formula}SHIF(D), {a mathematical formula}SHOIN(D) or {a mathematical formula}SROIQ(D) (which is EXP-, NEXP- and N2EXP-complete, respectively). However, matching lower bounds (i.e., corresponding hardness results) are not entailed by our results.</paragraph></section></section><section label="8"><section-title>Implementation of the well-justified FLP semantics</section-title><paragraph>We have implemented the well-justified FLP answer set semantics and developed a system that hosts normal logic programs with aggregates, dl-programs and, moreover, hex-programs (which we did not consider here). In this section, we describe the algorithm used for the implementation and the architecture of the system. We also describe an experimental evaluation of the performance of computing both FLP and well-justified FLP answer sets over some benchmark logic programs.</paragraph><paragraph>For simplicity, in the following description we restrict to ground logic programs. A complex atom is either an aggregate atom, a dl-atom, or an external atom, so by a normal logic program with complex atoms we refer to a normal logic program with aggregate atoms, a dl-program, or a hex-program. All complex atoms A are assumed to be decidable, i.e., for any Herbrand interpretation I, checking whether I satisfies A is feasible in finite time.</paragraph><section label="8.1"><section-title>Implementation description</section-title><paragraph>Our algorithm for computing well-justified FLP answer sets consists of two main parts: a guessing and a checking part. Given a normal logic program Π with complex atoms, the guessing part computes models of Π that serve as answer set candidates. For each such model I, the checking part then computes the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)) for the FLP reduct {a mathematical formula}fΠI; if {a mathematical formula}I=lfp(TfΠI(∅,¬I−)), then I is a well-justified FLP answer set of Π.</paragraph><paragraph>The implementation realizes the guessing part by first transforming Π into a normal logic program {a mathematical formula}Πˆ without complex atoms (called the guessing program). The result of this step will be sent to an ASP solver, which computes the stable models of {a mathematical formula}Πˆ under the standard answer set semantics. These models are used as input to the checking part, which selects the well-justified FLP answer sets as output.</paragraph><paragraph label="Definition 17">Let Π be a normal logic program with complex atoms. The guessing program of Π, denoted {a mathematical formula}Πˆ, is obtained from Π as follows. For each complex atom A in Π, (1) replace A with a fresh atom {a mathematical formula}EA, and (2) add two new rules to Π, {a mathematical formula}EA←¬EA′ and {a mathematical formula}EA′←¬EA, where {a mathematical formula}EA′ is a fresh atom.</paragraph><paragraph>For convenience, in the above definition we call {a mathematical formula}EA the replacement atom of A, and call A the source complex atom of {a mathematical formula}EA.</paragraph><paragraph>For an interpretation {a mathematical formula}Iˆ of {a mathematical formula}Πˆ, its projection I on Π is {a mathematical formula}Iˆ with all replacement atoms {a mathematical formula}EA along with {a mathematical formula}EA′ removed. Observe that when {a mathematical formula}Iˆ is an answer set of {a mathematical formula}Πˆ, I may not be an FLP or a well-justified FLP answer set of Π, and even not be a model of Π. So we make use of the concept of compatible sets as introduced by Eiter et al. [20].</paragraph><paragraph label="Definition 18">Let Π be a normal logic program with complex atoms and {a mathematical formula}Πˆ be its guessing program. Let {a mathematical formula}Iˆ be an answer set of {a mathematical formula}Πˆ and I be its projection on Π. We call {a mathematical formula}Iˆ a compatible set of Π, if for every replacement atom {a mathematical formula}EA in {a mathematical formula}Πˆ, {a mathematical formula}EA∈Iˆ if and only if I satisfies the source complex atom A of {a mathematical formula}EA.</paragraph><paragraph>It is not hard to see that for every compatible set {a mathematical formula}Iˆ of Π, its projection I on Π is a model of Π, and that the projections of all compatible sets include all FLP answer sets of Π (see the proof of Theorem 21), hence all well-justified FLP answer sets of Π.</paragraph><paragraph>However, there may exist compatible sets whose projections are not FLP answer sets. Therefore, we need to check whether the projection I of each compatible set {a mathematical formula}Iˆ is an FLP resp. well-justified FLP answer set of Π. This check amounts to verifying that I is a minimal model of the FLP reduct {a mathematical formula}fΠI in case of FLP answer sets [21]; for well-justified FLP answer sets, the checking part permits only candidates I that are equal to {a mathematical formula}lfp(TfΠI(∅,¬I−)).</paragraph><paragraph>Algorithm 1 summarizes the process of computing all well-justified FLP answer sets using compatible sets.</paragraph><paragraph label="Example 17">Consider the logic program {a mathematical formula}Π1 from Example 1. In the guessing part, we construct the following guessing program:{a mathematical formula} The replacement atom {a mathematical formula}ESUM〈X:p(X)〉≥1 has been introduced for the aggregate atom {a mathematical formula}SUM〈X:p(X)〉≥1 occurring in {a mathematical formula}Π1. The program {a mathematical formula}Πˆ1 has two answer sets: {a mathematical formula}Iˆ1={p(1),ESUM〈X:p(X)〉≥1′} and {a mathematical formula}Iˆ2={p(1),ESUM〈X:p(X)〉≥1,p(−1),p(2)}. Their projections on {a mathematical formula}Π1 are {a mathematical formula}I1={p(1)} and {a mathematical formula}I2={p(1),p(−1),p(2)}, of which only {a mathematical formula}Iˆ2 is a compatible set of {a mathematical formula}Π1; thus {a mathematical formula}I2 is the only answer set candidate of {a mathematical formula}Π1. The checking part then computes the fixpoint {a mathematical formula}lfp(TfΠ1I2(∅,¬I2−))={p(1)}; as it is different from {a mathematical formula}I2, the latter is not a well-justified FLP answer set of {a mathematical formula}Π1. Consequently, Algorithm 1 outputs for {a mathematical formula}Π1 no well-justified FLP answer sets, which is the correct result.</paragraph><paragraph>The following result shows that Algorithm 1 correctly computes the well-justified FLP answer set semantics.</paragraph><paragraph label="Theorem 21">Assume all complex atoms in logic programs are decidable. ThenAlgorithm 1is sound and complete w.r.t. the well-justified FLP answer set semantics for normal logic programs with aggregates, dl-programs andhex-programs.</paragraph><paragraph>We implemented Algorithm 1 by extending our ASP reasoner dlvhex.{sup:5} The system architecture of dlvhex is depicted in Fig. 1, which consists of four major components:</paragraph><list><list-item label="•">a rewriter, which constructs a guessing program {a mathematical formula}Πˆ from a normal logic program Π with complex atoms;</list-item><list-item label="•">a state-of-the-art ASP solverclasp,{sup:6} which computes answer sets of {a mathematical formula}Πˆ;</list-item><list-item label="•">a compatibility checker, which identifies the compatible sets among the answer sets of {a mathematical formula}Πˆ; and</list-item><list-item label="•">a fixpoint iterator, which for the projection I of each compatible set {a mathematical formula}Iˆ computes the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)).</list-item></list><paragraph>dlvhex can also compute FLP answer sets, using the same architecture except that the fixpoint iterator is replaced by a minimality checker, which checks if I is a minimal model of the FLP reduct {a mathematical formula}fΠI[21].</paragraph></section><section label="8.2"><section-title>Experimental evaluation</section-title><paragraph>In Section 7, we show that the well-justified FLP answer set semantics enhances the FLP answer set semantics with a level mapping formalism without affecting the worst-case complexity. In this subsection, we present experimental results which show that computing well-justified FLP answer sets is faster than computing FLP answer sets on some benchmark programs. To this end, we use hex-program encodings of several benchmark problems that have been developed in other contexts such that the FLP answer sets correspond to the solutions of the problems; as the well-justified FLP answer sets are particular FLP answer sets, the latter yield particular solutions obtained by a fixpoint construction that avoids a customary minimality check for a model candidate under the FLP semantics, which usually is expensive. It is thus interesting to see the effect of resorting to well-justified FLP answer sets of the encodings if one is just interested in some solutions (and less in the additional quality of avoiding circularity).</paragraph><paragraph>For the evaluation we compared runtimes in seconds under the FLP and under the well-justified FLP semantics using three benchmark domains: Abstract Argumentation, Inconsistency Explanation for Multi-Context Systems, and Set Partitioning, where {a mathematical formula}A, {a mathematical formula}M and {a mathematical formula}P are used to denote the set of all instances, respectively. The first and the second are motivated by applications in knowledge representation and reasoning, while the third benchmark is synthetic. Each benchmark instance {a mathematical formula}i∈A∪M∪P with size {a mathematical formula}|i| has an associated parameter setting. We collect the total runtime {a mathematical formula}tX(i), i.e., the time from startup to termination, and the runtime per answer set {a mathematical formula}pX(i), i.e., the total runtime divided by the number of answer sets (which is only applicable if at least one answer set exists) of our system under the FLP answer set semantics ({a mathematical formula}X=flp) and under the well-justified FLP answer set semantics ({a mathematical formula}X=wj). We summarize for each benchmark {a mathematical formula}B=A,M,P and instance size s the outcome in tables with maximum and average factors {a mathematical formula}tmaxB(s), {a mathematical formula}pmaxB(s), {a mathematical formula}tavgB(s) and {a mathematical formula}pavgB(s), which have been computed for {a mathematical formula}op=max,avg and runtime {a mathematical formula}r=t,p as follows:{a mathematical formula} We call {a mathematical formula}ropB(s) a speedup factor, if {a mathematical formula}ropB(s)&lt;1 and a slowdown factor, if {a mathematical formula}ropB(s)&gt;1. For computing {a mathematical formula}popB(s) we consider only those instances which have at least one answer set under both semantics.</paragraph><paragraph>We evaluated the implementation on a Linux server with two 12-core AMD 6176 SE CPUs with 128 GB RAM. The runtimes are compared with a timeout of 300 seconds, and each run has been limited to use at most 4 GB main memory. Learning from external sources (cf. [20] for external behavior learning) is an important optimization mechanism for improving the performance of answer set computation. At the moment, however, it has been implemented in dlvhex only for the FLP answer set semantics, not yet for the well-justified FLP semantics. Thus we decided to turn this optimization mechanism off for the benchmarks to ensure a fair comparison. If external behavior learning was enabled, due to the effect of optimization, the evaluation under the FLP answer set semantics would be faster than under the well-justified FLP semantics in all cases.{sup:7} The problem encodings have been developed for the FLP semantics. The well-justified FLP answer set semantics delivers a subset of the FLP answer sets as an approximation therefore.</paragraph><paragraph>Abstract argumentation An abstract argumentation framework (AF) [18] is a pair {a mathematical formula}F=(A,R) of a set A of arguments and a relation {a mathematical formula}R⊆A×A that can be viewed as a directed graph, where the nodes represent arguments and an arc {a mathematical formula}a→b represents that argument a attacks argument b. The semantics of an AF is defined in terms of extensions, which are sets of arguments that fulfill certain criteria, depending on the particular semantics in use. As shown by Dung, a number of problems in artificial intelligence can be elegantly encoded as reasoning tasks on abstract argumentation frameworks.</paragraph><paragraph>In this benchmark, which was considered earlier in [21], we consider computing ideal sets[17], which serve to refine the seminal semantics in [18]. A set I of arguments is an ideal set of an AF {a mathematical formula}F=(A,R) if I is an admissible set that is contained in all preferred extensions, i.e., subset-maximal admissible set of F, where a set S of arguments is admissible if S does not contain self attacks, i.e., there are no arcs between nodes in S, and each argument attacking some argument in S is attacked by some argument in S, i.e., if an arc leads from a node a into S then an arc leads from some node in S to a. For example, if {a mathematical formula}F=({a,b,c},{(a,b),(b,a)}), then ∅, {a mathematical formula}{c}, {a mathematical formula}{a,c}, and {a mathematical formula}{b,c} are the admissible sets and thus {a mathematical formula}{a,c}, {a mathematical formula}{b,c} the preferred extensions; hence, ∅ and {a mathematical formula}{c} are the ideal sets. For further discussion and use of ideal sets, we refer to [17], [5].</paragraph><paragraph>The hex-program encoding uses an external atom that allows to verify whether a given set T of arguments is a preferred extension of the input AF F; a guess for an ideal set I is then verified using this atom and a customary saturation technique to ensure that no preferred extension T exists such that {a mathematical formula}I⊈T. The FLP answer sets of the encoding correspond one-to-one to the ideal extensions of F.{sup:8}</paragraph><paragraph>Each argumentation framework {a mathematical formula}F=(A,R) in our benchmark set {a mathematical formula}A consists of {a mathematical formula}n=|A| arguments, and R is the attacks relation that consists of edges independently chosen from {a mathematical formula}A×A with probability p. For each parameter setting {a mathematical formula}(n,p), where {a mathematical formula}n=5,6,…,10 and {a mathematical formula}p∈{0.03,0.05,0.07,0.09,0.11}, we have created ten instances {a mathematical formula}F(n,p,1),…,F(n,p,10); the size of each instance F is {a mathematical formula}n=|A|.</paragraph><paragraph>Table 3 summarizes the results grouped by the number n of arguments. We also report the percentage of the instances within each group of n arguments that are faster resp. slower under the well-justified FLP semantics compared to the FLP semantics. For the remaining instances, we either could not observe a speedup or slowdown, or the runs timed out under both semantics. We see that if we measure the total runtime for an instance, then the evaluation under the well-justified FLP semantics is more efficient than under the FLP semantics for a majority of instances.</paragraph><paragraph>Eiter et al. [21] noted that the minimality check for model candidates under the FLP semantics is costly for this benchmark problem. In contrast, the fixpoint iteration under the well-justified FLP semantics seems to be rather cheap. Our explanation for this effect is that many atoms in this benchmark domain can be computed deterministically by exploiting the program structure. Thus, checking satisfaction of external atoms under partial assignments is efficient for such instances, even though the worst case would require to make exponentially many calls until the fixpoint has been reached. On the other hand, the minimality check of the FLP reduct under the FLP semantics remains exponential.</paragraph><paragraph>If we measure the runtime per answer set as defined above, the picture is different. In this case the evaluation under the FLP semantics is more efficient, as there is a large number of FLP answer sets that are not well-justified FLP answer sets (for most instances, only one FLP answer set is well-justified). Thus, the FLP semantics requires to compute far more models, but with only slightly longer total runtime, which leads to a better average runtime.</paragraph><paragraph>Inconsistency explanation for Multi-Context Systems Nonmonotonic Multi-Context-Systems (MCSs) were proposed in [7] as a generic formalism for aligning knowledge bases called contexts, which emerged by an evolution of formalisms rooted in [35]. An MCS is a collection {a mathematical formula}M=(C1,…,Cn) of contexts {a mathematical formula}Ci, each of which holds a knowledge base {a mathematical formula}kbi in some logic {a mathematical formula}Li whose semantics is given in terms of abstract acceptable belief sets (which usually are sets of formulas, or models). The contexts are interlinked via so called bridge rules, which enable belief exchange across contexts; for example, a bridge rule {a mathematical formula}br:(1:a)←not(2:b) informally says that a should be in {a mathematical formula}C1's knowledge base, if b is not in the local belief set of context {a mathematical formula}C2. The semantics of an MCS is defined in terms of equilibria, which are belief states {a mathematical formula}S=(S1,…,Sn) composed of local belief sets {a mathematical formula}Si of the knowledge bases {a mathematical formula}kbi satisfying the bridge rules.</paragraph><paragraph>However, compliance of the bridge rules with the knowledge bases may be impossible to achieve; that is, the MCS is inconsistent (even if the local knowledge bases are consistent). For example, if {a mathematical formula}M=(C1,C2), where {a mathematical formula}kb1={⊥←a} and {a mathematical formula}kb2={c} are both logic programs and there is the single bridge rule br from above, then M has no equilibrium, although both {a mathematical formula}kb1 and {a mathematical formula}kb2 have an answer set (where answer sets are acceptable belief sets). To understand the reasons for inconsistency, Eiter et al. [22] introduced the notion of an inconsistency explanation (IE) for an MCS M, which aims at characterizing an inconsistency core through bridge rules, i.e., faulty interlinkage. Roughly speaking, an IE consists of bridge rules whose presence or inapplicability will necessarily entails inconsistency; the technical definition is involved, and we thus refrain from detailing it here. In the example above, the presence of the single bridge rule br entails inconsistency, and hence amounts to an IE. For further background and discussion of MCS and applications, we refer to [7], [8], [22].</paragraph><paragraph>This benchmark set computes IEs, which correspond one-to-one to the FLP answer sets of an hex-encoding of the problem. The encoding{sup:9} as cycles through external atoms which intuitively evaluate the semantics of the context knowledge bases. We used the MCS benchmark instances generated for [19]. These random instances are grouped into consistent and inconsistent instances, and the contexts are interlinked with various fixed topologies that should resemble different scenarios: ordinary and zig-zag diamond stack, house stack, ring, and binary tree. A diamond stack combines multiple diamonds in a row (stacking m diamonds in a tower of {a mathematical formula}3m+1 contexts). Ordinary diamonds have, in contrast to zig-zag diamonds, no connection between the two middle contexts. A house consists of five nodes with six edges (the ridge context has directed edges to the two middle contexts, which form with the two base contexts a cycle with 4 edges); house stacks are subsequently built up by using the basement nodes as ridges for the next houses (thus, m houses have {a mathematical formula}4m+1 contexts). Binary trees grow balanced, i.e., every level is complete except for the last level, which grows from the left-most context.</paragraph><paragraph>A parameter setting {a mathematical formula}(c,s,b,r) for an instance {a mathematical formula}M=(C1,…,Cc) from {a mathematical formula}M specifies (i) the number c of contexts, (ii) the local alphabet size {a mathematical formula}|Σi|=s (each {a mathematical formula}Ci has a random logic program on s atoms with 2k answer sets, {a mathematical formula}0≤k≤s/2), (iii) the maximum interface size b (number of atoms exported), and (iv) the maximum number r of bridge rules per context, each having ≤2 body literals. The benchmark set consists of instances with {a mathematical formula}c=3,…,9 contexts, each {a mathematical formula}|Σi|=2, {a mathematical formula}b=1, and {a mathematical formula}r=2. The instances have been created with the benchmark generator for DMCS [13], which is available from the benchmark homepage.</paragraph><paragraph>Table 4 summarizes the results grouped by the number of contexts c. We report the results only up to size 9 because all greater instances timeout under both semantics. We also report the percentage of the instances within each group of c contexts that are faster resp. slower under the well-justified FLP semantics compared to the FLP semantics. For the remaining instances, we either could not observe a speedup or slowdown, or the runs timed out under both semantics.</paragraph><paragraph>As for the argumentation benchmarks, evaluation under the well-justified FLP semantics is mostly faster than under the FLP semantics if we measure the total runtime, but the speedup is smaller in this case. This is because the program structure does not allow for deriving as many literals deterministically as in the argumentation benchmark. This makes the fixpoint iteration more complex, as checking satisfaction of an external atom under a partial interpretation requires to consider all its possible completions.</paragraph><paragraph>Unlike in our argumentation benchmark, also the average runtime per answer set is for the well-justified FLP semantics smaller than for the FLP semantics. This is because in this benchmark most FLP answer sets are well-justified and the two semantics yield the same set of models in many cases. The better total runtime for the well-justified FLP semantics thus carries over to the average case.</paragraph><paragraph>Set partitioning This benchmark uses the following hex-program:{a mathematical formula} where {a mathematical formula}&amp;diff[p,q](X) computes the set of all elements X which are in the extension of p but not in the extension of q. It computes in its FLP answer sets all partitionings of a set into two (possibly empty) partitions where the first has size at most two, using an external atom for computing the set difference. In fact, each of the FLP answer sets is well-justified, and thus the two semantics coincide; this is because the derivation of any atom in an FLP answer set does not rely on other atoms except facts. Thus, fixpoint iteration can reproduce the answer set already in the first iteration.</paragraph><paragraph>The evaluation results are shown in Table 5. Note that we do not group benchmark instances in this case, thus the average and maximum speedup/slowdown is the same for each row. In this benchmark the computation under the well-justified FLP semantics is always faster than under the FLP semantics. This is because the constraints of kind {a mathematical formula}¬sel(x) (resp. {a mathematical formula}¬nsel(x)) are added right at the beginning of the fixpoint iteration for all atoms which are not in the compatible set. This makes the corresponding atom {a mathematical formula}&amp;diff[domain,sel](x) (resp. {a mathematical formula}&amp;diff[domain,nsel](x)) immediately satisfied in the first iteration. Thus, the fixpoint iteration always terminates after the first iteration, while the necessary minimality check for the FLP semantics is exponential. All FLP answer sets of this program are also well-justified FLP answer sets, thus the picture does not change if we measure the average runtime per answer set. For {a mathematical formula}c&gt;12 the results do not change anymore.</paragraph></section></section><section label="9"><section-title>Related work</section-title><paragraph>The FLP answer set semantics, in the spirit of minimal models of FLP reducts, was first introduced in [26], [27] for normal and disjunctive logic programs with aggregates. This method of defining answer sets has further been applied to description logic programs and hex-programs [25], [24], tightly coupled dl-programs [46], modular logic programs [12], etc. Since FLP reducts are treated as classical implications instead of rules, such FLP answer sets suffer from possible circular justifications (see Example 1, Example 15; Shen and Wang [55], [56] illustrated the circular justification problem with the FLP answer set semantics of Lukasiewicz [46]).</paragraph><paragraph>For logic programs with first-order formulas, Bartholomew et al. [4] reformulated the FLP answer set semantics of Definition 2 in terms of a modified form of circumscription. Unlike Definition 2, this reformulation refers to no program grounding and employs no SNA assumption. As shown in Example 2, this FLP answer set semantics suffers from the circular justification problem.</paragraph><paragraph>Ferraris [29] defined answer sets for logic programs with propositional formulas and aggregates based on a new definition of equilibrium logic [51]. Ferraris et al. [30] further extended this answer set semantics to first-order formulas in terms of a modified circumscription. Pearce [52] proposed to identify answer sets with equilibrium models in equilibrium logic. de Bruijn et al. [15] further applied the semantics of Pearce [52], while Lee and Palla [42] applied the semantics of Ferraris et al. [30], to integrate rules and ontologies for the Semantic Web. It turns out that the answer set semantics of Pearce [52] coincides with that of Ferraris [29] in the propositional case and with that of Ferraris et al. [30] in the first-order case. We observe that these answer set semantics also suffer from circular justifications. As an example, for the propositional logic program {a mathematical formula}Π={p←¬¬p}, {a mathematical formula}I={p} is neither a well-justified FLP answer set nor an FLP answer set (Definition 2); however, I is an answer set under the semantics of Ferraris [29], Ferraris et al. [30] and Pearce [52]. This answer set has a circular justification caused by the self-supporting loop {a mathematical formula}p⇐¬¬p⇐p, i.e. p being in I is due to I satisfying {a mathematical formula}¬¬p, which in turn is due to p being in I.</paragraph><paragraph>The well-justified FLP answer set semantics inherits the anti-chain property of the FLP answer set semantics, i.e. no well-justified FLP answer set is a proper subset of another well-justified FLP answer set (see Theorem 4); in contrast, none of the semantics of Ferraris [29], Ferraris et al. [30] and Pearce [52] has this property. As an alternative, Pearce [52] further proposed to use only minimal equilibrium models to define answer sets (see Section 6.1 of Pearce [52]). However, it turns out that applying the minimization method does not overcome the circular justification problem. To illustrate, consider the propositional logic program {a mathematical formula}Π={p←¬¬p,p←¬p}. {a mathematical formula}I={p} is not an FLP answer set of Π, but it is a minimal equilibrium model and thus is an answer set under the semantics of Pearce [52], Ferraris [29] and Ferraris et al. [30]. This answer set has a circular justification {a mathematical formula}p⇐¬¬p⇐p.</paragraph><paragraph>The above examples show that an answer set of Ferraris [29], Ferraris et al. [30] and Pearce [52] is not necessarily an FLP or a well-justified FLP answer set; the following example illustrates that also the converse direction fails. Consider the propositional logic program {a mathematical formula}Π={p←p∨¬p}. Since {a mathematical formula}p∨¬p is a tautology in classical logic, {a mathematical formula}I={p} is both an FLP and a well-justified FLP answer set of Π. However, under the semantics of Pearce [52], Ferraris [29] and Ferraris et al. [30], Π is identified with the normal logic program {a mathematical formula}Π′={p←p,p←¬p}, thus {a mathematical formula}I={p} is not an answer set of these semantics.</paragraph><paragraph>Truszczyński [63] defined an answer set semantics for logic programs with propositional formulas by introducing a different program transformation called FLPT reducts, which agrees with the FLP answer set semantics of Faber et al. [26], [27] for normal and disjunctive logic programs. Such answer sets may also have circular justifications. For instance, the interpretation {a mathematical formula}I={p(1),p(−1)} of {a mathematical formula}Π2 in Example 2, which has circular justifications, is an answer set under the semantics of Truszczyński [63]. Moreover, this semantics does not share the anti-chain property of the FLP answer set semantics. Hence, answer sets of Truszczyński [63] are neither FLP answer sets nor well-justified FLP answer sets in general. The following example (borrowed from [4]) disproves a converse inclusion. For a logic program {a mathematical formula}Π={¬¬p,p∨¬p←¬¬p}, {a mathematical formula}I={p} is both an FLP and a well-justified FLP answer set of Π, but I is not an answer set under the semantics of Truszczyński [63].</paragraph><paragraph>For a logic program Π whose rule heads are atoms, in [16], [53] a three-valued fixpoint semantics was introduced based on three-valued operators. This fixpoint semantics defines answer sets, called two-valued stable models, which are free of circular justifications. As discussed in Section 5.1, there are at least three significant differences between the three-valued fixpoint semantics and the well-justified FLP answer set semantics. That is, the former is defined over three-valued interpretations, while the latter is defined over two-valued interpretations; the former is applicable only to logic programs whose rule heads are atoms, while the latter applies to logic programs whose rule heads are arbitrary first-order formulas; and as shown by Theorem 8, the former is more conservative than the latter in the sense that two-valued stable models of the three-valued fixpoint semantics are well-justified FLP answer sets, which by Corollary 2 are also FLP answer sets, but the converse does not hold. This means that the two-valued stable models may exclude some FLP answer sets that are free of circular justifications.</paragraph><paragraph>For normal logic programs with c-atoms or positive basic logic programs, in [60], [59] it was shown that the conditional satisfaction-based answer set semantics agrees with the three-valued fixpoint semantics of Denecker et al. [16] and of Pelov et al. [53]. By Theorem 9, for such logic programs the well-justified FLP answer set semantics also agrees with the three-valued fixpoint semantics. Shen and You [57] gave an alternative characterization of the conditional satisfaction-based semantics in terms of a generalized Gelfond–Lifschitz transformation. Liu et al. [45] proposed a computation-based answer set semantics for normal logic programs with c-atoms, which proves to coincide with the conditional satisfaction-based semantics.</paragraph></section><section label="10"><section-title>Summary and future work</section-title><paragraph>The FLP answer set semantics [26], [27] has been widely used to define answer sets for different types of logic programs. However, when being extended from normal logic programs to more general classes of logic programs, the FLP answer set semantics suffers from circular justifications. The intuitive reason behind the circular justification problem is that the FLP answer set semantics does not induce a level mapping for its answer sets. In this paper, we have overcome this shortcoming by enhancing the FLP answer set semantics with a suitable level mapping.</paragraph><paragraph>Inspired by the fact that each answer set I of a normal logic program Π under the standard answer set semantics has a level mapping that is induced by the fixpoint construction of I using the van Emden–Kowalski one-step provability operator {a mathematical formula}TΠI(S) for the Gelfond–Lifschitz reduct {a mathematical formula}ΠI, we define well-justified FLP answer sets I of a general logic program Π as fixpoints that are obtained by iteratively applying an extended van Emden–Kowalski operator {a mathematical formula}TfΠI(O,N) for the FLP reduct {a mathematical formula}fΠI; such FLP answer sets always have a level mapping and are thus free of circular justifications. As a generic approach, the well-justified answer set semantics applies to logic programs with first-order formulas, logic programs with aggregates or c-atoms, and description logic programs. It can easily be extended to other well-known types of logic programs, such as hex-programs, tightly coupled dl-programs and modular logic programs, by a suitable adjustment of the satisfaction relation. To the best of our knowledge, the answer set semantics presented here is the first that is free of circular justifications for such general kinds of logic programs.</paragraph><paragraph>We have studied in depth the computational complexity of the FLP and the well-justified FLP answer set semantics for general logic programs. For the major reasoning tasks, the FLP and the well-justified FLP answer set semantics fall in the same complexity classes. This means that the well-justified FLP answer set semantics enhances the FLP answer set semantics with a level mapping formalism without affecting the worst-case complexity.</paragraph><paragraph>We have implemented the well-justified FLP answer set semantics by extending the ASP reasoner dlvhex, which currently can compute well-justified FLP answer sets for normal logic programs with aggregates, dl-programs and hex-programs. We also conducted an experimental evaluation, which shows on benchmark problems the potential of the well-justified FLP answer set semantics in two respects: it not only employs a stronger notion of foundedness than the FLP answer set semantics, but it is also faster to compute (due to its fixpoint design, which is beneficial for answer set checking). To find some FLP answer set, it thus seems attractive to start the search by finding a well-justified FLP answer set.</paragraph><paragraph>Open issues We focused in this article on logic programs with rules of the form {a mathematical formula}H←B, where H and B are first-order formulas, possibly with aggregates and/or dl-atoms. Such logic programs do not cover disjunctive logic programs introduced in [34], which consist of rules of the form {a mathematical formula}A1|⋯|Al←B1∧⋯∧Bm∧¬C1∧⋯∧¬Cn, where each {a mathematical formula}Ai, {a mathematical formula}Bi and {a mathematical formula}Ci is an atom, and | is an epistemic disjunction operator that is different from the classical disjunction connective ∨ (see [31] for their differences). As future work, it is interesting to extend the well-justified FLP answer set semantics to logic programs with rules of the form {a mathematical formula}H1|⋯|Hl←B, where B and each {a mathematical formula}Hi are first-order formulas. In connection with this, it remains to deploy well-justified answer sets to further classes of logic programs.</paragraph><paragraph>On the computational side, a study of the decidability and computational complexity of first-order logic programs with formulas from various decidable fragments of first-order logic, under different notions of answer sets (including well-justified FLP answer sets) is an interesting issue. Moreover, to develop methods for further improving the efficiency of the current implementation of the well-justified FLP answer set semantics is a challenging task.</paragraph><paragraph>Finally, it is of practical significance to exploit real-world applications where the well-justified FLP answer set semantics yields more intuitive results than the existing state-of-the-art answer set semantics.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>We would like to thank all anonymous reviewers for their constructive comments, which helped to significantly improve this paper. This work is supported in part by China National 973 program2014CB340301 and NSFC grant 61379043, the Austrian Science Fund (FWF) project P24090, and the Australian Research Council (ARC) under DP1093652 and DP130102302.</paragraph></acknowledgements><appendices><section label="Appendix A"><section-title>Proofs</section-title><paragraph label="Proof of Proposition 1">(⟹) Assume that {a mathematical formula}S=〈S0,S1,⋯,Sm〉 is a level mapping of I under Definition 4. Since all rule heads of Π are atoms, {a mathematical formula}S′=〈S1,⋯,Sm〉 is a level mapping of rule heads of Π w.r.t. I. Since I is a model of Π and {a mathematical formula}⋃1≤i≤mSi=I, there is no rule r in {a mathematical formula}ground(Π) such that {a mathematical formula}head(r) is not in {a mathematical formula}⋃1≤i≤mSi and {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤mSi (otherwise, I would not be a model of Π). This means {a mathematical formula}S′ is a total level mapping of rule heads of Π w.r.t. I. For {a mathematical formula}k=1,⋯,m, let {a mathematical formula}lk=k. Obviously, for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, {a mathematical formula}⋃0≤i≤lkSi⊨A but {a mathematical formula}⋃0≤i≤lk−1Si⊭A. Therefore, S is a level mapping of I under Definition 7.(⟸) Assume that {a mathematical formula}S=〈S0,S1,⋯,Sm〉 is a level mapping of I under Definition 7. Let {a mathematical formula}S0′=I−. Then there is a total level mapping {a mathematical formula}S′=〈S1′,⋯,Sn′〉 of rule heads of Π w.r.t. I and integers {a mathematical formula}l1,⋯,lm where {a mathematical formula}1≤l1&lt;⋯&lt;lm≤n such that for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, {a mathematical formula}⋃0≤i≤lkSi′⊨A but {a mathematical formula}⋃0≤i≤lk−1Si′⊭A. Since all rule heads of Π are atoms, for each {a mathematical formula}k&gt;0{a mathematical formula}Sk′ consists of atoms. By the fact that for every {a mathematical formula}A∈Sk, {a mathematical formula}⋃0≤i≤lkSi′⊨A but {a mathematical formula}⋃0≤i≤lk−1Si′⊭A, it follows that for every {a mathematical formula}k=1,⋯,m, {a mathematical formula}Sk⊆Slk′. Since {a mathematical formula}⋃1≤i≤mSi=I, I is a subset of {a mathematical formula}⋃1≤i≤nSi′; since I is a model of Π, {a mathematical formula}⋃1≤i≤nSi′ must be a subset of I; hence {a mathematical formula}⋃1≤i≤nSi′=I. By the fact that {a mathematical formula}⋃1≤i≤mSi=I, that {a mathematical formula}⋃1≤k≤mSlk′⊆I, and that for every {a mathematical formula}k=1,⋯,m, {a mathematical formula}Sk⊆Slk′, it follows that for every {a mathematical formula}k=1,⋯,m, {a mathematical formula}Sk=Slk′. This means {a mathematical formula}m=n and {a mathematical formula}lk=k for every {a mathematical formula}k&gt;0. Thus {a mathematical formula}S′=〈S1,⋯,Sm〉. Therefore {a mathematical formula}〈S1,⋯,Sm〉 is also a total level mapping of rule heads of Π w.r.t. I. By Definition 6, for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, there is a rule {a mathematical formula}A←body(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤k−1Si. Hence S is a level mapping of I under Definition 4.  □</paragraph><paragraph label="Proof of Proposition 2">(⟹) When I has a level mapping, it is immediate from Definition 7 that there is a total level mapping {a mathematical formula}S′=〈S1′,⋯,Sn′〉 of rule heads of Π w.r.t. I such that {a mathematical formula}⋃0≤i≤nSi′⊨A for every {a mathematical formula}A∈I.(⟸) Assume that there is a total level mapping {a mathematical formula}S′=〈S1′,⋯,Sn′〉 of rule heads of Π w.r.t. I such that {a mathematical formula}⋃0≤i≤nSi′⊨A for every {a mathematical formula}A∈I. For {a mathematical formula}k=1,⋯,n, let {a mathematical formula}Rk consist of all {a mathematical formula}A∈I such that {a mathematical formula}⋃0≤i≤kSi′⊨A but {a mathematical formula}⋃0≤i≤k−1Si′⊭A. Then {a mathematical formula}⋃1≤i≤nRi=I. Among {a mathematical formula}R1,⋯,Rn, assume only {a mathematical formula}Rl1,⋯,Rlm are nonempty, where {a mathematical formula}1≤l1&lt;⋯&lt;lm≤n. For {a mathematical formula}k=1,⋯,m, let {a mathematical formula}Sk=Rlk. Then by Definition 7, {a mathematical formula}S=〈S0,S1,⋯,Sm〉 is a level mapping of I.  □</paragraph><paragraph label="Proof of Lemma 1">We prove the claim by induction on {a mathematical formula}i≥0. It clearly holds for {a mathematical formula}i=0. For the induction step, assume that I is a model of {a mathematical formula}TΠi(∅,¬I−); we prove that I is then also a model of {a mathematical formula}TΠi+1(∅,¬I−).Let {a mathematical formula}S=TΠi+1(∅,¬I−)∖TΠi(∅,¬I−). For each formula {a mathematical formula}H∈S, there is a rule {a mathematical formula}r∈ground(Π) with {a mathematical formula}head(r)=H such that {a mathematical formula}TΠi(∅,¬I−)∪¬I−⊨body(r). By the induction hypothesis, I is a model of {a mathematical formula}TΠi(∅,¬I−)∪¬I−, so I is a model of {a mathematical formula}body(r). Since I is a model of Π, I is a model of r and thus is a model of H. This shows that I is a model of S, hence a model of {a mathematical formula}TΠi+1(∅,¬I−).  □</paragraph><paragraph label="Proof of Theorem 2">We show that for every {a mathematical formula}r∈ground(Π)∖fΠI and {a mathematical formula}i≥0, it holds that {a mathematical formula}TΠi(∅,¬I−)∪¬I−⊭body(r); hence {a mathematical formula}TΠi(∅,¬I−)=TfΠIi(∅,¬I−) for all {a mathematical formula}i≥0, which proves the result. Assume towards a contradiction that {a mathematical formula}TΠi(∅,¬I−)∪¬I−⊨body(r). As by Lemma 1, I is a model of {a mathematical formula}TΠi(∅,¬I−)∪¬I−, it follows that I satisfies {a mathematical formula}body(r). However, this means {a mathematical formula}r∈fΠI, which is a contradiction.  □</paragraph><paragraph label="Proof of Theorem 3">We prove it by induction on {a mathematical formula}i≥0. It is trivial for {a mathematical formula}i=0. As induction step, assume that for some integer n, {a mathematical formula}TΠIn(∅)=TΠn(∅,¬I−). We next show that this claim holds for {a mathematical formula}n+1.For any rule {a mathematical formula}r∈ΠI such that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΠIn(∅), by definition of {a mathematical formula}ΠI there must be a rule {a mathematical formula}r′∈ground(Π) such that {a mathematical formula}head(r)=head(r′) and {a mathematical formula}body(r) is {a mathematical formula}body(r′) with all negative literals in {a mathematical formula}¬I− removed. This means all positive literals of {a mathematical formula}body(r′) are in {a mathematical formula}TΠIn(∅) and all negative literals are in {a mathematical formula}¬I−. By the induction hypothesis, {a mathematical formula}TΠn(∅,¬I−)∪¬I−⊨body(r′). This shows {a mathematical formula}TΠIn+1(∅)⊆TΠn+1(∅,¬I−). Conversely, let {a mathematical formula}r′∈ground(Π) be a rule such that {a mathematical formula}TΠn(∅,¬I−)∪¬I−⊨body(r′). Since I is a model of Π, by Lemma 1, I is a model of {a mathematical formula}TΠn(∅,¬I−)∪¬I− and thus I satisfies {a mathematical formula}body(r′). This means (1) {a mathematical formula}TΠn(∅,¬I−)⊆I; (2) there is a rule {a mathematical formula}r∈ΠI such that {a mathematical formula}head(r)=head(r′) and {a mathematical formula}body(r) is {a mathematical formula}body(r′) with all negative literals removed; and (3) {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΠn(∅,¬I−). By the induction hypothesis, {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΠIn(∅). This shows {a mathematical formula}TΠn+1(∅,¬I−)⊆TΠIn+1(∅); hence {a mathematical formula}TΠn+1(∅,¬I−)=TΠIn+1(∅). Consequently, for any {a mathematical formula}i≥0{a mathematical formula}TΠIi(∅)=TΠi(∅,¬I−) and thus {a mathematical formula}lfp(TΠI(∅))=lfp(TΠ(∅,¬I−)).  □</paragraph><paragraph label="Proof of Theorem 4">Let I be an answer set of a logic program Π, and assume, on the contrary, that {a mathematical formula}J⊂I is a minimal model of Π. Then, {a mathematical formula}¬I−⊂¬J−. Since the entailment relation ⊨ is monotone, for every {a mathematical formula}i≥0, {a mathematical formula}TΠi(∅,¬I−)⊆TΠi(∅,¬J−) and thus {a mathematical formula}lfp(TΠ(∅,¬I−))⊆lfp(TΠ(∅,¬J−)). By Theorem 2, {a mathematical formula}lfp(TfΠI(∅,¬I−))⊆lfp(TfΠJ(∅,¬J−)). Since I is an answer set, for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A and thus {a mathematical formula}lfp(TfΠJ(∅,¬J−))∪¬J−⊨A. Since {a mathematical formula}I∩J−≠∅, this implies {a mathematical formula}lfp(TfΠJ(∅,¬J−))∪¬J− is inconsistent. This contradicts Lemma 1 that J is a model of {a mathematical formula}lfp(TfΠJ(∅,¬J−)). We then conclude that I is a minimal model of Π.For the second part, assume, on the contrary, that {a mathematical formula}J⊂I is a minimal model of {a mathematical formula}fΠI. Then, {a mathematical formula}lfp(TfΠI(∅,¬I−))⊆lfp(TfΠI(∅,¬J−)). Since I is an answer set, for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A and thus {a mathematical formula}lfp(TfΠI(∅,¬J−))∪¬J−⊨A. Since {a mathematical formula}I∩J−≠∅, this implies {a mathematical formula}lfp(TfΠI(∅,¬J−))∪¬J− is inconsistent. This contradicts Lemma 1 that J is a model of {a mathematical formula}lfp(TfΠI(∅,¬J−)). We then conclude that I is a minimal model of {a mathematical formula}fΠI.  □</paragraph><paragraph label="Proof of Theorem 5">Let Π be a logic program and I an answer set of Π. Let {a mathematical formula}S0′=¬I− and {a mathematical formula}S′=〈S1′,⋯,Sn′〉 be a partitioning of rule heads of Π, where for every {a mathematical formula}k&gt;0{a mathematical formula}Sk′=TfΠIk(∅,¬I−)∖TfΠIk−1(∅,¬I−). So for every {a mathematical formula}k&gt;0, {a mathematical formula}⋃1≤i≤kSi′=TfΠIk(∅,¬I−), and {a mathematical formula}⋃1≤i≤nSi′=TfΠIn(∅,¬I−)=lfp(TfΠI(∅,¬I−)). As I is an answer set of Π, the set {a mathematical formula}⋃1≤i≤nSi′ consists of all rule heads {a mathematical formula}head(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}body(r) is true in {a mathematical formula}⋃0≤i≤nSi′. Furthermore for every {a mathematical formula}H∈Sk′ where {a mathematical formula}k&gt;0, there is a rule {a mathematical formula}r∈fΠI⊆ground(Π) with {a mathematical formula}head(r)=H whose body is true in {a mathematical formula}TfΠIk−1(∅,¬I−)∪¬I−=⋃0≤i≤k−1Si′. By Definition 6, {a mathematical formula}S′ is a total level mapping of rule heads of Π w.r.t. I. Since I is an answer set, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A and thus {a mathematical formula}⋃0≤i≤nSi′⊨A for every {a mathematical formula}A∈I. By Proposition 2, I has a level mapping as in Definition 7.  □</paragraph><paragraph label="Proof of Lemma 2">Let {a mathematical formula}S0′=¬I−. Since {a mathematical formula}S′=〈S1′,⋯,Sm′〉 is a total level mapping of rule heads of Π w.r.t. I, the set {a mathematical formula}⋃1≤i≤mSi′ consists of all rule heads {a mathematical formula}head(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}⋃0≤i≤mSi′⊨body(r). As I is a model of Π, it is by Theorem 2 sufficient to prove that {a mathematical formula}lfp(TΠ(∅,¬I−))=⋃1≤i≤mSi′.We first prove that {a mathematical formula}lfp(TΠ(∅,¬I−))⊆⋃1≤i≤mSi′. To this end, we show by induction on {a mathematical formula}j≥1 that {a mathematical formula}TΠj(∅,¬I−)⊆⋃1≤i≤mSi′. For the base case {a mathematical formula}j=1, since {a mathematical formula}S0′=¬I−, the set {a mathematical formula}⋃1≤i≤mSi′ includes all rule heads {a mathematical formula}head(r) in {a mathematical formula}ground(Π) such that {a mathematical formula}¬I−⊨body(r). This means {a mathematical formula}TΠ1(∅,¬I−)⊆⋃1≤i≤mSi′. For the induction step, assume that {a mathematical formula}TΠj(∅,¬I−)⊆⋃1≤i≤mSi′ holds for {a mathematical formula}j≥1. We next show that this claim holds for {a mathematical formula}j+1.Let H be a rule head in {a mathematical formula}TΠj+1(∅,¬I−)∖TΠj(∅,¬I−). Then there must be a rule {a mathematical formula}r∈ground(Π) with {a mathematical formula}head(r)=H such that {a mathematical formula}TΠj(∅,¬I−)∪¬I−⊨body(r). By the induction hypothesis, {a mathematical formula}⋃0≤i≤mSi′⊨body(r). Hence H is in {a mathematical formula}⋃1≤i≤mSi′. This shows that for every {a mathematical formula}j&gt;0, {a mathematical formula}TΠj(∅,¬I−)⊆⋃1≤i≤mSi′. Hence it follows that {a mathematical formula}lfp(TΠ(∅,¬I−))⊆⋃1≤i≤mSi′.Next we show that {a mathematical formula}⋃1≤i≤jSi′⊆lfp(TΠ(∅,¬I−)) by induction on {a mathematical formula}j≥1. For the base case {a mathematical formula}j=1, by Definition 6, for each {a mathematical formula}H∈S1′ there must exist a rule {a mathematical formula}r∈ground(Π) with {a mathematical formula}head(r)=H such that {a mathematical formula}¬I−⊨body(r). Then H must be in {a mathematical formula}TΠ1(∅,¬I−) and thus {a mathematical formula}S1′⊆lfp(TΠ(∅,¬I−)). For the induction step, assume that for {a mathematical formula}j≥1, {a mathematical formula}⋃1≤i≤jSi′⊆lfp(TΠ(∅,¬I−)). We next show that this claim holds for {a mathematical formula}j+1. For each {a mathematical formula}H∈Sj+1′ there must exist a rule {a mathematical formula}r∈ground(Π) with {a mathematical formula}head(r)=H such that {a mathematical formula}⋃1≤i≤jSi′∪¬I−⊨body(r). By the induction hypothesis, {a mathematical formula}lfp(TΠ(∅,¬I−))∪¬I−⊨body(r) and thus H is in {a mathematical formula}lfp(TΠ(∅,¬I−)). This shows that {a mathematical formula}⋃1≤i≤j+1Sj′⊆lfp(TΠ(∅,¬I−)), and it follows that {a mathematical formula}⋃1≤i≤mSi′⊆lfp(TΠ(∅,¬I−)).  □</paragraph><paragraph label="Proof of Theorem 6">(⟹) When I is a well-justified FLP answer set, by Theorem 5 it has a level mapping as in Definition 7.(⟸) Let I be an FLP answer set of Π that has a level mapping {a mathematical formula}S=〈S0,S1,⋯,Sm〉 as in Definition 7, where {a mathematical formula}S0=¬I− and {a mathematical formula}⋃1≤i≤mSi=I. Let {a mathematical formula}S0′=¬I−; then there is a total level mapping {a mathematical formula}S′=〈S1′,⋯,Sn′〉 of rule heads of Π w.r.t. I and integers {a mathematical formula}l1,⋯,lm, where {a mathematical formula}1≤l1&lt;⋯&lt;lm≤n, such that for every {a mathematical formula}A∈Sk where {a mathematical formula}k&gt;0, {a mathematical formula}⋃0≤i≤lkSi′⊨A but {a mathematical formula}⋃0≤i≤lk−1Si′⊭A. Then for every {a mathematical formula}A∈I, {a mathematical formula}⋃0≤i≤nSi′⊨A. By Lemma 2, for every {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A. By Definition 9, I is a well-justified FLP answer set of Π.  □</paragraph><paragraph label="Proof of Theorem 7">By Theorem 4, when I is a well-justified FLP answer set of Π, I is a minimal model of Π.Conversely, assume that I is a minimal model of Π. Then for each {a mathematical formula}A∈I, {a mathematical formula}ground(Π)∪¬I−⊨A. Since all rule bodies in Π are empty, {a mathematical formula}lfp(TΠ(∅,¬I−))=ground(Π) and by Theorem 2, {a mathematical formula}lfp(TfΠI(∅,¬I−))=ground(Π). This means that for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A. By Definition 9, I is a well-justified FLP answer set of Π. This establishes the first equivalence. From this and since every well-justified FLP answer of an arbitrary logic program Π is an FLP answer of Π (Corollary 2) and every FLP answer set of Π as a minimal model of {a mathematical formula}fΠI also must be a minimal model of Π, the second equivalence follows.  □</paragraph><paragraph>To prove Theorem 8, we introduce the following lemma.</paragraph><paragraph label="Lemma 4">Let{a mathematical formula}Iˆ=(I1,I2)be a three-valued interpretation of a propositional logic program Π and F be a propositional formula. If{a mathematical formula}Iˆ(F)=t, then{a mathematical formula}I1∪¬I2−⊨F; if{a mathematical formula}Iˆ(F)=f, then{a mathematical formula}I1∪¬I2−⊨¬F.</paragraph><paragraph label="Proof">Induction step:∧: If {a mathematical formula}Iˆ(ϕ∧ψ)=t, then {a mathematical formula}Iˆ(ϕ)=t and {a mathematical formula}Iˆ(ψ)=t. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨ϕ and {a mathematical formula}I1∪¬I2−⊨ψ. Thus, {a mathematical formula}I1∪¬I2−⊨ϕ∧ψ. If {a mathematical formula}Iˆ(ϕ∧ψ)=f, then {a mathematical formula}Iˆ(ϕ)=f or {a mathematical formula}Iˆ(ψ)=f. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨¬ϕ or {a mathematical formula}I1∪¬I2−⊨¬ψ. This means {a mathematical formula}I1∪¬I2−⊨¬ϕ∨¬ψ, i.e. {a mathematical formula}I1∪¬I2−⊨¬(ϕ∧ψ).∨: If {a mathematical formula}Iˆ(ϕ∨ψ)=t, then {a mathematical formula}Iˆ(ϕ)=t or {a mathematical formula}Iˆ(ψ)=t. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨ϕ or {a mathematical formula}I1∪¬I2−⊨ψ, i.e. {a mathematical formula}I1∪¬I2−⊨ϕ∨ψ. If {a mathematical formula}Iˆ(ϕ∨ψ)=f, then {a mathematical formula}Iˆ(ϕ)=f and {a mathematical formula}Iˆ(ψ)=f. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨¬ϕ and {a mathematical formula}I1∪¬I2−⊨¬ψ, i.e. {a mathematical formula}I1∪¬I2−⊨¬ϕ∧¬ψ. Thus {a mathematical formula}I1∪¬I2−⊨¬(ϕ∨ψ).¬: If {a mathematical formula}Iˆ(¬ϕ)=t, then {a mathematical formula}Iˆ(ϕ)=f. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨¬ϕ. If {a mathematical formula}Iˆ(¬ϕ)=f, then {a mathematical formula}Iˆ(ϕ)=t. By induction hypothesis, {a mathematical formula}I1∪¬I2−⊨ϕ.  □</paragraph><paragraph label="Proof of Theorem 8">Let {a mathematical formula}Iˆ=(I,I) be a three-valued interpretation of Π. Since I is a two-valued stable model of Π, we have {a mathematical formula}lfp(StΦ(I,I))=(I,I). Then there is an iteration sequence of the operator {a mathematical formula}ΦΠ w.r.t. {a mathematical formula}Iˆ:{a mathematical formula} where {a mathematical formula}xα=I is the fixpoint {a mathematical formula}StΦ↓(I). Consider the following iteration sequence of the extended van Emden–Kowalski operator {a mathematical formula}TΠ w.r.t. I:{a mathematical formula} where {a mathematical formula}yβ=lfp(TΠ(∅,¬I−)) is the fixpoint. We next prove by induction that for every {a mathematical formula}i≥0, {a mathematical formula}xi⊆yi.As induction base, for {a mathematical formula}i=0, {a mathematical formula}x0⊆y0. As induction hypothesis, assume that for some {a mathematical formula}i≥0, {a mathematical formula}xi⊆yi. We next prove {a mathematical formula}xi+1⊆yi+1.Let {a mathematical formula}Jˆ=(xi,I) be a three-valued interpretation. We have{a mathematical formula} By Lemma 4, {a mathematical formula}Jˆ(body(r))=t implies {a mathematical formula}xi∪¬I−⊨body(r). By induction hypothesis that {a mathematical formula}xi⊆yi, then {a mathematical formula}yi∪¬I−⊨body(r). This shows that every {a mathematical formula}head(r) in {a mathematical formula}xi+1 is in {a mathematical formula}yi+1, i.e. {a mathematical formula}xi+1⊆yi+1. This means {a mathematical formula}xα⊆yβ and thus {a mathematical formula}I⊆lfp(TΠ(∅,¬I−)).Since I is a model of Π, by Lemma 1 the sequence {a mathematical formula}y0,y1,⋯,yi,⋯ will not exceed I, i.e., {a mathematical formula}lfp(TΠ(∅,¬I−))⊆I. Consequently, {a mathematical formula}lfp(TΠ(∅,¬I−))=I and by Theorem 2, {a mathematical formula}lfp(TfΠI(∅,¬I−))=I. Thus I is a well-justified FLP answer set of Π.  □</paragraph><paragraph label="Proof of Lemma 3">Let {a mathematical formula}A=(V,C). {a mathematical formula}R⊨IA if and only if for every F with {a mathematical formula}R∩V⊆F⊆I∩V, {a mathematical formula}F∈C if and only if for every F with {a mathematical formula}R∩V⊆F⊆I∩V, F satisfies A if and only if {a mathematical formula}R∪¬I−⊨A.  □</paragraph><paragraph label="Proof of Theorem 9">Let I be a model of a positive basic logic program Π. By Lemma 3, for every {a mathematical formula}R⊆I and any rule {a mathematical formula}r∈Π, {a mathematical formula}R⊨Ibody(r) if and only if {a mathematical formula}R∪¬I−⊨body(r). This means for every {a mathematical formula}i≥0, {a mathematical formula}TΠi(∅,¬I−)=ΓΠi(∅,I) and thus {a mathematical formula}lfp(TΠ(∅,¬I−))=lfp(ΓΠ(∅,I)). By Theorem 2, {a mathematical formula}lfp(TfΠI(∅,¬I−))=lfp(ΓΠ(∅,I)). Since Π is a positive basic logic program, {a mathematical formula}lfp(TfΠI(∅,¬I−)) consists of ground atoms. Since I is a model of Π, by Lemma 1I is a model of {a mathematical formula}lfp(TΠ(∅,¬I−)) and thus a model of {a mathematical formula}lfp(TfΠI(∅,¬I−)). This means {a mathematical formula}lfp(TfΠI(∅,¬I−)) is disjoint from {a mathematical formula}I−. Therefore, I is a well-justified FLP answer set of Π if and only if for each {a mathematical formula}A∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨A if and only if for each {a mathematical formula}A∈I, {a mathematical formula}A∈lfp(TfΠI(∅,¬I−)) if and only if {a mathematical formula}I=lfp(TfΠI(∅,¬I−)) if and only if {a mathematical formula}I=lfp(ΓΠ(∅,I)) if and only if I is a conditional satisfaction-based answer set of Π.  □</paragraph><paragraph label="Proof of Theorem 10">By Corollary 2, a well-justified FLP answer set for a dl-program is an FLP answer set. Eiter et al. [24] have shown that a strong answer set is a weak answer set.Let I be an FLP answer set of a dl-program Π relative to a DL knowledge base L. Then, I is a minimal model of the FLP reduct {a mathematical formula}fΠLI. Consider the reduct {a mathematical formula}sΠLI, which is {a mathematical formula}fΠLI with all negative literals and all nonmonotonic dl-atoms removed. Assume, on the contrary, that I is not a strong answer set of Π; i.e., I is not the least model of {a mathematical formula}sΠLI. Let {a mathematical formula}J⊂I be the least model of {a mathematical formula}sΠLI. Then, {a mathematical formula}fΠLI is inconsistent in J; i.e., there is a rule r in {a mathematical formula}fΠLI such that J satisfies {a mathematical formula}body(r) but {a mathematical formula}head(r) is not in J. In this case, there must be a rule {a mathematical formula}r′ in {a mathematical formula}sΠLI, which is r with all negative literals and all nonmonotonic dl-atoms in {a mathematical formula}body(r) removed. Since J satisfies {a mathematical formula}body(r), J satisfies {a mathematical formula}body(r′) and thus {a mathematical formula}head(r′) is in J. Since {a mathematical formula}head(r)=head(r′), {a mathematical formula}head(r) is in J, a contradiction. This shows that I is a strong answer set of Π. Hence, we conclude that an FLP answer set is a strong answer set.  □</paragraph><paragraph label="Proof of Theorem 11">By Theorem 10 it suffices to show that when Π contains no nonmonotonic dl-atoms, if I is a strong answer set then I is a well-justified FLP answer set.Let I be a strong answer set of Π relative to L. I is the least model of the reduct {a mathematical formula}sΠLI. Since {a mathematical formula}sΠLI is a positive dl-program, the least model I can be computed from {a mathematical formula}sΠLI by applying the van Emden–Kowalski one-step provability operator {a mathematical formula}TP(S) via the sequence {a mathematical formula}〈TsΠLIi(∅)〉i=0∞, where {a mathematical formula}TsΠLI0(∅)=∅ and for {a mathematical formula}i≥0{a mathematical formula}TsΠLIi+1(∅)=TsΠLI(TsΠLIi(∅)). That is, I is equal to the fixpoint {a mathematical formula}lfp(TsΠLI(∅)). We next show that the least model I can also be computed from the FLP reduct {a mathematical formula}fΠLI via the sequence {a mathematical formula}〈TfΠLIi(∅,¬I−)〉i=0∞. That is, I is equal to the fixpoint {a mathematical formula}lfp(TfΠLI(∅,¬I−)).We show by induction that for all {a mathematical formula}i≥0, {a mathematical formula}TsΠLIi(∅)=TfΠLIi(∅,¬I−). When {a mathematical formula}i=0, {a mathematical formula}TsΠLI0(∅)=TfΠLI0(∅,¬I−)=∅. As induction hypothesis, assume that for some integer n, {a mathematical formula}TsΠLIn(∅)=TfΠLIn(∅,¬I−). Next we show {a mathematical formula}TsΠLIn+1(∅)=TfΠLIn+1(∅,¬I−).Since I is a model of Π, by Theorem 2, Theorem 3 and Lemma 1, for every {a mathematical formula}i≥0, {a mathematical formula}TsΠLIi(∅)⊆I and {a mathematical formula}TfΠLIi(∅,¬I−)⊆I.By definition, {a mathematical formula}TsΠLIn+1(∅)=TsΠLI(TsΠLIn(∅)){a mathematical formula}={head(r)|r∈sΠLI such that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TsΠLIn(∅)}, and {a mathematical formula}TfΠLIn+1(∅,¬I−)={head(r′)|r′∈fΠLI such that {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨body(r′)}. Note that {a mathematical formula}sΠLI has a rule r if and only if {a mathematical formula}fΠLI has a rule {a mathematical formula}r′, where {a mathematical formula}head(r)=head(r′) and {a mathematical formula}body(r) is obtained from {a mathematical formula}body(r′) by deleting all negative literals and all nonmonotonic dl-atoms. Since Π contains no nonmonotonic dl-atoms, for simplicity let {a mathematical formula}body(r′)=body(r)∧¬A∧¬B, where A is a ground monotonic dl-atom and B is a ground atom.Assume {a mathematical formula}head(r′)∈TfΠLIn+1(∅), due to {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨body(r′). Then, {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨body(r). Since {a mathematical formula}TfΠLIn(∅,¬I−)⊆I, {a mathematical formula}body(r) is satisfied by {a mathematical formula}TfΠLIn(∅,¬I−). By the induction hypothesis, {a mathematical formula}body(r) is satisfied by {a mathematical formula}TsΠLIn(∅,¬I−) and thus {a mathematical formula}head(r)∈TsΠLIn+1(∅). Since {a mathematical formula}head(r)=head(r′), {a mathematical formula}head(r′)∈TsΠLIn+1(∅). This shows {a mathematical formula}TsΠLIn+1(∅)⊇TfΠLIn+1(∅,¬I−).Conversely, assume {a mathematical formula}head(r)∈TsΠLIn+1(∅), due to that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TsΠLIn(∅). By the induction hypothesis, {a mathematical formula}body(r) is satisfied by {a mathematical formula}TfΠLIn(∅,¬I−). Since {a mathematical formula}body(r) is a conjunction of ground atoms and monotonic dl-atoms and {a mathematical formula}TfΠLIn(∅,¬I−)⊆I, {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨body(r).Since A is a monotonic dl-atom and I does not satisfy A (I satisfies ¬A), no J with {a mathematical formula}∅⊆J⊆I satisfies A. This means all {a mathematical formula}J⊆I satisfies ¬A. Since {a mathematical formula}TfΠLIn(∅,¬I−)⊆I, {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨¬A.Since B is a ground atom and I satisfies ¬B, {a mathematical formula}¬B∈¬I−. This means {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨¬B.As a result, {a mathematical formula}TfΠLIn(∅,¬I−)∪¬I−⊨body(r′), so {a mathematical formula}head(r′)∈TfΠLIn+1(∅,¬I−). Since {a mathematical formula}head(r)=head(r′), {a mathematical formula}head(r)∈TfΠLIn+1(∅,¬I−). This shows {a mathematical formula}TsΠLIn+1(∅)⊆TfΠLIn+1(∅,¬I−).Therefore, {a mathematical formula}TsΠLIn+1(∅)=TfΠLIn+1(∅,¬I−) and we conclude the proof.  □</paragraph><paragraph label="Proof of Theorem 13">By Theorem 10 it suffices to show that if I is a strong answer set then I is a well-justified FLP answer set. Assume that Π has {a mathematical formula}k+1 strata {a mathematical formula}{Π0,…,Πk} and let I be a strong answer set of Π.By Theorem 2 and Lemma 1, {a mathematical formula}lfp(TfΠI(∅,¬I−)) is a subset of I.By Theorem 12, {a mathematical formula}I=Ik, where {a mathematical formula}I0 be the least model of {a mathematical formula}Π0, and for each {a mathematical formula}1≤i≤k, {a mathematical formula}Ii is the least model of {a mathematical formula}Πi(Ii−1)∪Ii−1. Let {a mathematical formula}I−1=∅. We show by induction that for {a mathematical formula}−1≤i≤k, {a mathematical formula}Ii⊆lfp(TfΠLI(∅,¬I−)). When {a mathematical formula}i=−1, {a mathematical formula}I−1⊆lfp(TfΠLI(∅,¬I−)). As induction hypothesis, assume that for any i with {a mathematical formula}0≤i≤k, {a mathematical formula}Ii−1⊆lfp(TfΠLI(∅,¬I−)). We next prove {a mathematical formula}Ii⊆lfp(TfΠLI(∅,¬I−)).Note that {a mathematical formula}Ii is the least model of {a mathematical formula}Πi(Ii−1)∪Ii−1 and by the induction hypothesis, {a mathematical formula}Ii−1⊆lfp(TfΠLI(∅,¬I−)). Let {a mathematical formula}Γ=Πi(Ii−1)∪Ii−1. Since Γ is a positive dl-program, the least model {a mathematical formula}Ii can be computed from Γ by applying the van Emden–Kowalski one-step provability operator {a mathematical formula}TΓ(S) via the sequence {a mathematical formula}〈TΓj(∅)〉j=0∞, where {a mathematical formula}TΓ0(∅)=∅ and for {a mathematical formula}j≥0{a mathematical formula}TΓj+1(∅)=TΓ(TΓj(∅)). That is, {a mathematical formula}Ii is equal to the fixpoint {a mathematical formula}lfp(TΓ(∅)). Therefore, to prove {a mathematical formula}Ii⊆lfp(TfΠLI(∅,¬I−)), we prove by induction that for each {a mathematical formula}j≥0, {a mathematical formula}TΓj(∅)⊆lfp(TfΠLI(∅,¬I−)). It is obviously true for {a mathematical formula}j=0. As induction hypothesis, assume that for {a mathematical formula}0≤j&lt;s, {a mathematical formula}TΓj(∅)⊆lfp(TfΠLI(∅,¬I−)). We next show {a mathematical formula}TΓs(∅)⊆lfp(TfΠLI(∅,¬I−)).{a mathematical formula}TΓs(∅)=TΓ(TΓs−1(∅))={head(r)|r∈Γ such that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΓs−1(∅)}. Note that {a mathematical formula}Γ=Πi(Ii−1)∪Ii−1, {a mathematical formula}Ii−1⊆lfp(TfΠLI(∅,¬I−)) and {a mathematical formula}TΓs−1(∅)⊆lfp(TfΠLI(∅,¬I−)). Let r be a rule in {a mathematical formula}Πi(Ii−1) such that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΓs−1(∅). {a mathematical formula}Πi must have a rule {a mathematical formula}r′, where {a mathematical formula}head(r)=head(r′) and {a mathematical formula}body(r) is obtained from {a mathematical formula}body(r′) by deleting all negative literals and all nonmonotonic dl-atoms. For simplicity let {a mathematical formula}body(r′)=body(r)∧A∧¬B, where A is a ground nonmonotonic dl-atom and B is either a ground atom or a ground dl-atom. By the definition of {a mathematical formula}Πi(Ii−1), A is satisfied by {a mathematical formula}Ii−1 and B is not satisfied by {a mathematical formula}Ii−1. Since Π is stratified, the satisfaction of A and B only depends on the satisfaction of their input atoms in {a mathematical formula}⋃0≤j&lt;iHBΠj, independently of any atoms in {a mathematical formula}HBΠ∖⋃0≤j&lt;iHBΠj. This means that A is entailed by {a mathematical formula}Ii−1∪¬Ii−1− and B is not entailed by {a mathematical formula}Ii−1∪¬Ii−1−; i.e. {a mathematical formula}Ii−1∪¬Ii−1−⊨A and {a mathematical formula}Ii−1∪¬Ii−1−⊭B. Then, for any interpretation J with {a mathematical formula}Ii−1⊆J and {a mathematical formula}Ii−1−⊆J−, A (resp. B) is satisfied (resp. not satisfied) by J. Since {a mathematical formula}Ii−1⊆I and {a mathematical formula}Ii−1−⊆I−, A (resp. B) is satisfied (resp. not satisfied) by I. Since {a mathematical formula}body(r) contains no negative literals or nonmonotonic dl-atoms and {a mathematical formula}TΓs−1(∅)⊆Ii⊆I, that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΓs−1(∅) implies {a mathematical formula}body(r) is satisfied by I. This shows that {a mathematical formula}body(r′) is satisfied by I. Thus, the rule {a mathematical formula}r′ is in {a mathematical formula}fΠLI.For the above rule {a mathematical formula}r′ with {a mathematical formula}body(r′)=body(r)∧A∧¬B, we next prove {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨body(r′). Since {a mathematical formula}body(r) contains no negative literals or nonmonotonic dl-atoms, that {a mathematical formula}body(r) is satisfied by {a mathematical formula}TΓs−1(∅) implies {a mathematical formula}body(r) is satisfied by all interpretations J with {a mathematical formula}TΓs−1(∅)⊆J. Since {a mathematical formula}TΓs−1(∅)⊆lfp(TfΠI(∅,¬I−))⊆I, {a mathematical formula}body(r) is satisfied by all interpretations that satisfy {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−. This means {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨body(r). Moreover, as shown above, for any interpretation J with {a mathematical formula}Ii−1⊆J and {a mathematical formula}Ii−1−⊆J−, A (resp. B) is satisfied (resp. not satisfied) by J. Since {a mathematical formula}Ii−1⊆lfp(TfΠLI(∅,¬I−)) and {a mathematical formula}Ii−1−⊆I−, for any interpretation J that satisfies {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−, A (resp. B) is satisfied (resp. not satisfied) by J. This means {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨A and {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨¬B. As a result, {a mathematical formula}lfp(TfΠLI(∅,¬I−))∪¬I−⊨body(r′). By the definition of the fixpoint {a mathematical formula}lfp(TfΠLI(∅,¬I−)), {a mathematical formula}head(r′)∈lfp(TfΠLI(∅,¬I−)) and thus {a mathematical formula}head(r)∈lfp(TfΠLI(∅,¬I−)). This shows {a mathematical formula}TΓs(∅)⊆lfp(TfΠLI(∅,¬I−)). Therefore, {a mathematical formula}lfp(TΓ(∅))⊆lfp(TfΠLI(∅,¬I−)) and thus {a mathematical formula}Ii⊆lfp(TfΠLI(∅,¬I−)).To conclude, {a mathematical formula}I=Ik⊆lfp(TfΠLI(∅,¬I−))⊆I; i.e. {a mathematical formula}lfp(TfΠLI(∅,¬I−))=I. Hence, I is a well-justified FLP answer set.  □</paragraph><paragraph label="Proof of Theorem 14"><list><list-item label="1.">Membership</list-item></list><paragraph>We first prove the {a mathematical formula}Σ2p-membership of deciding the existence of FLP answer sets. Given a propositional logic program Π, we guess an interpretation I and first verify that I is a model of Π, and then compute the FLP-reduct {a mathematical formula}fΠI. These two steps can be done in polynomial time. The main part of determining if I is an FLP answer set of Π is to determine if I is a minimal model of {a mathematical formula}fΠI. Note that I is a minimal model of {a mathematical formula}fΠI if and only if {a mathematical formula}fΠI∪¬I−∪¬⋀A∈IA is unsatisfiable. This is {a mathematical formula}co-NP-complete because it is NP-complete to determine if a propositional theory is satisfiable. Thus with a call to an NP oracle, we can verify whether I is an FLP answer set of Π in polynomial time.Next we prove the {a mathematical formula}Σ2p-membership of deciding the existence of well-justified FLP answer sets. Given a propositional logic program Π, we guess an interpretation I and can verify that I is a model of Π and compute the FLP-reduct {a mathematical formula}fΠI in polynomial time. It consists of two major parts to determine if I is a well-justified FLP answer set of Π: (1) compute the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)); and (2) determine whether {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨⋀A∈IA. Let Π consist of M rules. To reach the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)), we have computations of the form {a mathematical formula}TfΠIi(∅,¬I−)∪¬I−⊨body(r) for at most {a mathematical formula}M2 times. Note that it is {a mathematical formula}co-NP-complete to compute {a mathematical formula}TfΠIi(∅,¬I−)∪¬I−⊨body(r). Thus part (1) can be done in polynomial time with the help of an NP oracle. Part (2) can be computed with one call to an NP oracle. Consequently, we can verify whether I is a well-justified FLP answer set of Π in polynomial time with the help of an NP oracle.</paragraph><list><list-item label="2.">Hardness</list-item></list><paragraph>Next we prove the {a mathematical formula}Σ2p-hardness of deciding the existence of ordinary FLP resp. well-justified FLP answer sets. A positive disjunctive logic program P consists of a finite set of rules of the form {a mathematical formula}A1∨⋯∨Al←B1∧⋯∧Bm, where {a mathematical formula}l&gt;0, {a mathematical formula}m≥0, and each {a mathematical formula}Ai and {a mathematical formula}Bi is a ground atom. An interpretation I is a standard answer set of P if and only if I is a minimal model of P[34]. As shown by Eiter and Gottlob [23], for a given ground atom A it is {a mathematical formula}Σ2p-hard to decide whether a given P has a standard answer set (i.e. a minimal model) in which A is true.Let {a mathematical formula}Π=P′∪{A←¬A} be a propositional logic program, where {a mathematical formula}P′ is P with each rule {a mathematical formula}H←B replaced by a material implication {a mathematical formula}B⊃H. Note that an interpretation I is a minimal model of P if and only if I is a minimal model of {a mathematical formula}P′. Since all rule bodies in {a mathematical formula}P′ are empty, by Theorem 7, I is a minimal model (standard answer set) of P if and only if I is a well-justified FLP answer set of {a mathematical formula}P′ if and only if I is an FLP answer set of {a mathematical formula}P′.Assume that I is a minimal model (standard answer set) of P in which A is true. Then, the FLP-reduct {a mathematical formula}fΠI of Π w.r.t. I is the same as {a mathematical formula}P′. By Theorem 7, I is a well-justified FLP answer set of {a mathematical formula}fΠI, i.e., for each {a mathematical formula}E∈I, {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨E. This means I is also a well-justified FLP answer set of Π, and by Corollary 2 also an FLP answer set of Π.Conversely, assume that I is an FLP or a well-justified FLP answer set of Π. Due to the rule {a mathematical formula}A←¬A in Π, A must be in I and thus {a mathematical formula}fΠI=P′. By Theorem 4, I is a minimal model of {a mathematical formula}fΠI. Thus I is a minimal model (standard answer set) of P in which A is true.The above proof shows that deciding whether a positive disjunctive logic program P has a standard answer set in which a given ground atom A is true can be reduced to deciding the existence of ordinary FLP resp. well-justified FLP answer sets of a propositional logic program Π. Since Π can be constructed from P in polynomial time, the {a mathematical formula}Σ2p-hardness of deciding the existence of ordinary FLP resp. well-justified FLP answer sets of a propositional logic program immediately follows. We thus conclude the proof of Theorem 14.  □</paragraph></paragraph><paragraph>To prove Theorem 15, we introduce the following two lemmas, which show that cautious (resp. brave) reasoning for propositional logic programs under the FLP or the well-justified FLP answer set semantics can be reduced to deciding the non-existence (resp. existence) of FLP or well-justified FLP answer sets, and vice versa.</paragraph><paragraph label="Lemma 5">Let Π be a propositional logic program and l an atom in{a mathematical formula}HBΠ. Let{a mathematical formula}Π1=Π∪{p←l∧¬p}(resp.{a mathematical formula}Π1=Π∪{p←¬l∧¬p}), where p is a ground atom of a 0-ary predicate not occurring in Π (i.e.,{a mathematical formula}HBΠ1=HBΠ∪{p}≠HBΠ). Then, l belongs to every (resp. some) FLP or well-justified FLP answer set of Π if and only if{a mathematical formula}Π1has no (resp. an) FLP or well-justified FLP answer set.</paragraph><paragraph label="Proof">We next prove that brave reasoning can be reduced to deciding the existence of FLP or well-justified FLP answer sets.(⟹) Let I be an FLP or well-justified FLP answer set of Π with {a mathematical formula}l∈I. Then I is a model of {a mathematical formula}Π1 and {a mathematical formula}fΠI=fΠ1I. So I is also an FLP or well-justified FLP answer set of {a mathematical formula}Π1.(⟸) Let {a mathematical formula}Π1 have an FLP or well-justified FLP answer set I. Then {a mathematical formula}p∉I and {a mathematical formula}l∈I (by the rule {a mathematical formula}p←¬l∧¬p). Since {a mathematical formula}fΠI=fΠ1I, I is also an FLP or well-justified FLP answer set of Π with {a mathematical formula}l∈I.  □</paragraph><paragraph label="Lemma 6">Let Π be a propositional logic program,{a mathematical formula}Π1=Π∪{p←p}and{a mathematical formula}Π2=Π∪{p}, where p is a ground atom of a 0-ary predicate not occurring in Π (i.e.,{a mathematical formula}HBΠ1=HBΠ2=HBΠ∪{p}≠HBΠ). Then, Π has no (resp. an) FLP or well-justified FLP answer set if and only if p belongs to every (resp. some) FLP or well-justified FLP answer set of{a mathematical formula}Π1(resp.{a mathematical formula}Π2).</paragraph><paragraph label="Proof">First note that if a logic program Π has no answer set, which means Π is inconsistent, then everything is cautiously true in Π under the answer set semantics, i.e., any {a mathematical formula}l∈HBΠ trivially belongs to every answer set of Π.Since p is a fresh atom not occurring in Π, Π and {a mathematical formula}Π1 by construction have the same FLP and well-justified FLP answer sets, none of which contains p (which would not be founded). Therefore, if Π has no FLP or well-justified FLP answer set, then {a mathematical formula}Π1 has no FLP or well-justified FLP answer set. Thus, p trivially belongs to every FLP or well-justified FLP answer set of {a mathematical formula}Π1. Conversely, if p belongs to every FLP or well-justified FLP answer set of {a mathematical formula}Π1, then {a mathematical formula}Π1 must be inconsistent without FLP or well-justified FLP answer sets. Hence, Π must have no FLP or well-justified FLP answer set.Since p is a fresh atom not occurring in Π, by construction Π has an FLP or well-justified FLP answer set I if and only if {a mathematical formula}Π2 has an FLP or well-justified FLP answer set {a mathematical formula}I∪{p}. If Π has an FLP or well-justified FLP answer set I, then p belongs to the FLP or well-justified FLP answer set {a mathematical formula}I∪{p} of {a mathematical formula}Π2. Conversely, if p belongs to an FLP or well-justified FLP answer set I of {a mathematical formula}Π2, then Π has an FLP or well-justified FLP answer set {a mathematical formula}I∖{p}.  □</paragraph><paragraph label="Proof of Theorem 15">Lemma 5 says that for propositional logic programs, the problem of deciding whether a ground atom belongs to every (resp. some) FLP or well-justified FLP answer set can be reduced to deciding whether there exists no (resp. an) FLP or well-justified FLP answer set, while Lemma 6 states the converse reduction. This shows that cautious (resp. brave) reasoning for propositional logic programs falls in the same complexity class as the non-existence (resp. existence) of FLP or well-justified FLP answer sets. Since it is {a mathematical formula}Σ2p-complete to determine if a propositional logic program has an FLP answer set or a well-justified FLP answer set (Theorem 14), deciding whether a ground atom is in every (resp. some) FLP or well-justified FLP answer set is complete for co-{a mathematical formula}Σ2p (resp. {a mathematical formula}Σ2p).  □</paragraph><paragraph label="Proof of Theorem 16">The proof is similar to the proof of Theorem 14, Theorem 15, so we only give a sketch for the {a mathematical formula}Σ2p-completeness of answer set existence. For the membership proof, since deciding whether a propositional formula is satisfiable is in NP, deciding whether a propositional formula with polynomially computable aggregates is satisfiable is also in NP. Then, by the same argument as the proof of Theorem 14, we can conclude that deciding whether a propositional logic program with polynomially computable aggregates has an FLP answer set or a well-justified FLP answer set is in {a mathematical formula}Σ2p. For the hardness proof, since propositional logic programs without aggregates are a special case of propositional logic programs with aggregates, by Theorem 14 it is {a mathematical formula}Σ2p-hard to decide whether a propositional logic program with aggregates has an FLP answer set or a well-justified FLP answer set.  □</paragraph><paragraph label="Proof of Theorem 17">For the membership proof, since ground normal logic programs with aggregates are special propositional logic programs with aggregates, by Theorem 16 deciding whether a ground normal program with polynomially computable aggregates has a well-justified FLP answer set is in {a mathematical formula}Σ2p.Since a ground Horn logic program is a special ground normal logic program, to establish the theorem it remains to prove the {a mathematical formula}Σ2p-hardness of deciding the existence of some well-justified FLP answer set for a given ground Horn logic program with polynomially computable aggregates. We achieve this by a reduction of deciding the validity of a quantified Boolean formula{a mathematical formula} where E is a propositional formula made of ground atoms {a mathematical formula}x1,…,xn,y1,…,ym. For each truth assignment υ to {a mathematical formula}x1,…,xn, Φ is true if {a mathematical formula}(⋀υ(xi)=truexi)∧(⋀υ(xi)=false¬xi)⊨E. Also, Φ is valid if there is such an assignment υ such that Φ is true. It has been shown that deciding the validity of a quantified Boolean formula of the above type is {a mathematical formula}Σ2p-hard [61].Note that for any ground formula F, we can construct an aggregate atom {a mathematical formula}SUM〈({1},X):F〉=1 which is logically equivalent to F; i.e., since the aggregate variable X does not appear in F, any interpretation I satisfies {a mathematical formula}SUM〈({1},X):F〉=1 if and only if I satisfies F. Therefore, we can use F and {a mathematical formula}SUM〈({1},X):F〉=1 exchangeably.Let {a mathematical formula}x1′,…,xn′,f,f′ be new ground atoms with a zero-arity predicate. We define a ground Horn logic program Π with aggregate, which consists of the following rules:{a mathematical formula} Intuitively, for each {a mathematical formula}1≤i≤n, {a mathematical formula}xi′ corresponds to {a mathematical formula}¬xi, which is denoted by the logically equivalent aggregate atom {a mathematical formula}SUM〈({1},X):¬xi〉=1. Since all of the ground atoms {a mathematical formula}xi, {a mathematical formula}xi′, {a mathematical formula}yj, f, {a mathematical formula}f′ are with a zero-arity predicate, the Herbrand base of Π is {a mathematical formula}HBΠ={x1,…,xn,y1,…,ym,x1′,…,xn′,f,f′}.Note that all aggregate atoms in Π are computable in polynomial time.Let I be a well-justified FLP answer set of Π. Observe that neither f nor {a mathematical formula}f′, which only occur in rules (3) and (4), can be founded. Therefore, {a mathematical formula}f∉I and {a mathematical formula}f′∉I. Moreover, rules (3) and (4) intuitively act as constraints, whose body must not be satisfied for I to be well-justified. Therefore, {a mathematical formula}yj is in I (by rules (4)) for every {a mathematical formula}1≤j≤m, and for every {a mathematical formula}i=1,…,n, atoms {a mathematical formula}xi and {a mathematical formula}xi′ cannot be jointly in I (by rules (3)). Additionally, either {a mathematical formula}xi∈I or {a mathematical formula}xi′∈I holds (by rules (1) and (2), because if {a mathematical formula}I∩{xi,xi′}=∅ for some index i, then the body of the respective rules (1) and (2) is satisfied but not their head). That is, {a mathematical formula}xi∈I ({a mathematical formula}xi′∈I) if and only if {a mathematical formula}xi′∉I (resp. {a mathematical formula}xi∉I).Next we show that Π has a well-justified FLP answer set if and only if the quantified Boolean formula Φ is valid.(⟹) Let I be a well-justified FLP answer set of Π. We define the truth assignment υ to the atoms {a mathematical formula}x1,…,xn as follows:{a mathematical formula} By {a mathematical formula}I|υ we denote {a mathematical formula}{xi|xi∈I} and by {a mathematical formula}¬I−|υ we denote {a mathematical formula}{¬xi|xi∉I}. Then under the assignment υ, Φ is true if {a mathematical formula}I|υ∪¬I−|υ⊨E.Since {a mathematical formula}{y1,…,ym}⊆I and rules (5) are the only rules in Π whose heads contain {a mathematical formula}y1,…,ym, by the level mapping of the well-justified FLP answer set semantics the FLP reduct {a mathematical formula}fΠI must contain rules (5) and the entailment {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨SUM〈({1},X):E〉=1 must hold; for otherwise {a mathematical formula}y1,…,ym would have no justification. Then {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨E. Since every rule head in Π is a ground atom, the least fixpoint itself is an interpretation, in particular {a mathematical formula}lfp(TfΠI(∅,¬I−))=I and thus {a mathematical formula}I∪¬I−⊨E. Note that {a mathematical formula}y1,…,ym can be justified only by the rules (5). Due to {a mathematical formula}SUM〈({1},X):E〉=1 in their bodies, this only is the case if {a mathematical formula}I∖{y1,…,ym}∪¬I−⊨E. Moreover, since the atoms {a mathematical formula}x1′,…,xn′,f,f′ do not occur in E, {a mathematical formula}I∖{y1,…,ym,x1′,…,xn′}∪¬I−∖{¬x1′,…,¬xn′,¬f,¬f′}⊨E. This means {a mathematical formula}I|υ∪¬I−|υ⊨E and thus Φ is true under the above truth assignment υ. Hence Φ is valid.(⟸) Assume that Φ is valid, i.e. there exists a truth assignment υ to the atoms {a mathematical formula}x1,…,xn such that Φ is true. Let I be the following interpretation:{a mathematical formula} Obviously, I is a model of Π. Since all rule heads in Π are ground atoms, to show that I is a well-justified FLP answer set, it suffices to show {a mathematical formula}lfp(TfΠI(∅,negI−))=I.Clearly, no rules of (3) and (4) are in the FLP reduct {a mathematical formula}fΠI. Since Φ is true under the assignment υ, {a mathematical formula}I|υ∪¬I−|υ⊨E and thus I satisfies E. Then, I satisfies {a mathematical formula}SUM〈({1},X):E〉=1. So all rules of (5) are in {a mathematical formula}fΠI. For {a mathematical formula}1≤i≤n, {a mathematical formula}xi∈I if and only if {a mathematical formula}xi←SUM〈({1},X):¬xi′〉=1 is in {a mathematical formula}fΠI, and {a mathematical formula}xi′∈I if and only if {a mathematical formula}xi′←SUM〈({1},X):¬xi〉=1 is in {a mathematical formula}fΠI. As a result, {a mathematical formula}fΠI consists of the following rules:{a mathematical formula} Note that the heads of all rules of (1′) and (2′) constitute {a mathematical formula}I∖{y1,…,ym}.Next we build the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)). To start, let {a mathematical formula}TfΠI0(∅,¬I−)=∅. Since the bodies of all rules of (1′) and (2′) are true in {a mathematical formula}TfΠI0(∅,¬I−)∪¬I−, {a mathematical formula}TfΠI1(∅,¬I−)=I∖{y1,…,ym}. Since {a mathematical formula}I|υ∪¬I−|υ⊨E, {a mathematical formula}(I∖{y1,…,ym})|υ∪¬I−|υ⊨E and thus {a mathematical formula}TfΠI1(∅,¬I−)∪¬I−⊨E. Then, {a mathematical formula}TfΠI1(∅,¬I−)∪¬I−⊨SUM〈({1},X):E〉=1. So {a mathematical formula}TfΠI2(∅,¬I−)=TfΠI1(∅,¬I−)∪{y1,…,ym}=I. The fixpoint is {a mathematical formula}lfp(TfΠI(∅,¬I−))=TfΠI2(∅,¬I−), so I is a well-justified FLP answer set of Π.The above proof shows that deciding the validity of a quantified Boolean formula Φ can be reduced to deciding the existence of well-justified FLP answer sets of a ground Horn logic program Π with polynomially computable aggregates. Since Π can be constructed from Φ in polynomial time, the {a mathematical formula}Σ2p-hardness of deciding the existence of well-justified FLP answer sets of a ground Horn logic program with aggregates immediately follows from the {a mathematical formula}Σ2p-hardness of deciding the validity of a quantified Boolean formula. This concludes the proof of Theorem 17.  □</paragraph><paragraph>For the proof of Theorem 18, we first recall the following lemma from [24, Lemma E.5].</paragraph><paragraph label="Lemma 7">Let Π be a dl-program relative to a DL knowledge base L. The number of ground dl-atoms in{a mathematical formula}ground(Π)is polynomial, and every such ground dl-atom{a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c)has in general exponentially many different concrete inputs{a mathematical formula}Ip(that is, interpretations{a mathematical formula}Ipof its input predicate symbols{a mathematical formula}p=p1,…,pm), but each of these concrete inputs{a mathematical formula}Iphas a polynomial size. Furthermore, if Π is positive, then during the computation of the least model of Π by fixpoint iteration, the input of any ground dl-atom A in{a mathematical formula}ground(Π)can increase only polynomially many times, and it thus needs to be evaluated polynomially often.</paragraph><paragraph>For clarity, we prove Theorem 18 by dividing it into three independent cases and proving them separately. Case 1: L belongs to {a mathematical formula}SHIF(D); case 2: L belongs to {a mathematical formula}SHOIN(D); and case 3: L belongs to {a mathematical formula}SROIQ(D). We first prove two lemmas. In the sequel, we denote {a mathematical formula}HBΠ⁎=HBΠ∪{¬A|A∈HBΠ}. A subset of {a mathematical formula}HBΠ⁎ is said to be consistent if it contains no contradictory literals A and ¬A.</paragraph><paragraph label="Lemma 8">Let Π be a dl-program relative to a DL knowledge base L,{a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c)a ground dl-atom in{a mathematical formula}ground(Π), and S a consistent subset of{a mathematical formula}HBΠ⁎. Computing{a mathematical formula}S⊨Aor{a mathematical formula}S⊨¬Ais in EXP when L belongs to{a mathematical formula}SHIF(D).</paragraph><paragraph label="Proof">By definition, an interpretation I of Π satisfies the dl-atom A if {a mathematical formula}L∪⋃i=1mAi(I)⊨Q(c), where each {a mathematical formula}Ai(I) is a set of concept membership axioms, role membership axioms, equality/inequality axioms, or their negations, which are obtained from the input predicate {a mathematical formula}pi in terms of I. By Lemma 7, any interpretation of the input predicates of A has a polynomial size, so {a mathematical formula}⋃i=1mAi(I) has a polynomial size and the computation of {a mathematical formula}⋃i=1mAi(I) is feasible in exponential time. The computation of {a mathematical formula}L∪⋃i=1mAi(I){a mathematical formula}⊨Q(c) can be reduced to computing the unsatisfiability of the DL knowledge base {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)}. Since deciding whether a DL knowledge base in {a mathematical formula}SHIF(D) is satisfiable is complete for EXP [62], [39], the computation of {a mathematical formula}L∪⋃i=1mAi(I){a mathematical formula}⊨Q(c) is feasible in exponential time. As a result, deciding whether an interpretation I satisfies a dl-atom A (resp. ¬A) is in EXP.Computing {a mathematical formula}S⊨A (resp. {a mathematical formula}S⊨¬A) is to check that every model I of S satisfies A (resp. ¬A). Checking if an interpretation I is a model of S is in EXP. By Lemma 7, A has exponentially many different concrete inputs/interpretations. So {a mathematical formula}S⊨A or {a mathematical formula}S⊨¬A can be computed by calling a {a mathematical formula}SHIF(D) reasoner at most exponential times. In each call one interpretation is checked to see if it satisfies A (resp. ¬A). Consequently, computing {a mathematical formula}S⊨A or {a mathematical formula}S⊨¬A is in EXP when L belongs to {a mathematical formula}SHIF(D).  □</paragraph><paragraph label="Lemma 9">Let Π be a dl-program relative to a DL knowledge base L,{a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c)a ground dl-atom in{a mathematical formula}ground(Π), and S a consistent subset of{a mathematical formula}HBΠ⁎. Computing{a mathematical formula}S⊨A(resp.{a mathematical formula}S⊨¬A) is in{a mathematical formula}co-NEXP(resp. NEXP) when L belongs to{a mathematical formula}SHOIN(D), and in{a mathematical formula}co-N2EXP(resp. N2EXP) when L belongs to{a mathematical formula}SROIQ(D).</paragraph><paragraph label="Proof">As shown for Lemma 8, checking whether an interpretation I of Π satisfies a dl-atom {a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c) amounts to checking the unsatisfiability of the DL knowledge base {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)}. Recall that deciding whether a DL knowledge base in {a mathematical formula}SHOIN(D) (resp. {a mathematical formula}SROIQ(D)) is satisfiable is complete for NEXP (resp. N2EXP) [62], [41].To compute {a mathematical formula}S⊨A is to check that every model I of S satisfies the dl-atom A. Its complementary task, i.e., to compute {a mathematical formula}S⊭A, is to check that there exists a model I of S that does not satisfy A. The latter can be done by guessing an interpretation I for Π together with an interpretation J for the DL knowledge base {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)} and then verifying that (1) I is a model of S, and (2) J satisfies {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)}.{sup:10} The guess of I and J can be done in exponential (resp. double exponential) time when L is in {a mathematical formula}SHOIN(D) (resp. {a mathematical formula}SROIQ(D)). Verifying that I is a model of S can be done in exponential time. Since deciding whether a DL knowledge base in {a mathematical formula}SHOIN(D) (resp. {a mathematical formula}SROIQ(D)) is satisfiable is complete for NEXP (resp. N2EXP), verifying that J satisfies {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)} can be done in exponential (resp. double exponential) time. This shows that the computation of {a mathematical formula}S⊭A can be done in NEXP (resp. N2EXP) for {a mathematical formula}SHOIN(D) (resp. {a mathematical formula}SROIQ(D)). As a result, computing {a mathematical formula}S⊨A is in {a mathematical formula}co-NEXP when L belongs to {a mathematical formula}SHOIN(D), and in {a mathematical formula}co-N2EXP when L belongs to {a mathematical formula}SROIQ(D).To compute {a mathematical formula}S⊨¬A is to check that every model I of S does not satisfy the dl-atom A. That is, for every model I of S, {a mathematical formula}L∪⋃i=1mAi(I)⊭Q(c) or equivalently, {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)} is satisfiable. Checking this satisfiability is in NEXP (resp. N2EXP) for {a mathematical formula}SHOIN(D) (resp. {a mathematical formula}SROIQ(D)). There may be at most exponentially many such models for S (Lemma 7). Therefore, computing {a mathematical formula}S⊨¬A is in NEXP when L belongs to {a mathematical formula}SHOIN(D), and in N2EXP when L belongs to {a mathematical formula}SROIQ(D).  □</paragraph><paragraph label="Proof of Theorem 18">Case 1: deciding whether Π has a well-justified FLP answer set is NEXP-complete when L belongs to {a mathematical formula}SHIF(D).We first guess an interpretation I and show that we can verify in EXP that I is a well-justified FLP answer set of Π. By Lemma 8, for each dl-atom A appearing in a rule body {a mathematical formula}body(r) of {a mathematical formula}ground(Π), computing {a mathematical formula}I∪¬I−⊨A and {a mathematical formula}I∪¬I−⊨¬A is in EXP and thus checking if I satisfies {a mathematical formula}body(r) is in EXP. {a mathematical formula}ground(Π) may have exponentially many rules, so checking whether I is a model of Π and computing the FLP reduct {a mathematical formula}fΠI is in EXP.To verify that I is a well-justified FLP answer set of Π, we (1) build the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)), and (2) check {a mathematical formula}lfp(TfΠI(∅,¬I−))∪¬I−⊨⋀A∈IA. Let {a mathematical formula}ground(Π) consist of M rules. To reach the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)), we have computations of the form {a mathematical formula}TfΠIi(∅,¬I−)∪¬I−⊨body(r) for at most {a mathematical formula}M2 times. By Lemma 8, it is EXP to compute {a mathematical formula}TfΠIi(∅,¬I−)∪¬I−⊨body(r). Thus part (1) is feasible in exponential time. Part (2) can also be done in exponential time. Consequently, we can verify whether I is a well-justified FLP answer set of Π in exponential time. Therefore, deciding whether Π has a well-justified FLP answer set can be done in NEXP.Recall that for a normal logic program, the well-justified FLP answer set semantics coincides with the standard answer set semantics. Since deciding whether a non-ground normal logic program has an answer set under the standard answer set semantics is NEXP-complete [11], it is NEXP-hard to determine whether Π has a well-justified FLP answer set.To conclude, deciding whether Π has a well-justified FLP answer set is NEXP-complete when L belongs to {a mathematical formula}SHIF(D).  □</paragraph><paragraph>In the above proof of the hardness of answer set existence for a dl-program relative to a {a mathematical formula}SHIF(D) knowledge base, we used the existing hardness result for a non-ground normal logic program under the standard answer set semantics. It seems that there is no such existing hardness result available for a dl-program relative to a {a mathematical formula}SHOIN(D) or {a mathematical formula}SROIQ(D) knowledge base. Observe that Lemma 5, Lemma 6 apply to dl-programs relative to any DL knowledge bases as well (with the same proof); i.e., cautious (resp. brave) reasoning for dl-programs under the well-justified FLP answer set semantics can be reduced to deciding the non-existence (resp. existence) of well-justified FLP answer sets, and vice versa. Thus, cautious (resp. brave) reasoning for dl-programs falls in the same complexity class as the non-existence (resp. existence) of well-justified FLP answer sets. Therefore, to prove Theorem 18 for the case of {a mathematical formula}SHOIN(D), we first introduce the following hardness result.</paragraph><paragraph label="Lemma 10">Let Π be a dl-program relative to a{a mathematical formula}SHOIN(D)knowledge base L and l a ground atom in{a mathematical formula}HBΠ. Deciding whether l is in some well-justified FLP answer set of Π is{a mathematical formula}PNEXP-hard.</paragraph><paragraph label="Proof">Let M be a polynomial-time bounded deterministic Turing machine with access to a NEXP oracle. The {a mathematical formula}PNEXP-hardness is proved by a reduction of M to brave reasoning for a stratified dl-program P relative to a {a mathematical formula}SHOIN(D) knowledge base, where dl-atoms in P are used to decide NEXP oracle calls made by M. The reduction is just the same as the one presented in [24, Theorem 7.2] except that we do not need to introduce the rule {a mathematical formula}¬b2l−2l(0)← to the stratified dl-program P, where {a mathematical formula}¬b2l−2l(0) is a “classical negated atom”. For simplicity, we do not reproduce the reduction here. As a result, M accepts an input ν if and only if a ground atom l belongs to the unique strong answer set of P. By Theorem 13, M accepts an input ν if and only if a ground atom l belongs to the unique well-justified FLP answer set of P. Therefore, deciding whether l is in some well-justified FLP answer set of Π is {a mathematical formula}PNEXP-hard.  □</paragraph><paragraph label="Proof of Theorem 18">Case 2: deciding whether Π has a well-justified FLP answer set is {a mathematical formula}PNEXP-complete when L belongs to {a mathematical formula}SHOIN(D).By Lemma 7, the number of ground dl-atoms in {a mathematical formula}ground(Π) is polynomial. Let {a mathematical formula}HBΠDL={A∈HBΠ|A is an input atom ofa dl-atom in ground(Π)}. The size of {a mathematical formula}HBΠDL is also polynomial. Let {a mathematical formula}Ip⊆HBΠDL be an interpretation of input atoms of all dl-atoms in {a mathematical formula}ground(Π). We call {a mathematical formula}Ip an input interpretation of dl-atoms. Let {a mathematical formula}Ip−=HBΠDL∖Ip.We first guess an input interpretation {a mathematical formula}Ip together with a chain {a mathematical formula}Ip0=∅⊂Ip1⊂⋯⊂Ipk=Ip. Since the size of {a mathematical formula}Ip is polynomial, k is a polynomial. For each dl-atom {a mathematical formula}A=DL[S1op1p1,…,Smopmpm;Q](c) in {a mathematical formula}ground(Π) and each {a mathematical formula}i∈{0,…,k}, we check {a mathematical formula}Ipi∪¬Ip−⊨A and {a mathematical formula}Ipi∪¬Ip−⊨¬A by calling a NEXP oracle (see Lemma 9). Hence the evaluation of all dl-atoms in {a mathematical formula}ground(Π) can be done in polynomial time with the help of a NEXP oracle.Given the above guess and the recorded results of the above checks {a mathematical formula}Ipi∪¬Ip−⊨A and {a mathematical formula}Ipi∪¬Ip−⊨¬A for all dl-atoms A in {a mathematical formula}ground(Π), we next call a NEXP oracle to check if there is a Herbrand model I of Π that (1) is an extension of {a mathematical formula}Ip, which (2) is obtained by a fixpoint computation compliant with the chain and (3) yielding I as a least fixpoint. More specifically, we guess I and check (1) {a mathematical formula}Ip=I∩HBΠDL; (2) whether in the sequence {a mathematical formula}〈TΠi(∅,¬I−)〉i=0∞ for the computation of the fixpoint {a mathematical formula}lfp(TfΠI(∅,¬I−)), the input interpretations increase following the chain {a mathematical formula}Ip0=∅⊂Ip1⊂⋯⊂Ipk=Ip; and (3) whether {a mathematical formula}lfp(TfΠI(∅,¬I−))=I, i.e., whether I is a well-justified FLP answer set of Π. Since this essentially amounts to evaluating an ordinary normal logic program it can be done in polynomial time with the help of a NEXP oracle.The above proof shows that given a guess of input interpretations for all ground dl-atoms, deciding whether Π has a well-justified FLP answer set complying with the guess is in {a mathematical formula}PNEXP when L belongs to {a mathematical formula}SHOIN(D). Consequently, deciding whether Π has a well-justified FLP answer set is in {a mathematical formula}NPNEXP when L belongs to {a mathematical formula}SHOIN(D). Recalling that {a mathematical formula}NPNEXP=PNEXP[37], the result follows.By Lemma 10, brave reasoning for dl-programs relative to {a mathematical formula}SHOIN(D) knowledge bases is {a mathematical formula}PNEXP-hard. Since brave reasoning for dl-programs falls in the same complexity class as existence of well-justified FLP answer sets, deciding whether a dl-program has a well-justified FLP answer set is also {a mathematical formula}PNEXP-hard when L belongs to {a mathematical formula}SHOIN(D). As a result, deciding whether a dl-program relative to a {a mathematical formula}SHOIN(D) knowledge base has a well-justified FLP answer set is {a mathematical formula}PNEXP-complete.  □</paragraph><paragraph>To prove Theorem 18 for the case of {a mathematical formula}SROIQ(D), we recall the concept of a domino system. A domino system is a triple {a mathematical formula}D=(D,H,V), where {a mathematical formula}D={1,…,p} is a finite set of tiles and {a mathematical formula}H,V⊆{a mathematical formula}D×D are horizontal and vertical matching relations. For a positive integer m and a word {a mathematical formula}w=w1…wn over D of length {a mathematical formula}n≤m, we say {a mathematical formula}D admits the tiling of {a mathematical formula}m×m with initial condition w iff there exists a mapping {a mathematical formula}τ:{1,…,m}×{1,…,m}→D such that for {a mathematical formula}1&lt;i≤m and {a mathematical formula}1≤j≤m, {a mathematical formula}〈τ(i−1,j),τ(i,j)〉∈H, for {a mathematical formula}1≤i≤m and {a mathematical formula}1&lt;j≤m, {a mathematical formula}〈τ(i,j−1),τ(i,j)〉∈V, and for {a mathematical formula}1≤i≤n, {a mathematical formula}τ(i,1)=wi.</paragraph><paragraph>We also borrow from [41, Theorem 5] the following polynomial-time reduction of the tilability of domino systems to the satisfiability of DL knowledge bases in {a mathematical formula}SROIQ(D).</paragraph><paragraph label="Lemma 11">For a domino system{a mathematical formula}D=(D,H,V)with{a mathematical formula}D={1,…,p}and initial condition{a mathematical formula}w=w1…wn, there exist{a mathematical formula}SROIQ(D)knowledge bases{a mathematical formula}Lg,{a mathematical formula}Lcand{a mathematical formula}Lw, where{a mathematical formula}Lgconsists of axioms (3)–(33) in[41],{a mathematical formula}Lcconsists of the following axioms (1)–(5) and{a mathematical formula}Lwconsists of the axioms (6)–(9){a mathematical formula}such that{a mathematical formula}Dadmits the tiling of{a mathematical formula}22n×22nwith initial condition w iff the concept O is satisfiable w.r.t. the DL knowledge base{a mathematical formula}Lg∪Lc∪Lw.</paragraph><paragraph>The next result follows from a reduction from simple Turing machines to domino systems [6, Theorem 6.12].</paragraph><paragraph label="Lemma 12">Let M be a nondeterministic Turing machine with time-(and thus space-) bound{a mathematical formula}22n, deciding an N2EXP-complete language{a mathematical formula}L(M)over the alphabet{a mathematical formula}Σ={0,1,“ ”}. There exists a domino system{a mathematical formula}D=(D,H,V)and a linear-time reduction{a mathematical formula}transthat takes any input{a mathematical formula}b∈Σ⁎to a word{a mathematical formula}w∈D⁎with{a mathematical formula}|b|=n=|w|such that M accepts b if and only if{a mathematical formula}Dadmits the tiling of{a mathematical formula}22n×22nwith initial condition w.</paragraph><paragraph>Since brave reasoning for dl-programs falls in the same complexity class as the existence of well-justified FLP answer sets, to prove Theorem 18 for the case of {a mathematical formula}SROIQ(D), we first prove the following hardness result.</paragraph><paragraph label="Lemma 13">Let Π be a dl-program relative to a{a mathematical formula}SROIQ(D)knowledge base L and l a ground atom in{a mathematical formula}HBΠ. Deciding whether l is in some well-justified FLP answer set of Π is{a mathematical formula}PN2EXP-hard.</paragraph><paragraph label="Proof">Recall that a stratified dl-program has a unique strong answer set, which is also the unique well-justified FLP answer set. The {a mathematical formula}PN2EXP-hardness is proved by a generic reduction of a Turing machine M with access to an N2EXP oracle to brave reasoning for a stratified dl-program Π relative to a {a mathematical formula}SROIQ(D) knowledge base L under the strong answer set semantics, exploiting the N2EXP-hardness proof for {a mathematical formula}SROIQ(D)[41]. The key is to use dl-atoms in Π to decide the results of N2EXP oracle calls made by M. The reduction is a slight modification of the reduction presented in [24, Theorem 7.2].More concretely, let M be a polynomial-time bounded deterministic Turing machine with access to an N2EXP oracle, and let ν be an input for M. Since every oracle call can simulate the computation of M on ν before that call, once the results of all previous oracle calls are known, we can assume that the input of every oracle call is given by ν and the results of all previous oracle calls. Since the computation of M after all oracle calls can be simulated within an additional oracle call, we can assume that the result of the last oracle call is the result of the computation of M on ν. Finally, since any input to an oracle call can be enlarged by “{a mathematical formula}dummy” bits, we can assume that the inputs to all oracle calls have the same length {a mathematical formula}n=2×(t+l), where t is the size of ν, and {a mathematical formula}l=f(t) is the number of all oracle calls: We assume that the input to the {a mathematical formula}m+1-th oracle call {a mathematical formula}(m∈{0,…,l−1}) has the form{a mathematical formula} where {a mathematical formula}νt,νt−1,…,ν1 are the symbols of ν in reverse order, which are all marked as valid by a subsequent “1”, {a mathematical formula}c0,c1,…,cm−1 are the results of the previous m oracle calls, which are all marked as valid by a subsequent “1”, and {a mathematical formula}cm,…,cl−1 are “{a mathematical formula}dummy” bits, which are all marked as invalid by a subsequent “0”.By Lemma 12, for an N2EXP oracle {a mathematical formula}M′, there exists a domino system {a mathematical formula}D=(D,H,V) and a linear-time reduction {a mathematical formula}trans that takes any input {a mathematical formula}b∈Σ⁎ with {a mathematical formula}|b|=n to a word {a mathematical formula}w=w1⋯wn∈D⁎ such that {a mathematical formula}M′ accepts b if and only if {a mathematical formula}D admits the tiling of {a mathematical formula}22n×22n with initial condition w. By Lemma 11, there exist {a mathematical formula}SROIQ(D) knowledge bases {a mathematical formula}Lg, {a mathematical formula}Lc, {a mathematical formula}Lw such that {a mathematical formula}D admits the tiling of {a mathematical formula}22n×22n with initial condition w if and only if the concept O is satisfiable w.r.t. the knowledge base {a mathematical formula}Lg∪Lc∪Lw.Let the stratified dl-program Π relative to a {a mathematical formula}SROIQ(D) knowledge base L be defined as follows:{a mathematical formula} where {a mathematical formula}Lw′ consists of the following axioms{a mathematical formula}p is the number of tiles of the domino system, n is the size of the inputs to all oracle calls, A, s, {a mathematical formula}ak,j are fresh concept, role, individuals that do not occur in {a mathematical formula}Lg and {a mathematical formula}Lc. {a mathematical formula}Lw′ consists of {a mathematical formula}(2×n+p×n) axioms, which is polynomial. Intuitively, {a mathematical formula}Ik⊑Dj means that the tile in the k-th position of the initial condition is j. The concept {a mathematical formula}∃s.({ak,j}⊓¬A) acts as a “{a mathematical formula}switch” because when {a mathematical formula}A(ak,j) is true, {a mathematical formula}({ak,j}⊓¬A)≡⊥ and {a mathematical formula}∃s.({ak,j}⊓¬A)≡⊥ and thus {a mathematical formula}Ik⊑Dj. The set {a mathematical formula}{A(ak,wk)|1≤k≤n} of concept membership axioms expresses that the initial condition of the domino system is {a mathematical formula}w=w1⋯wn.For every {a mathematical formula}j∈{0,…,l}, {a mathematical formula}Πj=Πνj∪Πqj∪Πw←bj∪Πs←wj. Informally, every set of dl-rules {a mathematical formula}Πj generates the input of the {a mathematical formula}j+1-th oracle call, which includes the results of the first j oracle calls. Here {a mathematical formula}Πl prepares the input of a “dummy” (non-happening) {a mathematical formula}l+1-th oracle call which contains the result of the l-th (i.e., the last) oracle call. More concretely, the bitstring {a mathematical formula}a−2t⋯a2l−1 is the input of the {a mathematical formula}j+1-th oracle call if and only if {a mathematical formula}b−2tj(a−2t),…,b2l−1j(a2l−1) are in the strong answer set of Π. The components {a mathematical formula}Πνj, {a mathematical formula}Πqj, {a mathematical formula}Πw←bj and {a mathematical formula}Πs←wj, with {a mathematical formula}j∈{0,…,l}, are defined as follows:<list>{a mathematical formula}Πν0 writes ν into the input of the first oracle call, and for each {a mathematical formula}j∈{1,…,l}, {a mathematical formula}Πνj copies ν into the input of the {a mathematical formula}j+1-th oracle call, i.e.{a mathematical formula}{a mathematical formula}Πq0 initializes the rest of the input of the first oracle call with “{a mathematical formula}dummy” bits, and every {a mathematical formula}Πqj with {a mathematical formula}j∈{1,…,l} writes the result of the j-th oracle call into the input of the {a mathematical formula}j+1-th oracle call and carries over all the other result and dummy bits from the input of the j-th oracle call, i.e.{a mathematical formula} Note that for a DL knowledge base {a mathematical formula}S, {a mathematical formula}S⊨O⊑⊥ if and only if O is unsatisfiable w.r.t. {a mathematical formula}S.Every {a mathematical formula}Πw←bj with {a mathematical formula}j∈{0,…,l} realizes the above-mentioned linear-time reduction {a mathematical formula}trans, which transforms any input {a mathematical formula}bj of the Turing machine M into an initial condition {a mathematical formula}wj of the same length of {a mathematical formula}M′s domino system {a mathematical formula}D.Every {a mathematical formula}Πs←wj with {a mathematical formula}j∈{0,…,l} transforms the initial condition {a mathematical formula}wj of {a mathematical formula}D into an input of the {a mathematical formula}j+1-th dl-atom via the predicate {a mathematical formula}Aj, i.e.{a mathematical formula}Observe that </list><paragraph>M accepts ν if and only if the last oracle call returns “yes”. The latter is equivalent to {a mathematical formula}b2l−2l(1) being derived from Π and thus {a mathematical formula}b2l−2l(0) being not derived from Π. So M accepts ν if and only if {a mathematical formula}b2l−2l(1) belongs to the strong answer set of Π if and only if {a mathematical formula}b2l−2l(1) belongs to the well-justified FLP answer set of Π.To conclude, it is {a mathematical formula}PN2EXP-hard to decide whether a given ground atom {a mathematical formula}l∈HBΠ is in some well-justified FLP answer set of a dl-program Π relative to a {a mathematical formula}SROIQ(D) knowledge base L.  □</paragraph></paragraph><paragraph label="Proof of Theorem 18">Case 3: deciding whether Π has a well-justified FLP answer set is {a mathematical formula}PN2EXP-complete when L belongs to {a mathematical formula}SROIQ(D).The proof of membership is analogous to the above proof of membership for the case of {a mathematical formula}SHOIN(D).By Lemma 13, brave reasoning for dl-programs relative to {a mathematical formula}SROIQ(D) knowledge bases is {a mathematical formula}PN2EXP-hard. Since brave reasoning for dl-programs falls in the same complexity class as the existence of well-justified FLP answer sets, deciding whether a dl-program has a well-justified FLP answer set is also {a mathematical formula}PN2EXP-hard when L belongs to {a mathematical formula}SROIQ(D). Consequently, deciding whether a dl-program relative to a {a mathematical formula}SROIQ(D) knowledge base has a well-justified FLP answer set is {a mathematical formula}PN2EXP-complete.  □</paragraph><paragraph label="Proof of Theorem 19">Recall that cautious (resp. brave) reasoning for dl-programs falls in the same complexity class as the non-existence (resp. existence) of well-justified FLP answer sets. By Theorem 18, it immediately follows that deciding whether a ground atom is in every (resp. some) well-justified FLP answer set is {a mathematical formula}co-NEXP-complete (resp. NEXP-complete) when L belongs to {a mathematical formula}SHIF(D), {a mathematical formula}PNEXP-complete (resp. {a mathematical formula}PNEXP-complete) when L belongs to {a mathematical formula}SHOIN(D), and {a mathematical formula}PN2EXP-complete (resp. {a mathematical formula}PN2EXP-complete) when L belongs to {a mathematical formula}SROIQ(D).  □</paragraph><paragraph>To prove Theorem 20, we introduce the following lemma. Given a dl-program Π relative to a DL knowledge base L, for every subset S of {a mathematical formula}HBΠ, let {a mathematical formula}S≤2 denote its restriction to unary and binary predicates. Moreover, we associate with Π its dl-satisfaction table {a mathematical formula}T(Π,L) given by all tuples {a mathematical formula}〈I,A,v〉 such that I is a subset of {a mathematical formula}HBΠ≤2, A is a ground dl-atom from {a mathematical formula}ground(Π), and {a mathematical formula}v=1 if I satisfies A under L, while {a mathematical formula}v=0 otherwise.</paragraph><paragraph label="Lemma 14">Given a ground dl-program Π relative to a DL knowledge base L, its dl-satisfaction table{a mathematical formula}T(Π,L), and a Herbrand interpretation I, deciding whether I is an FLP answer set of Π relative to L is in EXP.</paragraph><paragraph label="Proof">We first compute {a mathematical formula}fΠI, which can be done in polynomial time. For this purpose the projection {a mathematical formula}I≤2 is generated, and then {a mathematical formula}I⊨body(r) is checked by deciding {a mathematical formula}A∈I for ordinary body atoms A, respectively by looking up {a mathematical formula}〈I≤2,A,1〉∈T(Π,L) for dl-atoms A. The correctness of the latter is an immediate consequence of the fact the only unary and binary predicates occur in the input list of any dl-atom.Clearly, checking {a mathematical formula}head(r)∈I for every {a mathematical formula}r∈fΠI can also be done in polynomial time, and it (if it succeeds) additionally verifies that I is a model of Π relative to L (otherwise I is also not an FLP answer set).Second, we need to check for minimality, that is we need to verify {a mathematical formula}J⊭fΠI for every {a mathematical formula}J⊂I. We do so by an exponential number of tests of answer set existence for ground ordinary Horn programs with constraints. The size of each of the programs is bounded by the size {a mathematical formula}fΠI plus a single constraint. Hence, answer set existence can be checked in polynomial time for each of these programs. Every program {a mathematical formula}P(I,I′) corresponds to a subset {a mathematical formula}I′ of {a mathematical formula}I≤2 by the following construction: {a mathematical formula}P(I,I′) is obtained from {a mathematical formula}fΠI by<list>removing all literals ¬A from rule bodies where A is an ordinary atom;replacing every unary or binary ordinary atom A with 1 if {a mathematical formula}A∈I′, and with 0 otherwise;replacing every dl-atom A with v, where {a mathematical formula}〈I′,A,v〉∈T(Π,L);removing then all rules r such that {a mathematical formula}head(r)=1, or {a mathematical formula}body(r) contains 0 or ¬1, and removing 0 from the heads, respectively ¬0 and 1 from the bodies of the remaining rules; andif {a mathematical formula}I′=I≤2, then adding the constraint {a mathematical formula}←A1,…,Am, where {a mathematical formula}I∖I≤2={A1,…,Am}.We have thus shown that deciding whether </list><paragraph>I is an FLP answer set of Π relative to L is in EXP provided that its dl-satisfaction table {a mathematical formula}T(Π,L) is given.  □</paragraph></paragraph><paragraph label="Proof of Theorem 20">In case of {a mathematical formula}SHIF(D) determining the value v for a tuple {a mathematical formula}〈I′,A,v〉 of {a mathematical formula}T(Π,L) is possible in deterministic exponential time. Therefore, the whole table {a mathematical formula}T(Π,L) can be computed by performing exponentially many exponential time computations; hence, {a mathematical formula}T(Π,L) is computable in deterministic exponential time. Consequently, guessing an interpretation I and deciding whether it is an FLP answer set (computing {a mathematical formula}T(Π,L) first and applying Lemma 14) is feasible in nondeterministic exponential time.When L belongs to {a mathematical formula}SHOIN(D), computing {a mathematical formula}T(Π,L) is not feasible in deterministic exponential time. However, given that the number {a mathematical formula}n0 of tuples where {a mathematical formula}v=0 is known, one can proceed as before in nondeterministic exponential time. Establishing {a mathematical formula}n0 requires a polynomial number (in the size of Π) of decision problems to be solved, where each problem is in NEXP (and depends on the previous result). Thus, {a mathematical formula}PNEXP membership of the problem can be established as follows.We first compute {a mathematical formula}n0 in binary search by deciding problems of the form: given k and Π, are there at least k tuples in {a mathematical formula}T(Π,L) such that {a mathematical formula}v=0. Since the number of tuples in {a mathematical formula}T(Π,L) is exponential in the size of Π, the required size of k in binary representation is polynomial in the size of Π. Moreover, given a ground dl-atom A, an interpretation {a mathematical formula}I⊆HBΠ≤2, and an exponential size witness candidate w for {a mathematical formula}I⊭A (recall that {a mathematical formula}I⊭A is in NEXP and think of a potential computation path of a corresponding nondeterministic Turing machine computation), checking that w indeed witnesses {a mathematical formula}I⊭A is in EXP. Therefore, the sub-problems used in our binary search, i.e., given k and Π, deciding whether there are at least k tuples in {a mathematical formula}T(Π,L) such that {a mathematical formula}v=0, are in NEXP. By polynomially many calls to a NEXP oracle, we thus can establish the exact number {a mathematical formula}n0 of tuples in {a mathematical formula}T(Π,L) such that {a mathematical formula}v=0 in {a mathematical formula}PNEXP.Once {a mathematical formula}n0 is known, we can use one more call to the oracle to decide FLP answer set existence, by guessing I together with {a mathematical formula}n0 tuples {a mathematical formula}t1,…,tn0 of {a mathematical formula}T(Π,L) where {a mathematical formula}v=0 and corresponding witness candidates {a mathematical formula}w1,…,wn0 for {a mathematical formula}I⊭A. The oracle then first checks in exponential time for each {a mathematical formula}wi, that it correctly witnesses {a mathematical formula}I⊭A and then proceeds as in Lemma 14, given that {a mathematical formula}T(Π,L) can now be constructed in exponential time since all other entries are known to have {a mathematical formula}v=1. This proves {a mathematical formula}PNEXP-membership in case of {a mathematical formula}SHOIN(D).The membership proof for {a mathematical formula}SROIQ(D) is analogous, using an N2EXP oracle instead of the NEXP oracle.Matching lower bounds, i.e, hardness for NEXP, {a mathematical formula}PNEXP, and {a mathematical formula}PN2EXP, respectively, follows from the corresponding reductions for well-justified FLP answer set semantics. It is sufficient to observe that the programs constructed make use of monotonic dl-atoms only; hence, its well-justified FLP answer sets coincide with its FLP answer sets.  □</paragraph><paragraph label="Proof of Theorem 21">The termination property of Algorithm 1 follows from the assumption that all complex atoms occurring in a logic program are decidable.We note that the projections of all compatible sets of a normal logic program Π with complex atoms include all FLP answer sets of Π. Then by Corollary 2 they also include all well-justified FLP answer sets. Indeed, given an interpretation I of Π, let {a mathematical formula}Iˆ denote its extension to {a mathematical formula}Πˆ in which, for each complex atom A, (i) {a mathematical formula}EA is true if and only if I satisfies A and (ii) {a mathematical formula}EA′ is opposite to {a mathematical formula}EA. Then the reduct {a mathematical formula}fΠˆIˆ consists of all rules in {a mathematical formula}fΠIˆ plus for every complex atom A the rule {a mathematical formula}EA←¬EA′ if I satisfies A and the rule {a mathematical formula}EA′←¬EA otherwise. Hence if {a mathematical formula}I′⊆I is a model of {a mathematical formula}fΠI, then {a mathematical formula}fΠˆIˆ has a model {a mathematical formula}Jˆ which on all {a mathematical formula}EA and {a mathematical formula}EA′ coincides with {a mathematical formula}Iˆ and whose projection J on Π coincides with {a mathematical formula}I′; if I is minimal (i.e., an FLP answer set of Π), then also the corresponding J is minimal, and thus an answer set of {a mathematical formula}Πˆ.This means that for every well-justified FLP answer set I of Π, there must be a compatible set {a mathematical formula}Iˆ whose projection on Π is I such that {a mathematical formula}I=lfp(TfΠI(∅,¬I−)). Obviously, this well-justified answer set will be identified in the checking step of Algorithm 1. This shows the completeness of Algorithm 1.For each output I of Algorithm 1, I must be the projection of some compatible set {a mathematical formula}Iˆ such that {a mathematical formula}I=lfp(TfΠI(∅,¬I−)). As shown in [20], I is an FLP answer set of Π. Since {a mathematical formula}I=lfp(TfΠI(∅,¬I−)), I is also a well-justified FLP answer set of Π. This shows the soundness of Algorithm 1.  □</paragraph></section></appendices><references><reference label="[1]"><authors>F. Baader,S. Brandt,C. Lutz</authors><title>Pushing the EL envelope</title><host>Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence(2005)Professional Book CenterEdinburgh, Scotland, UK pp.364-369</host></reference><reference label="[2]"><host>F. BaaderD. CalvaneseD. McGuinnessD. NardiP.F. Patel-SchneiderThe Description Logic Handbook: Theory, Implementation and Applications2nd edition(2010)Cambridge University Press</host></reference><reference label="[3]"><authors>C. Baral</authors><title>Knowledge Representation, Reasoning and Declarative Problem Solving with Answer Sets</title><host>(2003)Cambridge University Press</host></reference><reference label="[4]"><authors>M. Bartholomew,J. Lee,Y. Meng</authors><title>First-order extension of the FLP stable model semantics via modified circumscription</title><host>22nd International Joint Conference on Artificial Intelligence (IJCAI)(2011) pp.724-730</host></reference><reference label="[5]"><authors>T.J.M. Bench-Capon,P.E. Dunne</authors><title>Argumentation in artificial intelligence</title><host>Artif. Intell.171 (10–15)(2007) pp.619-641</host></reference><reference label="[6]"><authors>E. Börger,E. Grädel,Y. Gurevich</authors><title>The Classical Decision Problem</title><host>(2001)Springer</host></reference><reference label="[7]"><authors>G. Brewka,T. Eiter</authors><title>Equilibria in heterogeneous nonmonotonic multi-context systems</title><host>AAAI(2007) pp.385-390</host></reference><reference label="[8]"><authors>G. Brewka,T. Eiter,M. Fink</authors><title>Nonmonotonic multi-context systems: a flexible approach for integrating heterogeneous knowledge sources</title><host>M. BalducciniT.C. SonLogic Programming, Knowledge Representation, and Nonmonotonic ReasoningLect. Notes Comput. Sci.vol. 6565 (2011)Springer pp.233-258</host></reference><reference label="[9]"><authors>G. Brewka,T. Eiter,M. Truszczyński</authors><title>Answer set programming at a glance</title><host>Commun. ACM54 (12)(2011) pp.92-103</host></reference><reference label="[10]"><authors>D. Calvanese,G.D. Giacomo,D. Lembo,M. Lenzerini,R. Rosati</authors><title>Tractable reasoning and efficient query answering in description logics: the DL-Lite family</title><host>J. Autom. Reason.39 (3)(2007) pp.385-429</host></reference><reference label="[11]"><authors>E. Dantsin,T. Eiter,G. Gottlob,A. Voronkov</authors><title>Complexity and expressive power of logic programming</title><host>ACM Comput. Surv.33 (3)(2001) pp.374-425</host></reference><reference label="[12]"><authors>M. Dao-Tran,T. Eiter,M. Fink,T. Krennwallner</authors><title>Modular nonmonotonic logic programming revisited</title><host>25th International Conference on Logic Programming (ICLP)(2009)Springer pp.145-159</host></reference><reference label="[13]"><authors>M. Dao-Tran,T. Eiter,M. Fink,T. Krennwallner</authors><title>Distributed nonmonotonic multi-context systems</title><host>F. LinU. Sattler12th International Conference on the Principles of Knowledge Representation and ReasoningKR 2010, Toronto, Ontario, Canada, May 9–13, 2010(2010)AAAI Press pp.60-70</host></reference><reference label="[14]"><authors>J. de Bruijn,T. Eiter,H. Tompits</authors><title>Embedding approaches to combining rules and ontologies into autoepistemic logic</title><host>11th International Conference on Principles of Knowledge Representation and Reasoning (KR)(2008)AAAI Press pp.485-495</host></reference><reference label="[15]"><authors>J. de Bruijn,D. Pearce,A. Polleres,A. Valverde</authors><title>A semantical framework for hybrid knowledge bases</title><host>Knowl. Inf. Syst.25 (1)(2010) pp.81-104</host></reference><reference label="[16]"><authors>M. Denecker,N. Pelov,M. Bruynooghe</authors><title>Ultimate well-founded and stable semantics for logic programs with aggregates</title><host>17th International Conference on Logic Programming (ICLP)(2001)Springer pp.212-226</host></reference><reference label="[17]"><authors>P. Dung,P. Mancarella,F. Toni</authors><title>Computing ideal sceptical argumentation</title><host>Artif. Intell.171 (2007) pp.642-674</host></reference><reference label="[18]"><authors>P.M. Dung</authors><title>On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games</title><host>Artif. Intell.77 (2)(1995) pp.321-357</host></reference><reference label="[19]"><authors>T. Eiter,M. Fink,G. Ianni,T. Krennwallner,P. Schüller</authors><title>Pushing efficient evaluation of HEX programs by modular decomposition</title><host>J. DelgrandeW. Faber11th International Conference on Logic Programming and Nonmonotonic ReasoningLPNMR 2011, Vancouver, British Columbia, Canada, May 16–19Lect. Notes Comput. Sci.vol. 6645 (2011) pp.93-106</host></reference><reference label="[20]"><authors>T. Eiter,M. Fink,T. Krennwallner,C. Redl</authors><title>Conflict-driven ASP solving with external sources</title><host>Theory Pract. Log. Program.12 (4–5)(2012) pp.659-679</host></reference><reference label="[21]"><authors>T. Eiter,M. Fink,T. Krennwallner,C. Redl,P. Schüller</authors><title>Exploiting unfounded sets for HEX-program evaluation</title><host>13th European Conference on Logics in Artificial Intelligence (JELIA)(2012) pp.160-175</host></reference><reference label="[22]">T. Eiter,M. Fink,P. Schüller,A. WeinzierlFinding explanations of inconsistency in nonmonotonic multi-context systemsTech. Rep. INFSYS RR-1843-12-09, INFSYS RR-1843-03-08, Inst. für Informationssysteme, TU Wien, preliminary version<host>Proc. 12th International Conference on Knowledge Representation and ReasoningKR 2010(2012)AAAI Press pp.329-339</host></reference><reference label="[23]"><authors>T. Eiter,G. Gottlob</authors><title>On the computational cost of disjunctive logic programming: propositional case</title><host>Ann. Math. Artif. Intell.15 (3–4)(1995) pp.289-323</host></reference><reference label="[24]"><authors>T. Eiter,G. Ianni,T. Lukasiewicz,R. Schindlauer,H. Tompits</authors><title>Combining answer set programming with description logics for the semantic web</title><host>Artif. Intell.172 (12–13)(2008) pp.1495-1539</host></reference><reference label="[25]"><authors>T. Eiter,G. Ianni,R. Schindlauer,H. Tompits</authors><title>A uniform integration of higher-order reasoning and external evaluations in answer-set programming</title><host>19th International Joint Conference on Artificial Intelligence (IJCAI)(2005)Professional Book Center pp.90-96</host></reference><reference label="[26]"><authors>W. Faber,N. Leone,G. Pfeifer</authors><title>Recursive aggregates in disjunctive logic programs: semantics and complexity</title><host>9th European Conference on Logics in Artificial Intelligence (JELIA)(2004)Springer pp.200-212</host></reference><reference label="[27]"><authors>W. Faber,G. Pfeifer,N. Leone</authors><title>Semantics and complexity of recursive aggregates in answer set programming</title><host>Artif. Intell.175 (1)(2011) pp.278-298</host></reference><reference label="[28]"><authors>F. Fages</authors><title>Consistency of Clark's completion and existence of stable models</title><host>J. Methods Log. Comput. Sci.1 (1994) pp.51-60</host></reference><reference label="[29]"><authors>P. Ferraris</authors><title>Answer sets for propositional theories</title><host>8th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR)(2005)Springer pp.119-131</host></reference><reference label="[30]"><authors>P. Ferraris,J. Lee,V. Lifschitz</authors><title>Stable models and circumscription</title><host>Artif. Intell.175 (1)(2011) pp.236-263</host></reference><reference label="[31]"><authors>P. Ferraris,V. Lifschitz</authors><title>Mathematical foundations of answer set programming</title><host>We Will Show Them!vol. 1 (2005) pp.615-664</host></reference><reference label="[32]"><authors>M. Fitting</authors><title>First-Order Logic and Automated Theorem Proving</title><host>2nd edition(1996)Springer</host></reference><reference label="[33]"><authors>M. Gelfond,V. Lifschitz</authors><title>The stable model semantics for logic programming</title><host>5th International Conference on Logic Programming (ICLP)(1988)MIT Press pp.1070-1080</host></reference><reference label="[34]"><authors>M. Gelfond,V. Lifschitz</authors><title>Classical negation in logic programs and disjunctive databases</title><host>New Gener. Comput.9 (1991) pp.365-385</host></reference><reference label="[35]"><authors>C. Ghidini,F. Giunchiglia</authors><title>Local models semantics, or contextual reasoning = locality + compatibility</title><host>Artif. Intell.127 (2)(2001) pp.221-259</host></reference><reference label="[36]"><authors>B.C. Grau,I. Horrocks,B. Motik,B. Parsia,P.F. Patel-Schneider,U. Sattler</authors><title>OWL 2: The next step for OWL</title><host>J. Web Semant.6 (4)(2008) pp.309-322</host></reference><reference label="[37]"><authors>L.A. Hemachandra</authors><title>The strong exponential hierarchy collapses</title><host>J. Comput. Syst. Sci.39 (3)(1989) pp.299-322</host></reference><reference label="[38]"><authors>I. Horrocks,O. Kutz,U. Sattler</authors><title>The even more irresistible SROIQ</title><host>10th International Conference on Principles of Knowledge Representation and Reasoning (KR)(2006) pp.57-67</host></reference><reference label="[39]"><authors>I. Horrocks,P.F. Patel-Schneider</authors><title>Reducing OWL entailment to description logic satisfiability</title><host>International Semantic Web Conference (ISWC)(2003) pp.17-29</host></reference><reference label="[40]"><authors>I. Horrocks,P.F. Patel-Schneider,F. van Harmelen</authors><title>From SHIQ and RDF to OWL: the making of a web ontology language</title><host>J. Web Semant.1 (1)(2003) pp.7-26</host></reference><reference label="[41]"><authors>Y. Kazakov</authors><title>RIQ and SROIQ are harder than SHOIQ⁎</title><host>11th International Conference on Principles of Knowledge Representation and Reasoning (KR)(2008) pp.274-284</host></reference><reference label="[42]"><authors>J. Lee,R. Palla</authors><title>Integrating rules and ontologies in the first-order stable model semantics (preliminary report)</title><host>AAAI Spring Symposium: Logical Formalizations of Commonsense Reasoning(2011)</host></reference><reference label="[43]"><authors>V. Lifschitz</authors><title>Answer set programming and plan generation</title><host>Artif. Intell.138 (1–2)(2002) pp.39-54</host></reference><reference label="[44]"><authors>V. Lifschitz</authors><title>Thirteen definitions of a stable model</title><host>Fields of Logic and Computation(2010) pp.488-503</host></reference><reference label="[45]"><authors>L. Liu,E. Pontelli,T. Son,M. Truszczyński</authors><title>Logic programs with abstract constraint atoms: the role of computations</title><host>Artif. Intell.174 (3–4)(2010) pp.295-315</host></reference><reference label="[46]"><authors>T. Lukasiewicz</authors><title>A novel combination of answer set programming with description logics for the semantic web</title><host>IEEE Trans. Knowl. Data Eng.22 (11)(2010) pp.1577-1592</host></reference><reference label="[47]"><authors>V.W. Marek,M. Truszczyński</authors><title>Stable models and an alternative logic programming paradigm</title><host>The Logic Programming Paradigm: a 25-Year Perspective(1999)Springer pp.375-398</host></reference><reference label="[48]"><authors>V.W. Marek,M. Truszczyński</authors><title>Logic programs with abstract constraint atoms</title><host>19th National Conference on Artificial Intelligence (AAAI)(2004)MIT Press pp.86-91</host></reference><reference label="[49]"><authors>B. Motik,R. Rosati</authors><title>Reconciling description logics and rules</title><host>J. ACM57 (5)(2010)</host></reference><reference label="[50]"><authors>I. Niemela</authors><title>Logic programs with stable model semantics as a constraint programming paradigm</title><host>Ann. Math. Artif. Intell.25 (1999) pp.241-273</host></reference><reference label="[51]"><authors>D. Pearce</authors><title>A new logical characterisation of stable models and answer sets</title><host>Non-Monotonic Extensions of Logic Programming(1996) pp.57-70</host></reference><reference label="[52]"><authors>D. Pearce</authors><title>Equilibrium logic</title><host>Ann. Math. Artif. Intell.47 (1–2)(2006) pp.3-41</host></reference><reference label="[53]"><authors>W. Pelov,M. Denecker,M. Bruynooghe</authors><title>Well-founded and stable semantics of logic programs with aggregates</title><host>Theory Pract. Log. Program.7 (3)(2007) pp.301-353</host></reference><reference label="[54]"><authors>Y.D. Shen</authors><title>Well-supported semantics for description logic programs</title><host>22nd International Joint Conference on Artificial Intelligence (IJCAI)(2011) pp.1081-1086</host></reference><reference label="[55]"><authors>Y.D. Shen,K.W. Wang</authors><title>Extending logic programs with description logic expressions for the semantic web</title><host>International Semantic Web Conference (ISWC)(2011) pp.633-648</host></reference><reference label="[56]"><authors>Y.D. Shen,K.W. Wang</authors><title>FLP semantics without circular justifications for general logic programs</title><host>26th AAAI Conference on Artificial Intelligence (AAAI)(2012)AAAI Press pp.821-827</host></reference><reference label="[57]"><authors>Y.D. Shen,J.H. You</authors><title>A generalized Gelfond–Lifschitz transformation for logic programs with abstract constraints</title><host>22nd AAAI Conference on Artificial Intelligence (AAAI)(2007) pp.483-488</host></reference><reference label="[58]"><authors>Y.D. Shen,J.H. You</authors><title>A default approach to semantics of logic programs with constraint atoms</title><host>10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR)(2009)Springer pp.277-289</host></reference><reference label="[59]"><authors>T.C. Son,E. Pontelli</authors><title>A constructive semantic characterization of aggregates in answer set programming</title><host>Theory Pract. Log. Program.7 (3)(2007) pp.355-375</host></reference><reference label="[60]"><authors>T.C. Son,E. Pontelli,P.H. Tu</authors><title>Answer sets for logic programs with arbitrary abstract constraint atoms</title><host>J. Artif. Intell. Res.29 (2007) pp.353-389</host></reference><reference label="[61]"><authors>L. Stockmeyer,A. Meyer</authors><title>Word problems requiring exponential time</title><host>5th ACM Symposium on the Theory of Computing(1973) pp.1-9</host></reference><reference label="[62]">S. TobiesComplexity results and practical algorithm for logics in knowledge representationPh.D. thesis<host>(2001)RWTH AachenGermany</host></reference><reference label="[63]"><authors>M. Truszczyński</authors><title>Reducts of propositional theories, satisfiability relations, and generalizations of semantics of logic programs</title><host>Artif. Intell.174 (16–17)(2010) pp.1285-1306</host></reference><reference label="[64]"><authors>M.H. van Emden,R.A. Kowalski</authors><title>The semantics of predicate logic as a programming language</title><host>J. ACM23 (4)(1976) pp.733-742</host></reference></references><footnote><note-para label="1">Logic programs with classical logic formulas were recently introduced by Bartholomew et al. [4], which consist of rules of the form {a mathematical formula}H←B, where H and B are arbitrary first-order formulas. Normal logic programs can be viewed as a special form of logic programs with first-order formulas, where the negation not is identified with ¬, each rule head H with an atom, and each rule body B with a conjunction of literals. Answer sets of such logic programs are defined by the FLP answer set semantics.</note-para><note-para label="2">Epistemic disjunctions are usually expressed using the epistemic operator | in the literature. A classical disjunction {a mathematical formula}A∨¬A is a tautology, but an epistemic disjunction {a mathematical formula}A|¬A is not a tautology since it does not follow the law of the excluded middle (see [31] for detailed explanations).</note-para><note-para label="3">Note that aggregates over multisets can be readily supported using a list {a mathematical formula}X=X1,…,Xn of aggregate variables and defining {a mathematical formula}OP(SAI) to work on the first component of the tuples in {a mathematical formula}SAI={(a1,…,an)∈Dn|I satisfies F(a1,…,an)} (as in the dlv system).</note-para><note-para label="4">Technically, for atomic rule heads it can be captured in the framework of Denecker et al. [16] and of Pelov et al. [53].</note-para><note-para label="5">dlvhex is available at http://www.kr.tuwien.ac.at/research/systems/dlvhex.</note-para><note-para label="6">Available at http://www.cs.uni-potsdam.de/clasp.</note-para><note-para label="7">All benchmark encodings, instances and results are available at http://www.kr.tuwien.ac.at/staff/redl/wjflp.</note-para><note-para label="8">See http://www.kr.tuwien.ac.at/staff/redl/wjflp. We note that the (unique) subset-maximal ideal set, the ideal extension, can be obtained using a further optimization constraint or using a more involved encoding.</note-para><note-para label="9">See http://www.kr.tuwien.ac.at/staff/redl/wjflp or [22].</note-para><note-para label="10">When J satisfies {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)}, {a mathematical formula}L∪⋃i=1mAi(I)∪{¬Q(c)} is satisfiable. In this case, {a mathematical formula}L∪⋃i=1mAi(I)⊭Q(c) and thus I does not satisfy the dl-atom A.</note-para></footnote></root>