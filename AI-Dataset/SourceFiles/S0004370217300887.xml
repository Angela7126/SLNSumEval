<?xml version="1.0" encoding="UTF-8"?><root><url>https://www.sciencedirect.com/science/article/pii//S0004370217300887</url><title>Towards breaking more composition symmetries in partial symmetry breaking</title><authors>Jimmy H.M. Lee,Zichen Zhu</authors><abstract>The paper proposes a dynamic method, Recursive Symmetry Breaking During Search (ReSBDS), for efficient partial symmetry breaking. We first demonstrate how Partial Symmetry Breaking During Search (ParSBDS) misses important pruning opportunities when given only a subset of symmetries to break. The investigation pinpoints the culprit and in turn suggests rectification. The main idea is to add extra symmetry breaking constraints during search recursively to prune also symmetric nodes of some pruned subtrees. Thus, ReSBDS can break extra symmetry compositions, but is carefully designed to break only the ones that are easy to identify and inexpensive to break. We present theorems to guarantee the soundness and termination of our approach, and compare our method with popular static and dynamic methods. When the variable (value) heuristic is static, ReSBDS is also complete in eliminating all interchangeable variables (values) given only the generator symmetries. We propose further a light version of ReSBDS method (LReSBDS), which has a slightly weaker pruning power of ReSBDS but with a reduced overhead. We give theoretical characterization on the soundness and termination of LReSBDS, and comparisons on pruning strengths against other symmetry breaking methods including ReSBDS. Extensive experimentations confirm the efficiency of ReSBDS and LReSBDS, when compared against state of the art methods.</abstract><keywords>Dynamic symmetry breaking;Partial symmetry breaking;Composition symmetries</keywords><content><section label="1"><section-title>Introduction</section-title><paragraph>Constraint Programming (CP) is a practical framework for modeling and solving combinatorial search and optimization problems, which are NP-complete in general. Mainstream constraint-solving mechanisms encompass systematic exploration of the search tree augmented with various forms and degrees of constraint propagation [1] to prune the search space. Symmetries are transformations that map a problem solution into an equivalent solution (and also from non-solutions to non-solutions). Visiting symmetrical equivalents of traversed subtrees is fruitless. In many cases, all symmetrical variants of every deadend encountered during the search must be explored before a solution can be found. The goal of symmetry breaking is to avoid searching the symmetrical equivalents of visited search nodes, so as to increase solving efficiency.</paragraph><paragraph>Symmetries can be broken statically [2], [3], [4], [5] or dynamically [6], [7], [8]. Static methods alter the original problem by adding new constraints to eliminate symmetric parts and solutions. In contrast, dynamic methods modify the search procedure to exclude exploration of symmetric regions. There are pros and cons for each approach. Static methods are more commonly adopted since they are easier to implement and incur relatively less overhead. Static symmetry breaking constraints interact well (a) with one another to prune also extra composition symmetries in addition to the target symmetries, and (b) with problem constraints to increase constraint propagation. However, static techniques are usually tailored for specialized symmetry types and can be in conflict with search heuristics. An important advantage of dynamic techniques is the flexibility to handle symmetries of all kinds and the compatibility with search heuristics.</paragraph><paragraph>In this paper, we focus on dynamic symmetry breaking, in particular the Symmetry Breaking During Search (SBDS) method [7] that adds conditional symmetry breaking constraints during search. The completeness of SBDS, however, relies on the fact that all symmetries are given to SBDS to break. For problems with exponential number of symmetries, direct use of SBDS is impractical [7]. Apart from the large number of symmetry functions to implement, many symmetry breaking constraints may be added to the constraint store, slowing down search significantly. The first method to make SBDS practical is partial SBDS (ParSBDS). While SBDS tries to break all symmetries in the problem, ParSBDS tackles only a selected subset of symmetries [4], [9]. This is a direct application of partial symmetry breaking [10], which trades completeness for efficiency. Apart from ParSBDS, other adaptations of SBDS include shortcut SBDS [7] and Lightweight Dynamic Symmetry Breaking (LDSB) [11].</paragraph><paragraph>A starting point of our work is based on a simple observation: in many partial variants of static methods, posting only a few symmetry breaking constraints can sometimes eliminate most if not all symmetries in a problem. This is due to the fact that symmetry breaking constraints intended for a particular symmetry often break more than just the intended symmetry as a side-effect [12]. Thus, by carefully choosing the subset of symmetries to break, static methods can break also a large number of composition symmetries. Unfortunately, ParSBDS fails to generate the same strong side-effect. In a subsequent section, we give a detailed example showing how ParSBDS misses pruning opportunities when compared to a static method and given the same subset of symmetries to break.</paragraph><paragraph>Another starting point is LDSB, which is a further extension of shortcut SBDS designed for small overhead and ability to break composition symmetries. However, LDSB [11] targets only at symmetries that are common in constraint problems, has compact representation, and can be easily and efficiently processed. This limits the applicability of LDSB.</paragraph><paragraph>We propose a generalization of ParSBDS that enjoys the benefits of both ParSBDS and LDSB as summarized in Table 1. The main idea of Recursive SBDS (ReSBDS) is to add extra symmetry breaking constraints during search recursively to prune also symmetric nodes of some pruned subtrees. Thus, ReSBDS can break extra symmetry compositions. Our proposal features a careful tradeoff between the number of constraints added and the benefits of extra pruning. We give theoretical characterization on the soundness and termination of our method, and comparisons on pruning strengths against other well-known symmetry breaking methods, such as LDSB [11] and the LexLeader method [3]. When given generators of interchangeable variables (values) according to a static search heuristic, ReSBDS is complete in eliminating the entire symmetry group. We propose further a light version of ReSBDS method (LReSBDS), which has a slightly weaker pruning power of ReSBDS but with a reduced overhead. We also give theoretical characterization on the soundness and termination of LReSBDS, and comparisons on pruning strengths against other symmetry breaking methods including ReSBDS. We perform extensive experimentation on benchmarks of different natures and compare against state of the art static and dynamic methods. Results confirm the feasibility and competitiveness of our proposal.</paragraph><paragraph>As evidenced by Walsh's Spotlight Talk [13] at AAAI 2012, most recent successful symmetry breaking work [4], [14], [15], [16], [17], [5], [18], [19], [20], [21], [12], [22], [23] has been static in nature. Our work can help to revive interests of researchers in dynamic symmetry breaking and is the starting point of a series of further work on dynamic symmetry breaking [24], [25], [26]. The paper enhances the work of Lee and Zhu [27] and the Light ReSBDS algorithm by Lee and Zhu [24].</paragraph></section><section label="2"><section-title>Background</section-title><paragraph>In this section, we give some background on CSPs, symmetries as well as the two symmetry breaking methods: LexLeader and SBDS.</paragraph><section label="2.1"><section-title>Basic definitions</section-title><paragraph>A Constraint Satisfaction Problem (CSP) [1]P is a tuple {a mathematical formula}(X,D,C) where X is a finite set of variables, D is a finite set of domains such that each {a mathematical formula}x∈X has a domain {a mathematical formula}D(x) and C is a set of constraints, each a subset of the Cartesian product {a mathematical formula}D(xi1)×…×D(xik) of the domains of the involved variables (scope). An assignment{a mathematical formula}x=v assigns value v to variable x. A full assignment is a set of assignments, one for each variable in X. A partial assignment is a subset of a full assignment. A solution for P is a full assignment that makes every member of C true. A constraint is generalized arc consistent (GAC) iff when a variable in the scope of a constraint is assigned any value in its domain, there exist compatible values in the domains of all other variables in the scope of the constraint. A CSP is GAC iff every constraint is GAC. In the following, given a CSP {a mathematical formula}P=(X,D,C), we use the short form {a mathematical formula}P∪{c} for {a mathematical formula}(X,D,C∪{c}) where c is a constraint.</paragraph><paragraph>In order to make sensible comparisons against other methods, we consider only search trees with static variable and value orderings. A search tree for a CSP P with variables X is finite and has CSPs as nodes. The root is P. A node {a mathematical formula}P0 is a leaf node iff either {a mathematical formula}P0 has a variable with empty domain or the domains of all variables of {a mathematical formula}P0 are singletons. Without loss of generality, we consider search trees with binary branching, in which every non-leaf node has exactly two descendants. Suppose a non-leaf node {a mathematical formula}P1 has x and {a mathematical formula}v∈D(x) as the branching variable and value. The left and right children of {a mathematical formula}P1 are cons{a mathematical formula}(P1∪{x=v}) and cons{a mathematical formula}(P1∪{x≠v}) respectively where cons() enforces some form of consistency to a CSP. We call {a mathematical formula}x=v the branching assignment from {a mathematical formula}P1 to cons{a mathematical formula}(P1∪{x=v}). Each node {a mathematical formula}P1 is associated with a partial assignment{a mathematical formula}A1 which is the set of branching assignments collected from the root P to {a mathematical formula}P1. If a node {a mathematical formula}P0 is in a subtree under node {a mathematical formula}P1, {a mathematical formula}P0 is the descendant node of {a mathematical formula}P1 and {a mathematical formula}P1 is the ancestor node of {a mathematical formula}P0.</paragraph><paragraph>Throughout the paper, we assume that cons() enforces generalized arc consistency to the CSP associated with each node. Given a node {a mathematical formula}P0 with branching variable x and value v. The left child cons{a mathematical formula}(P0∪{x=v}) of {a mathematical formula}P0 and the entire subtree are pruned by its ancestor {a mathematical formula}Pk during search if v is pruned from {a mathematical formula}D(x) in {a mathematical formula}Pk. In addition, the right child of {a mathematical formula}P0 is then merged with {a mathematical formula}P0.</paragraph></section><section label="2.2"><section-title>Symmetry, group and symmetry breaking methods</section-title><paragraph>Here we consider symmetry as a property of the set of solutions. A solution symmetry[28] is a solution-preserving permutation on assignments. A variable symmetry σ is a bijection on variables that preserves solutions: if {a mathematical formula}{xi=vi|1≤i≤n} is a solution, then {a mathematical formula}{xσ(i)=vi|1≤i≤n} is also a solution. A value symmetry θ is a bijection on values that preserves solutions: if {a mathematical formula}{xi=vi|1≤i≤n} is a solution, then {a mathematical formula}{xi=θ(vi)|1≤i≤n} is also a solution. A set of variables X (values V) is interchangeable iff any bijection mapping from {a mathematical formula}X→X ({a mathematical formula}V→V) is a variable (value) symmetry. A symmetry class[4] is an equivalence class of full assignments, where two assignments are equivalent if there is some symmetry mapping one into the other. Given two nodes {a mathematical formula}P0 and {a mathematical formula}P1 with partial assignments {a mathematical formula}A0 and {a mathematical formula}A1 respectively. {a mathematical formula}P1 is a symmetric node of {a mathematical formula}P0 w.r.t. symmetry g if {a mathematical formula}A0g⊆W1 where {a mathematical formula}W1 is the set of assignments {a mathematical formula}x=v where {a mathematical formula}D(x)={v} in {a mathematical formula}P1.</paragraph><paragraph>A group is a non-empty set Σ with a composition operator ∘ such that:</paragraph><list><list-item label="1.">Σ is closed under ∘. That is, for all g, {a mathematical formula}h∈Σ, {a mathematical formula}g∘h∈Σ; and</list-item><list-item label="2.">there is an identity {a mathematical formula}id∈Σ. That is, for all {a mathematical formula}g∈Σ, {a mathematical formula}g∘id = {a mathematical formula}id∘g = g; and</list-item><list-item label="3.">every element g of Σ has an inverse {a mathematical formula}g−1 such that {a mathematical formula}g∘g−1 = {a mathematical formula}g−1∘g = id; and</list-item><list-item label="4.">∘ is associative. That is, for all {a mathematical formula}f,g,h∈Σ, {a mathematical formula}(f∘g)∘h=f∘(g∘h).</list-item></list><paragraph>A set of symmetries G generates a group Σ iff every element of Σ can be written as a product of elements in G with the composition operator ∘ and every product of any sequence of elements of G is in Σ. G is called a set of generators for Σ, which is in turn the symmetry group of G.</paragraph><paragraph>A symmetry breaking method is sound (complete) iff it leaves at least (most) one solution in each symmetry class. A symmetry breaking method breaks a symmetry g iff there exists a remaining solution S after applying this method, {a mathematical formula}Sg is pruned. A symmetry breaking method eliminates a symmetry g iff for each remaining solution S after applying this method, {a mathematical formula}Sg must be pruned if {a mathematical formula}S≠Sg. A symmetry breaking method eliminates a symmetry group Σ iff all symmetries in Σ except the identity one are eliminated.</paragraph><paragraph>Symmetry breaking method {a mathematical formula}m1 is stronger in nodes (resp. solutions) pruning than method {a mathematical formula}m2, denoted by {a mathematical formula}m1⪰n(resp. ⪰s)m2, when all the nodes (resp. solutions) pruned by {a mathematical formula}m2 would also be pruned by {a mathematical formula}m1. Symmetry breaking method {a mathematical formula}m1 is strictly stronger in nodes (resp. solutions) pruning than method {a mathematical formula}m2, denoted by {a mathematical formula}m1≻n(resp. ≻s)m2, when {a mathematical formula}m1⪰n(resp. ⪰s)m2 and {a mathematical formula}m2⪰̸n(resp. ⪰̸s)m1. Note that {a mathematical formula}⪰n and {a mathematical formula}≻n imply {a mathematical formula}⪰s and {a mathematical formula}≻s respectively. Symmetry breaking method {a mathematical formula}m1 is incomparable in nodes (resp. solutions) pruning than method {a mathematical formula}m2, denoted by {a mathematical formula}m1∦n(resp. ∦s)m2, when {a mathematical formula}m1⊁n(resp. ⊁s)m2 and {a mathematical formula}m2⊁n(resp. ⊁s)m1. Note that {a mathematical formula}∦s implies {a mathematical formula}∦n.</paragraph></section><section label="2.3"><section-title>LexLeader and its partial versions</section-title><paragraph>The LexLeader method [3] adds constraints for each symmetry to the problem to ensure that only the lexicographically least full assignments among all the symmetric full assignments are allowed. Thus only one full assignment is chosen by LexLeader in each symmetry class. In this way, all symmetries are broken. Given two vectors, {a mathematical formula}x‾=〈x1,…,xn〉 and {a mathematical formula}y‾=〈y1,…,yn〉 of n variables, the lexicographic ordering (lex) constraint, {a mathematical formula}x‾≤lexy‾, ensures that {a mathematical formula}x‾ is lexicographically less than or equal to {a mathematical formula}y‾. Such lexicographic ordering constraint is added for each variable symmetry according to a fixed variable order. Generalized arc consistency on lexicographic ordering between a pair of vectors, denoted as {a mathematical formula}≤lex or {a mathematical formula}≥lex, has been enforced [29]. For matrix symmetries, which are of exponential size, posting a lexicographic ordering constraint for each symmetry is impractical. DoubleLex [4] is a special case of LexLeader which posts constraints under row-wise or column-wise canonical order, to break only adjacent row and column interchangeability generator symmetries. Another partial symmetry breaking method based on LexLeader is SnakeLex [21] which posts lexicographical ordering constraints under snake ordering to break the same subset of symmetries as DoubleLex as well as an extra linear number of row or column symmetries. Allperm [16] is another method to partially break the matrix symmetries by constraining that the first row is less than or equal to all permutations of all other rows.</paragraph></section><section label="2.4"><section-title>Symmetry breaking during search and its variants</section-title><paragraph>Given the set of all symmetries to a CSP, SBDS [7] adds symmetry breaking constraints for each symmetry upon backtracking. Consider a node {a mathematical formula}P0 in the search tree with partial assignment A, branching variable x and value v. After backtracking from the node cons{a mathematical formula}(P0∪{x=v}), for each solution symmetry g, SBDS adds the following symmetry breaking constraint to the node cons{a mathematical formula}(P0∪{x≠v}):{a mathematical formula} meaning that once {a mathematical formula}A∧(x=v) has been searched, its symmetric partial assignments {a mathematical formula}(A∧(x=v))g for any g in the symmetry set under this subtree should not be searched at all. Note that Equation (1) can be simplified to {a mathematical formula}Ag⇒(x≠v)g as A and {a mathematical formula}x≠v must hold in the subtree to be searched. If {a mathematical formula}Ag for symmetry g is satisfied at a node with partial assignment A, we call g an active symmetry at this node; otherwise, it is inactive. If {a mathematical formula}Ag for a symmetry g is false at a search node with partial assignment A, we say g is broken at this node; otherwise, it is non-broken. Note that SBDS does not add symmetry breaking constraints for symmetries that are broken, as the left-hand side of (1) is false already. Partial SBDS (ParSBDS) is SBDS but handles only a given subset of all symmetries, which are usually generator symmetries [4], [9].</paragraph><paragraph>Gent and Smith [7] also propose shortcut SBDS, which reduces overheads by breaking only active symmetries (the symmetric counterpart of the partial assignment at the current node being true) during search and thus adding only unconditional constraints. Similar to shortcut SBDS, Lightweight Dynamic Symmetry Breaking (LDSB) [11], handles only active symmetries and also their compositions. LDSB is restricted to breaking only certain kinds of symmetries, which enjoy a compact representation and efficient processing, but gives little flexibility for users to specify the symmetries to break. It provides a pattern syntax [11] for users to specify symmetries to break, but works best on only symmetries for which these patterns are very compact.</paragraph></section></section><section label="3"><section-title>Partial SBDS and missing pruning opportunities</section-title><paragraph>In partial symmetry breaking using static methods, Lee and Li [12] show that symmetry breaking constraint intended for a particular symmetry always breaks more than just the intended symmetry with a side-effect. This explains the reason why a few static symmetry breaking constraints can sometimes eliminate most if not all symmetries in a problem. We will show partial symmetry breaking using SBDS method (ParSBDS) cannot generate the same side-effect as the static method of Crawford et al. [3].</paragraph><paragraph>In the following, we analyze how LexLeader [3] is stronger in both nodes and solutions pruning than ParSBDS when variable and value orders are fixed and both are given the same subset of symmetries. We use as example the matrix model of the {a mathematical formula}n×n unconstrained matrix problem with domain size d which contains only variables but no constraints. Suppose {a mathematical formula}n=d=2. The symmetries to break are interchangeable rows and columns, which are denoted by R and C respectively.</paragraph><paragraph>Fig. 1 gives the symmetry classes under matrix symmetries of the unconstrained matrix problem with generators {a mathematical formula}{R,C}. Symmetric solutions are connected by lines with horizontal straightline and vertical curved double arrows marked by the corresponding symmetries. There are 7 symmetry classes. Modeling the problem with 4 variables {{a mathematical formula}x11,x12,x21,x22}, one for each square with the domain of each variable being {1, 2}, we can break {a mathematical formula}{R,C} using the LexLeader method [3] by statically adding two constraints{a mathematical formula} to choose the lexicographically least solutions according to the input order ({a mathematical formula}x11,x12, {a mathematical formula}x21,x22).</paragraph><paragraph>Only 7 solutions are left: ①, ②, ④, ⑥, ⑦, ⑧ and ⑯. Solutions ③ and ⑤ are pruned by ②. Solution ⑨ is pruned by ③ and ⑤. Solution ⑩ is pruned by ⑦. Solution ⑪ is pruned by ⑥. Solution ⑬ is pruned by ④. Solutions ⑫ and ⑭ are pruned by ⑧. Solution ⑮ is pruned by ⑫ and ⑭.</paragraph><paragraph>The ParSBDS method leaves 8 solutions: ①, ②, ④, ⑥, ⑦, ⑧, ⑮ and ⑯ by breaking {a mathematical formula}{R,C} with input variable order ({a mathematical formula}x11,x12,x21,x22) and min value heuristic. We show the depth-first search tree in Fig. 2 where each solution leaf node is marked by its solution number. Upon each backtrack, ParSBDS adds a symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g for each non-broken given symmetry g, where A is the partial assignment of the parent node, and x and v are the branching variable and value of the parent node respectively. The constraints are labeled by {an inline-figure}.</paragraph><list><list-item label="•">After backtracking from {a mathematical formula}x22=1 at (a), R and C are broken as {a mathematical formula}x22=1 is false.</list-item><list-item label="•">After backtracking from {a mathematical formula}x21=1 at (b), symmetry R is broken as {a mathematical formula}x21=1 is false. One constraint {a mathematical formula}(x11=1∧x12=1)C⇒(x21≠1)C is added. Solution ③ is pruned.</list-item><list-item label="•">After backtracking from {a mathematical formula}x12=1 at (c), symmetry C is broken as {a mathematical formula}x12=1 is false. One constraint {a mathematical formula}(x11=1)R⇒(x12≠1)R is added. Solution ⑤ is pruned.</list-item><list-item label="•">After backtracking from {a mathematical formula}x21=1 at (d), symmetry R is broken as {a mathematical formula}x21=1 is false. Symmetry C has been broken at (c). No symmetries are left in the subtree.</list-item><list-item label="•">After backtracking from {a mathematical formula}x11=1 at (e), A is empty. Constraints {a mathematical formula}(x11≠1)R and {a mathematical formula}(x11≠1)C are added. Solutions ⑨, ⑩, ⑬ and ⑭ are pruned by the first constraint. Solutions ⑨, ⑩, ⑪ and ⑫ are pruned by the second constraint.</list-item><list-item label="•">After backtracking from {a mathematical formula}x22=1 at (f), two constraints {a mathematical formula}(x11=2∧x12=2∧x21=2)R⇒(x22≠1)R and {a mathematical formula}(x11=2∧x12=2∧x21=2)C⇒(x22≠1)C are added.</list-item></list><paragraph>LexLeader can prune solution ⑮ but ParSBDS cannot. LexLeader prunes ⑮ because ⑮ is lexicographically larger than ⑫ and ⑭. For ParSBDS, after backtracking from {a mathematical formula}x11=1 at (e) in Fig. 2, symmetry breaking constraints prune value 1 from {a mathematical formula}D(x12) and {a mathematical formula}D(x21). Solutions ⑫ and ⑭ are thus pruned. There would not be any more backtrack from these pruned nodes in the subtree of (b). However, ParSBDS is triggered to add symmetry breaking constraints only by backtracking. Thus, no constraints are added to prune ⑮, which is symmetric to ⑧ by simply composing R and C.</paragraph><paragraph>We compare ParSBDS and LexLeader theoretically by considering only symmetries of the form {a mathematical formula}σ∘θ, which are compositions of a variable symmetry σ and a value symmetry θ. Such symmetries {a mathematical formula}σ∘θ are common in practice (variable and value symmetries are special cases) and are bijections on assignments that preserve solutions: if {a mathematical formula}{xi=vi|1≤i≤n} is a solution, then {a mathematical formula}{xσ(i)=θ(vi)|1≤i≤n} is also. Note {a mathematical formula}σ∘θ=θ∘σ. LexLeader breaks value symmetries using the element constraint [30].</paragraph><paragraph>When we compare the pruning power of LexLeader and ParSBDS in the following, we give the set of inverse symmetries to LexLeader of the ones given by ParSBDS. The reason is because LexLeader and ParSBDS are different in how they break symmetries. Consider two solutions {a mathematical formula}s1 and {a mathematical formula}s2 where {a mathematical formula}s2=s1g for a symmetry g. Suppose {a mathematical formula}s1&lt;lexs2, and ParSBDS and LexLeader are used to break g under the static variable ordering used by LexLeader and min value ordering. In this order, {a mathematical formula}s1 is searched before {a mathematical formula}s2. Once {a mathematical formula}s1 is searched, {a mathematical formula}s2 would be pruned by ParSBDS since {a mathematical formula}s2=s1g. However, LexLeader cannot prune {a mathematical formula}s2 since {a mathematical formula}s1&lt;lexs2 satisfies the LexLeader constraint {a mathematical formula}X≤lexXg. If, otherwise, symmetry {a mathematical formula}g−1 is given to LexLeader, the constraint {a mathematical formula}s2≤lexs2g−1 is violated since {a mathematical formula}s1=s2g−1 and {a mathematical formula}s2&gt;lexs1. Thus {a mathematical formula}s2 can be pruned now.</paragraph><paragraph>With a proof technique similar to that by Puget [31] in comparing SBDS and dynamic lex constraints, we give the following theorem.</paragraph><paragraph label="Theorem 1">Suppose G and H are sets of variable and value symmetries so that{a mathematical formula}γ∈G⇔γ−1∈H. LexLeader{a mathematical formula}≻nParSBDS and LexLeader{a mathematical formula}≻sParSBDS by posting G to ParSBDS and breaking H by LexLeader when both search with the same static variable ordering used by LexLeader and min (max) value ordering.</paragraph><paragraph label="Proof">We prove the symmetry breaking constraints added by ParSBDS during search will always be implied by the static symmetry breaking constraints added by LexLeader at the root node. Suppose we are at the node cons{a mathematical formula}(P0∪{xt≠vt}) after assigning {a mathematical formula}t−1 variables and backtracking from a node cons{a mathematical formula}(P0∪{xt=vt}). ParSBDS adds to node cons{a mathematical formula}(P0∪{xt≠vt}) the following symmetry breaking constraints{a mathematical formula} for all {a mathematical formula}γ≡σ∘θ in G where σ is a variable symmetry and θ is a value symmetry. LexLeader (choosing the lexicographically least solution) adds the following constraints{a mathematical formula} at the root node for all {a mathematical formula}γ−1≡σ−1∘θ−1 in H where n is the number of variables. Each of these constraints implies the following n constraints{a mathematical formula} where {a mathematical formula}k∈{1,…,n}. The tth constraint in the above n constraints can be rewritten as{a mathematical formula} at node cons{a mathematical formula}(P0∪{xt≠vt}). With min value ordering, {a mathematical formula}xt&gt;vt at node cons{a mathematical formula}(P0∪{xt≠vt}). Therefore, combining (5) and {a mathematical formula}xt&gt;vt, we have:{a mathematical formula} which can be rewritten as{a mathematical formula} It is straightforward to derive that (7) implies (2). Thus LexLeader implies (7) and also (2). In other words, the symmetry breaking constraints added by ParSBDS during search will always be implied by the static constraints added by LexLeader at the root node.Now we show LexLeader can prune more nodes and solutions than ParSBDS. Consider the unconstrained matrix problem in the above. Given only two generators {a mathematical formula}{R,C} where {a mathematical formula}R−1=R and {a mathematical formula}C−1=C, LexLeader has 13 nodes and leaves 7 solutions while ParSBDS has 15 nodes and leaves 8 solutions. Therefore LexLeader {a mathematical formula}≻n ParSBDS and LexLeader {a mathematical formula}≻s ParSBDS. □</paragraph></section><section label="4"><section-title>Enhancing partial SBDS</section-title><paragraph>In order to circumvent the pitfalls of ParSBDS, we propose Recursive SBDS, which adds extra constraints that are easy to derive, inexpensive to compute and can break many of the composition symmetries. After that, we propose a lightweight version of ReSBDS to further reduce the overhead. Formal characterizations and properties of these two methods, and comparisons with other state of the art methods are given in the form of theorems. Experimental results show our methods can strike good balances between the number of symmetry breaking constraints to add and the extra prunings induced.</paragraph><section label="4.1"><section-title>Recursive SBDS</section-title><paragraph>Consider the unconstrained matrix problem in Fig. 2 again. Given the generators {{a mathematical formula}R,C}, ParSBDS will add at most two symmetry breaking constraints in each backtrack. After backtracking from {a mathematical formula}x11=1 at (e), as A is empty, both symmetries are intact. ParSBDS adds {a mathematical formula}x12≠1 and {a mathematical formula}x21≠1. After 1 is pruned from {a mathematical formula}D(x12), symmetric nodes {a mathematical formula}P0 containing partial assignment {a mathematical formula}x12=1 are thus pruned in the subtree. Why should we not also prune {a mathematical formula}P0's symmetric nodes? Adding {a mathematical formula}(x12≠1)R, we get {a mathematical formula}x22≠1. Solution ⑮ is pruned. Thus symmetry {a mathematical formula}C∘R is eliminated by adding this extra constraint.</paragraph><paragraph>Given a set of symmetries, breaking the potentially exponential number of all symmetry compositions is expensive in general. An important observation from the last example is that some such compositions can be easy to identify and break. Generalizing from the example, we give Recursive SBDS (ReSBDS) as follows.</paragraph><list><list-item label="1.">Given the input symmetries G. Upon each backtrack, ReSBDS adds symmetry breaking constraints added by ParSBDS.</list-item><list-item label="2.">ReSBDS maintains a backtrackable set T of assignments, which is initially empty at the root node. Whenever ReSBDS adds a symmetry breaking constraint, {a mathematical formula}Ag⇒(x≠v)g (where {a mathematical formula}g∈G), we add the following into T:</list-item><list-item label="3.">After constraint propagation at every node {a mathematical formula}P0 with partial assignment E during search, ReSBDS performs:</list-item></list><paragraph> Since T is backtrackable, when the search backtracks, modifications to T must be undone.</paragraph><paragraph>Similar to ParSBDS, ReSBDS also does not add symmetry breaking constraints for symmetries that are broken. Moreover, if {a mathematical formula}v∉D(x), the assignment {a mathematical formula}x=v would never be violated in subsequent search and thus does not need to be recorded into T. Note also that T is a set. This means if an assignment {a mathematical formula}x=v has already been recorded in T, we do not need to record it again in subsequent search.</paragraph><paragraph>We show the depth-first search tree of the {a mathematical formula}2×2 unconstrained matrix problem with domain size 2 in Fig. 3 which utilizes the above ReSBDS method to break the two generators R and C. Upon each backtrack, ReSBDS adds a symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g for each non-broken given symmetry g, where A is the partial assignment of the parent node, and x and v are the branching variable and value of the parent node respectively. This kind of constraints are also added by ParSBDS and are labeled by {an inline-figure} in Fig. 3. Once an assignment {a mathematical formula}xi=vi in T is violated at a node P, ReSBDS adds a symmetry breaking constraint {a mathematical formula}Eh⇒(xi≠vi)h for each non-broken given symmetry h, where E is the partial assignment of P. This kind of constraints are additional constraints added at Step 3 and are indicated by ◇ in Fig. 3.</paragraph><list><list-item label="•">After backtracking from {a mathematical formula}x22=1 at (a), R and C are broken as {a mathematical formula}x22=1 is false. {a mathematical formula}T=∅.</list-item><list-item label="•">After backtracking from {a mathematical formula}x21=1 at (b), symmetry R is broken as {a mathematical formula}x21=1 is false. One constraint {a mathematical formula}(x11=1∧x12=1)C⇒(x21≠1)C is added. This constraint is simplified to {a mathematical formula}x22≠1 after doing symmetry computations. ReSBDS records {a mathematical formula}x22=1 into T. {a mathematical formula}T={x22=1}. After constraint propagation, 1 is immediately pruned from {a mathematical formula}D(x22) and solution ③ is pruned. Assignment {a mathematical formula}x22=1 is violated now and is deleted from T. Extra constraints can be added according to this violation. Since symmetry R is broken, constraint {a mathematical formula}(x11=1∧x12=1)C⇒(x22≠1)C is added. This constraint is simplified to {a mathematical formula}x21≠1 after doing symmetry computations. Assignment {a mathematical formula}x21=1 has been violated since (b) backtracks from {a mathematical formula}x21=1. No assignments are put into T. {a mathematical formula}T=∅. And no further pruning occurs.</list-item><list-item label="•">After backtracking from {a mathematical formula}x12=1 at (c), symmetry C is broken as {a mathematical formula}x12=1 is false. One constraint {a mathematical formula}(x11=1)R⇒(x12≠1)R is added. This constraint is simplified to {a mathematical formula}(x21=1)⇒(x22≠1) after doing symmetry computations. ReSBDS records {a mathematical formula}x21=1 and {a mathematical formula}x22=1 into T. {a mathematical formula}T={x21=1,x22=1}.</list-item><list-item label="•">After branching with {a mathematical formula}x21=1 at (d), propagation of the symmetry breaking constraint {a mathematical formula}(x21=1)⇒(x22≠1) prunes 1 from {a mathematical formula}D(x22) and prunes solution ⑤ in subsequent search. Assignment {a mathematical formula}x22=1 is violated. Now {a mathematical formula}T={x21=1} after deleting {a mathematical formula}x22=1 from T. Extra constraints can be added. Since symmetry C has been broken, constraint {a mathematical formula}(x11=1∧x21=1)R⇒(x22≠1)R is added. This constraint is simplified to {a mathematical formula}x12≠1 after doing symmetry computations. Assignment {a mathematical formula}x12=1 has been violated since its parent node backtracks from {a mathematical formula}x12=1 at (c). No assignments are put into T. And no more prunings take place.</list-item><list-item label="•">After backtracking from {a mathematical formula}x21=1 at (e), symmetry R is broken as {a mathematical formula}x21=1 is false. Symmetry C has been broken at (c). No symmetries are left in the subtree. Moreover, symmetry breaking constraint {a mathematical formula}(x21=1)⇒(x22≠1) is satisfied as {a mathematical formula}x21≠1. Assignment {a mathematical formula}x21=1 in T is violated. However, both generator symmetries are broken, thus no extra symmetry breaking constraints are added.</list-item><list-item label="•">After backtracking from {a mathematical formula}x22=1 at (f), symmetries R and C have been broken at (e). Assignment {a mathematical formula}x22=1 in T is violated. However, both generator symmetries are broken, no symmetry breaking constraints are added. {a mathematical formula}T=∅.</list-item><list-item label="•">After backtracking from {a mathematical formula}x11=1 at (g), A is empty. Constraints {a mathematical formula}(x11≠1)R and {a mathematical formula}(x11≠1)C are added. These constraints are {a mathematical formula}x21≠1 and {a mathematical formula}x12≠1 after doing symmetry computations. ReSBDS records {a mathematical formula}x21=1 and {a mathematical formula}x12=1 into T. {a mathematical formula}T={x21=1,x12=1}. After constraint propagation, 1 is immediately pruned from {a mathematical formula}D(x21) and {a mathematical formula}D(x12). Solutions ⑨, ⑩, ⑪, ⑫, ⑬ and ⑭ are pruned. Assignments {a mathematical formula}x21=1 and {a mathematical formula}x12=1 are violated and are deleted from T. Constraints {a mathematical formula}(x21≠1)R, {a mathematical formula}(x21≠1)C, {a mathematical formula}(x12≠1)R and {a mathematical formula}(x12≠1)C are added. They are {a mathematical formula}x11≠1, {a mathematical formula}x22≠1, {a mathematical formula}x22≠1 and {a mathematical formula}x11≠1 after doing symmetry computations respectively. Only assignment {a mathematical formula}x22=1 is not violated yet and is put into T. Constraint propagation immediately prunes 1 from {a mathematical formula}D(x22) and prunes solution ⑮. Assignment {a mathematical formula}x22=1 is violated and is deleted from T. Two constraints {a mathematical formula}(x22≠1)R and {a mathematical formula}(x22≠1)C are added. No values can be further pruned. {a mathematical formula}T=∅.</list-item></list><paragraph>We elaborate the meaning of T briefly in the following. There are two different reasons for ReSBDS to add a symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g for some {a mathematical formula}g∈G at a node P. First, ReSBDS follows ParSBDS to add a symmetry breaking constraint upon backtracking ({an inline-figure} in Fig. 3). Second, P has partial assignment A with v being pruned from {a mathematical formula}D(x) by constraint propagation (◇ in Fig. 3). ReSBDS needs to detect when exactly the intended symmetric nodes to prune for an added symmetry breaking constraint are actually pruned. To achieve this, we record in T all the assignments whose violations can indicate that {a mathematical formula}Ag⇒(x≠v)g is already satisfied, in which case all nodes containing the partial assignments {a mathematical formula}Ag∧(x=v)g under the subtree of P are pruned.</paragraph><paragraph>At every node after constraint propagation, Step 3 of ReSBDS checks T to see if any stored assignment is violated. Suppose assignment {a mathematical formula}xi=vi is added to T at {a mathematical formula}P0 because of the posted symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g. Suppose further a descendant node {a mathematical formula}P1 of {a mathematical formula}P0 has partial assignment E with {a mathematical formula}vi being pruned from {a mathematical formula}D(xi) and {a mathematical formula}(xi=vi)∈T. It means that every node {a mathematical formula}Ps in the subtree of {a mathematical formula}P1 containing partial assignments {a mathematical formula}E∧(xi=vi) are pruned. ReSBDS adds additional constraints {a mathematical formula}Eh⇒(xi≠vi)h for all non-broken given symmetries h. Suppose {a mathematical formula}Ps is associated with the partial assignment {a mathematical formula}As. Consider all assignments {a mathematical formula}xj=vj (which can be none) in {a mathematical formula}Ag∧(x=v)g but not in {a mathematical formula}E∧(xi=vi). If all such assignments are true in {a mathematical formula}As, {a mathematical formula}Ps is a symmetric node of a previously visited or pruned node w.r.t. g, which is intended to be pruned by {a mathematical formula}Ag⇒(x≠v)g. Posting {a mathematical formula}Eh⇒(xi=vi)h can potentially break {a mathematical formula}g∘h (when this constraint has pruned a solution) for all {a mathematical formula}h∈G. Otherwise, {a mathematical formula}Ps is just an ordinary pruned node. Posting {a mathematical formula}Eh⇒(xi=vi)h to prune the symmetric nodes of such ordinary pruned nodes is sound but not useful for breaking compositions. Consider constraints added at {an inline-figure} in Fig. 3. All {a mathematical formula}Ps containing {a mathematical formula}x21=1 or {a mathematical formula}x12=1 are pruned under (g) after doing constraint propagation. Each {a mathematical formula}Ps is symmetric to a previously visited node according to R or C. ReSBDS adds constraints at {an inline-figure} in Fig. 3. These constraints break the generator symmetric nodes of all {a mathematical formula}Ps. While each {a mathematical formula}Ps is also generator symmetric to a visited node, composition symmetries are broken. Constraints at {an inline-figure} break {a mathematical formula}R∘C (and {a mathematical formula}C∘R) as they prune solution ⑮.</paragraph><paragraph>ReSBDS, however, might have useless recordings which cannot help to break composition symmetries. We will elaborate and propose a light version of ReSBDS to avoid such useless recordings in the next section.</paragraph><paragraph>Given a CSP {a mathematical formula}P=(X,D,C). We present the ReSBDS algorithm with given symmetries G in the following.{sup:1}</paragraph><paragraph>We show how to implement ReSBDS in a depth first search solver in Algorithm 1. To add the symmetry breaking constraint, we need to know the current partial assignment, which is recorded in E. T is the backtrackable set that is maintained by ReSBDS while VT records the set of violated assignments in T after constraint propagation at a search node.</paragraph><paragraph>Algorithm 1 shows the branching algorithm, i.e. how to branch at a search node. Choice() creates a choice according to the current node which is used to decide the branching variable and value, and whether to branch to its left or right child. If {a mathematical formula}b=0 (line 2), the node branches to the left child with {a mathematical formula}x=v (line 3) and E is updated (line 4); otherwise, it signifies a backtrack: search is branched to the right child with {a mathematical formula}x≠v (line 6) and symmetry breaking constraints are added by calling AddCon() (line 7). All the assignments in the added constraints are also recorded in T by AddCon() (line 7). After enforcing GAC to each constraint in the constraint store using EnforceConsistency(), we need to check whether some recorded assignments in T are violated or not by calling CheckT() (line 10), where the violated assignments are recorded into VT (line 10). While there are violations (line 11), we add symmetry breaking constraints according to the current E and G for each of the violated assignments (lines 12–14). We need to do consistency enforcement (line 15), check violations (line 16), and add symmetry breaking constraints (lines 12–14) until there are no more violations (line 11).</paragraph><paragraph>Algorithm 2 shows how to add symmetry breaking constraints according to the symmetries in G, current partial assignment E and the branching assignment (from which the backtrack happens) or violated assignment {a mathematical formula}x=v. For each of the non-broken symmetries in G, one symmetry breaking constraint is added (line 2). We record in T all assignments in these symmetry breaking constraints that are not violated and have not been recorded into T (lines 3–7) yet.</paragraph><paragraph>Algorithm 3 checks whether some assignments recorded in T are violated. If an assignment is violated (line 3), we record this assignment into VT and delete this assignment from T (lines 4–5). Such an assignment will never be recorded into T again in subsequent search.</paragraph><paragraph>Similar to the implementation of SBDS [7], ReSBDS does not add symmetry breaking constraints for broken symmetries and a boolean variable {a mathematical formula}bhP is also constructed for each symmetry {a mathematical formula}h∈G at each node P representing whether {a mathematical formula}Eh is satisfied or not where E is the partial assignment of P. Along branching, {a mathematical formula}bhP is incrementally computed in the following way. Suppose P is branched to {a mathematical formula}P′ with branching assignment {a mathematical formula}x=v. The partial assignment {a mathematical formula}E′ of {a mathematical formula}P′ is extended to {a mathematical formula}E′≡(E∧(x=v)). Now the value of {a mathematical formula}bhP′ for symmetry {a mathematical formula}h∈G at {a mathematical formula}P′ is the conjunction of the satisfaction of {a mathematical formula}Eh and {a mathematical formula}(x=v)h, i.e. {a mathematical formula}bhP∧(x=v)h. Hence, we can compute the symmetric partial assignment of the current partial assignment incrementally for each symmetry during search. A further advantage of these boolean variables is that when a {a mathematical formula}bhP is proven to be false at P, its corresponding symmetry is broken at P as well as under the subtree of P.</paragraph><paragraph>Now we give theorems on the termination, space and time complexity of Algorithm 1.</paragraph><paragraph label="Proof">Algorithm 1always terminates.The number of all possible assignments is limited. Once an assignment is recorded into VT, it would be removed from T (line 5 of Algorithm 3) and never recorded back to T due to the condition in line 4 of Algorithm 2. Thus the while loop (lines 11–17) of Algorithm 1 always terminates. □</paragraph><paragraph label="Proof">Given a CSP{a mathematical formula}P=(X,D,C)with{a mathematical formula}|X|=n. The maximum size of T is{a mathematical formula}∑i=0n−1|D(xi)|.The maximum size of T is {a mathematical formula}∑i=0n−1|D(xi)|, which is the number of all possible assignments for the CSP P. □</paragraph><paragraph label="Proof">Given a subset of symmetries G and a CSP{a mathematical formula}P=(X,D,C)with{a mathematical formula}|X|=n. The time complexity ofAlgorithm 1is{a mathematical formula}O(∑i=0n−1|D(xi)|(n|G|+∑i=0n−1|D(xi)|/2)).The time complexity of Algorithm 2 and Algorithm 3 are {a mathematical formula}O(|G||X|) and {a mathematical formula}O(|T|) respectively. The worst time complexity of Algorithm 1 happens when {a mathematical formula}|VT|=1 after calling Algorithm 3 every time until T is empty. Thus the total time complexity is {a mathematical formula}O(|T‖G‖X|+|T|2/2). While T has the maximum size {a mathematical formula}∑i=0n−1|D(xi)| and {a mathematical formula}|X|=n, the time complexity of Algorithm 1 is {a mathematical formula}O(∑i=0n−1|D(xi)|(n|G|+(∑i=0n−1|D(xi)|)/2)). □</paragraph></section><section label="4.2"><section-title>Light ReSBDS</section-title><paragraph>Domain filtering prunes values by an AC3-like [1] constraint propagation mechanism. If a value v is pruned from the domain of a variable during the propagation of a constraint c, we say this pruning is effected by constraint c.</paragraph><paragraph>The ReSBDS method utilizes a backtrackable set T to record useful assignments which might be violated in the future. Suppose {a mathematical formula}xi=vi is recorded in T since the constraint {a mathematical formula}Ag⇒(x≠v)g is added at node {a mathematical formula}P0. Suppose further this assignment is violated at a descendant node {a mathematical formula}P1, i.e. {a mathematical formula}vi is pruned from {a mathematical formula}D(xi). The pruning indicates that {a mathematical formula}Ag⇒(x≠v)g is already satisfied. This pruning is effected either by a problem constraint or a symmetry breaking constraint. The latter case has the following feature.</paragraph><paragraph label="Lemma 1">Given a set of symmetries G. If, using the ReSBDS method, value{a mathematical formula}viis pruned from{a mathematical formula}D(xi)at node{a mathematical formula}P1effected by a symmetry breaking constraint,{a mathematical formula}xi=vimust have been recorded into T at node{a mathematical formula}P1.</paragraph><paragraph label="Proof">Given any symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g added by ReSBDS, ReSBDS records all assignments in {a mathematical formula}Ag∧(x=v)g. If {a mathematical formula}vi is pruned from {a mathematical formula}D(xi) at node {a mathematical formula}P1 and is effected by a symmetry breaking constraint {a mathematical formula}c≡Ag⇒(x≠v)g, {a mathematical formula}xi=vi must be in {a mathematical formula}Ag∧(x=v)g. Thus {a mathematical formula}xi=vi must have been recorded into T at {a mathematical formula}P1. □</paragraph><paragraph>ReSBDS has the opportunity to record assignments whose violations generate extra constraints but cannot help to prune composition symmetries. Suppose a symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g is added at node {a mathematical formula}P0 and {a mathematical formula}xi=vi and {a mathematical formula}xj=vj are two of its assignments. ReSBDS records both {a mathematical formula}xi=vi and {a mathematical formula}xj=vj into T and generates symmetry breaking constraints once they are violated in subsequent search. Suppose {a mathematical formula}xi=vi is violated at a descendant node {a mathematical formula}P1 of {a mathematical formula}P0 and {a mathematical formula}xj=vj is violated at a descendant node {a mathematical formula}P2 of {a mathematical formula}P1. The symmetry breaking constraints added at {a mathematical formula}P1 due to the violation of {a mathematical formula}xi=vi prune all symmetric nodes of nodes (if any) containing {a mathematical formula}Ag∧(x=v)g and in the subtree of {a mathematical formula}P1. The violation of {a mathematical formula}xj=vj in {a mathematical formula}P2 which is a descendant node of {a mathematical formula}P1 thus cannot prune any symmetric nodes of nodes containing {a mathematical formula}Ag∧(x=v)g and in the subtree of {a mathematical formula}P2. Constraints added due to the violation of {a mathematical formula}xj=vj in {a mathematical formula}P2 is therefore useless to prune composition symmetries.</paragraph><paragraph>We would like to propose an adaptation of ReSBDS where extra symmetry breaking constraints are generated due to the violation of at most one assignment in each symmetry breaking constraint. Lemma 1 gives us some hints on a light ReSBDS method (LReSBDS) by considering only the assignments violated by the propagation of symmetry breaking constraints. In this way, we only need to add extra symmetry breaking constraints when a pruning is effected by a symmetry breaking constraint. T is not needed anymore and time is saved since there is no need to record assignments and check violations. Moreover, this ensures at most one assignment in each symmetry breaking constraint is used to generate extra symmetry breaking constraints.</paragraph><paragraph>The LReSBDS method is given as follows.</paragraph><list><list-item label="1.">Given the input symmetries G. Upon each backtrack, LReSBDS adds symmetry breaking constraints added by ParSBDS.</list-item><list-item label="2.">After constraint propagation at every node {a mathematical formula}P0 with partial assignment A during search, LReSBDS performs:</list-item></list><paragraph>The depth-first search tree of the {a mathematical formula}2×2 unconstrained matrix problem with domain size 2 is exactly the same as the one in Fig. 3 after utilizing the LReSBDS method to break the two generators R and C. Upon each backtrack, LReSBDS adds a symmetry breaking constraint {a mathematical formula}Ag⇒(x≠v)g for each non-broken given symmetry g, where A is the partial assignment of the parent node, and x and v are the branching variable and value of the parent node respectively. This kind of constraints are also added by ParSBDS and are labeled by {an inline-figure} in Fig. 3. Once a symmetry breaking constraint prunes a value {a mathematical formula}vi from {a mathematical formula}D(xi) at a node P, LReSBDS adds a symmetry breaking constraint {a mathematical formula}Eh⇒(xi≠vi)h for each non-broken given symmetry h, where E is the partial assignment of P. This kind of constraints are additional constraints added at Step 2 and are indicated by ◇ in Fig. 3.</paragraph><paragraph>The reason that ReSBDS and LReSBDS have the same search tree for the above example is that there are no problem constraints. Thus the prunings of all violated assignments in T that can add extra constraints are effected only by the symmetry breaking constraints when using ReSBDS. Combining Lemma 1 and the fact that LReSBDS only adds extra constraints according to the prunings effected by the symmetry breaking constraints, we introduce the following lemma.</paragraph><paragraph label="Lemma 2">Given the same set of symmetries to ReSBDS and LReSBDS. Suppose both use the same variable and value orderings. If the prunings of all violated assignments in T are effected by the symmetry breaking constraints when using ReSBDS, ReSBDS{a mathematical formula}=nLReSBDS and ReSBDS{a mathematical formula}=sLReSBDS.</paragraph><paragraph>What about the cases when the conditions of Lemma 2 are not satisfied? Consider the ECCLD problems in Section 5.1.4. Given the same set of interchangeability of adjacent rows (columns) and using the same input variable ordering and minimum value ordering heuristic, LReSBDS and ReSBDS result in search trees of different sizes, 3648007 nodes and 3648003 nodes respectively, for the instance (6, 8, 4). In Section 4.3, we give formal characterizations and comparisons of the node and solution pruning powers of LReSBDS and ReSBDS in the general case.</paragraph><paragraph>Similar with ReSBDS, there are two different reasons for LReSBDS to add a symmetry breaking constraint. First, LReSBDS follows ParSBDS to add a symmetry breaking constraint upon backtracking. Second, an assignment is violated due to the pruning effected by a symmetry breaking constraint (rather than any constraint in ReSBDS). Now we do not need extra effort to detect when exactly the intended assignment are actually pruned. We can “hack” into the propagation algorithm so that once a value is pruned by the symmetry breaking constraint, extra constraints are added.</paragraph><paragraph>Given a CSP {a mathematical formula}P=(X,D,C). We present the LReSBDS algorithm with given symmetries G in the following.{sup:2}</paragraph><paragraph>We show how to implement LReSBDS with the depth first search engine. Algorithm 4 shows the branching algorithm, i.e. how to branch at a search node. Choice() has the same functionality as in Algorithm 1. Here we do not need backtrackable sets T and VT. When branching to the left, E needs to be updated (line 4). Otherwise, symmetry breaking constraints are added by calling AddConL() upon backtracking (line 7).</paragraph><paragraph>Algorithm 5 shows how to add symmetry breaking constraints according to the given symmetries G, current partial assignment E and the branching assignment {a mathematical formula}x=v where backtrack happens or violated assignment {a mathematical formula}x=v. For each of the non-broken symmetry in G, one symmetry breaking constraint is added (line 2).</paragraph><paragraph>Once a constraint is added to the constraint store or some form of consistency is enforced at a search node, Algorithm 6, an AC3-like constraint propagation algorithm, would be called to trigger propagators of all constraints in the constraint store. In this algorithm, a constraint c would be chosen from the constraint store (line 3) and deleted from Q (line 4). After that, we call its propagator (line 5). If its propagator can prune some values (line 5), all other constraints that have been deleted from Q but have the same variable in their scope with that in c would be added back to Q (line 6). The while-loop would trigger all constraints in Q until Q is empty (line 2).</paragraph><paragraph>Algorithm 7 shows the constraint propagation algorithm of all symmetry breaking constraints added by LReSBDS which is in the form {a mathematical formula}A⇒(x≠v). Values are pruned when all assignments except {a mathematical formula}xi=vi in the assignment set {a mathematical formula}A∧(x=v) are true (line 1). Now {a mathematical formula}xi=vi is enforced to be false (line 2). Additional symmetry breaking constraints are added according to this pruning (line 3). And these symmetry breaking constraints' propagation is also done by Algorithm 7. Hence the recursive addition of constraints is done by the propagation mechanism which stops propagation only when every variable's domain does not change and no extra constraints are added then.</paragraph><paragraph>Similar to the implementation of SBDS and ReSBDS, LReSBDS does not add symmetry breaking constraints for broken symmetries and also a boolean variable is constructed for each symmetry {a mathematical formula}h∈G at each node P representing whether {a mathematical formula}Eh is satisfied or not where E is the partial assignment of P. Along branching, {a mathematical formula}bhP is incrementally computed in the similar way of that in ReSBDS.</paragraph><paragraph>We give theorems on the termination of Step 2.</paragraph><paragraph label="Theorem 5">Step 2 of LReSBDS always terminates.</paragraph><paragraph label="Proof">The number of all possible assignments is limited. Once a value is pruned from its variable's domain, this value never be pruned from its variable's domain again in subsequent constraint propagation. Thus the recursive addition of constraints will always terminate. □</paragraph></section><section label="4.3"><section-title>Theoretical results</section-title><paragraph>In this section, we give theorems on the properties of ReSBDS and LReSBDS in addition to comparing the pruning power of ReSBDS and LReSBDS as well as against other state of the art methods.</paragraph><paragraph label="Proof">Similar to ReSBDS, the extra symmetry breaking constraints added by LReSBDS are used only to prune the symmetric equivalent subtrees of pruned subtrees which either contain no solutions or solutions symmetric to the leftmost solution discovered earlier. The result for LReSBDS follows directly. □</paragraph><paragraph>In ParSBDS, the symmetry breaking constraints added at a descendant node are implied by the constraints added upon backtracking from its ancestor node. Consider the depth-first search tree in Fig. 2 again. The symmetry breaking constraint added by ParSBDS at node (c) does not need to be added upon backtracking to node (e) since the left-hand side of the constraint {a mathematical formula}(x11=1)R⇒(x12≠1)R is implied by the symmetry breaking constraint {a mathematical formula}(x11≠1)R posted at (e). Thus all the symmetry breaking constraints added by ParSBDS at a search node {a mathematical formula}P0 only need to be posted locally to the subtree of {a mathematical formula}P0 which means that they are removed from the constraint store upon backtracking from an ancestor node of {a mathematical formula}P0. This property also holds in ReSBDS and LReSBDS.</paragraph><paragraph label="Proof">Given a set of symmetries G. Suppose{a mathematical formula}P0is an ancestor node of{a mathematical formula}P1. The symmetry breaking constraints generated by ReSBDS/LReSBDS at node{a mathematical formula}P1are implied by the constraints generated by ReSBDS upon backtracking from{a mathematical formula}P0.There are two kinds of constraints added by ReSBDS at node {a mathematical formula}P1.<list>{a mathematical formula}P1 is backtracking from a node and symmetry breaking constraints are thus added. For the same reason that ParSBDS posts constraints locally, these symmetry breaking constraints are implied by the constraints added upon backtracking from {a mathematical formula}P0.A recorded assignment {a mathematical formula}xi=vi is violated at node {a mathematical formula}P1 with the current partial assignment {a mathematical formula}E1. Constraints {a mathematical formula}E1h⇒(xi≠vi)h for all {a mathematical formula}h∈G are added at {a mathematical formula}P1. Suppose {a mathematical formula}P0 has current partial assignment {a mathematical formula}E0 and {a mathematical formula}P2 backtracks from {a mathematical formula}P0. The constraints {a mathematical formula}¬E0h for all {a mathematical formula}h∈G are thus added upon backtracking from {a mathematical formula}P0 at {a mathematical formula}P2. While {a mathematical formula}E0⊆E1, {a mathematical formula}E0h⊆E1h for all {a mathematical formula}h∈G. Thus {a mathematical formula}¬E0h implies {a mathematical formula}¬E1h and also implies {a mathematical formula}E1h⇒(xi≠vi)h.Similarly, LReSBDS adds two kinds of constraints at node </list><paragraph>{a mathematical formula}P1. The first one is the same with that of ReSBDS. The second kind of constraint is added when a value {a mathematical formula}vi is pruned from {a mathematical formula}D(xi) which is effected by a symmetry breaking constraint at node {a mathematical formula}P1 with the current partial assignment {a mathematical formula}E1. Constraints {a mathematical formula}E1h⇒(xi≠vi)h for all {a mathematical formula}h∈G are added at {a mathematical formula}P1. Suppose {a mathematical formula}P0 has current partial assignment {a mathematical formula}E0 and {a mathematical formula}P2 backtracks from {a mathematical formula}P0. The constraints {a mathematical formula}¬E0h for all {a mathematical formula}h∈G are thus added upon backtracking from {a mathematical formula}P0 at {a mathematical formula}P2. While {a mathematical formula}E0⊆E1, {a mathematical formula}E0h⊆E1h for all {a mathematical formula}h∈G. Thus {a mathematical formula}¬E0h implies {a mathematical formula}¬E1h and also implies {a mathematical formula}E1h⇒(xi≠vi)h. Therefore, the symmetry breaking constraints added by LReSBDS at node {a mathematical formula}P1 are implied by the constraints added by LReSBDS upon backtracking from {a mathematical formula}P0. □</paragraph></paragraph><paragraph>The above theorem shows the symmetry breaking constraints added by ReSBDS and LReSBDS only need to be posted locally to the subtree of the node where they are generated.</paragraph><paragraph>We give theorems to compare the pruning power of LReSBDS with ReSBDS.</paragraph><paragraph label="Proof">Given a CSP with only variables, domains but no problem constraints and a subset of symmetries G. ReSBDS{a mathematical formula}=nLReSBDS when both use the same static variable and value orderings and given the same set of symmetries.Since there are no problem constraints, the prunings of all violated assignments in T are effected by the symmetry breaking constraints when using ReSBDS. The result follows directly from Lemma 2. □</paragraph><paragraph label="Theorem 9">When there are problem constraints, things can get complicated. We have symmetry breaking constraints added by ReSBDS but not by LReSBDS when the violation of a recorded assignment in T is effected by a problem constraint. However, LReSBDS without these symmetry breaking constraints can have more backtracks and results in more symmetry breaking constraints being added. Thus their node pruning powers are incomparable in general. Given the same set of symmetries. ReSBDS{a mathematical formula}∦nLReSBDS when both use the same static variable and value orderings.</paragraph><paragraph label="Proof">Thus, the node pruning powers of ReSBDS and LReSBDS are incomparable in general. □</paragraph><paragraph>According to our empirical results (to be reported below), ReSBDS always prunes more than LReSBDS. However, their solution pruning powers remain the same.</paragraph><paragraph label="Proof">ReSBDS{a mathematical formula}=sLReSBDS when given the same set of symmetries and both use the same static variable and value orderings.Suppose {a mathematical formula}CR and {a mathematical formula}CL are the sets of all symmetry breaking constraints added by ReSBDS and LReSBDS respectively. We prove that each constraint that can prune solutions in {a mathematical formula}CL are also in {a mathematical formula}CR or implied by the constraints in {a mathematical formula}CR. Consider the resulting search trees {a mathematical formula}ϒR of ReSBDS and {a mathematical formula}ϒL of LReSBDS. There are three cases to consider.</paragraph><list><list-item label="1.">LReSBDS adds a constraint {a mathematical formula}c0∈CL at node {a mathematical formula}P0 in {a mathematical formula}ϒL due to a backtrack from node {a mathematical formula}P1 and symmetry g, and {a mathematical formula}P1 is pruned in {a mathematical formula}ϒR. Suppose the parent node of {a mathematical formula}P0 and {a mathematical formula}P1 is P in {a mathematical formula}ϒL. Thus {a mathematical formula}P0 is merged with P in {a mathematical formula}ϒR. Constraint {a mathematical formula}c0 in {a mathematical formula}ϒL can prune solutions only if {a mathematical formula}P1 has solutions in its subtree. Thus {a mathematical formula}P1 must be pruned by the symmetry breaking constraints added by ReSBDS. An assignment {a mathematical formula}xi=vi in {a mathematical formula}P1 must have been recorded into T and violates at node P or its ancestor node. Assume this violation results constraint {a mathematical formula}c′ being added by ReSBDS according to symmetry g. If the violation occurs at an ancestor node of P in {a mathematical formula}ϒR, {a mathematical formula}c′ implies {a mathematical formula}c0. Otherwise, {a mathematical formula}c′=c0.</list-item><list-item label="2.">LReSBDS adds a constraint {a mathematical formula}c0∈CL at node {a mathematical formula}P0 in {a mathematical formula}ϒL due to a backtrack from node {a mathematical formula}P1 and symmetry g, and {a mathematical formula}P1 is not pruned in {a mathematical formula}ϒR. If {a mathematical formula}P0 is pruned in {a mathematical formula}ϒR, since {a mathematical formula}c0 is posted locally to the subtree of {a mathematical formula}P0, {a mathematical formula}c0 cannot prune more nodes than ReSBDS. Otherwise, {a mathematical formula}c0 is added by ReSBDS at node {a mathematical formula}P0.</list-item><list-item label="3.">LReSBDS adds a constraint {a mathematical formula}c1∈CL at node {a mathematical formula}P1 in {a mathematical formula}ϒL because the propagation of a symmetry breaking constraint on symmetry g prunes value {a mathematical formula}vi from {a mathematical formula}D(xi) at {a mathematical formula}P1. If {a mathematical formula}P1 is pruned in {a mathematical formula}ϒR, {a mathematical formula}c1 cannot prune more nodes than ReSBDS. Otherwise, assignment {a mathematical formula}xi=vi must have been recorded into T and violates at node {a mathematical formula}P1 or its ancestor node. Assume this violation results constraint {a mathematical formula}c′ being added by ReSBDS according to symmetry g. If the violation occurs at an ancestor node of {a mathematical formula}P1 in {a mathematical formula}ϒR, {a mathematical formula}c′ implies {a mathematical formula}c1. Otherwise, {a mathematical formula}c′=c1.</list-item></list><paragraph>We give theorems to compare the pruning power of ReSBDS and LReSBDS with the variants of LexLeader and SBDS methods.</paragraph><paragraph label="Proof">Given a CSP with only variables, domains but no problem constraints and a subset of symmetries G. ReSBDS{a mathematical formula}≻nParSBDS and LReSBDS{a mathematical formula}≻nParSBDS when all use the same static variable and value orderings and given the same set of symmetries.Suppose {a mathematical formula}CP and {a mathematical formula}CR are the sets of all symmetry breaking constraints added by ParSBDS and ReSBDS respectively. We prove that each constraint in {a mathematical formula}CP are also in {a mathematical formula}CR or implied by the constraints in {a mathematical formula}CR. Consider the resulting search trees {a mathematical formula}ϒP of ParSBDS and {a mathematical formula}ϒR of ReSBDS. Suppose a constraint {a mathematical formula}c∈CP is added at a node {a mathematical formula}P0 by ParSBDS in {a mathematical formula}ϒP due to the backtracking from node {a mathematical formula}P1.<list>If {a mathematical formula}P0 and {a mathematical formula}P1 are both in {a mathematical formula}ϒR, c is also added by ReSBDS and in {a mathematical formula}CR.If {a mathematical formula}P0 is in {a mathematical formula}ϒR but {a mathematical formula}P1 is not, {a mathematical formula}P1 must have been pruned at an ancestor node of {a mathematical formula}P0 in {a mathematical formula}ϒR. It must be pruned due to the extra symmetry breaking constraints added by ReSBDS. Thus, the pruning that occurs at the ancestor node would trigger ReSBDS to add extra symmetry breaking constraints {a mathematical formula}c′ which implies c.If both {a mathematical formula}P0 and {a mathematical formula}P1 are not in {a mathematical formula}ϒR, one of their ancestor nodes must have been pruned from {a mathematical formula}ϒR. Since c are only added at the subtree of {a mathematical formula}P0 in {a mathematical formula}ϒP, it is implied by the constraints added by ReSBDS.Since we further have ReSBDS </list><paragraph>{a mathematical formula}=n LReSBDS, LReSBDS {a mathematical formula}≻n ParSBDS by Theorem 8. □</paragraph></paragraph><paragraph>With similar reasoning as in the proof of Theorem 9, the node pruning powers of ReSBDS/LReSBDS and ParSBDS are incomparable if there are problem constraints. Empirically, however, ReSBDS/LReSBDS usually results in a much smaller search tree than ParSBDS does.</paragraph><paragraph label="Theorem 12">Given the same set of symmetries. ReSBDS/LReSBDS{a mathematical formula}∦nParSBDS when both use the same static variable and value orderings.</paragraph><paragraph label="Proof">Similar to the proof of Theorem 9, ReSBDS/LReSBDS adds more extra composition symmetry breaking constraints than ParSBDS, but ParSBDS without these symmetry breaking constraints can have more backtracks and result in more symmetry breaking constraints being added. Thus their node pruning powers are incomparable in general. □</paragraph><paragraph label="Proof">However, solution pruning power is not affected by the above case. Given the same set of symmetries. Symmetry breaking constraints added by ParSBDS but not by ReSBDS cannot prune solutions when both use the same static variable and value orderings.Consider the resulting search trees {a mathematical formula}ϒP of ParSBDS and {a mathematical formula}ϒR of ReSBDS. Suppose a constraint c is added at a node {a mathematical formula}P0 by ParSBDS in {a mathematical formula}ϒP due to the backtracking from node {a mathematical formula}P1. Constraint c cannot be added or implied by the constraints added by ReSBDS in {a mathematical formula}ϒR only when (a) {a mathematical formula}P0 is in {a mathematical formula}ϒR but {a mathematical formula}P1 is not, (b) {a mathematical formula}P1 is pruned by a problem constraint and (c) this pruned assignment is not recorded into T. Since {a mathematical formula}P1 is pruned by problem constraint in {a mathematical formula}ϒR, no solutions exist in the subtree of {a mathematical formula}P1 in {a mathematical formula}ϒP. Thus c cannot prune any symmetric solutions. □</paragraph><paragraph label="Proof">Given the same set of symmetries. ReSBDS{a mathematical formula}≻sParSBDS and LReSBDS{a mathematical formula}≻sParSBDS when all use the same static variable and value orderings.Lemma 3 shows all symmetry breaking constraints added by ParSBDS but not by ReSBDS cannot prune solutions. Thus ReSBDS {a mathematical formula}⪰s ParSBDS. Consider the unconstrained matrix problem again. Given only two generators {a mathematical formula}{R,C}, ReSBDS leaves 7 solutions while ParSBDS leaves 8 solutions. Therefore, ReSBDS {a mathematical formula}≻s ParSBDS.Since we further have ReSBDS {a mathematical formula}=s LReSBDS, LReSBDS {a mathematical formula}≻s ParSBDS by Theorem 10. □</paragraph><paragraph>When comparing ReSBDS/LReSBDS with LexLeader and its partial methods, similar to what we have done when comparing ParSBDS and LexLeader, we give ReSBDS and LReSBDS the inversions of the symmetries broken by the LexLeader family of methods. ReSBDS and LReSBDS are stronger in solutions pruning than LexLeader when we consider only symmetries that are compositions {a mathematical formula}σ∘θ of a variable symmetry σ and a value symmetry θ.</paragraph><paragraph label="Theorem 14">Suppose G and H are sets of symmetries so that{a mathematical formula}γ∈G⇔γ−1∈H. ReSBDS{a mathematical formula}≻sLexLeader and LReSBDS{a mathematical formula}≻sLexLeader by posting G to ReSBDS and LReSBDS and breaking H by LexLeader when all search with the same static variable ordering used by LexLeader and min (max) value ordering.</paragraph><paragraph label="Proof">We prove that all the symmetric solutions pruned by LexLeader will always be pruned by ReSBDS. LexLeader (retaining the lexicographically least solution) adds the following constraints{a mathematical formula} at the root node for all {a mathematical formula}γ−1≡σ−1∘θ−1 in H where n is the number of variables, {a mathematical formula}σ−1 is a variable symmetry and {a mathematical formula}θ−1 is a value symmetry. Each of these constraints implies the following n constraints{a mathematical formula} where {a mathematical formula}k∈{1,…,n}. ReSBDS adds the following constraint for all {a mathematical formula}γ≡σ∘θ in G{a mathematical formula} at a node {a mathematical formula}P0 after assigning {a mathematical formula}k−1 variables with the backtracking or violated recorded assignment {a mathematical formula}xr=vr.Suppose solution {a mathematical formula}s1 is pruned by the LexLeader constraints (8). There must exist a solution {a mathematical formula}s2 (pruned or not) and a symmetry {a mathematical formula}(σ′)−1∘(θ′)−1 in H such that {a mathematical formula}s2=s1(σ′)−1∘(θ′)−1 and {a mathematical formula}s1&gt;lexs2. Suppose {a mathematical formula}s1≡(x1=a1∧…∧xn=an) and {a mathematical formula}s1 has the first {a mathematical formula}t−1 assignments (according to variable order) same with {a mathematical formula}s2. We must have{a mathematical formula} since {a mathematical formula}s1&gt;lexs2. Suppose{a mathematical formula}s1cannot be pruned by ReSBDS. With the static variable ordering used by LexLeader and min value ordering, {a mathematical formula}s2 is searched earlier than {a mathematical formula}s1 since {a mathematical formula}s1&gt;lexs2. Assume node {a mathematical formula}Pi is the deepest common ancestor of {a mathematical formula}s1 and {a mathematical formula}s2 with the partial assignment {a mathematical formula}x1=a1∧…∧xt−1=at−1 and the branching variable {a mathematical formula}xt and value {a mathematical formula}(θ′)−1(aσ′(t)) respectively. There are two cases to consider.<list>The node cons{a mathematical formula}(Pi∪{xt=(θ′)−1(aσ′(t))}) is not pruned. Upon backtracking from cons{a mathematical formula}(Pi∪{xt=(θ′)−1(aσ′(t))}), ReSBDS adds symmetry breaking constraint{a mathematical formula} according to the symmetry {a mathematical formula}σ′∘θ′∈G, which can be rewritten as{a mathematical formula} Thus solution {a mathematical formula}s1≡(x1=a1∧…∧xn=an) is pruned. CONTRADICTION.The node {a mathematical formula}Pi∧{xt=(θ′)−1(aσ′(t))} is pruned. It is pruned because {a mathematical formula}xt=(θ′)−1(aσ′(t)) is violated by the propagation of a symmetry breaking constraint at {a mathematical formula}Pi or an ancestor node of {a mathematical formula}Pi since there exists a solution {a mathematical formula}s2 in the subtree. Thus assignment {a mathematical formula}xt=(θ′)−1(aσ′(t)) must have been recorded in T by ReSBDS at the time it is violated. Suppose {a mathematical formula}xt=(θ′)−1(aσ′(t)) is violated at node {a mathematical formula}Pj with the partial assignment {a mathematical formula}x1=a1∧…∧xs−1=as−1 where {a mathematical formula}s≤t. ReSBDS adds the following constraint{a mathematical formula} when this violation happens according to the symmetry {a mathematical formula}σ′∘θ′∈G, which can be rewritten as{a mathematical formula} Thus solution {a mathematical formula}s1≡(x1=a1∧…∧xn=an) is pruned. CONTRADICTION.Theorem 10</list><paragraph> further shows ReSBDS {a mathematical formula}=s LReSBDS. Thus LReSBDS {a mathematical formula}≻s LexLeader follows directly. □</paragraph></paragraph><paragraph>The DoubleLex [4] method, a special case of LexLeader, breaks adjacent rows and columns interchangeability in matrix problems. Following directly from Theorem 14, we show that when ReSBDS and LReSBDS are given the same adjacent rows and columns interchangeability symmetries, and searching with row-wise or column-wise variable ordering and min (max) value ordering, ReSBDS and LReSBDS are strictly stronger in solutions pruning than DoubleLex.</paragraph><paragraph label="Proof">ReSBDS{a mathematical formula}≻sDoubleLex and LReSBDS{a mathematical formula}≻sDoubleLex.ReSBDS {a mathematical formula}⪰s DoubleLex and LReSBDS {a mathematical formula}⪰s DoubleLex following directly from Theorem 14. To show strictness, consider the ECCLD results in Table 6. ReSBDS and LReSBDS are given the same subset of symmetries as that to DoubleLex, but ReSBDS and LReSBDS leave less solutions than DoubleLex does for all cases. □</paragraph><paragraph>Another partial symmetry breaking method of LexLeader, SnakeLex [21], breaks the same subset of symmetries as DoubleLex as well as an extra linear number of symmetries that rows (columns) with distance two are interchangeable. Following directly from Theorem 14, we show that when ReSBDS and LReSBDS are given the same generator symmetries as SnakeLex, and searching with snake-wise ordering and min (max) value ordering, ReSBDS and LReSBDS are strictly stronger in solutions pruning than SnakeLex.</paragraph><paragraph label="Proof">ReSBDS{a mathematical formula}≻sSnakeLex and LReSBDS{a mathematical formula}≻sSnakeLex.ReSBDS {a mathematical formula}⪰s SnakeLex and LReSBDS {a mathematical formula}⪰s SnakeLex following directly from Theorem 14. To show strictness, consider the ECCLD results in Table 7. ReSBDS and LReSBDS are given the same subset of symmetries as that to SnakeLex, but ReSBDS and LReSBDS leave less solutions than SnakeLex does for all cases. □</paragraph><paragraph>Even though LexLeader leaves 57 nodes while ReSBDS leaves 55 nodes for the {a mathematical formula}n×n unconstrained matrix problem with {a mathematical formula}n=2 and {a mathematical formula}d=3, ReSBDS is not stronger in nodes pruning than LexLeader in general.</paragraph><paragraph label="Theorem 17">Given the same set of symmetries. ReSBDS/LReSBDS{a mathematical formula}∦nLexLeader when both search with the same static variable ordering used by LexLeader and min (max) value ordering.</paragraph><paragraph label="Proof">ReSBDS {a mathematical formula}≻s LexLeader and LReSBDS {a mathematical formula}≻s LexLeader by Theorem 14. Thus LexLeader {a mathematical formula}⊁n ReSBDS/LReSBDS. Next, we show ReSBDS/LReSBDS {a mathematical formula}⊁n LexLeader using two examples that exhibit this property for two different reasons.Consider the CSP with variables {a mathematical formula}{x1,…,x6} and {a mathematical formula}{1,2,3} as domains. The constraint is: {a mathematical formula}x1+x2+x3=x4+x5+x6. There are several variable symmetries. Here we consider only the symmetry mapping {a mathematical formula}xi onto {a mathematical formula}x7−i which is identical to its inverse symmetry. LexLeader adds constraint {a mathematical formula}〈x1,…x6〉≤lex〈x6,…,x1〉 at the root node to break this symmetry. ReSBDS adds conditional symmetry breaking constraints during search. Suppose we are at node {a mathematical formula}P0 with partial assignment {a mathematical formula}{x1=1,x2=3,x3=1}. After backtracking from cons{a mathematical formula}(P0∪{x4=1}), the problem constraint would prune value 3 from {a mathematical formula}D(x5) and {a mathematical formula}D(x6). {a mathematical formula}D(x5) is {a mathematical formula}{1,2}, {a mathematical formula}x2≤x5 is false. LexLeader thus guarantees {a mathematical formula}x1&lt;x6. This prunes value 1 from {a mathematical formula}D(x6). The problem constraint again prunes value 3 from {a mathematical formula}D(x4) and value 2 from {a mathematical formula}D(x5). The solution {a mathematical formula}{1,3,1,2,1,2} is found. ReSBDS adds the following two constraints{a mathematical formula} along branching to {a mathematical formula}P0. Even though {a mathematical formula}D(x5) is {a mathematical formula}{1,2}, these two constraints cannot prune value 1 from {a mathematical formula}D(x6). Both ReSBDS and LexLeader return 84 solutions, but LexLeader has 175 nodes in the search tree while ReSBDS has 187. The reason is because LexLeader adds one symmetry breaking constraint for each symmetry, while ReSBDS posts the symmetry breaking constraints separately and thus loses pruning opportunities. This shows that there are nodes pruned by LexLeader that cannot be pruned by ReSBDS, i.e. ReSBDS {a mathematical formula}⊁n LexLeader.Consider another CSP with variables {a mathematical formula}{x1,x2} and {a mathematical formula}{0,1} as domains. The constraint is: {a mathematical formula}x1≠x2. The two values are interchangeable. LexLeader adds constraint {a mathematical formula}〈x1,x2〉≤lexA(01)[〈x1,x2〉] at the root node to break this symmetry where {a mathematical formula}A(01)=[1,0] and {a mathematical formula}A(01)[X] is defined as the application of an element constraint to the variables in X. ReSBDS adds conditional symmetry breaking constraints during search. Once the LexLeader constraint is added at the root node, values 1 and 0 would be pruned from {a mathematical formula}D(x1) and {a mathematical formula}D(x2) respectively. ReSBDS, however, would not add constraint {a mathematical formula}x1≠1 until backtrack happens before which {a mathematical formula}x1 is assigned the value 0 and the solution {a mathematical formula}{x1=0,x2=1} is found. Both ReSBDS and LexLeader return 1 solution, but LexLeader only has the root node while ReSBDS has an extra search node. The reason is LexLeader posts all the symmetry breaking constraints at the root node, while ReSBDS has to wait until there is a backtrack or a value {a mathematical formula}vi being pruned from the domain of a variable {a mathematical formula}xi and {a mathematical formula}(xi=vi) is already recorded in T. Only at that point are symmetry breaking constraints added to do the value pruning. This shows again that there are nodes pruned by LexLeader that cannot be pruned by ReSBDS, i.e. ReSBDS {a mathematical formula}⊁n LexLeader.Similar analysis can also show that there are nodes pruned by LexLeader that cannot be pruned by LReSBDS in the last two examples. Thus LReSBDS {a mathematical formula}⊁n LexLeader. □</paragraph><paragraph>Even though their nodes pruning powers are incomparable, we shall demonstrate empirically in our experiments, however, that ReSBDS/LReSBDS prunes many more symmetric solutions and also more nodes than LexLeader in practice.</paragraph><paragraph>LDSB [11] is an improvement of shortcut SBDS. LDSB handles only active symmetries and also their compositions. In addition, when v is pruned from the domain of variable x, LDSB not only asserts {a mathematical formula}(x≠v)g but also {a mathematical formula}(x≠v)g∘h for each active symmetries g and h. This recursive step is repeated in a breadth-first manner until no more new prunings are obtained [11]. LDSB is close in spirit to ReSBDS and has smaller overhead, but also misses important pruning opportunities since it only handles active symmetries. We give theorems to compare the nodes and solution pruning power of ReSBDS/LReSBDS and LDSB. Since LDSB [11] can deal only with variable symmetries and value symmetries, we restrict our attention to these symmetries.</paragraph><paragraph label="Proof">Otherwise, LDSB breaks only active non-broken symmetries and their compositions, but ReSBDS breaks all non-broken symmetries (active and inactive) and their compositions. Hence, ReSBDS is strictly stronger. □</paragraph><paragraph label="Proof">Otherwise, LDSB breaks only active non-broken symmetries and their compositions, but LReSBDS breaks all non-broken symmetries (active and inactive) and their compositions. Hence, LReSBDS is strictly stronger. □</paragraph><paragraph label="Theorem 20">Even when ReSBDS and LReSBDS are given only generators, they can be complete in specific situations. Given a fixed variable (value) ordering Π. Suppose G is the set of symmetries such that adjacent variables (values) are interchangeable. Applying ReSBDS or LReSBDS on G and searching with the Π variable (value) ordering eliminates all symmetries in Σ, where Σ is the symmetry group of G.</paragraph><paragraph label="Proof">For interchangeable variables, LexLeader can eliminate Σ by being only given G according to any Π ordering. For interchangeable values, Walsh [32] proves VALSYMBREAK(G,X) eliminates Σ, where VALSYMBREAK is a global lexicographic ordering constraint to break value symmetries. Thus, results follow directly from Theorem 14. □</paragraph><paragraph>Therefore, when breaking interchangeable variables and values, ReSBDS and LReSBDS only need to be given adjacent variable or value interchangeabilities to eliminate the complete symmetry group.</paragraph><paragraph label="Theorem 21">Suppose G is the set of symmetries such that adjacent rows (columns) are interchangeable. Applying ReSBDS/LReSBDS on G and searching with the input variable variable ordering and static value ordering eliminates all symmetries in Σ, where Σ is the symmetry group of G.</paragraph><paragraph label="Proof">For interchangeable rows (columns), LexLeader can eliminate Σ by being only given G according to the input variable variable ordering and static value ordering. Thus, results follow directly from Theorem 14. □</paragraph><paragraph>Therefore, when breaking interchangeable rows and columns, ReSBDS and LReSBDS only need to be given adjacent row or column interchangeabilities to eliminate the complete symmetry group.</paragraph></section></section><section label="5"><section-title>Experimental results</section-title><paragraph>This section reports experiments on five satisfaction problems and three optimization problems. In case of partial symmetry breaking, the symmetries to break are some generators of the entire symmetry group. Our ReSBDS and LReSBDS implementations are modified directly from the code base of SBDS and ParSBDS. When we propagate symmetry breaking constraints which are actually nogoods, dynamic subscriptions (dynamic event sets [33], also known as dynamic triggers [34]) are used.</paragraph><paragraph>We compare ReSBDS and LReSBDS against SBDS, ParSBDS and LDSB as well as state of the art static symmetry breaking methods: (a) two partial symmetry breaking variants of LexLeader, DoubleLex [4] and SnakeLex [21] for breaking matrix symmetries, (b) value precedence [18] for breaking value interchangeability, (c) the SigLex constraint [19] for breaking variable and value interchangeability and its descending-partition-size variation and (d) the static method by Puget [17], [35] to break all variable symmetries in all-different problems and all value symmetries in surjection problems. We do not compare with allperm [16] since its implementation is not available. All experiments are conducted using Gecode Solver 4.2.0 on Xeon E5620 2.4 GHz processors.</paragraph><paragraph>We also compare against other state of the art dynamic symmetry breaking methods: symmetry breaking with lazy clause generation [36], GE-trees [8], GAP-SBDD [37] and GAP-SBDS [38]. Here, we can do the comparison only indirectly for these four methods by using results from the literature since they are not available on the Gecode platform. In Table 2, we give the Passmark CPU marks [39] on the reported CPUs in the literature and the CPU of our experimental machines. The higher the mark, the better the efficiency of the CPU.</paragraph><paragraph>We compare against SBDS, ParSBDS and LDSB since they are state of the art dynamic methods and also starting point of our work. The other methods chosen for comparison are best static and dynamic methods on handling the respective problems in the literature.</paragraph><paragraph>Although Mears et al. [11] has designed a pattern syntax to specify the input symmetries for LDSB, the syntax is not available in the Gecode implementation, which gives only a restricted syntax to specify the types of symmetries and parameters. It is unclear exactly what symmetries are processed by LDSB. In subsequent sections, we state only the types of symmetries given to LDSB in our experiments.</paragraph><paragraph>In our tables, #s denotes the number of solutions, #f denotes the number of failures (number of failed leaf nodes), #bt denotes the number of backtrack and t denotes the running time. An entry with the symbol “–” indicates that the search timed out after the 1 hour limit. The best results are highlighted in bold. SBDS uses SBDS to break all symmetries. DoubleLex and SnakeLex lexicographically orders variable sequences in increasing order according to the DoubleLex and SnakeLex methods. ParSBDS, LDSB, ReSBDS and LReSBDS handle the given symmetries by ParSBDS, LDSB, ReSBDS and LReSBDS respectively. Unless otherwise specified, the search order is defaulted to input variable order and min value order.</paragraph><section label="5.1"><section-title>Satisfaction problems</section-title><paragraph>In this part, we give five experiments to show the benefit of our methods on finding all solutions in satisfaction problems.</paragraph><section label="5.1.1">N-Queens<paragraph>The N-Queens problem is prob054 in CSPLib [40], which is to place N queens on an {a mathematical formula}N×N chessboard so that none of the queens can attack each other. We model the N-Queens problem the standard way using one variable per column. This model has 8 geometric symmetries which are classified into variable symmetries, value symmetries and variable-value symmetries. All 8 geometric symmetries are given to SBDS. We give ParSBDS, ReSBDS and LReSBDS only the two generators rx (reflection on the vertical axis) and d1 (reflection on the diagonal), which can generate all 8 geometric symmetries. Note that all the symmetry breaking constraints added by ReSBDS and LReSBDS according to these two generators are unconditional constraints. This means that all non-broken symmetries at each node during search are active symmetries. Thus the pruning power of ReSBDS and LReSBDS are identical according to Lemma 2. We thus show their solutions and failures together and use {a mathematical formula}TR and {a mathematical formula}TL to denote the runtime of ReSBDS and LReSBDS respectively. LDSB can only handle the rx, ry and r180 symmetries, which are reflections on the vertical and horizontal axes and rotation of 180 degrees. They form a symmetry group which is a subset of the geometric symmetry group. Following Mears et al. [11], we give LDSB only the two generators rx and ry. SBC uses the static method by Puget [17], [35] to break all variable symmetries in all-different problems and all value symmetries. Thus only rx and ry can be broken by SBC.</paragraph><paragraph>Table 3 shows the results. SBC eliminates the smallest set of symmetric solutions and search parts. Being given two symmetries, ReSBDS and LReSBDS achieve over 63% reduction in solution size and over 36% in failures when compared to ParSBDS. In terms of runtime, ReSBDS and LReSBDS are 1.56 and 1.64 times faster than ParSBDS on average respectively. This shows the additional constraints we add can break more compositions and prune more symmetric subtrees in an efficient way. LReSBDS runs 1.05 times faster than ReSBDS on average since there is no need to record and check the violations of assignments in T. The saving is not that prominent since there are only two symmetries added and both of them are active symmetries if they are not broken yet during search. SBDS eliminates the symmetries in N-Queens completely and has the smallest solution size and search tree. ReSBDS and LReSBDS, which break the symmetries only partially, are 1.34 and 1.40 times faster than SBDS on average respectively. This shows partial symmetry breaking method can be efficient even for polynomially symmetric CSPs [10]. LDSB performs worse than ParSBDS in search tree size and runtime. This example demonstrates the main advantages of ReSBDS and LReSBDS: flexibility in choosing symmetries to break, and good balance in overhead and extra pruning. For ReSBDS, the maximum size of T is 2. In more than 99.99% of the cases, the size of T is 0.</paragraph></section><section label="5.1.2"><section-title>Graceful graph</section-title><paragraph>The graceful graph problem is prob053 in CSPLib [40], which is to find a labeling f of the nodes of a graph with q edges so that each node is assigned a unique label from {a mathematical formula}0,…,q and when each edge xy is labeled with {a mathematical formula}f(x)−f(y), the edge labels are all different. The graceful graph problem is an all-different problem [9]. We model this problem by one variable for a node. For {a mathematical formula}Kn×Pm graph, it has intra-clique permutations, inter-clique permutations, complement symmetry, and their combinations. All variable and value symmetries and their combinations are given to SBDS. ParSBDS is given {a mathematical formula}n⁎(n−1)/2 symmetries to describe any two nodes in each clique being permutable simultaneously and two more symmetries to describe inter-clique permutation and complement symmetry.</paragraph><paragraph>ReSBDS, LReSBDS and LDSB are given {a mathematical formula}(n−1) symmetries to describe simultaneous permutation of adjacent nodes in each clique and also one inter-clique permutation and one complement symmetry. The intra-clique permutations and inter-clique permutations are actually row and column symmetries in this model. All row and column interchangeabilities are eliminated by ReSBDS and LReSBDS when given only interchangeabilities of adjacent rows (columns) according to Theorem 21. Posting any extra symmetries to ReSBDS and LReSBDS as in the case of ParSBDS is fruitless. We have also tried giving the same symmetries for ReSBDS to ParSBDS. In this case, ParSBDS fails to solve most of the problem instances within the time limit. Similarly, LDSB needs to be given only adjacent symmetries due to its power in pruning composition symmetries.</paragraph><paragraph>Note that all the symmetry breaking constraints added by ReSBDS and LReSBDS according to these two generators are unconditional constraints. This means that all non-broken symmetries at each node during search are active symmetries. Thus the pruning power of ReSBDS, LReSBDS and LDSB are identical according to Lemma 2. We thus show the solutions and failures of ReSBDS and LReSBDS together and use {a mathematical formula}tR and {a mathematical formula}tL to denote the runtime of ReSBDS and LReSBDS respectively. SBC uses the static method by Puget [17], [35] to break all variable symmetries in all-different problems and all value symmetries. For GAP-SBDD[37] and GAP-SBDS[38], we replicate their results from the literature [41].</paragraph><paragraph>Table 4 shows the results. Since we run more instances than those reported in the literature, instances not tested by GAP-SBDD and GAP-SBDS are given empty entries in the table. SBDS eliminates all symmetries and has the smallest solution size and search tree. ReSBDS and LReSBDS, which break the symmetries only partially, are 4.05 and 4.29 times faster than SBDS on average respectively. LReSBDS performs the best and runs slightly faster than ReSBDS. When comparing with the other two complete methods, GAP-SBDD is solved under a 2.6 GHz Pentium IV processor and GAP-SBDS is solved under a 600 MHz Intel PIII processor. According to Table 2, our CPU (Xeon E5620 2.4 GHz processor) is 16.87 and 20.48 times faster than the two reported CPUs respectively. However, LReSBDS runs 100 and 80 times faster than GAP-SBDD and GAP-SBDS. This shows the gains of our efficient partial symmetry breaking methods. Being given a smaller subset of symmetries, ReSBDS and LReSBDS achieve over 46% reduction in solution size and over 47% in failures when compared to ParSBDS. In terms of runtime, ReSBDS and LReSBDS are 1.68 and 1.89 times faster than ParSBDS on average. This demonstrates ReSBDS and LReSBDS break more composition symmetries and prune more symmetric subtrees in an efficient way. LDSB has the same performance with ReSBDS and LReSBDS in number of solutions left and search tree size. This demonstrates Theorem 18. The runtime of LDSB, however, are 1.24 and 1.37 times slower than ReSBDS and LReSBDS on average respectively due to the high overheads to handle symmetries. ReSBDS and LReSBDS better the static partial method SBC by 19% reduction in solution size on average, 37% reduction in failures on average and 1.40 and 1.47 times faster in runtime on average respectively. For ReSBDS, the maximum size of T is 4. In 99.11% of the cases on average, the size of T is 0.</paragraph></section><section label="5.1.3">The {a mathematical formula}n×n queen problem<paragraph>The {a mathematical formula}n×n queen problem is to color an {a mathematical formula}n×n chessboard with n colors, such that no line (row, column or diagonal) contains the same color twice [42]. This can be seen as searching for n non-intersecting solutions to the n queens problem. Each solution is given by the squares containing one of the n colors. This problem can be modeled with {a mathematical formula}n2 variables, one per square of the chess board, and one all different constraint per line. Like the N-Queens problem, it has 8 geometric symmetries. It also has value interchangeability and their compositions with variable symmetries. All these symmetries are given to SBDS. ParSBDS is given the 8 geometric symmetries and any two of values are interchangeable. ReSBDS and LReSBDS are given the 8 geometric symmetries and adjacent value interchangeability. All value interchangeabilities have been eliminated by ReSBDS and LReSBDS when given only adjacent value interchangeabilities according to Theorem 20. Thus posting the extra number of value symmetries to ReSBDS and LReSBDS as in the case of ParSBDS is fruitless. Since value symmetries are inactive symmetries, LDSB needs to be given only the adjacent value interchangeabilities by similar reasoning. LDSB is given the 8 geometric symmetries and value interchangeability. For the static method, variable symmetries are broken by the following VAR constraints [43]: {a mathematical formula}x0&lt;xn−1,x0&lt;xn(n−1),x0&lt;xn2−1,x1&lt;xn. Value symmetries are broken by OCC which is proposed by Puget [35] to break all value symmetries in surjection problems. The results of GAP-SBDD and GE-tree are replicated from the literature [42] where GE-tree uses GE-tree construction for the value symmetries and GAP-SBDD on the symmetry group for the variables. Unfortunately, the CPU/machine used in their experimentation is not reported.</paragraph><paragraph>Table 5 shows the results. Again, we leave the entries empty if an instance is not tested by GE-tree and GAP-SBDD. ReSBDS and LReSBDS are again much more time efficient and break more symmetries than ParSBDS. ReSBDS, LReSBDS and LDSB leave the same number of solutions and failures. This shows all non-broken symmetries are active symmetries under this searching order. But LReSBDS runs the fastest. The static partial method VAR+OCC leaves the smallest search tree size. LReSBDS leaves only slightly larger number of failures than VAR+OCC, but its runtime is 3.8 times faster on average due to its small overhead. When compared to the two complete methods, LReSBDS is 922 and 561 times faster than GE-tree and GAP-SBDD on average respectively. For ReSBDS, the maximum size of T is 4. In 87.70% of the cases on average, the size of T is 0.</paragraph></section><section label="5.1.4"><section-title>Error Correcting Code – Lee Distance (ECCLD)</section-title><paragraph>The ECCLD problem is prob036 in CSPLib [40]. The task is to find the maximum number b of codes of length n drawn from 4 symbols {a mathematical formula}{1,2,3,4} such that the Lee distance between any pair of codes is exactly c, where the Lee distance between two symbols a and b is min {a mathematical formula}{|a−b|,4−|a−b|}. We model it into a {a mathematical formula}b×n matrix with domain {a mathematical formula}{1…4}. Similar to Lee and Li [12], in order to illustrate the effect on solution set size, we transform the optimization problem to a satisfaction one by setting b in advance. This model has matrix symmetries which is exponential to the problem size. We only try to break a subset of the available matrix symmetries in the problem.</paragraph><paragraph>In Table 6, the symmetries are given as the following. ParSBDS is given the symmetry that any two rows (columns) are interchangeable. ReSBDS, LReSBDS and DoubleLex are given interchangeability of adjacent rows (columns). LDSB is given the interchangeable rows and columns. Note ParSBDS is given more symmetries than ReSBDS. Given the same symmetries as ReSBDS, ParSBDS fails to solve most of the problems within the time limit. To show the improvement of LReSBDS over ReSBDS and also their flexibility in choosing symmetries to break, we also use these two methods to break interchangeability of adjacent rows (columns) as well as cartesian-product of any two rows are interchangeable and any two columns are interchangeable. Now we get ReSBDS and LReSBDS respectively.</paragraph><paragraph>Table 6 shows the results by using input order heuristic. ReSBDS and LReSBDS are 1.92 and 2.29 times faster than ParSBDS on average respectively with more symmetries broken more efficiently. ReSBDS has smaller number of solutions and search tree size than DoubleLex. The runtime of ReSBDS, however, does not gain too much from the smaller search tree size because of the larger overhead of ReSBDS. After introducing our light version, LReSBDS leaves the same number of solutions and almost the same number of failures as those of ReSBDS, and is 1.31 times faster than DoubleLex on average. Given more symmetries, LReSBDS is 1.89 times faster than ReSBDS and has only slightly increase on number of failures. This shows LReSBDS is much more efficient than ReSBDS and does not loss too much pruning power. Now LReSBDS is 2.48 times faster than DoubleLex on average. We can also see that LDSB leaves many more solutions and is drastically less efficient than ReSBDS and LReSBDS. This shows ReSBDS and LReSBDS can gain a lot by breaking also inactive symmetries and their compositions. Another advantage over LDSB is again that ReSBDS and LReSBDS have the flexibility of choosing the given symmetries to break. For ReSBDS, the maximum size of T is 99, and the average size is 1.16. In 55.91% of the cases, the size of T is 0. For ReSBDS, the maximum size of T is 99, and the average size is 1.97. In 52.67% of the cases, the size of T is 0.</paragraph><paragraph>To compare with LexLeader in another variable order, we do the following experiments. In Table 7, the variable heuristic is row-wise snake order. We choose row-wise snake order rather than column-wise snake order because the static method SnakeLex performs better in row-wise snake order for this problem. ParSBDS is given the same subset of symmetries as in Table 6. ReSBDS, LReSBDS and SnakeLex are given interchangeability of adjacent rows (columns) and interchangeability of rows with distance 1 which is exactly the symmetries that are broken by SnakeLex. LDSB is given the interchangeable rows and columns. Given the same symmetries as ReSBDS, ParSBDS again fails to solve most of the problems within the time limit. ReSBDS and LReSBDS break the extra cartesian-product of any two rows are interchangeable and any two columns are interchangeable than ReSBDS and LReSBDS respectively.</paragraph><paragraph>Table 7 shows the results with row-wise snake ordering. ReSBDS and LReSBDS are 1.83 and 2.24 times faster than ParSBDS on average respectively. ReSBDS has smaller number of solutions and search tree size than SnakeLex. LReSBDS leaves the same number of solutions and almost the same number of failures as those of ReSBDS but runs faster, and is 1.33 times faster than SnakeLex on average. Given more symmetries, LReSBDS is 1.56 times faster than ReSBDS and has only slightly increase on number of failures. This shows LReSBDS is much more efficient than ReSBDS and does not loss too much pruning power. Note that for the last instance, LReSBDS leaves more solutions than ReSBDS. This is because the heuristic is not a static one. If we use static input variable order, they all leave {a mathematical formula}7,631,833 number of solutions. Now LReSBDS is 2.08 times faster than SnakeLex on average. Again, LDSB leaves many more solutions and is drastically less efficient than ReSBDS and LReSBDS. For ReSBDS, the maximum size of T is 91, and the average size is 1.32. In 54.71% of the cases, the size of T is 0. For ReSBDS, the maximum size of T is 105, and the average size is 1.62. In 53.42% of the cases, the size of T is 0.</paragraph></section><section label="5.1.5"><section-title>Cover Array problem (CA)</section-title><paragraph>The Cover Array Problem CA{a mathematical formula}(t,k,g,b), prob045 in CSPLib [40], is to construct a {a mathematical formula}k×b array A over {a mathematical formula}Zg=0,1,2,…,g−1 with the property that for any t distinct rows {a mathematical formula}1≤r1≤r2≤…≤rt≤k, and any member {a mathematical formula}(x1,x2,…,xt) of {a mathematical formula}Zg there exists at least one column c such that {a mathematical formula}xi equals the {a mathematical formula}(ri,c)-th element of A for all {a mathematical formula}1≤i≤t. We use the integrated model [44], which channels an original model and a compound model. This model also has matrix symmetries. We again only try to break a subset of the available matrix symmetries in the problem for each method which is same as that for ECCLD.</paragraph><paragraph>Table 8 shows the results by using input order heuristic. ReSBDS and LReSBDS are 2.23 and 3.08 times faster than ParSBDS on average respectively with more symmetries broken. ReSBDS and LReSBDS have smaller number of solutions and search tree size than DoubleLex. They gain little from the smaller search tree size because of the larger overhead of dynamically generating and handling nogoods even though LReSBDS is 1.39 times faster than ReSBDS on average. Given more symmetries, LReSBDS is 1.60 times faster than ReSBDS with almost the same number of failures. This shows again LReSBDS is much more efficient than ReSBDS and does not lose too much pruning power. Now LReSBDS is 1.75 times faster than DoubleLex on average. LDSB cannot solve any of the instances. This shows ReSBDS and LReSBDS can gain a lot by breaking also inactive symmetries and their compositions. For ReSBDS, the maximum size of T is 74, and the average size is 1.28. In 58.14% of the cases, the size of T is 0. For ReSBDS, the maximum size of T is 74, and the average size is 1.48. In 55.63% of the cases, the size of T is 0.</paragraph><paragraph>Table 9 shows the results with column-wise snake ordering. We choose column-wise snake order rather than row-wise snake order because the static method SnakeLex performs better in column-wise snake order for this problem. ReSBDS and LReSBDS are 1.13 and 1.77 times faster than ParSBDS on average respectively. ReSBDS and LReSBDS have smaller number of solutions and search tree size than SnakeLex but no gains on the runtime due to their larger overheads. LReSBDS is 1.60 times faster than ReSBDS on average. Given more symmetries, LReSBDS is 2.53 times faster than ReSBDS and has almost the same number of failures. This shows again LReSBDS is much more efficient than ReSBDS and does not loss too much pruning power. Given more symmetries, ReSBDS and LReSBDS cannot further prune many more symmetries so that the reduction of the search tree size cannot overweight the overhead of handling more symmetry breaking constraints. However, LDSB leaves only slightly number of solutions than ReSBDS and LReSBDS which shows that most non-broken symmetries are active ones under this search order. For ReSBDS, the maximum size of T is 74, and the average size is 1.75. In 55.77% of the cases, the size of T is 0. For ReSBDS, the maximum size of T is 74, and the average size is 1.92. In 55.10% of the cases, the size of T is 0.</paragraph></section></section><section label="5.2"><section-title>Optimization problems</section-title><paragraph>A Constraint Optimization Problem (COP) P is a tuple {a mathematical formula}(X,D,C) with an objective function f that maps full assignments to real numbers. An optimal solution s is a solution to {a mathematical formula}(X,D,C) such that {a mathematical formula}f(s)≤f(s′) for all other solutions {a mathematical formula}s′ of {a mathematical formula}(X,D,C). We note that maximization can be easily reformulated into a minimization problem. In this part, we give three experiments to show the benefit of our methods on finding optimal solutions in optimization problems. Optimization problems are quite sensitive to search heuristics. We employ dynamic heuristics for solving all benchmarks in this section.</paragraph><section label="5.2.1"><section-title>Concert hall scheduling</section-title><paragraph>Concert hall scheduling [18] is to choose among n applications specifying a period and an offered price to use k identical concert halls, to maximize profit. We take the benchmarks used by Law and Lee [19], and test with {a mathematical formula}k∈{8,10}. The concert halls are interchangeable, and so are applications within each partition.</paragraph><paragraph>We compare against the value precedence constraint [18] for breaking value interchangeability and LexLeader for breaking variable interchangeability (Precede), SigLex constraint (Siglex) for breaking variable and value interchangeability [19] and its descending-partition-size variation (Siglexdec). ParSBDS are given two sets of symmetries: any two variables within each partition being interchangeable and any two values being interchangeable. All variable interchangeabilities are eliminated by ReSBDS and LReSBDS when given only adjacent variable interchangeabilities according to Theorem 20. Thus posting the composition variable symmetries to ReSBDS and LReSBDS is fruitless. ReSBDS and LReSBDS are given two sets of symmetries: adjacent variables within each partition being interchangeable and adjacent values being interchangeable. Thus ReSBDS and LReSBDS only adds unconditional constraints and have the same pruning power according to Lemma 2. According to the symmetry pattern syntax, we give LDSB variable interchangeabilities and value interchangeabilities.</paragraph><paragraph>This problem is quite sensitive to search heuristics. For each symmetry breaking method, we experiment with several commonly used heuristics in the literature and report the best heuristic in our results. For the three static methods, smallest domain first heuristic is used. For ParSBDS, ReSBDS, LReSBDS and LDSB, the variable ordering heuristic chooses the variable with the most constraints and breaks ties by the size of the partition containing the variables. This can make more symmetries being broken at the upper level. Running the three static methods with this search heuristic would reduce their performance.</paragraph><paragraph>We do not compare the solution set size since the problem is optimization in nature. Fig. 4, Fig. 5 show the timing results in logarithmic scale and graphical form for easy visualization. The horizontal axis shows instance size, and the vertical axis shows the logarithmic mean time in seconds taken to solve the set of instances to optimality. Any instance that is not solved within the time limit is considered to have taken 1 hour for the purpose of calculating the mean. Results show ReSBDS and LReSBDS perform similar and achieve the best performance, while Precede, Siglex and ParSBDS perform the worst. ReSBDS and LReSBDS are significantly better than Siglexdec since they have a much lower overhead and collaborate relatively well with the most-constraining heuristic. ReSBDS and LReSBDS are also significantly better than ParSBDS due to their lower overhead and stronger pruning power. LDSB has similar performance trends as ReSBDS and LReSBDS, but is 3.18 and 3.28 times slower than ReSBDS and LReSBDS on average respectively.</paragraph><paragraph>Symmetry breaking with lazy clause generation [36] can also handle this problem well. SBDS-1UIP and Static-1UIP combine SBDS and static methods with lazy clause generation respectively. Their experiments were run on the Xeon Pro 2.4 GHz processor, which is a dual CPU version of our Xeon E5620 2.4 GHz processor running on a Mac Pro. Thus, according to Table 2 both CPUs have the same Passmark CPU marks, but their methods are implemented on top of the CHUFFED solver [45] which is one of the fastest existing CP solvers. Table 10 shows LReSBDS is 9.72 and 14.64 times faster than the replicated results [36] of SBDS-1UIP and Static-1UIP. This again shows our method is very efficient to break a large number of symmetries with a small overhead.</paragraph></section><section label="5.2.2"><section-title>Optimization versions of CA</section-title><paragraph>To achieve the near-orthogonal case of covering array which happens when every symbol appears with the same frequency in each column, Kim et al. [46] introduce several metrics to evaluate the quality of covering array. The second metric is to evaluate a covering array by the average of the absolute equal occurrence discrepancy of each column. Our objective is to minimize this metric. We use the smallest domain first heuristic to search the problem.</paragraph><paragraph>Table 11 shows the results. LDSB cannot solve most of the instances. ReSBDS and LReSBDS are 2.38 and 3.02 times faster than ParSBDS on average respectively with more symmetries broken. LReSBDS performs the best, and is 1.75 and 1.93 times faster than DoubleLex and SnakeLex on average. This demonstrates that our methods are competitive against state of the art symmetry breaking methods also in solving optimization problems.</paragraph><paragraph>We attempt also another metric: the sum variance in each column. Another objective is to minimize this metric. We again use the smallest domain first heuristic to search the problem. Table 12 shows the results. Again, LDSB cannot solve most of the instances. LReSBDS performs the best for all cases and is 2.02 and 2.26 times faster than DoubleLex and SnakeLex respectively on average. This gives an indication of the flexibility of our methods in dealing with objective functions of different natures.</paragraph></section><section label="5.2.3"><section-title>Optimization versions of ECCLD</section-title><paragraph>Two optimization versions of the ECCLD problem are formed by adopting the same two metrics used in the CA problem. Again, we use the smallest domain first heuristic to search the problems.</paragraph><paragraph>Table 13, Table 14 show the results using the two metrics respectively. LReSBDS performs the best in most of the cases under both metrics. It is 2.21 and 3.23 times faster than DoubleLex and SnakeLex respectively on average for the first metric and is 2.27 and 4.09 times faster than DoubleLex and SnakeLex respectively on average for the second metric. Our results confirm the empirical efficiency of ReSBDS and LReSBDS in solving optimization problems.</paragraph></section></section><section label="5.3"><section-title>Discussion</section-title><paragraph>We have performed extensive experimentation on five satisfaction benchmarks and three optimization benchmarks to demonstrate the benefits of ReSBDS and LReSBDS over state of the art symmetry breaking methods, including LexLeader and its partial variants, and SBDS and its partial variant.</paragraph><paragraph>ReSBDS and LReSBDS often achieve great reductions in number of failures when they are given the same or smaller subset of symmetries as ParSBDS. The substantial reduction in search tree size implies shorter time to find all solutions or optimal solutions. The extra prunings are attributed to the additional constraints added by ReSBDS and LReSBDS, which can break more composition symmetries and prune more symmetric subtrees with small overheads. Moreover, given the same subset of symmetries, LReSBDS runs slightly faster than ReSBDS since it does not need to record and check the violations of assignments in the table T. Such savings become more prominent with the increase in size of the subset of symmetries to break. When compared against LDSB which is designed for breaking only active symmetries but limits the form of symmetries to break, ReSBDS and LReSBDS perform significant better for their capabilities to break both active and inactive symmetries. Unlike LDSB, ReSBDS and LReSBDS are not restricted by pattern syntax and thus can break arbitrary symmetries.</paragraph><paragraph>In matrix problems, DoubleLex and SnakeLex are state of the art methods. ReSBDS and LReSBDS are comparable in running time to DoubleLex and SnakeLex when given the same subset of symmetries. When given slightly more symmetries, ReSBDS and LReSBDS can break substantially more composition symmetries, which results in tangible reduction in search space and runtime when compared to DoubleLex and SnakeLex.</paragraph><paragraph>When solving satisfaction problems in the experiments, we find all solutions. In case of searching only for the first solution, symmetry breaking methods in general and the ReSBDS family of methods in particular function similarly, and can help reduce search space by pruning symmetric counterparts of visited search regions. However, we did some simple experiments and confirmed that substantially less search effort is required to find the first solution in general. There are two consequences. First, we are searching only an initial part of the search tree. With less visited regions, there are less symmetric counterparts to avoid. Also some of these symmetric counterparts may lie even beyond the first solution in the search tree. Second, there are less branching and backtracking, and thus also less symmetry breaking nogoods being added during search by the ReSBDS family of methods. Very often, these characteristics translate to less symmetries being broken. As a result, symmetry breaking helps relatively little for first solution search, as compared to all solution search.</paragraph></section></section><section label="6"><section-title>Related work</section-title><paragraph>Symmetries can be broken statically or dynamically. We give the main and recent work on symmetry breaking techniques.</paragraph><section label="6.1"><section-title>Static symmetry breaking</section-title><paragraph>In the static symmetry breaking approach, symmetry breaking constraints[2] are added to a CSP to allow only some of the symmetrical regions to be traversed during search. Crawford et al. [3] suggest a general scheme, called LexLeader, to add symmetry breaking predicates to satisfiability problems. This constraint selects the lexicographically least solution to break symmetries of indistinguishable objects. Aloul et al. [47] improve this scheme by constructing more efficient CNF representations of symmetry-breaking predicates. Efficient consistency enforcing algorithms [29], [48], [49] are given for propagating the global lexicographical ordering constraints {a mathematical formula}≤lex. Walsh [14] gives an overview of the application and propagators of {a mathematical formula}≤lex to deal with various symmetries for both integer and set variables. DoubleLex [4] is an incomplete but efficient method for handling matrix symmetries by breaking only the row and column symmetries. Multiset ordering constraints [15] and allperm constraints [16] are also available for breaking row and column symmetries in matrix models [4], which are commonly found in many CSPs. SnakeLex [21] is similar to DoubleLex but is based on the snake ordering of variables. Yip and Van Hentenryck [22] break matrix symmetries by utilizing LexLeader feasibility checkers to verify, during search, whether the current partial assignment can be extended into a canonical solution. Narodytska and Walsh [23] study extensively the effect of variable ordering in the LexLeader method. When the CSP has an AllDiff on all variables, the exponential number of lex ordering constraints can be simplified to a linear number of inequality constraints [17]. Katsirelos et al. [20] suggest to put together lexicographical ordering symmetry breaking constraints and common global constraints to increase the propagation.</paragraph><paragraph>Several static symmetry breaking methods are also proposed for value symmetries. Petrie and Smith [9] adapt LexLeader [3] for breaking value symmetries by imposing an appropriate lexicographical ordering constraint on each value symmetry. Puget [30] and Walsh [14] give propagation methods for value symmetry breaking constraints around the same time but independently. Having to handle an exponential number of such constraints, Puget [30] propose a polytime global filtering algorithm which performs forward checking. To eliminate symmetric solutions due to interchangeable values [50], [51], Law and Lee [5], [18] formally define value precedence and propose a specialized propagator for a pair of interchangeable values. Walsh [52] extends the work of Law and Lee [5], [18] to a propagator for any number of interchangeable values. Assuming two redundant models connected by channeling constraints, Law and Lee [5], [18] also show how value symmetries in one model can be broken using variable symmetry breaking constraints in the dual. The Siglex constraint [19] is proposed for breaking variable and value interchangeability together.</paragraph><paragraph>Lee and Li [12] introduce the novel notion of symmetry preservation, and demonstrate its benefits in terms of more symmetries broken, and a smaller solution set and search space.</paragraph></section><section label="6.2"><section-title>Dynamic symmetry breaking</section-title><paragraph>Another approach is to break symmetries dynamically [53], [7], [6], [54]. Dynamic methods modify the search procedure to exclude exploration of symmetric regions. A representative dynamic approach is Symmetry Breaking During Search (SBDS) [7], [38]. Upon backtracking from a search decision, SBDS [7] adds a conditional symmetry breaking constraint for each symmetry to remove all future nodes symmetric to the current node. Backofen and Will [53] introduce Symmetry Excluding Search (SES), which is similar to but more general than SBDS. SES allows a search tree to branch over arbitrary constraints instead of simple unary assignment constraints in SBDS. Symmetries form groups. Gent et al. [38] incorporate GAP, a computational group theory system, to SBDS such that large symmetry groups can be handled efficiently. Recently, Mears et al. [11] propose a formalization of the shortcut SBDS method called Lightweight Dynamic Symmetry Breaking (LDSB) that handles only active symmetries and also their compositions.</paragraph><paragraph>Based on the notion of dominance detection, Symmetry Breaking via Dominance Detection (SBDD) [6], [55], [56] tests at each search node if the next node is symmetric to a previously explored node. Barnier and Brisset [56] propose SBDD+, an improvement of SBDD. The key idea of the improvement is a deep pruning technique which allows to prune higher in the search tree whenever possible. Gent et al. [37] again use computation group theory to extend SBDD, by proposing a generic dominance checker, which avoids the necessity of implementing a specific dominance checker in SBDD for each problem by a constraint programmer.</paragraph><paragraph>There is also research on the intersection of symmetry reasoning and nogood learning. Benhamou et al. [57] add to the clause base all its symmetrical assertive clauses when an assertive clause is detected during the search. Chu et al. [36] combine Lazy Clause Generation [58], [59] and create the SBDS-1UIP method. Lazy Clause Generation generates 1UIP nogood [60] to help reducing search in constraint programming. Once a 1UIP nogood is generated upon backtrack, its symmetric parts are also posted as nogoods. SBDS-1UIP can exploit symmetries that cannot be exploited by other static or dynamic symmetry breaking methods.</paragraph><paragraph>Another dynamic symmetry breaking method is by constructing GE-trees [8] which is a search tree containing a unique representative of each class of full assignments. Such a search tree also has the property that no node is isomorphic to any other node. Puget [61] proposes dynamic lexicographic constraints (DLC) to use a dynamic variable order (the one used during search) in the lexicographic constraints to avoid incompatibility with search heuristics.</paragraph><paragraph>Sellmann and Van Hentenryck [62] devise a polytime dominance tester for eliminating all symmetries of interchangeable variables and values. Flener et al. [63] also propose dominance detection search for other tractable symmetries such as piecewise variable and value symmetry. They prove intractability results for some classes of CSPs to show the limits of dominance-detection based symmetry breaking methods. To detect and break symmetries partially, Prestwich et al. [64] propose Symmetry Breaking by Nonstationary Optimisation (SBNO) which combines local search with standard backtrack search.</paragraph><paragraph>Most recent successful symmetry breaking work has been static in nature, as evidenced by Walsh's Spotlight Talk [13] at AAAI 2012. Our starting point is partial SBDS which is general and can cater for all symmetry types. The overhead of SBDS is big in general. Partial symmetry breaking trades completeness for efficiency by breaking on a subset of symmetries. By carefully controlling the overheads and cleverly breaking symmetry compositions in the context of partial symmetry breaking, we come up with dynamic methods that are competitive both theoretically and practically against the state of the art static methods, and yet enjoy the benefits of the dynamic approaches.</paragraph></section></section><section label="7"><section-title>Concluding remarks</section-title><paragraph>Our contributions are eight fold. First, we have identified the inadequacy of ParSBDS in pruning symmetric solutions with respect to LexLeader. Based on this observation, second, we propose ReSBDS which can utilize symmetry breaking constraints' information to break extra symmetry compositions with low overhead. Third, we give formally the time complexity, soundness and termination of ReSBDS and theoretical comparisons against ParSBDS, LexLeader, DoubleLex, SnakeLex and LDSB. Fourth, ReSBDS is shown to be complete to break all interchangeable variables (values) given only generators when the variable (value) ordering is fixed. Fifth, we also propose a light version of ReSBDS, LReSBDS, which can break extra symmetry compositions without recording assignments, and thus has lower overhead than ReSBDS. Sixth, we give formally the soundness and termination of LReSBDS and theoretical comparisons against ReSBDS, ParSBDS, LexLeader, DoubleLex, SnakeLex and LDSB. Seventh, LReSBDS is also shown to be complete to break all interchangeable variables (values) given only generators when the variable (value) ordering is fixed. Eighth, we demonstrate empirically the efficiency of ReSBDS and LReSBDS against state of the art static and dynamic methods via extensive experimentation.</paragraph><section-title>Acknowledgements</section-title></section></content><acknowledgements><paragraph>We are grateful to the insightful comments and valuable suggestions by the anonymous reviewers of AAAI'14, CP'14 and the Artificial Intelligence Journal. Zhizhen Ye's assistance with lots of last minute experimentation work is much appreciated. This research has been supported by the grant CUHK413713 from the Research Grants Council, University Grants Committee of Hong Kong SAR and a Direct Grant from The Chinese University of Hong Kong.</paragraph></acknowledgements><references><reference label="[1]"><authors>A.K. Mackworth</authors><title>Consistency in networks of relations</title><host>Artif. Intell.8 (1)(1977) pp.99-118</host></reference><reference label="[2]"><authors>J.-F. Puget</authors><title>On the satisfiability of symmetrical constrained satisfaction problems</title><host>Proceedings of the 7th International Symposium on Methodologies for Intelligent Systems(1993) pp.350-361</host></reference><reference label="[3]"><authors>J. Crawford,M. Ginsberg,E. Luks,A. Roy</authors><title>Symmetry breaking predicates for search problems</title><host>Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning(1996) pp.148-159</host></reference><reference label="[4]"><authors>P. Flener,A. Frisch,B. Hnich,Z. Kiziltan,I. Miguel,J. Pearson,T. Walsh</authors><title>Breaking row and column symmetries in matrix models</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.187-192</host></reference><reference label="[5]"><authors>Y.C. Law,J. Lee</authors><title>Global constraints for integer and set value precedence</title><host>Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming(2004) pp.362-376</host></reference><reference label="[6]"><authors>T. Fahle,S. Schamberger,M. Sellmann</authors><title>Symmetry breaking</title><host>Proceedings of the 7th International Conference on Principles and Practice of Constraint Programming(2001) pp.93-107</host></reference><reference label="[7]"><authors>I. Gent,B. Smith</authors><title>Symmetry breaking in constraint programming</title><host>Proceedings of the 14th European Conference on Artificial Intelligence(2000) pp.599-603</host></reference><reference label="[8]"><authors>C.M. Roney-Dougal,I.P. Gent,T. Kelsey,S. Linton</authors><title>Tractable symmetry breaking using restricted search trees</title><host>Proceedings of the 16th European Conference on Artificial Intelligence(2004) pp.211-215</host></reference><reference label="[9]"><authors>K.E. Petrie,B.M. Smith</authors><title>Symmetry breaking in graceful graphs</title><host>Proceedings of the 9th International Conference on Principles and Practice of Constraint Programming(2003) pp.930-934</host></reference><reference label="[10]"><authors>I. McDonald,B. Smith</authors><title>Partial symmetry breaking</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.431-445</host></reference><reference label="[11]"><authors>C. Mears,M.G. de la Banda,B. Demoen,M. Wallace</authors><title>Lightweight dynamic symmetry breaking</title><host>Constraints19 (3)(2014) pp.195-242</host></reference><reference label="[12]"><authors>J.H. Lee,J. Li</authors><title>Increasing symmetry breaking by preserving target symmetries</title><host>Proceedings of the 18th International Conference on Principles and Practice of Constraint Programming(2012) pp.422-438</host></reference><reference label="[13]"><authors>T. Walsh</authors><title>Symmetry breaking constraints: recent results</title><host>Proceedings of the 26th AAAI Conference on Artificial Intelligence(2012) pp.2192-2198</host></reference><reference label="[14]"><authors>T. Walsh</authors><title>General symmetry breaking constraints</title><host>Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming(2006) pp.650-664</host></reference><reference label="[15]"><authors>A. Frisch,I. Miguel,Z. Kiziltan,B. Hnich,T. Walsh</authors><title>Multiset ordering constraints</title><host>Proceedings of the 18th International Joint Conference on Artificial Intelligence(2003) pp.221-226</host></reference><reference label="[16]"><authors>A. Frisch,C. Jefferson,I. Miguel</authors><title>Constraints for breaking more row and column symmetries</title><host>Proceedings of the 9th International Conference on Principles and Practice of Constraint Programming(2003) pp.318-332</host></reference><reference label="[17]"><authors>J. Puget</authors><title>Breaking symmetries in all different problems</title><host>Proceedings of the 19th International Joint Conference on Artificial Intelligence(2005) pp.272-277</host></reference><reference label="[18]"><authors>Y. Law,J. Lee</authors><title>Symmetry breaking constraints for value symmetries in constraint satisfaction</title><host>Constraints (2006) pp.221-267</host></reference><reference label="[19]"><authors>Y.C. Law,J. Lee,T. Walsh,J. Yip</authors><title>Breaking symmetry of interchangeable variables and values</title><host>Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming(2007) pp.423-437</host></reference><reference label="[20]"><authors>G. Katsirelos,N. Narodytska,T. Walsh</authors><title>Combining symmetry breaking and global constraints</title><host>Recent Advances in Constraints(2009)Springer pp.84-98</host></reference><reference label="[21]"><authors>A. Grayland,I. Miguel,C.M. Roney-Dougal</authors><title>Snake Lex: an alternative to Double Lex</title><host>Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming(2009) pp.391-399</host></reference><reference label="[22]"><authors>J. Yip,P. Van Hentenryck</authors><title>Symmetry breaking via LexLeader feasibility checkers</title><host>Proceedings of the 22th International Joint Conference on Artificial Intelligence(2011) pp.687-692</host></reference><reference label="[23]"><authors>N. Narodytska,T. Walsh</authors><title>Breaking symmetry with different orderings</title><host>Proceedings of the 19th International Conference on Principles and Practice of Constraint Programming(2013) pp.545-561</host></reference><reference label="[24]"><authors>J. Lee,Z. Zhu</authors><title>An increasing-nogoods global constraint for symmetry breaking during search</title><host>Proceedings of the 20th International Conference on Principles and Practice of Constraint Programming(2014) pp.465-480</host></reference><reference label="[25]"><authors>J. Lee,Z. Zhu</authors><title>Filtering nogoods lazily in dynamic symmetry breaking during search</title><host>Proceedings of the 24th International Joint Conference on Artificial Intelligence(2015) pp.339-345</host></reference><reference label="[26]"><authors>J. Lee,Z. Zhu</authors><title>Breaking more composition symmetries using search heuristics</title><host>Proceedings of the 30th AAAI Conference on Artificial Intelligence(2016) pp.3418-3425</host></reference><reference label="[27]"><authors>J. Lee,Z. Zhu</authors><title>Boosting SBDS for partial symmetry breaking in constraint programming</title><host>Proceedings of the 28th AAAI Conference on Artificial Intelligence(2014) pp.2695-2702</host></reference><reference label="[28]"><authors>F. Rossi,P. Van Beek,T. Walsh</authors><title>Handbook of Constraint Programming</title><host>(2006)Elsevier</host></reference><reference label="[29]"><authors>A. Frisch,B. Hnich,Z. Kiziltan,I. Miguel,T. Walsh</authors><title>Global constraints for lexicographic orderings</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.93-108</host></reference><reference label="[30]"><authors>J.-F. Puget</authors><title>An efficient way of breaking value symmetries</title><host>Proceedings of the 21st AAAI Conference on Artificial Intelligence(2006) pp.117-122</host></reference><reference label="[31]"><authors>J.-F. Puget</authors><title>A comparison of SBDS and Dynamic Lex Constraints</title><host>The Sixth International Workshop on Symmetry and Constraint Satisfaction Problems(2006) pp.56-60</host></reference><reference label="[32]"><authors>T. Walsh</authors><title>Breaking value symmetry</title><host>Proceedings of the 13th International Conference on Principles and Practice of Constraint Programming(2007) pp.880-887</host></reference><reference label="[33]"><authors>C. Schulte,P.J. Stuckey</authors><title>Efficient constraint propagation engines</title><host>ACM Trans. Program. Lang. Syst.31 (1)(2008) pp.2:1-2:43</host></reference><reference label="[34]"><authors>I. Gent,C. Jefferson,I. Miguel</authors><title>Watched literals for constraint propagation in Minion</title><host>Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming(2006) pp.182-197</host></reference><reference label="[35]"><authors>J.-F. Puget</authors><title>Breaking all value symmetries in surjection problems</title><host>Proceedings of the 11th International Conference on Principles and Practice of Constraint Programming(2005) pp.490-504</host></reference><reference label="[36]"><authors>G. Chu,P. Stuckey,M. de la Banda,C. Mears</authors><title>Symmetries and lazy clause generation</title><host>Proceedings of the 22nd International Joint Conference on Artificial Intelligence(2011) pp.516-521</host></reference><reference label="[37]"><authors>I.P. Gent,W. Harvey,T. Kelsey,S. Linton</authors><title>Generic SBDD using computational group theory</title><host>Proceedings of the 9th International Conference on Principles and Practice of Constraint Programming(2003) pp.333-347</host></reference><reference label="[38]"><authors>I.P. Gent,W. Harvey,T. Kelsey</authors><title>Groups and constraints: symmetry breaking during search</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.415-430</host></reference><reference label="[39]">PassMark Software, Passmark CPU markhttps://www.cpubenchmark.net/cpu_list.php(2017)captured on 7 May 2017</reference><reference label="[40]"><authors>I. Gent,T. Walsh</authors><title>CSPLib: a benchmark library for constraints</title><host>Proceedings of the 5th International Conference on Principles and Practice of Constraint Programming(1999) pp.480-481</host></reference><reference label="[41]">K. PetrieCombining SBDS and SBDDTech. Rep., APES-86-2004(2004)available from<host>http://www.dcs.st-and.ac.uk/apes/apesreports.html</host></reference><reference label="[42]"><authors>T. Kelsey,S. Linton,C. Roney-Dougal</authors><title>New developments in symmetry breaking in search using computational group theory</title><host>Artificial Intelligence and Symbolic Computation(2004) pp.199-210</host></reference><reference label="[43]"><authors>J.-F. Puget</authors><title>Elimination des symétries dans les problemes injectifs</title><host>Premières Journées Francophones de Programmation par Contraintes(2005) pp.259-266</host></reference><reference label="[44]"><authors>B. Hnich,S.D. Prestwich,E. Selensky,B.M. Smith</authors><title>Constraint models for the covering test problem</title><host>Constraints (2006) pp.199-219</host></reference><reference label="[45]">G. ChuImproving Combinatorial OptimizationPh.D. thesis<host>(2011)The University of Melbourne</host></reference><reference label="[46]">Y. Kim, D.-H. Jang, C.M. Anderson-Cook, Selecting the best wild card entries in a covering array, Quality and Reliability Engineering International.</reference><reference label="[47]"><authors>F. Aloul,K. Sakallah,I. Markov</authors><title>Efficient symmetry breaking for Boolean Satisfiability</title><host>Proceedings of the 18th International Joint Conference on Artificial Intelligence(2003) pp.271-276</host></reference><reference label="[48]">M. Carlsson,N. BeldiceanuRevisiting the Lexicographic Ordering ConstraintTech. Rep. T2002-17<host>(2002)Swedish Institute of Computer Science</host></reference><reference label="[49]">M. Carlsson,N. BeldiceanuArc-Consistency for a Chain of Lexicographic Ordering ConstraintsTech. Rep. T2002-18<host>(2002)Swedish Institute of Computer Science</host></reference><reference label="[50]"><authors>B. Benhamou</authors><title>Study of symmetry in Constraint Satisfaction Problems</title><host>Proceedings of the 2nd Workshop on Principles and Practice of Constraint Programming(1994) pp.246-254</host></reference><reference label="[51]"><authors>I. Gent</authors><title>A symmetry breaking constraint for indistinguishable values</title><host>Proceedings of the 1st International Workshop on Symmetry in Constraint Satisfaction Problems(2001) pp.469-473</host></reference><reference label="[52]"><authors>T. Walsh</authors><title>Symmetry breaking using value precedence</title><host>Proceedings of the 17th European Conference on Artificial Intelligence(2006) pp.168-172</host></reference><reference label="[53]"><authors>R. Backofen,S. Will</authors><title>Excluding symmetries in constraint-based search</title><host>Proceedings of the 5th International Conference on Principles and Practice of Constraint Programming(1999) pp.73-87</host></reference><reference label="[54]"><authors>F. Focacci,M. Milano</authors><title>Global cut framework for removing symmetries</title><host>Proceedings of the 7th International Conference on Principles and Practice of Constraint Programming(2001) pp.77-92</host></reference><reference label="[55]"><authors>J.-F. Puget</authors><title>Symmetry breaking revisited</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.446-461</host></reference><reference label="[56]"><authors>N. Barnier,P. Brisset</authors><title>Solving the Kirkman's schoolgirl problem in a few seconds</title><host>Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming(2002) pp.477-491</host></reference><reference label="[57]"><authors>B. Benhamou,T. Nabhani,R. Ostrowski,M.R. Saidi</authors><title>Enhancing clause learning by symmetry in SAT solvers</title><host>ICTAI'10(2010) pp.329-335</host></reference><reference label="[58]"><authors>T. Feydy,P.J. Stuckey</authors><title>Lazy clause generation reengineered</title><host>Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming(2009) pp.352-366</host></reference><reference label="[59]"><authors>O. Ohrimenko,P. Stuckey,M. Codish</authors><title>Propagation via lazy clause generation</title><host>Constraints (2009) pp.357-391</host></reference><reference label="[60]"><authors>M.W. Moskewicz,C.F. Madigan,Y. Zhao,L. Zhang,S. Malik</authors><title>Chaff: engineering an efficient SAT solver</title><host>Proceedings of the 38th annual Design Automation Conference(2001) pp.530-535</host></reference><reference label="[61]"><authors>J.-F. Puget</authors><title>Dynamic Lex constraints</title><host>Proceedings of the 12th International Conference on Principles and Practice of Constraint Programming(2006)Springer pp.453-467</host></reference><reference label="[62]"><authors>M. Sellmann,P. Van Hentenryck</authors><title>Structural symmetry breaking</title><host>Proceedings of the 19th International Joint Conference on Artificial Intelligence(2005) pp.298-303</host></reference><reference label="[63]"><authors>P. Flener,J. Pearson,M. Sellmann,P. Van Hentenryck,M. Ågren</authors><title>Dynamic structural symmetry breaking for constraint satisfaction problems</title><host>Constraints14 (4)(2009) pp.506-538</host></reference><reference label="[64]"><authors>S.D. Prestwich,B. Hnich,H. Simonis,R. Rossi,S.A. Tarim</authors><title>Partial symmetry breaking by local search in the group</title><host>Constraints17 (2)(2012) pp.148-171</host></reference></references><footnote><note-para label="1">In GitHub https://github.com/zichenzu/Recursive-SBDS, the implementation of ReSBDS is given with the help of N-Queens as an illustrative example.</note-para><note-para label="2">In GitHub https://github.com/zichenzu/Light-Recursive-SBDS, the implementation of LReSBDS is further given with the help of N-Queens as an illustrative example.</note-para></footnote></root>