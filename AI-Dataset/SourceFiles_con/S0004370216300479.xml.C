<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Bounded situation calculus action theories.
   </title>
   <abstract>
    In this paper,1 we investigate bounded action theories in the situation calculus. A bounded action theory is one which entails that, in every situation, the number of object tuples in the extension of fluents is bounded by a given constant, although such extensions are in general different across the infinitely many situations. We argue that such theories are common in applications, either because facts do not persist indefinitely or because the agent eventually forgets some facts, as new ones are learned. We discuss various classes of bounded action theories. Then we show that verification of a powerful first-order variant of the μ-calculus is decidable for such theories. Notably, this variant supports a controlled form of quantification across situations. We also show that through verification, we can actually check whether an arbitrary action theory maintains boundedness.
   </abstract>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The situation calculus [65], [75] is a well-known first-order formalism with certain second-order features for representing dynamically changing worlds. It has proved to be an invaluable formal tool for understanding the subtle issues involved in reasoning about action. Its comprehensiveness allows us to place all aspects of dynamic systems in perspective. Basic action theories let us capture change as a result of actions in the system [73], while high-level languages such as Golog[58] and ConGolog[26] support the representation of processes over the dynamic system. Aspects such as time [74], knowledge and sensing [79], probabilities and utilities [14], and preferences [11], have all been addressed. The price of such a generality is that decidability results for reasoning in the situation calculus are rare, e.g., [86] for an argument-less fluents fragment, and [49] for a description logic-like two-variable fragment. Obviously, we have the major feature of being able to rely on regression to reduce reasoning about a given future situation to reasoning about the initial situation [75]. Generalizations of this basic result such as just-in-time histories [33] can also be exploited. However, when we move to temporal properties, virtually all approaches are based on assuming a finite domain and a finite number of states, and often rely on propositional modal logics and model checking techniques [6], [63]. There are only few exceptions such as [21], [32], [82], which develop incomplete fixpoint approximation-based methods.
     </paragraph>
     <paragraph>
      In this paper, we present an important new result on decidability of the situation calculus, showing that verification of bounded action theories is decidable. Bounded action theories are basic action theories [75], where it is entailed that in all situations, the number of object tuples that belong to the extension of any fluent is bounded. In such theories, the object domain remains nonetheless infinite and an infinite run may involve an infinite number of objects, though at every single situation the number of objects we predicate on is finite and, in fact, bounded.
     </paragraph>
     <paragraph>
      But why should we believe that practical domains conform to this boundedness assumption? While it is often assumed that the law of inertia applies and that fluent atoms persist indefinitely in the absence of actions that affect them, we all know that pretty much everything eventually decays and changes. We may not even know how the change may happen, but nevertheless know that it will. Another line of argument for boundedness is epistemic. Agents remember facts that they use and periodically try to confirm them, often by sensing. A fact that never gets used is eventually forgotten. If a fact can never be confirmed, it may be given up as too uncertain. Given this, it seems plausible that in several contexts an agent's knowledge, in every single moment, can be assumed to be bounded. While these philosophical arguments are interesting and relate to some deep questions about knowledge representation, one may take a more pragmatic stance, and this is what we do here. We identify some interesting classes of bounded action theories and show how they can model typical example domains. We also show how we can transform arbitrary basic action theories into bounded action theories, either by blocking actions that would exceed the bound, or by having persistence (frame axioms) apply only for a finite number of steps. Moreover we show that we can effectively check whether any arbitrary theory with a bounded initial situation description remains bounded in all executable situations (to do so we need to use verification).
     </paragraph>
     <paragraph>
      The main result of the paper is that verification of an expressive class of first-order μ-calculus temporal properties in bounded action theories is decidable and, precisely, EXPTIME-complete. This means that we can check whether a system or process specified over such a theory satisfies some specification even if we have an infinite domain and an infinite set of situations or states. In a nutshell, we prove our results by focussing on the active domain of situations, i.e., the set of objects for which some atomic fluent holds; we know that the set of such active objects is bounded. We show that essentially we can abstract situations whose active domains are isomorphic into a single state, and thus, by suitably abstracting also actions, we can obtain an abstract finite transition system that satisfies exactly the same formulas of our variant of the μ-calculus.
     </paragraph>
     <paragraph>
      This work is of interest not only for AI, but also for other areas of computer science. In particular it is of great interest for the work on data-aware business processes and services [53], [45], [38]. Indeed while there are well-established results and tools to analyze business processes and services, without considering the data manipulated, when data are taken into account results are scarce. The present work complements that in, e.g., [37], [4], [9], [5], [10], and hints at an even more profound relevance of the situation calculus in those areas [64]. More generally, our results can be recast in other formalisms for reasoning about action, both in AI and in CS.
     </paragraph>
     <paragraph>
      The rest of the paper is organized as follows. In Section 2, we briefly review the situation calculus and basic action theories. Then in Section 3, we define bounded action theories. Then, in Section 4, we discuss various ways of obtaining bounded action theories, while showing that many practical domains can be handled. In Section 5, we introduce the {a mathematical formula}μLp language that we use to express first-order temporal properties. After that, we show that verification of {a mathematical formula}μLp properties over bounded action theories is decidable, first in the case where we have complete information about the initial situation (Section 6), and then in the general incomplete information case (Section 7). In Section 8, we characterize the worst-case computational complexity of the problem as EXPTIME-complete. In Section 9, we give a technique based on our verification results, to check whether an arbitrary basic action theory maintains boundedness. In Section 10, we review the related literature. Finally, in Section 11, we conclude the paper by discussing future work topics.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      The situation calculus[65], [75] is a sorted predicate logic language for representing and reasoning about dynamically changing worlds. All changes to the world are the result of actions, which are terms in the language. We denote action variables by lower case letters a, action types by capital letters A, and action terms by α, possibly with subscripts. A possible world history is represented by a term called a situation. The constant {a mathematical formula}S0 is used to denote the initial situation where no actions have yet been performed. Sequences of actions are built using the function symbol do, where {a mathematical formula}do(a,s) denotes the successor situation resulting from performing action a in situation s. Besides actions and situations, there is also the sort of objects for all other entities. Predicates and functions whose value varies from situation to situation are called fluents, and are denoted by symbols taking a situation term as their last argument (e.g., {a mathematical formula}Holding(x,s), meaning that the robot is holding object x in situation s). For simplicity, and without loss of generality, we assume that there are no functions other than constants and no non-fluent predicates. We denote fluents by F and the finite set of primitive fluents by {a mathematical formula}F. The arguments of fluents (apart from the last argument which is of sort situation) are assumed to be of sort object.
     </paragraph>
     <paragraph>
      Within this language, one can formulate action theories that describe how the world changes as the result of the available actions. Here, we concentrate on basic action theories as proposed in [67], [75]. We also assume that there is a finite number of action types. Moreover, we assume that there is a countably infinite set of object constants {a mathematical formula}N for which the unique name assumption holds. However, we do not assume domain closure for objects.{sup:2} As a result, a basic action theory {a mathematical formula}D is the union of the following disjoint sets of first-order (FO) and second-order (SO) axioms:
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}D0: (FO) initial situation description axioms describing the initial configuration of the world (such a description may be complete or incomplete);
      </list-item>
      <list-item label="•">
       {a mathematical formula}Dposs: (FO) precondition axioms of the form{a mathematical formula} one per action type, stating the conditions {a mathematical formula}ϕA(x→,s) under which an action {a mathematical formula}A(x→) can be legally performed in situation s; these use a special predicate {a mathematical formula}Poss(a,s) meaning that action a is executable in situation s; {a mathematical formula}ϕA(x→,s) is a formula of the situation calculus that is uniform in s. A formula is uniform in s if it mentions no other situation term but s and does not mention Poss (see [75] for a formal definition);
      </list-item>
      <list-item label="•">
       {a mathematical formula}Dssa: (FO) successor state axioms of the form{a mathematical formula} one per fluent, describing how the fluent changes when an action is performed; the right-hand side (RHS) {a mathematical formula}ϕF(x→,a,s) is again a situation calculus formula uniform in s; successor state axioms encode the causal laws of the world being modeled; they take the place of the so-called effect axioms and provide a solution to the frame problem;
      </list-item>
      <list-item label="•">
       {a mathematical formula}Dca: (FO) unique name axioms for actions and (FO) domain closure on action types;
      </list-item>
      <list-item label="•">
       {a mathematical formula}Duno: (FO) unique name axioms for object constants in {a mathematical formula}N;
      </list-item>
      <list-item label="•">
       Σ: (SO) foundational, domain independent, axioms of the situation calculus [67].
      </list-item>
     </list>
     <paragraph>
      We say that a situation s is executable, written {a mathematical formula}Executable(s), if every action performed in reaching s was executable in the situation in which it occurred.
     </paragraph>
     <paragraph>
      One of the key features of basic action theories is the existence of a sound and complete regression mechanism for answering queries about situations resulting from performing a sequence of actions [67], [75]. In a nutshell, the regression operator {a mathematical formula}R⁎ reduces a formula ϕ about a particular future situation to an equivalent formula {a mathematical formula}R⁎[ϕ] about the initial situation {a mathematical formula}S0, by basically substituting fluent relations with the right-hand side formula of their successor state axioms. Here, we shall use a simple one-step only variant {a mathematical formula}R of the standard regression operator {a mathematical formula}R⁎ for basic action theories. Let {a mathematical formula}ϕ(do(α,s)) be a formula uniform in the situation {a mathematical formula}do(α,s). Then {a mathematical formula}R[ϕ(do(α,s))] stands for the one-step regression of ϕ through the action term α, which is itself a formula uniform in s.
     </paragraph>
    </section>
    <section label="3">
     <section-title>
      Bounded action theories
     </section-title>
     <paragraph>
      Let b be some natural number. We use the notation {a mathematical formula}|{x→|ϕ(x→)}|≥b, meaning that there exist at least b distinct tuples that satisfy ϕ, to stand for the following first-order logic (FOL) formula:{a mathematical formula} We also use the notation {a mathematical formula}|{x→|ϕ(x→)}|&lt;b, meaning that there are fewer than b distinct tuples that satisfy ϕ, to stand for: {a mathematical formula}¬(|{x→|ϕ(x→)}|≥b).
     </paragraph>
     <paragraph>
      Using this, we define the notion of a fluent {a mathematical formula}F(x→,s) in situation s being bounded by a natural number b as follows:{a mathematical formula} i.e., fluent F is bounded by b in situation s if there are fewer than b distinct tuples in the extension of F in situation s.
     </paragraph>
     <paragraph>
      The notion of situation s being bounded by a natural number b is defined as follows:{a mathematical formula} i.e., every fluent is bounded by b in situation s.
     </paragraph>
     <paragraph>
      We say that an action theory {a mathematical formula}D is bounded by b if every executable situation is bounded by b, formally:{a mathematical formula}
     </paragraph>
     <paragraph label="Example 1">
      Consider a warehouse where items are moved around by a robot (a similar example is formalized in [31]). There are k storage locations where items can be stored. There is also a shipping dock where new items may arrive and stored items may be shipped out. We can axiomatize this domain as follows.We have the following action precondition axioms{sup:3}:{a mathematical formula} The first axiom says that, in situation s, the robot can perform action {a mathematical formula}move(x,l,l′), i.e., move object x from location l to {a mathematical formula}l′, if and only if x is at l in s and {a mathematical formula}l′ is a location where no object is present in s. The second precondition axiom says that action {a mathematical formula}arrive(x) is executable in situation s, i.e., object x may arrive at the warehouse in s, if and only if the shipping dock is empty and x is not somewhere else in the warehouse. The last axiom says that object x can be shipped in situation s if it is at the shipping dock in s.For the fluent At, we have the following successor state axiom:{a mathematical formula} where{a mathematical formula} This says that object x is at location l in the situation that results from doing action a in s if and only if {a mathematical formula}γ+(x,l,a,s) holds or if x is already at l in s and {a mathematical formula}γ−(x,l,a,s) does not hold. {a mathematical formula}γ+(x,l,a,s) specifies the conditions under which action a makes object x be at location l in situation s, i.e., if a is to move x to a free location l from another location {a mathematical formula}l′ where x was in s, or a is x arriving and l is the shipping dock. {a mathematical formula}γ−(x,l,a,s) specifies the conditions under which action a makes object x cease to be at location l in situation s, i.e., a is to move x to a different location that is free, or is to ship x.We specify the initial situation with the following initial state axioms:{a mathematical formula} We also have unique name axioms for the locations. For clarity, {a mathematical formula}IsLoc is a non-fluent predicate, although it is easy to recast it as a fluent that is unaffected by any action.It is not difficult to show that this theory is bounded by {a mathematical formula}k+1. First note that there are {a mathematical formula}k+1 locations initially and the set of locations never changes, so {a mathematical formula}IsLoc is bounded by {a mathematical formula}k+1. For fluent At, it is initially bounded by 0, but the {a mathematical formula}arrive action can augment its extension. However, the action theory ensures there can be at most one item at each of the {a mathematical formula}k+1 locations. Thus At remains bounded by {a mathematical formula}k+1. Therefore, the theory is bounded by {a mathematical formula}k+1. Observe that, as there are infinitely many constants denoting distinct objects, effectively an unbounded number of items may be handled by subsequent {a mathematical formula}arrive, {a mathematical formula}move, and {a mathematical formula}ship actions. Despite this, the theory remains bounded. □
     </paragraph>
     <paragraph>
      We shall see that for bounded action theories, verification of sophisticated temporal properties is decidable.
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      Obtaining bounded action theories
     </section-title>
     <paragraph>
      Before focusing on verification, in this section we look at various interesting sufficient conditions that guarantee that a basic action theory is bounded. Later, in Section 9, we will see that it is actually possible to use verification to check whether any arbitrary basic action theory, with a bounded initial situation description, is indeed bounded.
     </paragraph>
     <section label="4.1">
      <section-title>
       Bounding by blocking
      </section-title>
      <paragraph>
       We observe that the formula {a mathematical formula}Boundedb(s) is a FO formula uniform in s and hence it is regressable for basic action theories. This allows us to introduce a first interesting class of bounded action theories. Indeed, from any basic action theory, we can immediately obtain a bounded action theory by simply blocking the execution of actions whenever the result would exceed the bound.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}D be a basic action theory. We define the bounded basic action theory {a mathematical formula}Db by replacing each action precondition axiom in {a mathematical formula}D of the form {a mathematical formula}Poss(a(x→),s)≡Φ(x→,s) by a precondition axiom of the form{a mathematical formula}
      </paragraph>
      <paragraph label="Theorem 1">
       Let{a mathematical formula}Dbe a basic action theory with the initial description{a mathematical formula}D0such that{a mathematical formula}D0⊨Boundedb(S0), for some b, and let{a mathematical formula}Dbbe the basic action theory obtained as discussed above. Then,{a mathematical formula}Dbis bounded by b.
      </paragraph>
      <paragraph label="Proof">
       By (1) it is guaranteed that any executable action leads to a bounded situation. Hence by induction on executable situations, we obtain the thesis.  □
      </paragraph>
      <paragraph label="Example 2">
       Suppose that we have a camera on a smartphone or tablet computer. We could model the storage of photos on the device using a fluent {a mathematical formula}PhotoStored(p,s), meaning that photo p is stored in the device's memory (in situation s). Such a fluent might have the following successor state axiom:{a mathematical formula} We may also assume that action {a mathematical formula}takePhoto(p) is always executable and that {a mathematical formula}deletePhoto(p) is executable in s if p is stored in s:{a mathematical formula}Now such a device would clearly have a limited capacity for storing photos. If we assume for simplicity that photos come in only one resolution and file size, then we can model this by simply applying the transformation discussed above. This yields the following modified precondition axioms:{a mathematical formula} Note how the condition on the right hand side of the first axiom above ensures there are fewer than b photos stored after the action of taking a photo p occurs. Clearly, the resulting theory is bounded by b (assuming that the original theory is bounded by b in {a mathematical formula}S0). □
      </paragraph>
      <paragraph>
       Note that this way of obtaining a bounded action theory is far from realistic in modeling the actual constraints on the storage of photos. One could develop a more accurate model, taking into account the size of photos, the memory management scheme used, etc. This would also yield a bounded action theory, though one whose boundedness is a consequence of a sophisticated model of memory capacity.
      </paragraph>
      <paragraph label="Example 3">
       Let's extend the previous example by supposing that the device also maintains a contacts directory. We could model this using a fluent {a mathematical formula}InPhoneDir(name,number,photo,s), with the following successor state axiom:{a mathematical formula} We could then apply our transformation to this new theory to obtain a bounded action theory, getting precondition axioms such as the following:{a mathematical formula} The resulting theory blocks actions from being performed whenever the action would result in a number of tuples in some fluent exceeding the bound. □
      </paragraph>
      <paragraph>
       We observe that this kind of bounded action theories are really modeling a capacity constraint on every fluent,{sup:4} which may block actions from being executed. As a result, an action may be executable in a situation in the original theory, but not executable in the bounded one. Thus an agent may want to “plan” to find a sequence of actions that would make the action executable again. In general, to avoid dead-ends, one should carefully choose the original action theory on which the bound is imposed, in particular there should always be actions that remove tuples from fluents.
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Effect bounded action theories
      </section-title>
      <paragraph>
       Let's consider another sufficient condition for boundedness. Without loss of generality we can take the general form of successor state axioms to be as follows:{a mathematical formula}
      </paragraph>
      <paragraph>
       We say that fluent F is effect bounded if, for every action a and situation s:{a mathematical formula} i.e., for every action and situation, the number of tuples added to the fluent is less than or equal to that deleted.
      </paragraph>
      <paragraph>
       We say that a basic action theory is effect bounded if every fluent {a mathematical formula}F∈F is effect bounded.
      </paragraph>
      <paragraph label="Proof">
       By induction on executable situations.  □
      </paragraph>
      <paragraph label="Example 4">
       Many axiomatizations of the Blocks World are not effect bounded. For instance, suppose that we have fluents {a mathematical formula}OnTable(x,s), i.e., block x is on the table in situation s, and {a mathematical formula}On(x,y,s), i.e., block x is on block y in situation s, with the following successor state axioms:{a mathematical formula} Then, performing the action {a mathematical formula}moveToTable(B1) will result in a net increase in the number of objects that are on the table (assuming that the action is executable and that B1 is not already on the table). Thus, fluent {a mathematical formula}OnTable is not effect bounded in this theory.However, it is easy to develop an alternative axiomatization of the Blocks World that is effect bounded. Suppose that we use only the fluent {a mathematical formula}On(x,y,s) and the single action {a mathematical formula}move(x,y), where y is either a block or the table, which is denoted by the constant {a mathematical formula}Table. We can axiomatize the domain dynamics as follows:{a mathematical formula} That is, x is on y after action a is performed in situation s if and only if a is moving x onto y or x is already on y in situation s and a does not involve moving x onto an object other than y. We say that {a mathematical formula}move(x,y) is executable in situation s if and only if x is not the table in s, x and y are distinct, x is clear and on something other than y in s, and y is clear unless it is the table in s:{a mathematical formula} Then it is easy to show that any occurrence of {a mathematical formula}move(x,y) in a situation s where the action is executable, adds {a mathematical formula}〈x,y〉 to {a mathematical formula}O={〈x′,y′〉|On(x′,y′,s)} while deleting {a mathematical formula}〈x,y″〉 for some {a mathematical formula}y″ s.t. {a mathematical formula}y″≠y, leaving {a mathematical formula}|O| unchanged. Note that we must require that x be on something in the action precondition axiom to get this. Any action other than {a mathematical formula}move(x,y) leaves O unchanged. Thus On is effect bounded.The precondition that x be on something for {a mathematical formula}move(x,y) to be executable means that we cannot move a new unknown block onto another or the table. We must of course impose restrictions on “moving new blocks in” if we want to preserve effect boundedness. One way to do this is to add an action {a mathematical formula}replace(x,y), i.e. replacing x by y. We can specify its preconditions as follows:{a mathematical formula} That is, {a mathematical formula}replace(x,y) is executable in situation s if and only if x and y are not the table and are distinct, x is clear and on something in s, and y is clear and not on something in s. We can modify the successor state axiom for On to be:{a mathematical formula} where {a mathematical formula}On(x,y) becomes true if x replaces z and z was on y in s, and {a mathematical formula}On(x,y) becomes false if z replaces x and x was on y in s. It is straightforward to show that this change leaves On effect bounded. □
      </paragraph>
      <paragraph label="Example 5">
       For another simple example (perhaps more practical), let's look at how we could specify the “favorite web sites” menu of an Internet application. We can assume that there is a fixed number of favorite web sites positions on the menu, say 1 to k. We can replace what is at position n on the menu by the URL u by performing the action {a mathematical formula}replace(n,u). This can be axiomatized as follows:{a mathematical formula} It is easy to show that in this axiomatization, {a mathematical formula}FavoriteSites is effect bounded. No action, including {a mathematical formula}replace(n,u), causes the extension of the fluent to increase. □
      </paragraph>
      <paragraph>
       The {a mathematical formula}FavoriteSites fluent is typical of many domain properties/relations, such as the passengers in a plane, the students in a class, or the cars parked in a parking lot, where we can think of the relation as having a finite capacity, and where we can reassign the objects that are in it. In some cases, the capacity bound may be difficult to pin down, e.g., the guests at a wedding, although the capacity is by no means unbounded. As well, there are definitely examples where we need an unbounded theory, e.g., to model a pushdown automata that can recognize a particular context-free language. The situation calculus is a very expressive language that accommodates this, for instance, it has been used to model Turing machines [75]. One might arguably want an unbounded “favorite sites” menu or contacts directory, although this seems hardly practical. Another interesting question is how such capacity constraints might apply to a complex agent such as a robot that is modeling its environment. Clearly, such a robot would have limitations with respect to how many environment features/objects/properties it can memorize and track. Finally, note that the condition {a mathematical formula}|{o→|ΦF+(o→,a,s)}|≤|{o′→|ΦF−(o′→,a,s)}| is not a FO formula and it is difficult (in fact, undecidable) in general to determine whether a basic action theory is effect bounded. But as our examples illustrate, there are many instances where it is easy to show that the bounded effects condition holds.
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       Fading fluents action theories
      </section-title>
      <paragraph>
       Fading fluents action theories are based on the idea that information over time loses strength and fades away unless it is reinforced explicitly. A fading fluents action theory with fading length given by a natural number ℓ is an action theory where a fluent {a mathematical formula}F(x→,s) is defined by making use of some auxiliary fluents {a mathematical formula}Fi(x→,s), for {a mathematical formula}0≤i≤ℓ where {a mathematical formula}F(x→,s)≐⋁0≤i≤ℓFi(x→,s) and the auxiliary fluents have successor state axioms of the following special form:{a mathematical formula} and for {a mathematical formula}0≤i&lt;ℓ we have:{a mathematical formula} Thus, tuples are initially added to {a mathematical formula}Fℓ, and progressively lose their strength, moving from {a mathematical formula}Fi to {a mathematical formula}Fi−1 each time an action occurs that does not delete or re-add them; eventually they move out of {a mathematical formula}F0 and are forgotten. Note that:
      </paragraph>
      <list>
       <list-item label="•">
        Technically, a fading fluents action theory is a basic action theory having as fluents only the auxiliary fluents.
       </list-item>
       <list-item label="•">
        It is simple to obtain a fading fluent version of any basic action theory.
       </list-item>
       <list-item label="•">
        It is often convenient to include explicit {a mathematical formula}refreshF(x→) actions, whose effect, when applied to a situation s, is simply to make {a mathematical formula}Fℓ(x→,do(refreshF(x→,s))) true, and {a mathematical formula}Fi(x→,do(refreshF(x→,s))) false for {a mathematical formula}0≤i&lt;ℓ. Similarly it may be convenient to include {a mathematical formula}forgetF(x→) actions, whose effect is to make {a mathematical formula}Fi(x→,do(forgetF(x→,s))) false, for all i.
       </list-item>
      </list>
      <paragraph label="Theorem 3">
       Let{a mathematical formula}Dbe a fading fluents action theory with fading length ℓ and initial database{a mathematical formula}D0such that{a mathematical formula}D0⊨Boundedb(S0), for some b. Then,{a mathematical formula}Dis bounded by b.
      </paragraph>
      <paragraph label="Proof">
       By induction on executable situations. For the base case, we have that initially for each fluent, we have at most b facts, hence {a mathematical formula}S0 is bounded by b. For the inductive case, by the inductive hypothesis we have that {a mathematical formula}Boundedb(s). Now, take an arbitrary action {a mathematical formula}a(t→), and an arbitrary fluent F. Then: (i){a mathematical formula}BoundedFℓ,b(do(a(t→),s)), since positive effects are bounded by b in its successor state axiom; and (ii) for all {a mathematical formula}0≤i&lt;ℓ, since {a mathematical formula}Fi depends on {a mathematical formula}Fi+1 in the previous situation in its successor state axioms, we have that {a mathematical formula}BoundedFi,b(do(a(t→),s)) since {a mathematical formula}BoundedFi+1,b(s) and in the worst case the whole extension of {a mathematical formula}Fi+1 in s is carried over to {a mathematical formula}Fi in {a mathematical formula}do(a(t→),s).  □
      </paragraph>
      <paragraph label="Example 6">
       Imagine a sort of “vacuum cleaner world” where a robotic vacuum cleaner may clean a room or region r[76]. If a room/region is used, then it becomes unclean. We could model this using a fluent {a mathematical formula}IsClean(r,s) with the following successor state axiom:{a mathematical formula} Clearly, cleanliness is a property that fades over time. By applying the proposed transformation to this specification, we obtain the following:{a mathematical formula} and for {a mathematical formula}0≤i&lt;ℓ we have:{a mathematical formula} This is a somewhat more realistic model where after ℓ steps, we forget about a room being clean. □
      </paragraph>
      <paragraph label="Example 7">
       Consider a robot that can move objects around. We might model this using a fluent {a mathematical formula}At(objet,location,s) with the following successor state axiom:{a mathematical formula} Here, {a mathematical formula}moveTo(o,l) represents the robot's moving object o to location l. We also have an action {a mathematical formula}observe(o,l) of observing that object o is at location l, a kind of exogenous action that might be produced by the robot's sensors. As well, we have another exogenous action {a mathematical formula}takeAway(o), representing another agent's taking object o to an unknown location. If the world is dynamic, most objects would not remain where they are indefinitely, even if the robot is unaware of anyone moving them. By applying the proposed transformation to this specification, we obtain a theory where information about the location of objects fades unless it is refreshed by the robot's observations or actions. After ℓ steps, the robot forgets the location of an object it has not observed or moved; moreover, this happens immediately if the object is taken away. □
      </paragraph>
      <paragraph label="Example 8">
       As a final example, consider a softbot that keeps track of which hosts are online. We might model this using a fluent {a mathematical formula}NonFaulty(host,s) with the following successor state axiom:{a mathematical formula} Here the action {a mathematical formula}pingS(h) means that the host h has been pinged successfully, and the action {a mathematical formula}pingF(h) means that the host h has not responded to a pinging within the allocated time. As time passes, we may not want to assume that currently non-faulty hosts remain non-faulty. If we apply the proposed transformation to this specification, we obtain a theory where information about hosts being non-faulty fades. The agent must periodically ping the host successfully to maintain its knowledge that the host is non-faulty. Notice that, obviously, the theory does not provide a full account of the mechanisms that regulate the hosts' availability, but only the knowledge that the softbot has about the hosts. □
      </paragraph>
      <paragraph>
       An interesting natural example of such fading representations is the pheromones left by insects. Note that it is also possible to model fading with time as opposed to fading with the number of actions, though in this case we have to bound how many actions can occur between clock ticks.
      </paragraph>
     </section>
    </section>
    <section label="5">
     <section-title>
      Expressing dynamic properties
     </section-title>
     <paragraph>
      To express properties about Situation Calculus action theories, we introduce a specific logic, inspired by the μ-calculus [40], [15], one of the most powerful temporal logics, subsuming, in the propositional setting, both linear time logics, such as Linear Temporal Logic (LTL) [69] and Property-Specification Language (PSL) [39], and branching time logics, such as Computational Tree Logic CTL [20] and CTL{sup:⁎}[41]. The main characteristic of the μ-calculus is its ability to express directly least and greatest fixpoints of (predicate-transformer) operators formed using formulas relating the current state to the next one. By using such fixpoint constructs one can easily express sophisticated properties defined by induction or co-induction. This is the reason why virtually all logics used in verification can be considered as fragments of the μ-calculus. Technically, the μ-calculus separates local properties, asserted on the current state or on states that are immediate successors of the current one, from properties talking about states that are arbitrarily far away from the current one [15]. The latter are expressed through the use of fixpoints. Our variant of the μ-calculus is able to express first-order properties over situations while, at the same time, allowing for a controlled form of first-order quantification across situations, inspired by [5], where the quantification ranges over objects that persist in the extension of some fluents across situations.
     </paragraph>
     <paragraph>
      Formally, we define the logic {a mathematical formula}μLp as:{a mathematical formula} In addition, we use the usual FOL abbreviations for ∨, ⊃, ≡, and ∀, plus the standard μ-calculus abbreviation {a mathematical formula}νZ.Φ=¬μZ.¬Φ[Z/¬Z], where we denote with {a mathematical formula}Φ[Z/¬Z] the formula obtained from Φ by substituting each occurrence of Z with ¬Z. Let us comment on some aspects of {a mathematical formula}μLp:
     </paragraph>
     <list>
      <list-item label="•">
       φ in the expression above is an arbitrary (possibly open) uniform situation-suppressed (i.e., with all situation arguments in fluents suppressed) situation calculus FO formula, in which the only constants that may appear are those explicitly mentioned in the situation calculus theory beyond {a mathematical formula}Duno, i.e., those occurring in {a mathematical formula}Dposs∪Dssa∪D0.{sup:5} Observe that quantification inside φ is not subject to any restriction; in particular, {a mathematical formula}live(⋅) is not required.
      </list-item>
      <list-item label="•">
       Z is an SO (0-ary) predicate variable, denoting a set of situations (the SO assignment to Z is parameterized by the FO assignment to the individual variables, see later).
      </list-item>
      <list-item label="•">
       {a mathematical formula}μZ.Φ and {a mathematical formula}νZ.Φ are fixpoint formulas which denote, respectively, the least and the greatest fixpoint of the formula Φ seen as a predicate transformer {a mathematical formula}λZ.Φ on sets of situations. To guarantee the existence of fixpoints, as usual in the μ-calculus, formulas of the form {a mathematical formula}μZ.Φ and {a mathematical formula}νZ.Φ must satisfy syntactic monotonicity of Φ with respect to Z, which states that every occurrence of the variable Z in Φ must be within the scope of an even number of negation symbols.
      </list-item>
      <list-item label="•">
       {a mathematical formula}μZ.Φ and {a mathematical formula}νZ.Φ may contain free individual variables, which are those of Φ; technically, these act as parameters of the fixpoint formula, i.e., the value of fixpoints {a mathematical formula}μZ.Φ and {a mathematical formula}νZ.Φ is determined only once an assignment to the free individual variables is given, see, e.g., [59] (Chap. 10).
      </list-item>
      <list-item label="•">
       {a mathematical formula}live(x1,…,xn) stands for {a mathematical formula}⋀i∈{1,…,n}live(xi). We assume that in {a mathematical formula}live(x→)∧〈−〉Φ and {a mathematical formula}live(x→)∧[−]Φ, the variables {a mathematical formula}x→ are exactly the free individual variables of Φ, after we have substituted each bound predicate variable Z in Φ by the corresponding binding fixpoint formula {a mathematical formula}μZ.Φ′ or {a mathematical formula}νZ.Φ′. Observe that Z is not further substituted in {a mathematical formula}Φ′.{sup:6}
      </list-item>
      <list-item label="•">
       The Boolean connectives have their usual meaning. Quantification over individuals in {a mathematical formula}∃x.live(x)∧Φ and {a mathematical formula}∀x.live(x)⊃Φ (i.e., {a mathematical formula}¬∃x.live(x)∧¬Φ) has the expected meaning, with the proviso that individuals over which quantification ranges must belong to the active domain of the current situation, i.e., belong to the extension of some fluent in the current situation, as required by {a mathematical formula}live(⋅).
      </list-item>
      <list-item label="•">
       Intuitively, the use of {a mathematical formula}live(⋅) in {a mathematical formula}μLp ensures that objects are only considered in quantification across situations if they persist along the system evolution, while the evaluation of a formula with objects that are not present in the current extension of the fluents trivially evaluates to either false for ∃ or true for ∀. In particular:
      </list-item>
     </list>
     <paragraph>
      Next we turn to semantics. Since {a mathematical formula}μLp contains formulas with free individual and predicate variables, given a model {a mathematical formula}M of an action theory {a mathematical formula}D with object domain Δ and situation domain {a mathematical formula}S, we introduce a valuation{a mathematical formula}(v,V) formed by an individual variable valuation v which maps each individual variable x to an object {a mathematical formula}v(x) in Δ, and a parameterized predicate variable valuation V, which, given the valuation of the individual variables v, maps each predicate variable Z to a subset {a mathematical formula}V(v,Z) of situations in {a mathematical formula}S (notice that for each individual variable valuation v the mapping may change). Given a valuation {a mathematical formula}(v,V), we denote by {a mathematical formula}(v,V)[x/d] the valuation {a mathematical formula}(v′,V′) such that: (i) for every individual variable {a mathematical formula}y≠x, we have that {a mathematical formula}v′(y)=v(y) and {a mathematical formula}v′(x)=d, (ii) for every predicate variable Z, we have that {a mathematical formula}V′(v′,Z)=V(v′,Z). Sometimes we also use the notation {a mathematical formula}v[x→/d→], to denote the valuation {a mathematical formula}v′ such that, for every individual variable y that is not a component of {a mathematical formula}x→, we have {a mathematical formula}v′(y)=v(y), and {a mathematical formula}v′(xi)=di for all components {a mathematical formula}xi of {a mathematical formula}x→. Analogously, we denote by {a mathematical formula}(v,V)[Z/E] the valuation {a mathematical formula}(v′,V′) such that: (i) for every individual variable x, we have {a mathematical formula}v′(x)=v(x), (ii) for every predicate variable {a mathematical formula}Y≠Z, we have {a mathematical formula}V′(v′,Y)=V(v,Y), and (iii){a mathematical formula}V′(v′,Z)=E. Also we denote by {a mathematical formula}adomM(s), the active (object) domain of situation s in the model {a mathematical formula}M, which is the set of all objects occurring in some {a mathematical formula}FM(s) ({a mathematical formula}F∈F) or as the denotation in {a mathematical formula}M of a constant in the set C of object constants occurring in {a mathematical formula}Dposs∪Dssa∪D0. Then, we assign semantics to formulas by associating to a model {a mathematical formula}M and a valuation {a mathematical formula}(v,V), an extension function{a mathematical formula}(⋅)(v,V)M which maps {a mathematical formula}μLp formulas to the inductively defined subsets of {a mathematical formula}S, as shown in Fig. 1 (for clarity, we interpret explicitly the abbreviation {a mathematical formula}νZ.Φ). Notice that, given a (possibly open) uniform situation-suppressed situation calculus formula φ, by a slight abuse of notation, we denote by {a mathematical formula}φ[s] the corresponding formula with the situation calculus argument reintroduced and assigned to situation s.
     </paragraph>
     <paragraph>
      Intuitively, the extension function {a mathematical formula}(⋅)(v,V)M assigns the following meaning to the {a mathematical formula}μLp constructs{sup:7}:
     </paragraph>
     <list>
      <list-item label="•">
       The extension of {a mathematical formula}μZ.Φ is the smallest subset{a mathematical formula}Eμ of situations such that, assigning to Z the extension {a mathematical formula}Eμ, the resulting extension of Φ is contained in {a mathematical formula}Eμ (with the assignments of the individual variables and the other predicate variables given by v and V, respectively). That is, the extension of {a mathematical formula}μZ.Φ is the least fixpoint of the operator {a mathematical formula}(Φ)(v,V)[Z/E]M. Notice that for each valuation of the free individual variables in Φ, this operator is different: the free variables act as parameters of the predicate transformer {a mathematical formula}λZ.Φ.
      </list-item>
      <list-item label="•">
       Similarly, the extension of {a mathematical formula}νZ.Φ is the greatest subset{a mathematical formula}Eν of situations such that, assigning to Z the extension {a mathematical formula}Eν, the resulting extension of Φ contains {a mathematical formula}Eν. That is, the extension of {a mathematical formula}νZ.Φ is the greatest fixpoint of the operator {a mathematical formula}(Φ)(v,V)[Z/E]M.
      </list-item>
     </list>
     <paragraph>
      Observe that when a {a mathematical formula}μLp formula Φ is closed, its extension {a mathematical formula}(Φ)(v,V)M does not depend on the valuation {a mathematical formula}(v,V). In fact, the only formulas of interest in verification are those that are closed. We say that a theory {a mathematical formula}Dentails a closed {a mathematical formula}μLp formula Φ, written {a mathematical formula}D⊨Φ, if, for every model {a mathematical formula}M of {a mathematical formula}D, it is the case that {a mathematical formula}S0M∈(Φ)(v,V)M (for any valuation {a mathematical formula}(v,V), which is in fact irrelevant for closed formulas).
     </paragraph>
     <paragraph>
      We can express arbitrary temporal/dynamic properties using least and greatest fixpoint constructions. For instance, to say that it is possible to reach a situation where (the closed formula) Φ holds, we use the least fixpoint formula {a mathematical formula}μZ.Φ∨〈−〉Z. This corresponds to a well-known CTL formula, namely EFΦ [20]. Instead, {a mathematical formula}μZ.Φ∨[−]Z expresses that, no matter which actions are executed, a situation where Φ holds is eventually reached. This corresponds to the CTL formula AFΦ. Similarly, we can use the greatest fixpoint formula {a mathematical formula}νZ.Φ∧[−]Z to express that Φ must hold in all possible reachable situations. Again, this corresponds to the well-known CTL formula AGΦ. Instead, {a mathematical formula}νZ.Φ∧〈−〉Z expresses that Φ holds in the current situation and there exists always the possibility of moving to a next situation where Φ continues to hold. This corresponds to the CTL formula EGΦ. For convenience we sometime use the CTL notation as abbreviation for the above fixpoint formulas.
     </paragraph>
     <paragraph label="Example 9">
      We show several examples of properties that we may want to verify for the warehouse robot domain of Example 1. First, suppose that we want to say that it is possible to eventually have shipped all items that are in the factory. This can be expressed in our language as a least fixpoint formula {a mathematical formula}Φeg9{sup:8}:{a mathematical formula} In the above, we rely on the fact that if there are no items left in the factory, then all items that were there must have been shipped. It is easy to check that the theory of Example 1, {a mathematical formula}D1, entails that this formula holds in the initial situation {a mathematical formula}S0, formally {a mathematical formula}D1⊨Φeg9. In fact, we can also show that the above property always holds:{a mathematical formula}The formula {a mathematical formula}Φeg9 corresponds to the CTL formula {a mathematical formula}EF(∀x,l.¬At(x,l)), while the formula above corresponds to {a mathematical formula}AGEF(∀x,l.¬At(x,l)).A second property that we may want to verify is that it is possible to eventually have all items shipped out of the factory and then later to eventually have all locations filled with items. This can be expressed as follows:{a mathematical formula} or, equivalently, in CTL notation:{a mathematical formula}Our next example concerns a safety property; we can show that it is always the case that if an item is at the shipping dock it can be moved away or shipped out next:{a mathematical formula} Notice that x is quantified across situations, although {a mathematical formula}live(x) is not explicitly written, as implied by {a mathematical formula}At(x,ShipDock). In CTL notation we write (informally, EX stands for “there exists a successor such that”):{a mathematical formula} However, this is not the case for other locations. Indeed, all locations, including the shipping dock, could become occupied, hence no movement between locations would be possible, except for shipping the item out from the shipping dock:{a mathematical formula} which simplifies to (also observing that {a mathematical formula}At(x,l) implies {a mathematical formula}live(x) and {a mathematical formula}live(l)):{a mathematical formula}But it is always possible to clear a location in two steps:{a mathematical formula} The above involves quantification across situations, and we require the location involved to persist (it trivially does).Now, let's consider another example where we quantify across situations. We may want to say that it is always the case that if an item is in the warehouse, it is possible to have it persist until it is eventually shipped out (i.e., removed from all locations):{a mathematical formula} Note that the weaker property that it is always the case that if an item is in the warehouse, it is possible to have it shipped out eventually if it persists also holds:{a mathematical formula}Finally, consider the property that if an item o is eventually shipped (i.e., {a mathematical formula}∀l.¬At(o,l) and hence o is not in the active domain) there is a future situation where o eventually comes back (i.e., it arrives back to the shipping dock and hence reappears in the active domain). While we cannot write this property in {a mathematical formula}μLp because o does not persist after it has been shipped, the property itself is trivially true. Indeed, if an object o disappears from the active domain, the theory does not predicate on o anymore. Hence the object o will appear back only if introduced by the action {a mathematical formula}arrive(o). Observe however that, since the theory is not predicating on o, if we can use o as the actual parameter of the action, then we can use as actual parameter any other object not in the active domain. That is, if {a mathematical formula}arrive(x) can be instantiated with some object outside the active domain (which is indeed the case) then it can be trivially instantiated with o. Analogously, the property that o eventually comes back no matter what actions are executed is trivially false. Indeed, if we can instantiate {a mathematical formula}arrive(x) with o, then we can instantiate it with every object outside the active domain. Thus, we can trivially have an infinite sequence of actions where {a mathematical formula}arrive(o) never occurs. This discussion hints at the essential aspect of persistence in quantification across: when objects persist we can express meaningful temporal properties over them, while when they do not, temporal properties trivialize, see Section 10. □
     </paragraph>
     <paragraph label="Observation 1">
      Observe that we do not have actions as parameters of {a mathematical formula}[−]⋅ and {a mathematical formula}〈−〉⋅. However, we can easily remember the last action performed, and in fact a finite sequence of previous actions. To do this, for each action type {a mathematical formula}A(x→), we introduce a fluent {a mathematical formula}LastA(x→,s) with successor state axiom:{a mathematical formula} We can also remember the second last action by introducing fluents {a mathematical formula}SecondLastA(x→,s) with successor state axioms:{a mathematical formula} Similarly for the third last action, etc. Notice that each of these fluents has an extension in each situation containing at most one tuple of objects corresponding to the parameters {a mathematical formula}x→ of the corresponding action A.In this way, we can store a finite suffix of the history in the current situation and write FO formulas relating the individuals in the parameters of actions occurring in the suffix. For example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):{a mathematical formula} i.e., it is possible to eventually do {a mathematical formula}B(x→) followed by {a mathematical formula}A(x→) for some {a mathematical formula}x→.
     </paragraph>
     <paragraph label="Observation 2">
      While {a mathematical formula}μLp allows for quantification over objects that persist across situations, the expressiveness of bounded action theories often makes its use avoidable. For instance, we can easily introduce a finite number of “registers”, i.e., fluents that store only one tuple, which can be used to store and refer to tuples across situations. We can do this by introducing fluents {a mathematical formula}Regi(x→,s) and two actions {a mathematical formula}setRegi(x→) and {a mathematical formula}clearRegi to set and clear the register {a mathematical formula}Regi respectively. These are axiomatized as follows:{a mathematical formula} For example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):{a mathematical formula} This formula says that there exists a sequence of actions where eventually the tuple referred to by register i has property F and there is an action after which it has property {a mathematical formula}F′. Note also that this approach can be used to handle some cases of quantification over objects that do not persist across situations.
     </paragraph>
    </section>
    <section label="6">
     Verification of bounded action theories with complete information on {a mathematical formula}S0
     <paragraph>
      We now show that verifying {a mathematical formula}μLp properties against bounded action theories is decidable. In this section we focus on action theories with complete information on the initial situation. The case of incomplete information is addressed in the next section. In particular, we assume that the extension of all fluents in the initial situation {a mathematical formula}S0 is given as a (bounded) database. We further assume that the domain of interpretation for objects Δ is also given. Notice that, as a consequence of the presence of infinitely many object constants and the unique name assumption on them {a mathematical formula}Duno, Δ must be infinite.{sup:9} As a result of these two assumptions, we have that the action theory {a mathematical formula}D admits only one model {a mathematical formula}MΔ[67] which, by a slight abuse of terminology, we call the model of the action theory {a mathematical formula}D (though in order to define it we need Δ as well).
     </paragraph>
     <paragraph label="Theorem 4">
      Our main result is the following. Let{a mathematical formula}Dbe a bounded action theory with initial situation described by a (bounded) database and with infinite object domain Δ, and let Φ be a closed{a mathematical formula}μLpformula. Then, checking whether{a mathematical formula}D⊨Φis decidable.
     </paragraph>
     <paragraph>
      The proof is structured as follows. Firstly, we show that action terms can be eliminated from {a mathematical formula}μLp formulas without loss of generality (cf. Section 6.1). Exploiting this, we show that only the fluent extensions in each situation, and not the situations themselves, are relevant when evaluating {a mathematical formula}μLp formulas (cf. Section 6.2). In this step, we also prove that checking FO formulas and answering FO queries locally, i.e., on a given situation, are, under boundedness, respectively decidable and effectively computable.
     </paragraph>
     <paragraph>
      Then, based on the observations above, we introduce transition systems as alternative structures (to the models of situation calculus action theories), over which {a mathematical formula}μLp formulas can be evaluated. Transition systems are less rich than the models of situation calculus action theories, as they do not reflect, in general, the structure of the situation tree. Yet, they can accommodate the information of models needed to evaluate {a mathematical formula}μLp formulas (cf. Sections 6.3 and 6.4). In this step, we define the notion of persistence-preserving bisimulation, i.e., a variant of standard bisimulation which requires a certain kind of isomorphism to exist between bisimilar states and their successors (cf. page 187), and prove that persistence-preserving bisimilar transition systems preserve the truth-value of {a mathematical formula}μLp formulas (cf. Theorem 13). This is a key step in the proof, which allows us to reduce the verification of {a mathematical formula}μLp formulas over an infinite transition system to that over a bisimilar transition system that is finite.
     </paragraph>
     <paragraph>
      In the third and fundamental step (Section 6.5), we carry out a faithful abstraction operation, and show how to actually construct a finite transition system that is persistence-preserving bisimilar to the one, infinite, induced by the model of the action theory (cf. Procedure 1 and Theorem 15, Theorem 16). Finally, we prove that verification is decidable on finite transition systems, thus on the one induced by the model of the action theory (cf. Theorem 17).
     </paragraph>
     <paragraph>
      The rest of this section details these steps.
     </paragraph>
     <section label="6.1">
      <section-title>
       Suppressing action terms
      </section-title>
      <paragraph>
       Under uniqueness of action names, domain closure for actions, and the fact that action types are finitely many, we can remove, without loss of generality, action terms from uniform situation calculus formulas.
      </paragraph>
      <paragraph label="Proof">
       For every, possibly open, situation calculus FO formula{a mathematical formula}φ(x→,s)uniform in s and with free variables{a mathematical formula}x→, all of object sort, there exists a situation calculus formula{a mathematical formula}φ′(x→,s)uniform in s, where no action terms occur, such that{a mathematical formula}By induction on the structure of φ. If φ is {a mathematical formula}F(t→,s), we have that, by definition, {a mathematical formula}t→ can only contain object terms, so {a mathematical formula}φ′ is {a mathematical formula}F(t→,s). If φ is {a mathematical formula}A(y→)=A′(y′→), with {a mathematical formula}x→⊆y→∪y→′, if {a mathematical formula}A=A′, then {a mathematical formula}φ′ is {a mathematical formula}y→=y′→, else {a mathematical formula}φ′ is ⊥. The case of Boolean connectives is straightforward. If φ is {a mathematical formula}∃a.ϕ(x→,a,s), consider the formula {a mathematical formula}φ″=⋁A∈A∃y→A.ϕA(x→,y→A,s), with {a mathematical formula}ϕA obtained from {a mathematical formula}ϕ(x→,a,s), by replacing each occurrence of a with {a mathematical formula}A(y→A), where {a mathematical formula}y→A are fresh variables. We obviously have: {a mathematical formula}Dca⊨∀(φ≡φ″). Now, for each {a mathematical formula}ϕA, let {a mathematical formula}ϕA′ be a formula containing no action terms, such that {a mathematical formula}Dca⊨∀(ϕA≡ϕA′). By induction hypothesis, such a {a mathematical formula}ϕA′ exists. Finally, let {a mathematical formula}φ′=⋁A∈A∃y→A.ϕA′(x→,y→A,s). Clearly, {a mathematical formula}φ′ contains no action terms and is uniform in s. By considering unique name axioms for actions and domain closure for action types ({a mathematical formula}Dca), we can see that {a mathematical formula}Dca⊨∀(φ″≡φ′). Thus, since {a mathematical formula}Dca⊨∀(φ≡φ″), the thesis follows, i.e., {a mathematical formula}Dca⊨∀(φ≡φ′).  □
      </paragraph>
      <paragraph label="Theorem 6">
       This result immediately extends to {a mathematical formula}μLp, since in {a mathematical formula}μLp formulas, only uniform (situation suppressed) situation calculus FO subformulas can occur. Any{a mathematical formula}μLpformula Φ can be rewritten as an equivalent{a mathematical formula}μLpformula{a mathematical formula}Φ′, where no action terms occur, such that{a mathematical formula}Dca⊨∀(Φ≡Φ′).
      </paragraph>
      <paragraph>
       On the basis of this theorem, without loss of generality, we always rewrite {a mathematical formula}μLp formulas so that actions do not occur in them.
      </paragraph>
     </section>
     <section label="6.2">
      <section-title>
       Suppressing situation terms
      </section-title>
      <paragraph>
       Since the FO components of {a mathematical formula}μLp formulas are situation-suppressed, situations are obviously irrelevant when checking {a mathematical formula}μLp formulas; more precisely, the FO components (thus the whole logic) are sensitive only to the interpretation of fluents (and constants) at each situation, while the situations themselves are not relevant. The impact of this observation on the evaluation of {a mathematical formula}μLp formulas in the general case will become evident in Section 6.4. Here, we focus on the local evaluation of FO components (on the interpretation of a single situation), or more specifically of FO situation calculus formulas uniform in s, and present some notable results that, besides being interesting per se, will be useful later on.
      </paragraph>
      <paragraph label="Theorem 7">
       Given a basic action theory {a mathematical formula}D, we denote by {a mathematical formula}F the set of its fluent symbols and by C the (finite) set of constants in {a mathematical formula}N explicitly mentioned in {a mathematical formula}D, beyond {a mathematical formula}Duno. Then, given a model {a mathematical formula}M of {a mathematical formula}D with object domain Δ and a situation s, it is natural to associate s with a FO interpretation {a mathematical formula}IM(s)≐〈Δ,⋅I〉, where: (i) for every {a mathematical formula}c∈C, {a mathematical formula}cI=cM and (ii) for every (situation-suppressed) fluent F of {a mathematical formula}D, {a mathematical formula}FI={d→|〈d→,s〉∈FM}. The following result is an obvious consequence of the definitions above. For any possibly open FO situation-suppressed situation calculus formula φ uniform in s, any situation s, and any object variable valuation v, we have that{a mathematical formula}M,v⊨φ[s]if and only if{a mathematical formula}IM(s),v⊨φ.
      </paragraph>
      <paragraph>
       In other words, when evaluating a uniform FO situation-calculus formula on a situation, one needs only focus on the interpretation relative to the situation of interest.
      </paragraph>
      <paragraph>
       Next, we show that, despite the object domain's infiniteness, for bounded action theories, we have decidability of FO formulas evaluation. Even more, we obtain that we can compute the answers to FO queries on specific situations. Notice that the latter result is not obvious, in that the object domain is infinite and, thus, so could be the answer. Importantly, these results imply that we can check action executability and compute the effects of action executions, two facts that we will strongly leverage when checking {a mathematical formula}μLp formulas.
      </paragraph>
      <paragraph>
       We start by showing some results concerning the decidability of FO formulas evaluation in an interpretation with finite predicate extensions, but infinite domain. Consider a finite set {a mathematical formula}F of predicate symbols (situation-suppressed fluents) and a finite set C (a subset of {a mathematical formula}N) of constant symbols; then, a (FO) interpretation{a mathematical formula}I, over an infinite domain Δ, is a tuple {a mathematical formula}I=〈Δ,⋅I〉, where {a mathematical formula}⋅I assigns an extension {a mathematical formula}FI over Δ to each predicate symbol {a mathematical formula}F∈F, and a distinct object {a mathematical formula}cI∈Δ to every constant in C. The active domain of an interpretation {a mathematical formula}I, denoted {a mathematical formula}adom(I), is the set of all the individuals occurring in the extension of some fluent {a mathematical formula}F∈F, or interpreting some constant {a mathematical formula}c∈C, in {a mathematical formula}I. Moreover, for simplicity, we assume that all the constants mentioned in FO formulas of interest belong to C.
      </paragraph>
      <paragraph>
       First, let us recall a classical result saying that FO formulas (with no function symbols other than constants) can always be rewritten as formulas with quantified variables ranging only over the active domain of the interpretation. For an interpretation {a mathematical formula}I=〈Δ,⋅I〉, we define the restriction of{a mathematical formula}Ito its active domain as the interpretation {a mathematical formula}I˜=〈adom(I),⋅I〉. In words, {a mathematical formula}I˜ is the same interpretation as {a mathematical formula}I, except that the object domain is replaced by the active domain. For technical convenience, given an interpretation {a mathematical formula}I, a FO formula φ, and a (FO) variable valuation v, we define the interpretation {a mathematical formula}I˜φ,v as the interpretation {a mathematical formula}〈adom(I)∪Dφ,v,⋅I〉, where {a mathematical formula}Dφ,v⊆Δ is the set containing all the objects from Δ that v assigns to the free variables of φ. Observe that {a mathematical formula}Dφ,v is always finite, since so is the set of φ's free variables.
      </paragraph>
      <paragraph label="Theorem 8">
       Theorem 5.6.3 of [60]For every FO formula φ, one can effectively compute a formula{a mathematical formula}φ′, with quantified variables ranging only over the active domain, such that for any interpretation{a mathematical formula}I=〈Δ,⋅I〉with infinite domain Δ, and any valuation v, we have that{a mathematical formula}I,v⊨φif and only if{a mathematical formula}I˜φ,v,v⊨φ′.
      </paragraph>
      <paragraph>
       This result essentially says that checking whether {a mathematical formula}I,v⊨φ′ requires knowing only the interpretation function {a mathematical formula}⋅I of {a mathematical formula}I, while the interpretation domain Δ can be disregarded. In other words {a mathematical formula}φ′ is a domain-independent formula [1]. One way to obtain domain-independent formulas is to avoid the use of negation and instead use logical difference with respect to the active domain. The above theorem says that it is always possible to transform a FO formula to be evaluated over an infinite domain to a domain-independent one to be evaluated over the active domain only, suitably augmented with the objects assigned to the free variables of the formula (and actually its proof gives an effective procedure to do so).
      </paragraph>
      <paragraph>
       An immediate consequence of Theorem 8 is that if {a mathematical formula}adom(I) is finite, then checking whether {a mathematical formula}I,v⊨φ is decidable, no matter whether the interpretation domain of {a mathematical formula}I is finite or infinite. Indeed, in the former case, decidability is obvious, while in the latter, one can simply check whether {a mathematical formula}I˜φ,v,v⊨φ′, which requires only lookups on the finite extensions of fluents and, in the presence of quantified variables, iterating over the finitely many elements of the active domain union the objects assigned by v to the free variables of φ. Thus, we have the following result.
      </paragraph>
      <paragraph label="Theorem 9">
       Given a possibly open FO formula φ and an interpretation{a mathematical formula}I=〈Δ,⋅I〉with infinite Δ, if{a mathematical formula}adom(I)is finite, then, for any valuation v, checking whether{a mathematical formula}I,v⊨φis decidable.
      </paragraph>
      <paragraph label="Proof">
       See discussion above.  □
      </paragraph>
      <paragraph>
       Theorem 9 can be lifted to computing all the valuations v such that {a mathematical formula}I,v⊨φ. Let φ be a FO formula with free variables {a mathematical formula}x→, and {a mathematical formula}I=〈Δ,⋅I〉 a FO interpretation. Then, the answer on{a mathematical formula}I to φ is the relation {a mathematical formula}φI≐{d→∈Δ→|I,v⊨φ, for v(x→)=d→}. Sometimes, it is useful to fix the valuation of some variables {a mathematical formula}x→in⊆x→, say {a mathematical formula}v(x→in)=d→in, and then consider the answer to φ under this partial assignment, that is, the relation {a mathematical formula}φx→in/d→inI≐{d→out∈Δ→|I,v⊨φ, for v(x→in)=d→in and v(x→∖x→in)=d→out}.{sup:10} The following theorem says that if {a mathematical formula}I has an infinite domain Δ but a finite active domain, and the answer {a mathematical formula}φx→in/d→inI is finite, then the objects occurring in the answer come necessarily from either the active domain, or the values assigned to {a mathematical formula}x→in by v.
      </paragraph>
      <paragraph label="Proof">
       Consider a FO formula φ with free variables{a mathematical formula}x→. Let{a mathematical formula}Ibe an interpretation with infinite Δ and finite active domain. If{a mathematical formula}φx→in/d→inIis finite, then{a mathematical formula}φx→in/d→inI⊆(adom(I)∪d→in)n, where{a mathematical formula}n=|x→∖x→in|.By contradiction. It can be easily proven that if {a mathematical formula}I,v⊨φ, for {a mathematical formula}v(xi)=di∉(adom(I)∪d→in) and {a mathematical formula}xi∈x→∖x→in, then for any other valuation {a mathematical formula}v′=v[xi/di′] such that {a mathematical formula}di′∈Δ∖(adom(I)∪d→in), we have that {a mathematical formula}I,v′⊨φ. Since Δ is infinite and {a mathematical formula}adom(I) is finite, such {a mathematical formula}di′ are infinitely many, thus {a mathematical formula}φx→in/d→inI is infinite. Contradiction.  □
      </paragraph>
      <paragraph label="Proof">
       In other words, any “new” object, with respect to those in {a mathematical formula}adom(I), occurring in the answer, must come from {a mathematical formula}d→in. A direct consequence of Theorem 9, Theorem 10 is that one can actually compute the answer on {a mathematical formula}I to φ. Consider a FO formula φ with free variables{a mathematical formula}x→. Let{a mathematical formula}I=〈Δ,⋅I〉be an interpretation with infinite Δ and finite active domain. If, for some valuation v such that{a mathematical formula}v(x→in)=d→in,{a mathematical formula}φx→in/d→inIis finite, then{a mathematical formula}φx→in/d→inIis effectively computable.It suffices to record in {a mathematical formula}φx→in/d→inI all those tuples {a mathematical formula}d→out such that for some v with {a mathematical formula}v(x→in)=d→in and {a mathematical formula}v(x→∖x→in)=d→out, it is the case that {a mathematical formula}I,v⊨φ. Since by Theorem 10 such {a mathematical formula}d→out are finitely many and can be obtained using values from {a mathematical formula}adom(I)∪d→in, which is finite, and, by Theorem 9, checking whether {a mathematical formula}I,v⊨φ is decidable, it follows that {a mathematical formula}φx→in/d→inI is computable.  □
      </paragraph>
      <paragraph label="Theorem 12">
       These results find immediate application to the case of bounded action theories. Indeed, bounded action theories guarantee that {a mathematical formula}IM(s), in Theorem 7, is finite (for s executable). Thus, by Theorem 9, for φ and v as above, we have that checking whether {a mathematical formula}IM(s),v⊨φ is decidable. A useful implication of this is that it is decidable to check whether an action {a mathematical formula}AM(o→) is executable in a given situation s. Indeed, this requires checking whether {a mathematical formula}M,v⊨Poss(A(x→),s), with {a mathematical formula}v(x→)=o→, which, by Theorem 7, is equivalent to {a mathematical formula}IM(s),v⊨ϕA(x→), with {a mathematical formula}ϕA(x→,s) the RHS of the precondition axiom of A, which, in turn, is decidable. Moreover, Theorem 11 can be used to show that for a bounded action theory, the effects of executing an action at a given situation, as determined by the successor-state axioms, are computable and depend only on {a mathematical formula}IM(s) (and the action). Indeed, we can exploit these results to get a sort of one-step regression theorem in our setting [67], [75]. Let{a mathematical formula}Mbe a model of a bounded action theory{a mathematical formula}D, s an executable situation, and{a mathematical formula}a=AM(o→)an action, with action type{a mathematical formula}A(y→). Then, for any fluent F, there exists a situation-suppressed action-term-free formula{a mathematical formula}ϕ=ϕ(x→,y→)such that{a mathematical formula}FIM(doM(a,s))=ϕy→/o→IM(s), and hence{a mathematical formula}FIM(doM(a,s))is effectively computable.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}F(x→,do(a,s))≡ϕF(x→,a,s) be the successor-state axiom for fluent F. For the extension of F at situation {a mathematical formula}s′=doM(a,s), we have that {a mathematical formula}〈p→,s′〉∈F iff {a mathematical formula}M,v⊨ϕF(x→,A(y→),s), for some v such that {a mathematical formula}v(x→)=p→ and {a mathematical formula}v(y→)=o→. Notice that {a mathematical formula}ϕF contains, in general, action and situation terms, and is uniform in s. However, by Theorem 5, it can be rewritten as an equivalent action-term-free formula {a mathematical formula}ϕFA(x→,y→,s). Then, by suppressing the situation argument, we obtain: {a mathematical formula}p→∈FIM(s′) iff {a mathematical formula}IM(s),v⊨ϕFA(x→,y→), for some v such that {a mathematical formula}v(x→)=p→ and {a mathematical formula}v(y→)=o→. That is, for {a mathematical formula}ϕ=ϕFA, {a mathematical formula}FIM(s′)=ϕy→/o→IM(s). Thus, since by boundedness of {a mathematical formula}D, {a mathematical formula}FIM(s′) is finite, Theorem 11 implies the thesis.  □
      </paragraph>
      <paragraph>
       This result implies that, given {a mathematical formula}IM(s) and an action {a mathematical formula}a=AM(o→), we can obtain the interpretation of each F at {a mathematical formula}doM(a,s) by simply “querying” {a mathematical formula}IM(s). Hence, by taking the same interpretation of constants as in {a mathematical formula}M, we can construct {a mathematical formula}IM(doM(a,s)), from {a mathematical formula}IM(s) and the successor-state axioms of {a mathematical formula}D.
      </paragraph>
     </section>
     <section label="6.3">
      {a mathematical formula}μLp over transition systems
      <paragraph>
       The results presented in Sections 6.1 and 6.2 suggest that, for the purpose of verification of {a mathematical formula}μLp formulas, one can operate on simpler structures than the models of situation calculus action theories. Indeed, as we saw, both actions and situations can be essentially disregarded. In this section, we introduce such simpler structures, namely transition systems (TS), show how {a mathematical formula}μLp formulas are evaluated over them, and present some important results that allow us to perform the verification on TSs instead of on the original model. The connection between models of situation calculus theories and transition systems will be discussed in Section 6.4. By Theorem 5, we can focus, without loss of generality, on a variant of {a mathematical formula}μLp where action terms do not occur.
      </paragraph>
      <paragraph>
       By {a mathematical formula}IntΔF,C, we denote the set of all possible interpretations of the situation suppressed fluents in {a mathematical formula}F and constants in C, over the object domain Δ. A transition system (TS) (over the situation-suppressed fluents {a mathematical formula}F, constants C, and object domain Δ) is a tuple {a mathematical formula}T=〈Δ,Q,q0,→,I〉, where:
      </paragraph>
      <list>
       <list-item label="•">
        Δ is an object domain;
       </list-item>
       <list-item label="•">
        Q is a set of states;
       </list-item>
       <list-item label="•">
        {a mathematical formula}q0∈Q is the initial state;
       </list-item>
       <list-item label="•">
        {a mathematical formula}→⊆Q×Q is a transition relation between states; and
       </list-item>
       <list-item label="•">
        {a mathematical formula}I:Q↦IntΔF,C is a labeling function associating each state q with an interpretation {a mathematical formula}I(q)=〈Δ,⋅I(q)〉 such that the constants in C are interpreted in the same way in all the states over which {a mathematical formula}I is defined.
       </list-item>
      </list>
      <paragraph>
       To interpret a {a mathematical formula}μLp formula over a TS {a mathematical formula}T=〈Δ,Q,q0,→,I〉, we use valuations {a mathematical formula}(v,V) formed by an individual variable valuation v and a parameterized predicate variable valuation V, as in Section 5. We define the extension function{a mathematical formula}(⋅)(v,V)T, which maps {a mathematical formula}μLp formulas to subsets of Q, as follows:{a mathematical formula}
      </paragraph>
      <paragraph>
       Given a {a mathematical formula}μLp formula Φ, we say that a transition system T satisfies Φ at state q, under v and V, written {a mathematical formula}T,q,(v,V)⊨Φ, if {a mathematical formula}q∈(Φ)(v,V)T. When Φ is closed on predicate variables, we omit V, as irrelevant, and write {a mathematical formula}T,q,v⊨Φ. If Φ is closed on both individual and predicate variables we simply write {a mathematical formula}T,q⊨Φ. For closed formulas, we say that T satisfies Φ, written {a mathematical formula}T⊨Φ, if {a mathematical formula}T,q0⊨Φ.
      </paragraph>
      <paragraph>
       For our TSs we can prove a suitable version of the classical bisimulation invariance result for the μ-calculus, which states that bisimilar TSs satisfy exactly the same μ-calculus formulas, see e.g., [15]. Obviously, the notion of bisimulation needed here is not the classical one, but one that takes into account the FO interpretations labeling the states of the transition systems, as well as the controlled form of quantification across states allowed in {a mathematical formula}μLp.
      </paragraph>
      <paragraph>
       We first recall the standard notions of isomorphism and isomorphic interpretations. Two FO interpretations {a mathematical formula}I1=〈Δ1,⋅I1〉 and {a mathematical formula}I2=〈Δ2,⋅I2〉, over the same fluents {a mathematical formula}F and constants C, are said to be isomorphic, written {a mathematical formula}I1∼I2, if there exists a bijection (called isomorphism) {a mathematical formula}h:Δ1↦Δ2 such that: (i) for every {a mathematical formula}F∈F, it is the case that {a mathematical formula}x→∈FI1 if and only if {a mathematical formula}h(x→)∈FI2; and (ii) for every {a mathematical formula}c∈C, we have that {a mathematical formula}cI2=h(cI1). It is immediate to see that if h is an isomorphism, then so is {a mathematical formula}h−1, and that ∼ is an equivalence relation. Intuitively, in order for two interpretations to be isomorphic, it is required that one can be obtained from the other by renaming the individuals in the interpretation domain. Notice that, necessarily, the interpretation domains of isomorphic interpretations have the same cardinality. When needed, to make it explicit that h is an isomorphism between {a mathematical formula}I1 and {a mathematical formula}I2, we write {a mathematical formula}I1∼hI2. We denote by {a mathematical formula}h|D1 the restriction of h to {a mathematical formula}D1, i.e., the mapping {a mathematical formula}h|D1:D1↦h(D1), such that {a mathematical formula}h|D1(d)=h(d), for every {a mathematical formula}d∈D1. In addition, recall that {a mathematical formula}I˜=〈adom(I),⋅I〉 denotes the restriction of an interpretation{a mathematical formula}I=〈Δ,⋅I〉 to its active domain.
      </paragraph>
      <paragraph>
       The bisimulation relation that captures {a mathematical formula}μLp can be defined as follows. Let {a mathematical formula}T1=〈Δ1,Q1,q10,→1,I1〉 and {a mathematical formula}T2=〈Δ2,Q2,q20,→2,I2〉 be two transition systems (over the situation-suppressed fluents and constants of an action theory {a mathematical formula}D), and let H be the set of all possible bijections {a mathematical formula}h:D1↦D2, for {a mathematical formula}D1⊆Δ1 and {a mathematical formula}D2⊆Δ2. A relation {a mathematical formula}B⊆Q1×H×Q2 is a persistence-preserving bisimulation between {a mathematical formula}T1 and {a mathematical formula}T2, if {a mathematical formula}〈q1,h,q2〉∈B implies that:
      </paragraph>
      <list>
       <list-item label="1.">
        {a mathematical formula}I1˜(q1)∼hI2˜(q2);
       </list-item>
       <list-item label="2.">
        for each {a mathematical formula}q1′∈Q1, if {a mathematical formula}q1→1q1′ then there exists {a mathematical formula}q2′∈Q2 such that:
       </list-item>
       <list-item label="3.">
        for each {a mathematical formula}q2′∈Q2, if {a mathematical formula}q2→2q2′ then there exists {a mathematical formula}q1′∈Q1 such that:
       </list-item>
      </list>
      <paragraph>
       Notice that requirements 2b and 3b impose the existence of a bijection {a mathematical formula}h′ that preserves the bijection h (in fact, the isomorphism) between the objects in {a mathematical formula}adom(I1(q1)) and those in {a mathematical formula}adom(I2(q2)); this essentially means that the “identity” of such objects is preserved along the transition. Moreover, {a mathematical formula}h′ is required to induce an isomorphism between {a mathematical formula}adom(I1(q1′)) and {a mathematical formula}adom(I2(q2′)), when restricted to {a mathematical formula}adom(I1(q1′)), such that {a mathematical formula}〈q1′,h′|adom(I1(q1′)),q2′〉∈B.
      </paragraph>
      <paragraph>
       We say that a state {a mathematical formula}q1∈Q1 is (persistence-preserving) bisimilar to {a mathematical formula}q2∈Q2, written {a mathematical formula}q1≈q2, if there exists a persistence-preserving bisimulation B between {a mathematical formula}T1 and {a mathematical formula}T2 such that {a mathematical formula}〈q1,h,q2〉∈B, for some h; when needed, we also write {a mathematical formula}q1≈hq2, to explicitly name h. Finally, a transition system {a mathematical formula}T1 is said to be persistence-preserving bisimilar to {a mathematical formula}T2, written {a mathematical formula}T1≈T2, if {a mathematical formula}q10≈q20. It is immediate to see that bisimilarity between states and transition systems, i.e., the (overloaded) relation ≈, is an equivalence relation.
      </paragraph>
      <paragraph>
       Next, we prove a result (Theorem 13) saying that {a mathematical formula}μLp enjoys invariance under this notion of bisimulation. To this end, we first show the result for the simpler logic {a mathematical formula}LP, obtained from {a mathematical formula}μLp by dropping the fixpoint construct. Namely, {a mathematical formula}LP is defined as:{a mathematical formula} Such a logic corresponds to a first-order variant of the Hennessy–Milner Logic [50]. Note that its semantics is completely independent from the second-order valuation.
      </paragraph>
      <paragraph label="Lemma 1">
       Given an individual variable valuation v we denote by {a mathematical formula}im(v) its image on the object domain. Consider two transition systems{a mathematical formula}T1=〈Δ1,Q1,q10,→1,I1〉and{a mathematical formula}T2=〈Δ2,Q2,q20,→2,I2〉, two states{a mathematical formula}q1∈Q1,{a mathematical formula}q2∈Q2, such that{a mathematical formula}q1≈hq2, and two individual variable valuations{a mathematical formula}v1and{a mathematical formula}v2mapping variables to{a mathematical formula}Δ1and{a mathematical formula}Δ2, respectively. If there exists a bijection{a mathematical formula}hˆbetween{a mathematical formula}adom(I1(q1))∪im(v1)and{a mathematical formula}adom(I2(q2))∪im(v2)whose restriction{a mathematical formula}hˆ|adom(I1(q1))coincides with h and such that for each individual variable x,{a mathematical formula}hˆ(v1(x))=v2(x), then for every formula Φ of{a mathematical formula}LP, possibly open on individual variables, we have that:{a mathematical formula}
      </paragraph>
      <paragraph label="Proof">
       We proceed by induction on the structure of Φ. For {a mathematical formula}Φ=φ, we observe that, by Theorem 8, {a mathematical formula}Ii(qi),vi⊨φ if and only if {a mathematical formula}Ii˜φ,vi(qi),vi⊨φ′ ({a mathematical formula}i=1,2), for {a mathematical formula}φ′ the rewriting of φ as its domain-independent version. Further, since {a mathematical formula}I1˜(q1)∼hI2˜(q2), and there is a bijection {a mathematical formula}hˆ between the objects assigned to variables by {a mathematical formula}v1 and {a mathematical formula}v2 (even if they are not in {a mathematical formula}adom(I1(q1)) or {a mathematical formula}adom(I2(q2))), it follows that {a mathematical formula}I1˜φ,v1(q1)∼I2˜φ,v2(q2), thus, by the invariance of FOL wrt isomorphic interpretations, it follows that {a mathematical formula}I1˜φ,v1(q1),v1⊨φ′ if and only if {a mathematical formula}I2˜φ,v2(q2),v2⊨φ′. These two facts easily imply the thesis. The cases for Boolean connectives are obtained by straightforward induction using the same individual valuations {a mathematical formula}v1 and {a mathematical formula}v2 and the same bijection {a mathematical formula}hˆ.For {a mathematical formula}Φ=∃y.live(y)∧Φ′. Suppose that {a mathematical formula}T1,q1,v1⊨Φ. Then, for some {a mathematical formula}d1, it is the case that {a mathematical formula}T1,q1,v1[y/d1]⊨live(y)∧Φ′. Notice that this implies {a mathematical formula}d1∈adom(I1(q1)), then {a mathematical formula}hˆ(d1)=h(d1)=d2, for some {a mathematical formula}d2∈adom(I2(q2)), as {a mathematical formula}hˆ coincides with h on {a mathematical formula}adom(I1(q1)). Consider the individual valuation {a mathematical formula}v2[y/d2]. For every variable x we have {a mathematical formula}hˆ(v1[y/d1](x))=v2[y/d2](x) (for y we have {a mathematical formula}v2[y/d2](y)=d2=hˆ(d1)=hˆ(v1[y/d1](y))). Hence, using these new valuations and the same bijection {a mathematical formula}hˆ, now restricted to {a mathematical formula}im(v1[y/d1]) and {a mathematical formula}im(v2[y/d2]) (to take into account the assignments to y), we can apply the induction hypothesis, and conclude that {a mathematical formula}T2,q2,v2[y/d2]⊨live(y)∧Φ′, which implies {a mathematical formula}T2,q2,v2⊨Φ. The other direction is proven symmetrically.For {a mathematical formula}Φ=live(x→)∧〈−〉Φ′. Suppose that {a mathematical formula}T1,q1,v1⊨(live(x→)∧〈−〉Φ′). By definition, this implies that {a mathematical formula}v1(xi)∈adom(I1(q1)) for each {a mathematical formula}xi∈x→, and there exists a transition {a mathematical formula}q1→1q1′ such that {a mathematical formula}T1,q1′,v1⊨Φ′. Since {a mathematical formula}q1≈hq2, there exist: (i) a transition {a mathematical formula}q2→2q2′, and (ii) a bijection {a mathematical formula}h′:adom(I1(q1))∪adom(I1(q1′))↦adom(I2(q2))∪adom(I2(q2′)) such that its restriction {a mathematical formula}h′|adom(I1(q1)) coincides with h, its restriction {a mathematical formula}h′|adom(I1(q1′)) is an isomorphism such that {a mathematical formula}I1˜(q1′)∼h′|adom(I1(q1′))I2˜(q2′), and {a mathematical formula}q1′≈h′|adom(I1(q1′))q2′. Now consider two new variable valuations {a mathematical formula}v1′ and {a mathematical formula}v2′, defined as follows:
       <list>
        for {a mathematical formula}xi∈x→ (for which we have that {a mathematical formula}v1(xi)∈adom(I1(q1))), let {a mathematical formula}v1′(xi)=v1(xi) and {a mathematical formula}v2′(xi)=v2(xi);choose {a mathematical formula}d1∈Δ1 and, for all {a mathematical formula}y∉x→, let {a mathematical formula}v1′(y)=d1, then: if {a mathematical formula}d1∈adom(I1(q1))∪adom(I1(q1′)), for all {a mathematical formula}y∉x→, let {a mathematical formula}v2′(y)=h′(d1); else, choose {a mathematical formula}d2∉adom(I2(q2))∪adom(I2(q2′)), let, for all {a mathematical formula}y∉x→, {a mathematical formula}v2′(y)=d2, and contextually extend {a mathematical formula}h′ so that {a mathematical formula}h′(d1)=d2.For
       </list>
       <paragraph>
        {a mathematical formula}Φ=live(x→)∧[−]Φ″: we observe that we can rewrite Φ as {a mathematical formula}¬(live(x→)⊃〈−〉Φ′), with {a mathematical formula}Φ′=¬Φ″. Then, assume that {a mathematical formula}T1,q1,v1⊨(live(x→)⊃〈−〉Φ′). By definition, this implies that: (i) either for some {a mathematical formula}xi∈x→ we have {a mathematical formula}v1(xi)∉adom(I1(q1)); or (ii) for all {a mathematical formula}xi∈x→ we have {a mathematical formula}v1(xi)∈adom(I1(q1)) and there exists a transition {a mathematical formula}q1→1q1′ such that {a mathematical formula}T1,q1′,v1⊨Φ′. We distinguish the two cases:
       </paragraph>
       <list>
        <list-item label="•">
         If for some {a mathematical formula}xi∈x→, {a mathematical formula}v1(xi)∉adom(I1(q1)), then we have that {a mathematical formula}v2(xi)∉adom(I2(q2)). Indeed, assume toward contradiction that {a mathematical formula}v2(xi)∈adom(I2(q2)). Since {a mathematical formula}I1˜(q1)∼hI2˜(q2) it follows that the inverse {a mathematical formula}h−1 of h is unique, hence {a mathematical formula}h−1(v2(xi))=v1(xi) and {a mathematical formula}v1(xi)∈adom(I1(q1)), getting a contradiction. Thus, we have that {a mathematical formula}T2,q2,v2⊭live(x→) and so {a mathematical formula}T2,q2,v2⊨(live(x→)⊃〈−〉Φ′).
        </list-item>
        <list-item label="•">
         If for all {a mathematical formula}xi∈x→, {a mathematical formula}vi(xi)∈adom(I1(q1)), we can proceed in the same way as for the case of {a mathematical formula}Φ=live(x→)∧〈−〉Φ′.
        </list-item>
       </list>
       <paragraph>
        The other direction is proven symmetrically.  □
       </paragraph>
      </paragraph>
      <paragraph label="Lemma 2">
       We can now extend the result to the whole {a mathematical formula}μLp. Consider two transition systems{a mathematical formula}T1=〈Δ1,Q1,q10,→1,I1〉and{a mathematical formula}T2=〈Δ2,Q2,q20,→2,I2〉, two states{a mathematical formula}q1∈Q1,{a mathematical formula}q2∈Q2, such that{a mathematical formula}q1≈hq2, and two individual variable valuations{a mathematical formula}v1and{a mathematical formula}v2mapping variables to{a mathematical formula}Δ1and{a mathematical formula}Δ2, respectively. If there exists a bijection{a mathematical formula}hˆbetween{a mathematical formula}adom(I1(q1))∪im(v1)and{a mathematical formula}adom(I2(q2))∪im(v2)whose restriction{a mathematical formula}hˆ|adom(I1(q1))coincides with h and such that for each individual variable x,{a mathematical formula}hˆ(v1(x))=v2(x), then for every formula Φ of{a mathematical formula}μLp, closed on the predicate variables but possibly open on the individual variables, we have:{a mathematical formula}
      </paragraph>
      <paragraph label="Proof">
       We prove the theorem in two steps. First, we show that Lemma 1 can be extended to the infinitary version of {a mathematical formula}LP that supports arbitrary infinite disjunction of formulas sharing the same free variables [88]. Then, we recall that fixpoints can be translated into this infinitary logic, thus guaranteeing invariance for the whole {a mathematical formula}μLp logic. Let Ψ be a possibly infinite set of open {a mathematical formula}LP formulas. Given a transition system {a mathematical formula}T=〈Δ,Q,q0,→,I〉, the semantics of ⋁Ψ is {a mathematical formula}(⋁Ψ)(v,V)T=⋃ψ∈Ψ(ψ)(v,V)T. Therefore, given a state q of T and a variable valuation v, we have {a mathematical formula}T,q,v⊨Ψ if and only if {a mathematical formula}T,q,v⊨ψ for some {a mathematical formula}ψ∈Ψ. Arbitrary infinite conjunction is obtained for free through negation. Lemma 1 extends to this arbitrary infinite disjunction. By the induction hypothesis, under the assumption of the Lemma, we can assume that for every formula {a mathematical formula}ψ∈Ψ, we have {a mathematical formula}T1,q10,v1⊨ψ if and only if {a mathematical formula}T2,q20,v2⊨ψ. Given the semantics of ⋁Ψ above, this implies that {a mathematical formula}T1,q10,v1⊨⋁Ψ if and only if {a mathematical formula}T2,q20,v2⊨⋁Ψ.In order to extend the result to the whole {a mathematical formula}μLp, we translate μ-calculus approximates into the infinitary {a mathematical formula}LP by (see [15], [88]), where the approximant of index α is denoted by {a mathematical formula}μαZ.Φ for least fixpoint formulas {a mathematical formula}μZ.Φ and {a mathematical formula}ναZ.Φ for greatest fixpoint formulas {a mathematical formula}νZ.Φ. This is a standard result that holds also for {a mathematical formula}μLp. In particular, such approximates are as follows:{a mathematical formula} where λ is a limit ordinal, and the notation {a mathematical formula}Φ[Z/νβZ.Φ] denotes the formula obtained from Φ by replacing each occurrence of Z by {a mathematical formula}νβZ.Φ. By Tarski and Knaster Theorem [85], the fixpoints and their approximates are connected by the following properties: given a transition system T and a state q of T,
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}q∈(μZ.Φ)(v,V)T if and only if there exists an ordinal α such that {a mathematical formula}s∈(μαZ.Φ)(v,V)T and, for every {a mathematical formula}β&lt;α, it holds that {a mathematical formula}s∉(μβZ.Φ)(v,V)M;
       </list-item>
       <list-item label="•">
        {a mathematical formula}q∉(νZ.Φ)(v,V)T if and only if there exists an ordinal α such that {a mathematical formula}s∉(ναZ.Φ)(v,V)T and, for every {a mathematical formula}β&lt;α, it holds that {a mathematical formula}q∈(νβZ.Φ)(v,V)M.
       </list-item>
      </list>
      <paragraph>
       With this lemma in place we can prove the invariance result.
      </paragraph>
      <paragraph label="Proof">
       Consider two transition systems{a mathematical formula}T1=〈Δ1,Q1,q10,→1,I1〉and{a mathematical formula}T2=〈Δ2,Q2,q20,→2,I2〉. If{a mathematical formula}T1≈T2, then, for every{a mathematical formula}μLpclosed formula Φ{a mathematical formula}If {a mathematical formula}T1≈T2 then for some bijection h we have {a mathematical formula}q10≈hq20. This implies that {a mathematical formula}I1˜(q10)∼hI2˜(q20). Now consider the variable valuations {a mathematical formula}v1 and {a mathematical formula}v2 defined as follows (notice that since Φ is closed such individual valuations are irrelevant in evaluating it): choose an arbitrary {a mathematical formula}d1∈Δ1 and let, for all variables x, {a mathematical formula}v1(x)=d1; if {a mathematical formula}d1∈adom(I1(q1)), let, for all x, {a mathematical formula}v2(x)=h(d1); else, choose {a mathematical formula}d2∉adom(I2(q2)) and let, for all x, {a mathematical formula}v2′(x)=d2.Now, define a bijection {a mathematical formula}h′ such that for all {a mathematical formula}d∈adom(I(q1)), {a mathematical formula}h′(d)=h(d), and if {a mathematical formula}d1∉adom(I1(q1)), {a mathematical formula}h′(d1)=d2. It can be seen that {a mathematical formula}h′ is a bijection between {a mathematical formula}adom(I1(q1)∪im(v1) and {a mathematical formula}adom(I2(q2)∪im(v2) such that {a mathematical formula}I1˜(q1)∼h′|adom(I1(q1))I2˜(q2) and for all variables x, {a mathematical formula}h′(v1(x))=v2(x). Hence, by Lemma 2, we obtain the thesis.  □
      </paragraph>
      <paragraph>
       Thus, to check whether a transition system T satisfies a {a mathematical formula}μLp formula Φ, one can perform the check on any transition system {a mathematical formula}T′ that is bisimilar to T. This is particularly useful in those cases where T is infinite-state but admits some finite-state bisimilar transition system. We exploit this result later on.
      </paragraph>
     </section>
     <section label="6.4">
      <section-title>
       Transition systems induced by a situation calculus theory
      </section-title>
      <paragraph>
       Among the various TSs, we are interested in those induced by models of the situation calculus action theory {a mathematical formula}D. Consider a model {a mathematical formula}M of {a mathematical formula}D with object domain Δ and situation domain {a mathematical formula}S. The TS induced by{a mathematical formula}M is the labeled TS {a mathematical formula}TM=〈Δ,Q,q0,I,→〉, such that:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}Q=S is the set of possible states, each corresponding to a distinct executable situation in {a mathematical formula}S;
       </list-item>
       <list-item label="•">
        {a mathematical formula}q0=S0M∈Q is the initial state, with {a mathematical formula}S0M the initial situation of {a mathematical formula}D;
       </list-item>
       <list-item label="•">
        {a mathematical formula}→⊆Q×Q is the transition relation such that {a mathematical formula}q→q′ iff there exists some action a such that {a mathematical formula}〈a,q〉∈PossM and {a mathematical formula}q′=doM(a,q);
       </list-item>
       <list-item label="•">
        {a mathematical formula}I:Q↦IntΔF,C is the labeling function associating each state (situation) q with the interpretation {a mathematical formula}I(q)=IM(q).
       </list-item>
      </list>
      <paragraph>
       As it can be seen, the TS induced by a model {a mathematical formula}M is essentially the tree of executable situations, with each situation labeled by an interpretation of fluents (and constants), corresponding to the interpretation associated by {a mathematical formula}M to that situation. Notice that transitions do not carry any information about the corresponding triggering action.
      </paragraph>
      <paragraph>
       We can now show that the semantics of {a mathematical formula}μLp on a model can alternatively be given in terms of the corresponding induced TS.
      </paragraph>
      <paragraph label="Proof">
       Let{a mathematical formula}Dbe an action theory,{a mathematical formula}Ma model of{a mathematical formula}Dwith (infinite) object domain Δ and situation domain{a mathematical formula}S, and{a mathematical formula}TMthe corresponding induced TS. Then for every{a mathematical formula}μLpformula Φ (with no occurrence of action terms) we have that:{a mathematical formula}By induction on the structure of Φ. For the base case of an open uniform situation-suppressed situation calculus formula φ, we need to prove that{a mathematical formula} This is indeed the case: since no action terms occur in φ and φ is uniform in s, the evaluation of φ depends only on the interpretation of each fluent (and constant) at s, i.e., on {a mathematical formula}IM(s). Once this base case is settled, the inductive cases are straightforward.  □
      </paragraph>
     </section>
     <section label="6.5">
      <section-title>
       Abstract finite-state transition system
      </section-title>
      <paragraph>
       As shown above, satisfaction of {a mathematical formula}μLp formulas is preserved by persistence-preserving bisimulations. This holds even between an infinite- and a finite-state TS. When this is the case, the verification can be performed on the finite TS using standard μ-calculus model checking techniques, which essentially perform fixpoint computations on a finite state space. We next show how, for the case of bounded theories, one can construct a finite TS {a mathematical formula}TF that is bisimilar to the TS {a mathematical formula}TM induced by {a mathematical formula}M.
      </paragraph>
      <paragraph>
       We construct {a mathematical formula}TF using Procedure 1. The procedure takes as input an action theory {a mathematical formula}D (with complete information on the initial situation) bounded by b and a model {a mathematical formula}M of {a mathematical formula}D with infinite object domain Δ,{sup:11} and returns a finite-state TS {a mathematical formula}TF bisimilar to {a mathematical formula}TM. {a mathematical formula}TF is built incrementally, through iterative refinements of the set of states Q, the interpretation function {a mathematical formula}I, and the transition relation →. Initially, Q contains only the initial state {a mathematical formula}q0 (line 2); {a mathematical formula}I(q0) interprets constants and fluents in the same way as {a mathematical formula}M at the initial situation (line 3); and → is empty (line 4). The set {a mathematical formula}Qte contains the states of {a mathematical formula}TF to be “expanded” (initially {a mathematical formula}q0 only, line 5); this is done at each iteration of the while loop (lines 6–20), as explained next.
      </paragraph>
      <paragraph>
       Firstly, a state q is extracted from {a mathematical formula}Qte (lines 7 and 8). Then, a finite subset O of objects from Δ is defined (line 9). The values from O, together with those from {a mathematical formula}adom(I(q)), are used, in combination with the action types, to generate actions executable on the interpretation {a mathematical formula}I(q){sup:12} (lines 10, 11). The particular choice of O guarantees that the set of generated actions, while finite, is fully representative, for the purpose of verification, of all the (possibly infinitely many) actions executable on {a mathematical formula}I(q) (see Theorem 16). Moreover, the objects are chosen so as to maximize reuse of the objects occurring in the interpretation of the states already in Q.
      </paragraph>
      <paragraph>
       The actual expansion step consists in computing, for each generated action, the interpretation {a mathematical formula}I′ obtained by executing the action on (a situation with interpretation) {a mathematical formula}I(q). This is done by computing, on {a mathematical formula}I(q), the answers to the right-hand side {a mathematical formula}ϕ(a,y→) of the (situation-suppressed) successor state axiom of each fluent F, with a set to the current action (line 12). Once {a mathematical formula}I′ has been computed, two cases are possible: either it is isomorphic to some interpretation {a mathematical formula}I(q′) labeling an existing state {a mathematical formula}q′∈Q (line 13), under some isomorphism that preserves {a mathematical formula}I(q), or it is not (line 15). In the former case, the transition relation is simply updated with a transition from q to {a mathematical formula}q′ (line 14) and no new state is generated. We stress that, in this case, the isomorphism is defined over the whole Δ, not only over the active domains of the interpretations. In the latter case, a fresh state {a mathematical formula}q′ with labeling {a mathematical formula}I(q′) is added to Q, and the transition relation is updated with {a mathematical formula}q→q′ (lines 16). Further, {a mathematical formula}q′ is also added to {a mathematical formula}Qte, so as to be expanded in future iterations. The procedure iterates over the expansion step until the set {a mathematical formula}Qte is empty, i.e., until there are no more states to expand.
      </paragraph>
      <paragraph>
       We observe that the choice of {a mathematical formula}q′ at line 14 guarantees the existence of an isomorphism {a mathematical formula}h′ between {a mathematical formula}I′ and {a mathematical formula}I(q′) that is the identity on {a mathematical formula}adom(I(q)). That is, any object occurring in {a mathematical formula}I′ that comes from {a mathematical formula}I(q) must be mapped into itself. The purpose of this choice is to avoid adding a fresh state {a mathematical formula}q″ (with interpretation {a mathematical formula}I′) to Q but reuse any state {a mathematical formula}q′ already in Q, if bisimilar to the candidate {a mathematical formula}q″. This is a key step for the procedure to construct a transition system that is both finite and persistence-preserving bisimilar to {a mathematical formula}TM.
      </paragraph>
      <paragraph>
       We can now show that Procedure 1 terminates and returns a TS persistence-preserving bisimilar to {a mathematical formula}TM. This result is split into two main results: Theorem 15, which shows that the procedure terminates, returning a finite TS, and Theorem 16, which shows that the obtained TS is indeed persistence-preserving bisimilar to {a mathematical formula}TM.
      </paragraph>
      <paragraph label="Lemma 3">
       To prove termination, we first derive a bound on the active domain of the interpretations labeling the states in Q. There exists a value{a mathematical formula}b′=∑F∈Fb⋅aF+|C|such that, at any iteration ofProcedure 1and for any{a mathematical formula}q∈Q,{a mathematical formula}|adom(I(q))|≤b′, where b is the value bounding{a mathematical formula}D,{a mathematical formula}aFthe arity of fluent F, and C the set of constants explicitly mentioned in{a mathematical formula}D.
      </paragraph>
      <paragraph label="Proof">
       We first show that: (†) for every {a mathematical formula}q∈Q, there exists a situation s executable in {a mathematical formula}D such that {a mathematical formula}I(q)=IM(s). This intuitively means that, modulo situation suppression, every state of {a mathematical formula}TF is labeled by an interpretation that matches that of {a mathematical formula}M on constants and fluents at some executable situation s.The proof is by induction on Q. For {a mathematical formula}q0, the thesis follows by the definition of {a mathematical formula}I(q0) at line 3, as {a mathematical formula}S0M is executable. For the induction step, consider {a mathematical formula}q∈Q and assume, by the induction hypothesis, that {a mathematical formula}I(q) is as above, for an executable situation s. Then, for any valuation (of object variables) v, we have that {a mathematical formula}I(q),v⊨Poss(A(x→)) if and only if {a mathematical formula}IM(s),v⊨Poss(A(x→)), that is, by Theorem 7, {a mathematical formula}M,v′⊨Poss(A(x→),σ), for σ a situation variable and {a mathematical formula}v′ a situation calculus variable assignment analogous to v on all individual variables and such that {a mathematical formula}v′(σ)=s. Thus, by line 11, {a mathematical formula}A(x→) is executable at s (with respect to {a mathematical formula}M and v). Similarly, for any fluent F and valuation v, we have that {a mathematical formula}I(q),v⊨ϕF(A(x→),y→) iff {a mathematical formula}M,v′⊨ϕF(A(x→),y→,σ), that is, since {a mathematical formula}F(y→,do(a,σ))≡ϕF(a,y→,σ) (by definition of successor-state axiom), {a mathematical formula}I(q),v⊨ϕF(A(x→),y→) iff {a mathematical formula}M,v′⊨F(y→,do(A(x→),σ)). But then, since by line 12, {a mathematical formula}FI′={d→∈Δ→|I(q),v[y→/d→]⊨ϕF(A(x→),y→)}, it follows that {a mathematical formula}I′,v⊨F(y→) iff {a mathematical formula}M,v′[y→/d→]⊨F(y→,do(A(x→),σ)). Thus, {a mathematical formula}FI′={d→∈Δ|M,v′[y→/d→]⊨F(x,do(A(x→),σ))}. Therefore, when a state {a mathematical formula}q′ is added to Q (line 16), its labeling {a mathematical formula}I(q′)=I′ is such that {a mathematical formula}I(q′)=IM(doM(AM(v(x→)),s)). This proves (†).Observe that (†) and the boundedness of {a mathematical formula}D imply, together, that {a mathematical formula}|adom(I(q))| is bounded, for any {a mathematical formula}q∈Q. We denote by {a mathematical formula}b′ the bound on {a mathematical formula}|adomM(s)|, for any executable situation s of {a mathematical formula}D, and on {a mathematical formula}|adom(I(q))|, for {a mathematical formula}q∈Q. Notice that, in general, {a mathematical formula}b′ is different than b, in that the former bounds the number of objects occurring in the interpretations, while the latter bounds the number of tuples in the interpretation of fluents. To obtain {a mathematical formula}b′, observe that if the theory is bounded by b, then, for any model, the extension of each fluent {a mathematical formula}F∈F at any executable situation contains at most b distinct tuples. Thus, the extension of the generic fluent F cannot contain, at any executable situation, more than {a mathematical formula}aF⋅b distinct objects, where {a mathematical formula}aF is the arity of F (the maximum number of tuples, each with distinct objects, distinct also from all others in the extension). As a result, the extensions cannot contain, overall, more than {a mathematical formula}∑F∈FaF⋅b distinct objects. Hence, considering that {a mathematical formula}I(q) interprets both the fluents in {a mathematical formula}F and the constants in C, it follows that {a mathematical formula}|adom(I(q))|≤∑F∈FaF⋅b+|C|≐b′.  □
      </paragraph>
      <paragraph label="Lemma 4">
       Then, we use the obtained bound to show that also the set of all objects occurring in the labelings of some state in Q, denoted {a mathematical formula}adom(Q), is bounded. Let{a mathematical formula}adom(Q)=⋃q∈Qadom(I(q)). At any iteration ofProcedure 1, we have that{a mathematical formula}|adom(Q)|≤2b′+N, for{a mathematical formula}b′the bound on{a mathematical formula}|adom(I(q))|defined as inLemma 3, and N the maximum number of parameters of the action types in{a mathematical formula}D.
      </paragraph>
      <paragraph label="Proof">
       By induction on the size of Q. For {a mathematical formula}Q={q0}, we have that {a mathematical formula}adom(Q)=adom(I(q0)), thus the thesis follows as, by Lemma 3, {a mathematical formula}|adom(I(q0))|&lt;b′. For {a mathematical formula}Q={q0,…,qn}, assume, by induction hypothesis, that {a mathematical formula}|adom(Q)|&lt;2b′+N. Since, by Lemma 3, the state {a mathematical formula}q∈Qte⊆Q picked at line 7 is such that {a mathematical formula}|adom(I(q))|≤b′ and Δ is infinite, then, by Theorem 10 (after applying Theorem 5, if action terms have to be suppressed in {a mathematical formula}ϕF), {a mathematical formula}I′ (line 12) is such that {a mathematical formula}adom(I′)⊆adom(I(q))∪v(x→).{sup:13} Now, observe that {a mathematical formula}v(x→) may take values from O and that the constraints on the choice of O (line 9) require that the reuse of objects from {a mathematical formula}adom(Q) be maximized. That is, including fresh objects (with respect to {a mathematical formula}adom(Q)) in O is allowed (in fact, required) only if needed to guarantee that {a mathematical formula}|O|=|x→| (while {a mathematical formula}O∩adom(I(q))=∅). Thus, two cases are possible: either {a mathematical formula}|adom(Q)∖adom(I(q))|&lt;|x→| (in which case fresh objects must be added to O), or not. In the first case, because {a mathematical formula}|x→|≤N and {a mathematical formula}adom(I(q))⊆adom(Q), it follows that {a mathematical formula}|adom(Q)|−|adom(I(q))|&lt;N. Thus, since {a mathematical formula}|adom(I(q))|≤b′, we have that {a mathematical formula}|adom(Q)|&lt;N+b′. From this, observing that {a mathematical formula}|adom(I(q′))|≤b′, we obtain {a mathematical formula}|adom(Q∪{q′})|≤2b′+N. In the second case, O contains no fresh objects, thus {a mathematical formula}|adom(Q∪{q′})|=|adom(Q)|≤2b′+N.  □
      </paragraph>
      <paragraph label="Proof">
       Exploiting this result, we can prove termination. Procedure 1terminates and returns a finite-state transition system{a mathematical formula}TF.Firstly, observe that, as a consequence of Lemma 4: (i) checking whether {a mathematical formula}I(q),v⊨Poss(A(x→)) (line 11) is decidable, and (ii){a mathematical formula}FI′ (line 12) is computable. These, indeed, are implied by the fact that {a mathematical formula}|adom(I(q))| is bounded, thus finite, and by Theorem 9, Theorem 11, respectively. To apply these theorems, however, one needs to suppress action terms first, if present, in formulas {a mathematical formula}ϕF(A(x→),y→) and {a mathematical formula}ϕA(x→). To this end, Theorem 5 can be used. Notice also that computability of {a mathematical formula}FI(q0) (line 3) is a direct consequence of the fact that {a mathematical formula}D has complete information and is bounded, therefore the extension of all fluents at {a mathematical formula}S0 is finite. Items (i) and (ii) above guarantee that all the atomic steps of Procedure 1 can be completed in finite time.Next, we prove that eventually {a mathematical formula}Qte=∅. Observe that, since {a mathematical formula}A (i.e., the set of action types of {a mathematical formula}D), Q, O, {a mathematical formula}adomM(S0), and {a mathematical formula}adom(I(q)) are finite, it follows that, at every iteration of the while-loop (lines 6–20), the nested loops (lines 10–19) terminate; thus, proving that {a mathematical formula}Qte becomes empty in a finite number of steps is sufficient to prove that only a finite number of iterations are executed and, hence, the procedure terminates. Obviously, this also implies that the returned Q, thus {a mathematical formula}TF, is finite.To see that eventually {a mathematical formula}Qte=∅, notice that Q is inflationary, i.e., states, once added, are never removed. Consequently, objects can be added to {a mathematical formula}adom(Q) (when a fresh {a mathematical formula}q′ is added) but not removed. This, together with the fact that, by Lemma 4, {a mathematical formula}|adom(Q)| is bounded, implies that, from some iteration i on, {a mathematical formula}adom(Q) remains unchanged. Let {a mathematical formula}AQi be {a mathematical formula}adom(Q) at iteration i (and at subsequent steps). Obviously, after that point, if a fresh state {a mathematical formula}q′ is added, it must be such that {a mathematical formula}adom(I(q′))⊆AQi. Notice that, even though {a mathematical formula}adom(Q) cannot change, this is not the case for Q. Indeed, new states {a mathematical formula}q′ could still be added, as long as {a mathematical formula}I(q′)=I′ contains only objects from {a mathematical formula}AQi. However, since {a mathematical formula}|adom(Q)|, thus {a mathematical formula}|AQi|, is bounded, only finitely many interpretations {a mathematical formula}I′ can be built using values from {a mathematical formula}AQi. Consequently, if new states keep being introduced after i, it follows that, from some step {a mathematical formula}i′ on, the interpretation {a mathematical formula}I′ generated at line 12 matches the interpretation {a mathematical formula}I(q′) of some {a mathematical formula}q′ already in Q. Hence, from {a mathematical formula}i′ on, the condition at line 13 is always satisfied (with h the identity function), and no fresh state {a mathematical formula}q′ can be added to Q any more. Therefore, no new state is added to {a mathematical formula}Qte (line 16), which becomes eventually empty, as at every iteration one state is extracted from it (line 7). This completes the proof.  □
      </paragraph>
      <paragraph label="Proof">
       Finally, we show that the returned {a mathematical formula}TF retains all the information needed to check whether {a mathematical formula}M⊨Φ. That is, by Theorem 13, we show that {a mathematical formula}TF is persistence-preserving bisimilar to {a mathematical formula}TM. The TS{a mathematical formula}TFcomputed byProcedure 1, on a basic action theory{a mathematical formula}D(with complete information) bounded by b and a model{a mathematical formula}Mfor{a mathematical formula}D, is persistence-preserving bisimilar to the TS{a mathematical formula}TMinduced by{a mathematical formula}M.Let {a mathematical formula}TF=〈Δ,Q,q0,IF,→F〉 and {a mathematical formula}TM=〈Δ,R,r0,IM,→M〉, and define the relation {a mathematical formula}B⊆Q×H×R such that {a mathematical formula}〈q,h,r〉∈B if and only if {a mathematical formula}I˜F(q)∼hI˜M(r) (for any h). Notice that, since {a mathematical formula}TF and {a mathematical formula}TM have the same object domain Δ, h can always be extended to a standard isomorphism {a mathematical formula}hˆ between {a mathematical formula}IF(q) and {a mathematical formula}IM(r): namely, one can take any bijection {a mathematical formula}hˆ:Δ↦Δ such that {a mathematical formula}hˆ|adom(IF(q))=h.We show that B is a persistence-preserving bisimulation between {a mathematical formula}TF and {a mathematical formula}TM (page 187). Consider a tuple {a mathematical formula}〈q,h,r〉∈B. Requirement 1 of the definition is trivially satisfied by the definition of B. As to requirement 2, let {a mathematical formula}q′∈Q be such that {a mathematical formula}q→Fq′. As shown in the proof of Theorem 15, there exists an executable situation s such that {a mathematical formula}IF(q)=IM(s). Moreover, by the definition of {a mathematical formula}TM, r is a situation such that {a mathematical formula}IM(r) matches the interpretation given by {a mathematical formula}M to fluents at r. Because {a mathematical formula}q→Fq′, by the construction of {a mathematical formula}TF in Procedure 1 (line 11), we have that, for some valuation v and action type A, {a mathematical formula}IF(q),v⊨Poss(A(x→)), that is, by the existence of s as above, {a mathematical formula}M,v⊨Poss(A(x→),s). Then, by extending h to an isomorphism {a mathematical formula}hˆ between {a mathematical formula}IF(q) and {a mathematical formula}IM(r), as discussed above, we can see that {a mathematical formula}IM(r),v′⊨Poss(A(x→),r), for {a mathematical formula}v′=hˆ∘v, which implies that {a mathematical formula}M,v′⊨Poss(A(x→),r). Therefore, by the definition of {a mathematical formula}TM, for {a mathematical formula}r′=doM(AM(hˆ(v(x→)),r)∈R, we have that {a mathematical formula}r→Mr′. Thus requirement 2a is fulfilled.Next, we show the existence of an isomorphism {a mathematical formula}hˆ′ between {a mathematical formula}IF(q′) and {a mathematical formula}IM(r′) that extends h. Once proven, this implies the existence of a bijection {a mathematical formula}h′:adom(q)∪adom(q′)↦adom(r)∪adom(r′) such that {a mathematical formula}h′|adom(IF(q))=h and {a mathematical formula}I˜F(q′)∼h′|adom(IF(q′))I˜M(r′). Indeed, it is sufficient to take {a mathematical formula}h′=hˆ′|adom(q)∪adom(q′). Thus, the existence of {a mathematical formula}hˆ′ implies requirement 2b.To prove that such an {a mathematical formula}hˆ′ exists, we distinguish two cases: (i) when the transition {a mathematical formula}q→Fq′ is added at line 16 (i.e., {a mathematical formula}q′ is a fresh state), and (ii) when it is added at line 14 (i.e., {a mathematical formula}q′ is already in Q). For case (i), observe that {a mathematical formula}IM(r′) can be obtained by applying the right-hand side of the successor-state axiom of each fluent F to {a mathematical formula}IM(r) (see Theorem 12), which is also the way to obtain {a mathematical formula}IF(q′) from {a mathematical formula}IF(q), according to Procedure 1. Then, since {a mathematical formula}hˆ is an isomorphism between {a mathematical formula}IF(q) and {a mathematical formula}IM(r), we have that {a mathematical formula}IM(r)=hˆ(IF(q)), where {a mathematical formula}hˆ(IF(q)) denotes the interpretation obtained from {a mathematical formula}IF(q) by renaming its objects according to {a mathematical formula}hˆ. Because {a mathematical formula}v′=hˆ∘v, it can be checked that {a mathematical formula}IM(r′)=hˆ(IF(q′)), thus {a mathematical formula}hˆ′=hˆ is an isomorphism between {a mathematical formula}IF(q′) and {a mathematical formula}IM(r′), which obviously extends h. For case (ii), let {a mathematical formula}I′ be the interpretation obtained by applying the successor-state axioms to {a mathematical formula}IF(q). By the discussion above, we have that {a mathematical formula}IM(r′)=hˆ(I′), while, in general, {a mathematical formula}I′≠IF(q′). However, the condition at line 13 guarantees the existence of an isomorphism g such that {a mathematical formula}I′=g(IF(q′)), that is the identity on {a mathematical formula}adom(IF(q)). Now, consider {a mathematical formula}hˆ′=hˆ∘g. Being a composition of isomorphisms, {a mathematical formula}hˆ′ is an isomorphism itself, in particular such that {a mathematical formula}IM(r′)=hˆ′(IF(q′)). Moreover, {a mathematical formula}hˆ′ extends {a mathematical formula}h|adom(IF(q)). This is a straightforward consequence of the facts that {a mathematical formula}hˆ extends h and g is the identity on {a mathematical formula}adom(IF(q)), which imply that {a mathematical formula}hˆ′ matches h on {a mathematical formula}adom(IF(q)). Thus, requirement 2 is fulfilled. The proof for requirement 3 follows the same argument, with h replaced by its inverse {a mathematical formula}h−1.Since B is a persistence-preserving bisimulation, the fact that {a mathematical formula}〈q0,h0,r0〉∈B, for {a mathematical formula}h0 the identity, completes the proof.  □
      </paragraph>
      <paragraph>
       Next we prove that checking whether {a mathematical formula}TF satisfies a {a mathematical formula}μLp formula is decidable.
      </paragraph>
      <paragraph label="Theorem 17">
       Given a transition system{a mathematical formula}T=〈Δ,Q,q0,I,→〉, if Q is finite and, for every{a mathematical formula}q∈Q,{a mathematical formula}adom(I(q))is finite, then for every{a mathematical formula}μLpformula Φ, checking whether{a mathematical formula}T⊨Φis decidable.
      </paragraph>
      <paragraph label="Proof">
       Firstly, by applying Theorem 6 followed by Theorem 8 to the FO components of Φ, we rewrite Φ as an equivalent {a mathematical formula}μLp (closed) formula {a mathematical formula}Φ′ where no action terms occur and whose FO components are domain-independent. Once done so, the theorem is a consequence of the finiteness of Q and {a mathematical formula}adom(q), for {a mathematical formula}q∈Q. Under these assumptions, {a mathematical formula}(Φ′)(v,V)T is easily computable by recursive applications of the definition of {a mathematical formula}(⋅)(v,V)T (page 186). In particular, for the base case of {a mathematical formula}Φ′ a FO formula {a mathematical formula}φ′, since {a mathematical formula}φ′ is action-term-free and domain-independent, one can apply Theorem 9. As to quantified variables (outside the FO components), they can be easily dealt with, by the finiteness of {a mathematical formula}adom(q). The other cases are straightforward.  □
      </paragraph>
      <paragraph>
       Finally, putting all the above results together, we obtain Theorem 4, by observing that one can compute {a mathematical formula}TF using Procedure 1 and then check whether {a mathematical formula}TF⊨Φ by Theorem 17. Termination and correctness of this construction are guaranteed by Theorem 13, Theorem 15, Theorem 16.{sup:14}
      </paragraph>
     </section>
    </section>
    <section label="7">
     <section-title>
      Dealing with incomplete information
     </section-title>
     <paragraph>
      In this section, we address the case of partial information on the initial situation, by assuming that {a mathematical formula}D0 is a set of axioms characterizing a possibly infinite set of bounded initial databases. Also in this case, we focus on theories whose models have infinite object domains (as we have infinitely many distinct constants).
     </paragraph>
     <paragraph>
      We first prove that whenever two models interpret their respective initial situations in isomorphic ways, they are persistence-preserving bisimilar. We observe that this result holds independently of the cardinalities of the object domains of the models.
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}Dbe a bounded basic action theory. For every two models{a mathematical formula}Mand{a mathematical formula}M′of{a mathematical formula}D, with possibly different infinite object domains Δ and{a mathematical formula}Δ′, respectively, if{a mathematical formula}I˜M(S0M)∼I˜M′(S0M′), then{a mathematical formula}TM≈TM′.Let {a mathematical formula}TM=〈Δ,Q,q0,→,I〉 and {a mathematical formula}TM′=〈Δ′,Q′,q0′,→′,I′〉. We prove a stronger claim, i.e., that the relation {a mathematical formula}B⊆Q×H×Q′ such that {a mathematical formula}〈q1,h,q2〉∈B if and only if {a mathematical formula}I˜(q1)∼hI′˜(q2) (for any h), is a persistence-preserving bisimulation relation between {a mathematical formula}TM and {a mathematical formula}TM′. This result, once proven, implies the thesis; indeed, by {a mathematical formula}I˜M(S0M)∼I˜M′(S0M′), we have that there exists {a mathematical formula}h¯ such that {a mathematical formula}I˜(S0M)∼h¯I˜(S0M′), thus, by the definition of B, {a mathematical formula}〈S0M,h¯,S0M′〉∈B, that is, {a mathematical formula}〈q0,h¯,q0′〉∈B, as {a mathematical formula}q0=S0M and {a mathematical formula}q0′=S0M′.Let {a mathematical formula}〈q1,h,q2〉∈B. Requirement 1 of the definition of bisimulation (page 187) is clearly satisfied. For requirement 2, first recall that, by definition of induced transition system (page 189), {a mathematical formula}I(q1)=IM(q1) and {a mathematical formula}I′(q2)=IM′(q2), thus {a mathematical formula}I˜M(q1)∼hI˜M′(q2). Assume that there exists {a mathematical formula}q1′∈Q such that {a mathematical formula}q1→q1′. By definition of transition system induced by {a mathematical formula}M (page 189), there exist an action type A and a valuation v such that {a mathematical formula}M,v⊨ϕA(x→,q1), for {a mathematical formula}Poss(A(x→),s)≡ϕA(x→,s) the precondition axiom of A. This is equivalent to {a mathematical formula}IM(q1),v⊨ϕA(x→), for {a mathematical formula}ϕA(x→) the situation-suppressed version of {a mathematical formula}ϕA(x→,s). Now, let {a mathematical formula}ϕA′(x→) be the domain-independent version of {a mathematical formula}ϕA(x→). By Theorem 8, we have that {a mathematical formula}IM(q1),v⊨ϕA(x→) if and only if {a mathematical formula}I˜MϕA,v(q1),v⊨ϕA′(x→). If we extend h to {a mathematical formula}v(x→) in a way such that we obtain a bijection {a mathematical formula}hˆ (by a cardinality argument, this is always possible), then, because {a mathematical formula}I˜M(q1)∼hI˜M′(q2), we have that {a mathematical formula}I˜Mφ,v(q1),v⊨ϕA′(x→) if and only if {a mathematical formula}I˜M′φ,hˆ∘v(q2),hˆ∘v⊨ϕA′(x→). But then, again by Theorem 8, {a mathematical formula}IM′(q2),hˆ∘v⊨ϕA(x→). Thus, by reintroducing the situation argument in {a mathematical formula}ϕA, we have that {a mathematical formula}M′,v′⊨ϕA(x→,q2), that is, there exists an action {a mathematical formula}a′=AM′(hˆ(v(x→))) such that {a mathematical formula}〈a′,q2〉∈PossM′. Therefore, by the definition of {a mathematical formula}TM′, it follows that {a mathematical formula}q2→q2′, for {a mathematical formula}q2′=doM(a′,q2). This proves requirement 2a.For requirement 2b, we first show that {a mathematical formula}I˜M(q1′) can be obtained from {a mathematical formula}I˜M(q1), through the successor-state axioms. To this end, notice that {a mathematical formula}IM(q1′) can be obtained by taking, for each fluent F, the right-hand side {a mathematical formula}ϕ(x→,a,s) of the corresponding successor-state axiom (the subscript F is removed to simplify the notation), then deriving the equivalent action-term-free formula {a mathematical formula}ϕ(y→,x→), as shown in Theorem 12, for action {a mathematical formula}a=AM(v(x→)), and finally letting {a mathematical formula}FIM(q1′)=ϕx→/v(x→)IM(q1), that is, by interpreting each F as the answer to the corresponding query ϕ on the interpretation {a mathematical formula}IM(q1), under the partial assignment {a mathematical formula}x→/v(x→) (constants are always interpreted as in {a mathematical formula}M). Now observe that, since the action theory is bounded, so is the extension of each fluent F at {a mathematical formula}q1 and {a mathematical formula}q1′. Thus, by Theorem 10, the extension of each fluent at {a mathematical formula}q1′ contains only values from {a mathematical formula}adom(IM(q1))∪v(x→), that is {a mathematical formula}adom(IM(q1′))⊆adom(IM(q1))∪v(x→). Hence, if we denote (for each F) the domain-independent rewriting of {a mathematical formula}ϕ(y→,x→) as {a mathematical formula}ϕ′(y→,x→), by Theorem 8, we have that {a mathematical formula}FIM(q1′)=ϕx→/v(x→)IM(q1)=ϕ′x→/v(x→)I˜M(q1), that is, by answering {a mathematical formula}ϕ′ on {a mathematical formula}I˜M(q1), we obtain the extension of F at {a mathematical formula}q1′. Obviously, by doing so for every fluent F, we can obtain {a mathematical formula}I˜M(q1′) from {a mathematical formula}I˜M(q1). By an analogous argument, it can be shown that {a mathematical formula}I˜M′(q2′) can be obtained from {a mathematical formula}I˜M′(q2), for action {a mathematical formula}a′=AM′(hˆ(v(x→))).Next, consider again the bijection {a mathematical formula}hˆ defined above, and recall that {a mathematical formula}hˆ extends h on {a mathematical formula}v(x→), and that {a mathematical formula}I˜M(q1)∼hI˜M′(q2). By the invariance of FO under isomorphic interpretations, we have that, for each fluent F, the answers to {a mathematical formula}ϕ′ on {a mathematical formula}I˜M(q1) and {a mathematical formula}I˜M′(q2), under the partial assignments, respectively, {a mathematical formula}x→/v(x→) and {a mathematical formula}x→/hˆ(v(x→)), coincide, modulo the object renaming induced by {a mathematical formula}hˆ. But then, it is immediate to check that {a mathematical formula}h′=hˆ|adom(IM(q1))∪adom(IM(q1′)) is a bijection such that {a mathematical formula}I˜M(q1′)∼h′|adom(IM(q1′))I˜M′(q2′) and, hence, by the definition of B, {a mathematical formula}〈q1′,h′|adom(IM(q1′)),q2′〉∈B. This proves requirement 2b. The proof of requirement 3b is analogous.  □
     </paragraph>
     <paragraph>
      Now, consider a set Mod of models of {a mathematical formula}D having isomorphic interpretations at {a mathematical formula}S0. By Theorem 18, all such models have induced TSs that are persistence-preserving bisimilar to each other. Thus, by Theorem 13, to check whether a {a mathematical formula}μLp formula ϕ holds in all models of Mod, one can perform the check on any arbitrary model of Mod, using, e.g., the technique discussed for the case of complete information. This result, together with the assumption of boundedness, will be exploited next, to prove our main theorem.
     </paragraph>
     <paragraph label="Theorem 19">
      Let{a mathematical formula}Dbe an action theory bounded by b with incomplete information on the initial situation, and let Φ be a{a mathematical formula}μLpclosed formula. Then, checking whether{a mathematical formula}D⊨Φis decidable.
     </paragraph>
     <paragraph label="Proof">
      Let {a mathematical formula}ModD be the set of all models of {a mathematical formula}D, and consider a partition of it such that each cell contains only models whose interpretations at {a mathematical formula}S0 match, modulo object renaming. Formally, we define {a mathematical formula}ModD=(ModD1,ModD2,…) such that, for every two models {a mathematical formula}M and {a mathematical formula}M′ in {a mathematical formula}ModDi, {a mathematical formula}I˜M(S0M)∼I˜M′(S0M′). As a consequence of the boundedness of {a mathematical formula}D, the number of cells in the partition is finite. Indeed, a bounded number of objects yields, up to object renaming, only a bounded number of possible interpretations (of finitely many fluents and constants) at {a mathematical formula}S0. Thus, for some finite n depending on the theory {a mathematical formula}D and the bound b, we have that {a mathematical formula}ModD=(ModD1,ModD2,…,ModDn).Since, by Theorem 18, any two models {a mathematical formula}M and {a mathematical formula}M′ of the generic cell {a mathematical formula}ModDi induce persistence-preserving bisimilar transition systems, then, by Theorem 13, we have that all the models of {a mathematical formula}ModDi satisfy Φ if and only if some model {a mathematical formula}M of {a mathematical formula}ModDi satisfies Φ. Thus, to check whether {a mathematical formula}D⊨Φ, we can simply choose one model {a mathematical formula}Mi per cell {a mathematical formula}ModDi, and then check whether, for all {a mathematical formula}i=1,…,n, {a mathematical formula}Mi⊨Φ; if this is the case, then, and only then, we can conclude that {a mathematical formula}D⊨Φ. Obviously, for this approach to be effective, we need a model {a mathematical formula}Mi per cell {a mathematical formula}ModDi and a way to perform the check. The rest of the proof addresses these two points.Let {a mathematical formula}F be the set of situation-suppressed fluents of {a mathematical formula}D, and C the (finite) set of constant symbols explicitly mentioned in {a mathematical formula}D (beyond {a mathematical formula}Duno). We observe that each cell {a mathematical formula}ModDi of the partition {a mathematical formula}ModD=(ModD1,…,ModDn) can be uniquely identified by an interpretation {a mathematical formula}Ii of {a mathematical formula}F and C over some infinite object domain Δ. Indeed, by transitivity of ∼, any two models {a mathematical formula}M,M′ of {a mathematical formula}D such that {a mathematical formula}I˜M(S0M)∼Ii and {a mathematical formula}I˜M′(S0M′)∼Ii are also such that {a mathematical formula}I˜M(S0M)∼I˜M′(S0M′). Notice that {a mathematical formula}Ii certainly exists, as one can simply take {a mathematical formula}I˜M(S0M), for some model {a mathematical formula}M∈ModDi. Clearly, each {a mathematical formula}Ii contains only a bounded number of objects in the active domain and satisfies {a mathematical formula}D0, i.e., {a mathematical formula}Ii⊨D0.Now, assume given one interpretation {a mathematical formula}Ii per cell {a mathematical formula}ModDi (we show below how to obtain them) and observe that, from {a mathematical formula}Ii, we can extract a complete initial situation description as a database {a mathematical formula}D0i. This can be easily done, as {a mathematical formula}Ii is finite. Consider the theory {a mathematical formula}Di=(D∖D0)∪D0i, obtained by replacing {a mathematical formula}D0 with {a mathematical formula}D0i, and assume the same interpretation of constants in C as that defined by {a mathematical formula}Ii. Under this assumption, {a mathematical formula}Di defines a family of models that differ only in the object domain and in the interpretation of constants outside C (which, however, must satisfy {a mathematical formula}Duno). In particular, the interpretation of fluents in {a mathematical formula}F and constants in C, at {a mathematical formula}S0, of all such models, is the same as that of {a mathematical formula}Ii. Thus, the models of {a mathematical formula}Di constitute a subset of {a mathematical formula}ModDi. To isolate one of such models, we fix an arbitrary infinite object domain Δ (such that {a mathematical formula}adom(Ii)⊆Δ), and arbitrarily extend the partial interpretation of constants over the constants outside C, satisfying {a mathematical formula}Duno. Notice that this can always be done, as Δ is infinite and the set of constant symbols countable. With Δ and the denotation of all constants fixed, {a mathematical formula}Di has complete information, i.e., yields a single model {a mathematical formula}Mi, thus, by Theorem 4, we can check whether {a mathematical formula}Di⊨Φ, i.e., whether {a mathematical formula}Mi⊨Φ (notice that, as it turns out from Procedure 1, to perform the check, one does not even need to know the interpretation of constants outside C). This, by the discussion above, is equivalent to checking whether for all models {a mathematical formula}M∈ModDi, it is the case that {a mathematical formula}M⊨Φ. Therefore, if the set of interpretations {a mathematical formula}Γ={I1,…,In} is given, we can check whether {a mathematical formula}D⊨Φ.It remains to explain how such a set of interpretations {a mathematical formula}Γ={I1,…,In} can be obtained. To this end, observe that, by Lemma 3, it follows that {a mathematical formula}|adom(Ii)|≤∑F∈FaF⋅b+|C|≐b′. Based on this, the set ϒ of interpretations {a mathematical formula}Ii can be obtained by: (i) fixing a set O of {a mathematical formula}b′ arbitrary objects; (ii) generating a set {a mathematical formula}ϒ′ of all the finitely many interpretations of {a mathematical formula}F and C over O, such that {a mathematical formula}Duno is enforced on C and for every interpretation {a mathematical formula}I′∈ϒ′, {a mathematical formula}I′⊨D0; (iii) for any set {a mathematical formula}ϒ″⊆ϒ′ of isomorphic interpretations, removing from {a mathematical formula}ϒ′ all but one of such interpretations (in fact, this step is not needed to our purposes, but avoids useless redundancies). The resulting {a mathematical formula}ϒ′ is the set of desired interpretations {a mathematical formula}I1,…,In, which we rename simply as ϒ.Now, observe that, by the way it is defined, ϒ contains, up to object renaming, all possible interpretations of {a mathematical formula}F and C over a set of {a mathematical formula}b′ distinct objects, that satisfy {a mathematical formula}D0 and {a mathematical formula}Duno (on C). Thus, since for a generic model {a mathematical formula}M of {a mathematical formula}D, the interpretation {a mathematical formula}I˜M(S0M) contains at most {a mathematical formula}b′ distinct objects (by the boundedness of {a mathematical formula}D), it turns out that there exists an interpretation {a mathematical formula}Ii∈ϒ such that {a mathematical formula}I˜M(S0M)∼Ii. Therefore, the cell {a mathematical formula}ModDi such that {a mathematical formula}M∈ModDi, is characterized by some interpretation {a mathematical formula}Ii∈ϒ, namely the interpretation at {a mathematical formula}S0 shared, up to object renaming, by the models of the cell itself. On the other hand, because any {a mathematical formula}Ii∈ϒ enforces {a mathematical formula}Duno and is such that {a mathematical formula}I⊨D0, it follows that there exists some model {a mathematical formula}M of {a mathematical formula}D such that {a mathematical formula}I˜M(S0M)∼Ii. Therefore, every interpretation of ϒ characterizes some cell {a mathematical formula}ModDi, specifically, that of the models {a mathematical formula}M such that {a mathematical formula}I˜M(S0M)∼Ii. Therefore, ϒ is indeed the set of desired interpretations. This concludes the proof.  □
     </paragraph>
     <paragraph>
      This result, besides stating decidability of the verification problem under incomplete information, provides us with an actual procedure to perform verification in this case.
     </paragraph>
    </section>
    <section label="8">
     <section-title>
      Computational complexity
     </section-title>
     <paragraph>
      In this section, we assess the computational complexity of verifying {a mathematical formula}μLp formulas over a bounded situation calculus basic action theory {a mathematical formula}D. In particular we show that the constructive techniques we have used for proving decidability are, in fact, optimal with respect to worst case computational complexity. We make the assumption that, for a basic action theory {a mathematical formula}D, the maximum number of distinct objects occurring in the state of any situation, dominates the input size of {a mathematical formula}D itself, and that there exists a bound {a mathematical formula}a¯F on the maximum arity of fluents. This is a reasonable assumption, analogous to that, typical in databases, that the size of the database provides a higher bound on the size of the input along all dimensions, and that, in practical cases, there exists an upper bound on the arity of relations. We exploit the constructive techniques introduced for showing decidability to get an exponential time upper-bound.
     </paragraph>
     <paragraph label="Proof">
      Verifying{a mathematical formula}μLpformulas over a situation calculus basic action theory bounded by b, with complete information on the initial situation, can be done in time exponential in b.This is a consequence of Procedure 1 and the complexity of {a mathematical formula}μLp model checking. Firstly, consider Procedure 1 and observe that, by Lemma 4, at any iteration, the number m of distinct objects occurring, overall, in the interpretations of states (i.e. {a mathematical formula}|adom(Q)| of Lemma 4) is bounded by {a mathematical formula}2b′+N, where {a mathematical formula}b′=∑F∈Fb⋅aF, {a mathematical formula}aF is the arity of fluent F, and N is the maximum number of parameters in action types. Since we assume {a mathematical formula}|F| and N bounded by b, and {a mathematical formula}aF bounded by a constant, it turns out that m is polynomial in b. Now, observe that, with m distinct objects and {a mathematical formula}aF bounded by a constant, one can obtain a number of interpretations of {a mathematical formula}F and C that is at most exponential in m, i.e., in (a polynomial of) b. Then, because in Procedure 1 every state is associated with exactly one interpretation, and since no state is visited more than once, we have that the while-loop (lines 6–20) terminates after, at most, an exponential number of iterations.As to each iteration, by our assumptions, we have that any loop inside the while-loop ends after at most exponentially many iterations. Indeed, for any action type with at most N parameters, we have at most {a mathematical formula}mN possible assignments, thus {a mathematical formula}mN≤mb′, which gives an exponential bound, as both m and {a mathematical formula}b′ are polynomial with respect to b. Now, observe that the dominant operation in the while-loop is checking whether two interpretations are isomorphic. Since also this check can be performed in exponential time with respect to b (the problem is in NP), we obtain, overall, an exponential time-bound for Procedure 1.Now, recall that propositional μ-calculus model checking is polynomial with respect to the sizes of the input transition system and the input formula [40]. As to the transition system, the check is performed on the one returned by Procedure 1, which has size at most exponential in b (i.e., as many interpretations as one can obtain with at most m objects, plus a quadratic number of transitions wrt it). As to the formula, say Φ, we first rewrite it (in polynomial time) into its equivalent domain-independent version {a mathematical formula}Φ′, and then “propositionalize” it, by quantifier elimination, using only the values that occur, overall, in the active domains of the interpretations of the states of the input transition system. This step can be done, again, in exponential time, and returns a quantifier-free formula exponentially larger than the original one, but equivalent to it, on the obtained finite transition system. Thus, since μ-calculus model checking is polynomial wrt the size of both the transition system and the formula, we obtain that, overall, the check requires time at most exponential wrt b.  □
     </paragraph>
     <paragraph label="Theorem 21">
      Such an exponential bound is, in fact, tight, as we can show the EXPTIME-hardness of the problem by reduction from acceptance in a polynomial-space bounded alternating Turing machine. Verifying{a mathematical formula}μLpformulas over bounded situation calculus basic action theories with complete information on the initial situation is EXPTIME-hard.
     </paragraph>
     <paragraph label="Proof">
      We show a reduction from polynomial-space bounded alternating Turing machines, whose acceptance problem is EXPTIME-complete [18]. A (one-tape) Alternating Turing Machine (ATM) [18] is a tuple {a mathematical formula}M=(Q,Γ,δ,q0,g) where
      <list>
       Q is the finite set of states;Γ is the finite tape alphabet;{a mathematical formula}δ:Q×Γ×Q×Γ×{L,R} is called the transition table (L shifts the head left and R shifts the head right);{a mathematical formula}q0∈Q is the initial state;{a mathematical formula}g:Q→{and,or,accept} specifies the type of each state.Following
      </list>
      <paragraph>
       [75] (Chap. 4), we can axiomatize the ATM using the following fluents:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}transTable(q,c,q′,c′,m,s). This is a situation-independent predicate (i.e., with a trivial successor-state-axioms preserving its content forever) describing the ATM's transition table δ: when in state q scanning tape symbol c, the machine enters state {a mathematical formula}q′, overwrites c with tape symbol {a mathematical formula}c′, and moves its tape head in the direction m, which is one of L (left) or R (right).
       </list-item>
       <list-item label="•">
        {a mathematical formula}gType(q,t,s). This is a situation-independent predicate assigning (once and for all) a type {a mathematical formula}t∈{and,or,accept} to the state q of the ATM.
       </list-item>
       <list-item label="•">
        {a mathematical formula}cell(i,c,s). This means that tape cell {a mathematical formula}i∈[0,…,ℓ] contains the symbol {a mathematical formula}c∈Γ∪{blank} in situation s. Notice that in every situation the number of facts of the form {a mathematical formula}cell(i,γ,s) is fixed and determined by the maximal length of the tape of the bounded ATM, ℓ. Initially, the first cells contains the input word w while the others are {a mathematical formula}blank.
       </list-item>
       <list-item label="•">
        {a mathematical formula}state(q,s). This means that in situation s, the machine's state is q. Initially, we have {a mathematical formula}state(q0,S0), where {a mathematical formula}q0 is the initial state of the ATM.
       </list-item>
       <list-item label="•">
        {a mathematical formula}scan(i,s). This means that the machine's head is scanning tape cell {a mathematical formula}i∈[0,…,ℓ] in situation s. Initially, the head is scanning tape cell 0. In any situation, there will only be one fact of the form {a mathematical formula}scan(i,s).
       </list-item>
      </list>
      <paragraph>
       We need just one action type {a mathematical formula}trans(q′,c′,m), meaning that the machine makes a transition from the current configuration to a new configuration where the state is {a mathematical formula}q′, tape symbol {a mathematical formula}c′ is written, and the tape head moves in direction m, whose precondition axiom is as follows:{a mathematical formula} The successor state axioms for the fluents that can change are as follows:{a mathematical formula} For initial situation description, assuming the input {a mathematical formula}w=c0…ci, we have:{a mathematical formula}Acceptance of the ATM is defined using the following {a mathematical formula}μLp formula Φ:{a mathematical formula} Then we have that {a mathematical formula}D⊨Φ if and only if M accepts w. Notice that in any situation there is exactly one fact of the form {a mathematical formula}gType(q,t,s). Notice also that the above condition does not require quantification across situations.  □
      </paragraph>
     </paragraph>
    </section>
    <section label="9">
     <section-title>
      Checking boundedness
     </section-title>
     <paragraph>
      We now show that we can always check whether a basic action theory maintains boundedness for a given bound. That is, if the initial situation description is bounded, then the entire theory is too (for all executable situations).
     </paragraph>
     <paragraph>
      First notice that we can determine in a situation s whether every executable action a if performed next does not exceed the bound (i.e. in {a mathematical formula}do(a,s)). We can capture the notion of a fluent F being bounded at the next step by the formula:{a mathematical formula} Notice that each {a mathematical formula}BoundedF,b(do(A(x→),s)) is regressable through {a mathematical formula}A(x→). As a result the formula above is equivalent to a first-order situation calculus formula uniform in s; we call the latter formula {a mathematical formula}NextOrigBoundedF,b(s), and we call {a mathematical formula}NextOrigBoundedb(s) the formula {a mathematical formula}⋀F∈FNextOrigBoundedF,b(s).
     </paragraph>
     <paragraph>
      To check that the theory is bounded by b it is sufficient to verify that the theory entails the temporal formula:{a mathematical formula} which expresses that always along any path {a mathematical formula}NextOrigBoundedb holds. Unfortunately deciding whether this formula is entailed by the action theory is directly doable with the techniques in previous sections only if the theory is bounded, which is what we want to check. However it turns out that we can construct a modified version of the action theory that is guaranteed to be bounded and that we can use to do the checking.
     </paragraph>
     <paragraph>
      Let {a mathematical formula}D be the action theory. We define a new action theory {a mathematical formula}DD obtained by augmenting {a mathematical formula}D as follows:
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}DDS0=DS0∪{ϕ[F→/F′→]|ϕ∈DS0}
      </list-item>
      <list-item label="•">
       {a mathematical formula}DDSS=DSS∪{F′(x→,do(a,s))≡Φ(x→,a,s)∧NextOrigBoundedb(s)|F(x→,do(a,s))≡Φ(x→,a,s)∈DSS}
      </list-item>
      <list-item label="•">
       {a mathematical formula}DDap={Poss(A(x→),s)≡Ψ(x→,a,s)∧NextOrigBoundedb(s)|Poss(A(x→),s)≡Ψ(x→,a,s)∈DAP}
      </list-item>
     </list>
     <paragraph label="Proof">
      By induction on situations.  □
     </paragraph>
     <paragraph>
      Now we define a new action theory {a mathematical formula}D′ which can be considered a sort of projection of {a mathematical formula}DD over the primed fluents only. Let {a mathematical formula}D′ be:
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}DS0′={ϕ[F→/F′→]|ϕ∈DS0}.
      </list-item>
      <list-item label="•">
       {a mathematical formula}DSS′={F′(x→,do(a,s))≡Φ[F→/F′→](x→,a,s)∧NextOrigBoundedb[F/F′](s)|F(x→,do(a,s))≡Φ(x→,a,s)∈DSS}
      </list-item>
      <list-item label="•">
       {a mathematical formula}Dap′={Poss(A(x→),s)≡Ψ[F→/F′→](x→,a,s)∧NextOrigBoundedb[F/F′](s)|Poss(A(x→),s)≡Ψ(x→,a,s)∈DAP}
      </list-item>
     </list>
     <paragraph label="Lemma 6">
      Notice that {a mathematical formula}D′ is bounded by construction if {a mathematical formula}DS0′ is, and furthermore it preserves the information about the original theory being bounded at the next step, though in terms of primed fluents. Exploiting the above lemma on {a mathematical formula}DD and the construction of {a mathematical formula}D′, we can show that {a mathematical formula}D′ has the following notable property: {a mathematical formula}
     </paragraph>
     <paragraph label="Proof">
      By Lemma 5, it is immediate to see that {a mathematical formula}D⊨AGNextOrigBoundedb(S0) implies {a mathematical formula}D′⊨AGNextOrigBoundedb[F→/F′→](S0). For the opposite direction, suppose that {a mathematical formula}D′⊨AGNextOrigBoundedb[F→/F′→](S0), but {a mathematical formula}D⊨AGNextOrigBoundedb(S0) does not hold. This means that there exists a model of {a mathematical formula}D and a situation S where {a mathematical formula}¬NextOrigBoundedb(S) holds, though in all previous situations {a mathematical formula}s&lt;S we have that {a mathematical formula}NextOrigBoundedb(s) holds. Now by Lemma 5, we can construct a model for {a mathematical formula}D′ such that the truth values of F are replicated in {a mathematical formula}F′ as long as {a mathematical formula}NextOrigBoundedb holds in the previous situation. So in S, we must have {a mathematical formula}¬NextOrigBoundedb[F→/F′→](S), which contradicts the assumption that {a mathematical formula}D′⊨AGNextOrigBoundedb[F→/F′→](S0).  □
     </paragraph>
     <paragraph>
      By Lemma 6, since {a mathematical formula}D′ is bounded by b if {a mathematical formula}DS0′ is, it follows that:
     </paragraph>
     <paragraph label="Theorem 22">
      Given a basic action theory whose initial situation description is bounded by b, then checking whether the entire theory is bounded by b is decidable.
     </paragraph>
     <paragraph label="Theorem 23">
      Notice that we pose no restriction on the initial situation description except that it is representable in first-order logic, hence checking its boundedness remains undecidable: Given a FO description of the initial situation{a mathematical formula}D0and a bound b, it is undecidable to check whether all models of{a mathematical formula}D0are bounded by b.
     </paragraph>
     <paragraph label="Proof">
      By reduction to FO unsatisfiability. Suppose we have an algorithm to check whether a FO theory {a mathematical formula}D0 is bounded by 0. Then we would have an algorithm to check (un)-satisfiability of {a mathematical formula}D0. Indeed consider for a fixed fluent {a mathematical formula}Fˆ:{a mathematical formula} Note that {a mathematical formula}⋀F∈F∀x→.¬F(x→,S0) has only models bounded by 0, while {a mathematical formula}∃x→.Fˆ(x→,S0) has only models with at least one tuple (and thus one object) in {a mathematical formula}Fˆ. Hence we get that {a mathematical formula}Dˆ0 is bounded by 0 iff {a mathematical formula}D0 is unsatisfiable. A similar argument holds for every bound b.  □
     </paragraph>
     <paragraph>
      Nonetheless in many cases we know by construction that the initial situation is bounded. In such cases the proof technique of Theorem 22 provides an effective way to check if the entire theory is bounded.
     </paragraph>
    </section>
    <section label="10">
     <section-title>
      Related work
     </section-title>
     <paragraph>
      Besides the situation calculus [65], [75], many other formalisms for reasoning about actions have been developed in AI, including the event calculus [55], [80], [81], the features and fluents framework [77], action languages such as {a mathematical formula}A[44] and {a mathematical formula}C+[47], the fluent calculus [87], and many others. In most of these, the focus is on addressing problems in the representation of action and change, such as the frame problem. Some attention has also been paid to specifying and verifying general temporal properties, especially in the context of planning. The Planning Domain Definition Language (PDDL) [66] has been developed for specifying planning domains and problems, and a recent version supports the expression of temporal constraints on the plan trajectory [46]. Approaches such as those in TLPlan [3], in TALplanner [56], or in planning via model checking [68] support planning with such temporal constraints. Within the situation calculus, temporal constraints for planning have been studied in, e.g., [11], [7]. All these planning-related approaches are essentially propositional and give rise to transition systems that are finite-state. One interesting attempt to interpret first-order linear temporal logic simultaneously as a declarative specification language and procedural execution language is that of MetateM[8], though verification is not addressed.
     </paragraph>
     <paragraph>
      Most work on verification has been done in computer science, generally focusing on finite-state systems and programs. Many logics have been developed to specify temporal properties of such systems and programs, including linear-time logics, such as Linear Temporal Logic (LTL) [69] and Property-Specification Language (PSL) [39], and branching time logics such as Computation Tree Logic (CTL) [20] and CTL{sup:⁎}[41], the μ-calculus [40], [15], which subsumes the previous two, as well as Propositional Dynamic Logic (PDL) [42], which incorporates programs in the language. Model checking (and satisfiability) in these propositional modal logics is decidable [6], but such logics can only represent finite domains and finite state systems. Practical verification systems, e.g., [52], [19], have been developed for many such logics, based on model checking techniques [6].
     </paragraph>
     <paragraph>
      In AI, verification by model checking has become increasingly popular in the autonomous agents and multi-agent systems area. There, many logics have been proposed that additionally deal with the informational and motivational attitudes of agents [72], [70], [90], [93], [23], [82]. Some recent work has been specifically concerned with formalizing multi-agent knowledge/belief and their dynamics [89], [51]. Moreover, various Belief–Desire–Intention (BDI) agent programming languages have been developed that operationalize these mental attitudes [71], [13], [24], [25]. Verification is important in this area as agent autonomy makes it crucial to be able to guarantee that the system behaves as required [43]. Furthermore, one generally wants to ensure that the agents' mental states as well as their behaviors evolve in a way that satisfies certain properties. Agent logics can be used to specify such properties. Much of the verification work in this area focuses on the model checking of BDI programs. For instance, [12] shows how to use the SPIN model checker [52] to verify properties of finite-state AgentSpeak programs. [36], [43] compile BDI programs and agent properties to verify into Java and use JPF[92] to model check them. [63] develops MCMAS, a symbolic model checker specifically for multi-agent systems. [2] develops a theorem proving-based verification framework for BDI programs that uses a PDL-like logic.
     </paragraph>
     <paragraph>
      In the situation calculus, there is also some previous work on verification. Perhaps the first such work is [34], where verification of possibly non-terminating Golog[58] programs is addressed, though no effective techniques are given. Focusing on the propositional situation calculus (where fluents have only the situation as argument), [86] presents decidable verification techniques. In [48], these techniques are generalized to a one-object-argument fluents fragment of the situation calculus, and in [49] to theories expressed in two-object-argument fragment. Techniques for verification resorting to second-order theorem proving with no decidability guarantees are presented in [82], [83], where the CASLve verification environment for multi-agent ConGolog[26] programs is described. In [21], characteristic graphs for programs are introduced to define a form of regression over programs to be used as a pre-image computation step in (sound) procedures for verifying Golog and ConGolog programs inspired by model checking. Verification of programs over a two-variable fragment of the situation calculus is shown to be decidable in [22]. [54] establishes conditions for verifying loop invariants and persistence properties. Finally, [32], [78] propose techniques (with model-checking ingredients) to reason about infinite executions of Golog and ConGolog programs based on second-order logic exploiting fixpoint approximates.
     </paragraph>
     <paragraph>
      More recently, work closely related to ours [27], [28], [31], [30] has shown that one obtains robust decidability results for temporal verification of situation calculus action theories under the assumption that in every situation the number of object tuples forming the extension of each fluent is bounded by a constant. In particular, [27] introduced bounded situation calculus basic action theories; this work, however, assumes standard names for the object domain and, more significantly, disallows quantification across situations in the verification language. In the present paper, which is a direct extension of [27], both of these limitations are removed. In [28] an extended language with an explicit knowledge operator was considered, while in [31] online executions (i.e., executions where the agent only performs actions that it knows are executable) and progression are studied; like [27], these papers also assume standard names and rule out quantification across situations from the verification language. [30] addresses verification over online executions with sensing in bounded situation calculus theories, adopting as verification language a first-order variant of Linear Temporal Logic (FO-LTL), again without quantification across situations.
     </paragraph>
     <paragraph>
      One may think of bounded action theories as related to certain classes of action theories that ensure that the progression of the theory remains first-order representable [61], [91], for instance, local-effect action theories [62], where only fluent instances involving the arguments of an action may be affected by it. However, it should be clear that bounded action theories need not be local-effect, as actions in a bounded action theory may affect fluent instances involving objects that are not arguments of the action, as long as the extension of fluents remains bounded. Nor are local-effect action theories necessarily bounded. Nonetheless, [31], [30] show that the progression of a bounded action theory is always first-order representable. It would be interesting to study further the relationship between such classes of theories.
     </paragraph>
     <paragraph>
      The work in this paper is also closely related to [10]. There, an ad-hoc formalism for representing actions and change is developed with the purpose of capturing data-aware artifact-centric processes. This formalism describes action preconditions and postconditions in first-order logic, and induces genericity[1] – there called uniformity – on the generated transition system. Intuitively genericity requires that if two states are isomorphic they induce the “same” transitions (modulo isomorphism). This means, in particular, that the system is essentially Markovian[75]. As verification language, [10] considers FO-CTL, a first-order variant of CTL that allows for quantifying across states without requiring object persistence, as, instead, we do here. Their results imply that one can construct a finite-state transition system over which the FO-CTL formula of interest can be verified. However, differently from our case, such a transition system depends also on the number of variables in the formula. While bounded situation calculus action theories enjoy genericity, it is easy to see that, without assuming object persistence, we immediately lose the possibility of abstracting to a finite transition system independently from the formula to verify. This is true even if we drop completely fixpoints. Indeed, assume that we have an action that replaces an object in the active domain by one in its parameters. Then, without persistence, for any bound n over the number of objects in a candidate finite abstraction, we can write a (fixpoint-free) formula saying that there exists a finite run with more than n distinct objects:{a mathematical formula} Obviously, this formula is false in the finite abstraction, while true in the original transition system, where objects are not “reused”. Notice that the formula belongs also to FO-CTL and this limitation applies to [10] as well. This observation shows that the persistence condition is crucial to obtain an abstraction that is independent from the formula.
     </paragraph>
     <paragraph>
      It is interesting to observe that while dropping persistence is certainly a valuable syntactic simplification, the deep reason behind it is that generic transition systems, including those generated by situation calculus basic action theories, are essentially unable to talk about objects that are not in the current active domain. If some object that is in the active domain disappears from it and reappears again, after some steps, the basic action theory will treat it essentially as a fresh object (i.e., an object never seen before). Hence, any special treatment of such objects must come from the formula we are querying the transition system with: for example, we may isolate runs with special properties and only on those do verification. The fact that FO-CTL can drop persistence while maintaining decidability of verification over generic transition systems tells us that FO-CTL is not powerful enough to isolate interesting runs to be used as a further assumption for verification. Recently, this intuition has been formally proven for the entire μ-calculus, by showing that the two notions of bisimulation induced by enforcing or relaxing persistence collapse for generic transition systems [17]. On the basis of this result, the paper shows the decidability of verification of μ-calculus properties without enforcing persistence against bounded situation calculus action theories. Interestingly this contrasts with the undecidability of FO-LTL when persistence is not enforced [17], [5].
     </paragraph>
     <paragraph>
      The results in this paper are relevant not only for AI, but also for other areas of computer science (CS). There is some work in CS that uses model checking techniques on infinite-state systems. However, in most of this work the emphasis is on studying recursive control rather than on a rich data-oriented state description; typically data are either ignored or finitely abstracted, see e.g., [16]. There has recently been some attention paid in the field of business processes and services to include data into the analysis of processes [53], [45], [38]. Interestingly, while we have verification tools that are quite good for dealing with data and processes separately, when we consider them together, we obtain infinite-state transition systems, which resist classical model checking approaches to verification. Only lately has there been some work on developing verification techniques that can deal with infinite-state processes [37], [4], [9], [5], [10]. In particular, the form of controlled quantification across situations in our {a mathematical formula}μLp language, which requires object persistence in the active domain, is inspired by the one in [5], which in turn extends the verification logic presented in [27]. There, the infinite-state data-aware transition systems (with complete information) to verify are defined using an ad-hoc formalism based on database operations, and the decidability results are based on two conditions over the transition systems, namely run-boundedness and state-boundedness. The latter is analogous to our situation-boundedness. In this paper, we make the idea of boundedness flourish in the general setting offered by the situation calculus, detailing conditions needed for decidability, allowing for incomplete information, and exploiting the richness of the situation calculus for giving sufficient conditions for boundedness that can easily be used in practice. Such results can find immediate application in the analysis of data-aware business processes and services.
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>