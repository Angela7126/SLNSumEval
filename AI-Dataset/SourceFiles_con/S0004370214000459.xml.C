<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    The price of query rewriting in ontology-based data access.
   </title>
   <abstract>
    We give a solution to the succinctness problem for the size of first-order rewritings of conjunctive queries in ontology-based data access with ontology languages such as OWL 2 QL, linear Datalog± and sticky Datalog±. We show that positive existential and nonrecursive datalog rewritings, which do not use extra non-logical symbols (except for intensional predicates in the case of datalog rewritings), suffer an exponential blowup in the worst case, while first-order rewritings can grow superpolynomially unless NP⊆P/poly. We also prove that nonrecursive datalog rewritings are in general exponentially more succinct than positive existential rewritings, while first-order rewritings can be superpolynomially more succinct than positive existential rewritings. On the other hand, we construct polynomial-size positive existential and nonrecursive datalog rewritings under the assumption that any data instance contains two fixed constants.
   </abstract>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Our aim in this article is to give a solution to the succinctness problem for various types of conjunctive query rewriting in ontology-based data access (OBDA) with basic ontology languages such as OWL 2 QL and fragments of {a mathematical formula}Datalog±.
     </paragraph>
     <paragraph>
      The idea of OBDA has been around since about 2005 [14], [19], [28], [47]. In the OBDA paradigm, an ontology defines a high-level global schema and provides a vocabulary for user queries. An OBDA system rewrites these queries into the vocabulary of the data and then delegates the actual query evaluation to the data sources (which can be relational databases, triple stores, datalog engines, etc.). OBDA is often regarded as an important ingredient of the new generation of information systems because it (i) gives a high-level conceptual view of the data, (ii) provides the users with a convenient vocabulary for queries, thus isolating them from the details of the structure of data sources, (iii) allows the system to enrich incomplete data with background knowledge, and (iv) supports queries to multiple and possibly heterogeneous data sources.
     </paragraph>
     <paragraph>
      A key concept of OBDA is first-order (FO) rewritability. An ontology language {a mathematical formula}L is said to enjoy FO-rewritability if any conjunctive query (CQ) q over any ontology Σ, formulated in {a mathematical formula}L, can be rewritten to an FO-query {a mathematical formula}q′ such that, for any data instance D, the answers to the original CQ q over the knowledge base {a mathematical formula}(Σ,D) can be computed by evaluating the rewriting {a mathematical formula}q′ over D. As {a mathematical formula}q′ is an FO-query, the answers to {a mathematical formula}q′ can be obtained using a standard relational database management system (RDBMS). Ontology languages with this property include the OWL 2 QL profile of the Web Ontology Language OWL 2, which is based on description logics of the DL-Lite family [16], [4], and fragments of {a mathematical formula}Datalog± such as linear tgds [11] (also known as atomic-body existential rules [6]) or sticky tgds [12], [13]. To illustrate, consider an OWL 2 QL-ontology Σ consisting of the following tuple-generating dependencies (tgds):{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} and the CQ {a mathematical formula}q(x) asking to find those who work with professors:{a mathematical formula} A moment's thought should convince the reader that the (positive existential) query{a mathematical formula} is an FO-rewriting of {a mathematical formula}q(x) and Σ in the sense that, for any set D of ground atoms and any constant a in D, we have{a mathematical formula} (In Section 2, we shall consider this example in more detail.) A number of different rewriting techniques have been proposed and implemented for OWL 2 QL (PerfectRef [47], Presto/Prexto [55], [54], Rapid [18], the combined approach [37], Ontop [51], [33]) and its various extensions (Requiem/Blackout [45], [46], Nyaya [25], [43], Clipper [20] and [35]). However, all FO-rewritings constructed so far have, in the worst case, been exponential in the size of the query q. Thus, despite the fact that, for data complexity, CQ answering over ontologies with FO-rewritability is as complex as standard database query evaluation (both are in {a mathematical formula}AC0), rewritings can be too large for RDBMSs to cope with. It has become apparent, in both theory and experiments, that for the OBDA paradigm to work in practice, we have to restrict attention to those ontologies and CQs that ensure polynomial FO-rewritability (in the very least).
     </paragraph>
     <paragraph>
      The major open question we are going to attack in this article is whether the standard ontology languages for OBDA (in particular, OWL 2 QL) enjoy polynomial FO-rewritability. Naturally, the answer depends on what means we can use in the rewritings. For example, in the rewriting {a mathematical formula}q′ of q and Σ above, we did not use any non-logical symbols other than those that occurred in q and Σ. Such rewritings (perhaps also containing equality) may be described as ‘pure’ as they can be used with all possible databases; cf. [16]. (Note that all known rewritings apart from the one in the combined approach [37] are pure in this sense.) Other important parameters are the available logical means (connectives and quantifiers) in rewritings and the way we represent them. Apart from the class of arbitrary FO-queries, we shall also consider positive existential (PE) queries and nonrecursive datalog (NDL) queries as possible formalisms for rewritings (needless to say that pure NDL-rewritings may contain new intensional predicates).
     </paragraph>
     <paragraph>
      At first sight, the results we obtain in this article could be divided into negative and positive. The bad news is that there is a sequence of CQs {a mathematical formula}qn and OWL 2 QL ontologies {a mathematical formula}Σn, both of size {a mathematical formula}O(n), such that any pure PE- or NDL-rewriting of {a mathematical formula}qn and {a mathematical formula}Σn is of exponential size in n, while any pure FO-rewriting is of superpolynomial size unless {a mathematical formula}NP⊆P/poly. We obtain this negative result by first showing that OBDA with OWL 2  QL is powerful enough to compute monotone Boolean functions in NP, and that PE-rewritings correspond to monotone Boolean formulas, NDL-rewritings to monotone Boolean circuits, and FO-rewritings to arbitrary Boolean formulas. Then we use the celebrated exponential lower bounds for the size of monotone circuits and formulas computing the (NP-complete) Boolean function {a mathematical formula}Cliquen,k ‘a graph with n nodes contains a k-clique’ [50], [49]; a superpolynomial lower bound for the size of arbitrary (not necessarily monotone) Boolean formulas computing {a mathematical formula}Cliquen,k is a consequence of the assumption {a mathematical formula}NP⊈P/poly. We also use known separation results [49], [48] for monotone Boolean functions such as ‘a bipartite graph with n vertices in each part has a perfect matching’ and ‘a given vertex is accessible in a path accessibility system with n vertices’ to show that pure NDL-rewritings are in general exponentially more succinct than pure PE-rewritings, while pure FO-rewritings can be superpolynomially more succinct than pure PE-rewritings.
     </paragraph>
     <paragraph>
      On the other hand, we have some good news as well: assuming that every data instance contains two fixed distinct individual constants, we construct polynomial-size impure PE- and NDL-rewritings of any CQ and any ontology with the polynomial witness property (in particular, any ontology in OWL 2 QL, linear {a mathematical formula}Datalog± of bounded arity or sticky {a mathematical formula}Datalog± of bounded arity). In essence, the rewriting guesses a polynomial number of ground atoms with database individuals and labelled nulls (encoded as tuples over the two fixed constants), and checks whether these atoms satisfy the given CQ and form a sequence of chase steps. We first construct a polynomial-size impure PE-rewriting and then show how its disjunctions can be encoded by a polynomial-size NDL-rewriting with intensional predicates of small arity. As the two constants in the impure PE-rewriting can be replaced with two fresh existentially quantified variables, say x and y, such that {a mathematical formula}x≠y, we also obtain a polynomial-size pure FO-rewriting over data instances with at least two domain elements.
     </paragraph>
     <paragraph>
      How to reconcile these seemingly contradictory results? To establish exponential and superpolynomial lower bounds for the size of pure rewritings, we show that computing monotone Boolean functions in NP is polynomially reducible to answering CQs over OWL 2 QL-ontologies and data instances with a single individual. As evaluating queries over such data instances is tractable, pure rewritings of the CQs and ontologies computing NP-complete monotone Boolean functions such as {a mathematical formula}Cliquen,k cannot be constructed in polynomial time—unless {a mathematical formula}P=NP. (Our argument in Section 3 is a bit subtler: we prove that pure polynomial rewritings of the CQs and ontologies computing NP-complete monotone Boolean functions do not actually exist.) In fact, standard pure rewritings represent explicitly all distinct homomorphisms of the given CQ into the labelled nulls of possible chases for the given ontology, and our construction shows that there may be exponentially-many such homomorphisms. On the other hand, our impure rewritings employ polynomially-many additional existential quantifiers over two fixed distinct domain elements in order to guess those homomorphisms. Thus, we show that the additional NP-overhead of OBDA compared to CQ evaluation over plain databases can be represented in a succinct way. The exponential succinctness of impure rewritings compared to pure ones is of the same kind as the succinctness of nondeterministic finite automata or ∃-QBFs compared to deterministic automata [42] or, respectively, SAT (cf. also [5]).
     </paragraph>
     <paragraph>
      The plan of the article is as follows. In Section 2, we introduce OWL 2 QL, linear and sticky {a mathematical formula}Datalog± as fragments of the language of tuple-generating dependencies and illustrate the construction of an FO-rewriting for OWL 2 QL-ontologies. We also introduce nonrecursive datalog rewritings and formulate the succinctness and separation problems. The exponential and superpolynomial lower bounds on the size of pure rewritings are obtained in Section 3. The polynomial-size impure PE- and NDL-rewritings for families of ontologies with the polynomial witness property are constructed in Section 4. We prove the separation results mentioned above in Section 5. Open problems and directions for future research are discussed in Section 6.
     </paragraph>
     <paragraph>
      Some of the results in this article first appeared in the conference proceedings [26], [32].
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      First-order rewritability: size of rewritings matters
     </section-title>
     <paragraph>
      Let {a mathematical formula}R be a relational schema. Given a data instance D over {a mathematical formula}R, we denote by {a mathematical formula}ΔD the set of individual constants in D. We regard D as a (finite) set of ground atoms. A conjunctive query (CQ, for short) {a mathematical formula}q(x) is a formula of the form {a mathematical formula}∃yφ(x,y), where φ is a conjunction of atoms {a mathematical formula}P(t) over {a mathematical formula}R extended with equality, and each t in t is a term (an individual constant or a variable from {a mathematical formula}x,y). The size{a mathematical formula}|q| of a CQ q is the number of symbols in q.
     </paragraph>
     <paragraph>
      Let Σ be a set of first-order sentences over {a mathematical formula}R. The pair {a mathematical formula}(Σ,D) is called a knowledge base (KB, for short). A tuple a of elements in {a mathematical formula}ΔD is said to be a certain answer to {a mathematical formula}q(x) over the KB {a mathematical formula}(Σ,D) if {a mathematical formula}M⊨q(a) for every model {a mathematical formula}M of {a mathematical formula}Σ∪D; in this case we write {a mathematical formula}(Σ,D)⊨q(a). If the tuple x of answer variables is empty, a certain answer to q over {a mathematical formula}(Σ,D) is ‘yes’ in case {a mathematical formula}M⊨q for every model {a mathematical formula}M of {a mathematical formula}Σ∪D, and ‘no’ otherwise. CQs without answer variables are called Boolean CQs.
     </paragraph>
     <paragraph>
      For the purposes of OBDA, we are interested in ontologies (or theories) Σ for which the problem of finding certain answers can be reduced to standard database query evaluation. More precisely, a first-order formula {a mathematical formula}q′(x) is called a first-order rewriting of q and Σ (FO-rewriting, for short) if, for any data instance D, a tuple a of elements in {a mathematical formula}ΔD is a certain answer to {a mathematical formula}q(x) over {a mathematical formula}(Σ,D) just in case a is an answer to {a mathematical formula}q′(x) over D. We say that Σ enjoys first-order rewritability if, for any CQ {a mathematical formula}q(x), there exists an FO-rewriting of q and Σ.
     </paragraph>
     <paragraph>
      There are two types of recognised ontology languages that guarantee first-order rewritability. The languages of the first type were introduced by the description logic community; they are based on the DL-Lite family of description logics [16], [4] and include the OWL 2 QL profile of the Web Ontology Language OWL 2.{sup:1} The languages of the second type were designed by the datalog community; they belong to the {a mathematical formula}Datalog± family [12], [11] and are also known as existential rules [7]. All of these ontology languages can be formulated in terms of tuple-generating dependencies.
     </paragraph>
     <paragraph>
      We remind the reader [1] that a tuple-generating dependency (a tgd, for short) is a first-order sentence of the form{a mathematical formula} where {a mathematical formula}φ(x), the body, and {a mathematical formula}ψ(x,y), the head of the tgd, are conjunctions of atoms and all the variables in x actually occur in {a mathematical formula}φ(x) (note that both {a mathematical formula}φ(x) and {a mathematical formula}ψ(x,y) can contain individual constants). Following the description logic tradition, we also consider negative constraints of the form{a mathematical formula} Finite sets of tgds and negative constraints will be called ontologies. (Note that ontologies can be inconsistent.) Given an ontology Σ, we denote by {a mathematical formula}|Σ| its size, that is, the number of symbols in Σ.
     </paragraph>
     <paragraph>
      An important property of tgds is the well-known fact [1] that, for any ontology Σ and any consistent KB {a mathematical formula}(Σ,D), there exists a (possibly infinite) model {a mathematical formula}CΣ,D of {a mathematical formula}(Σ,D), known as a universal (or canonical) model of {a mathematical formula}(Σ,D), such that, for any CQ {a mathematical formula}q(x) and any tuple a from {a mathematical formula}ΔD, we have {a mathematical formula}(Σ,D)⊨q(a) if and only if {a mathematical formula}CΣ,D⊨q(a). Such a universal model can be constructed by the following (oblivious) chase procedure, which, intuitively, ‘repairs’ D with respect to Σ (but not in the most economical way). We require the following definitions to describe the chase procedure formally. Let {a mathematical formula}C be a set of ground atoms and {a mathematical formula}φ(x) a conjunction of atoms (the body of a tgd or a negative constraint). We say that a map h from x to the individual constants in {a mathematical formula}C is a homomorphism from {a mathematical formula}φ(x) to {a mathematical formula}C if {a mathematical formula}h(φ(x))⊆C, where {a mathematical formula}h(φ(x)) denotes the set of atoms {a mathematical formula}P(h(t)), for {a mathematical formula}P(t) in {a mathematical formula}φ(x) (as usual, we assume that {a mathematical formula}h(a)=a, for any individual constant a). We say that {a mathematical formula}C is consistent with Σ if there is no negative constraint {a mathematical formula}∀x(φ(x)→⊥) in Σ with a homomorphism h from {a mathematical formula}φ(x) to {a mathematical formula}C.
     </paragraph>
     <paragraph>
      The chase algorithm initially sets {a mathematical formula}CΣ,D0=D. Suppose now that {a mathematical formula}CΣ,Dk−1 has already been defined. A tgd τ of the form {a mathematical formula}∀x(φ(x)→∃yψ(x,y)) is said to be applicable to{a mathematical formula}CΣ,Dk−1via h if h is a homomorphism from {a mathematical formula}φ(x) to {a mathematical formula}CΣ,Dk−1 with either {a mathematical formula}k=1 or {a mathematical formula}h(φ(x))⊈CΣ,Dk−2. Define an extension {a mathematical formula}h′ of h by taking {a mathematical formula}h′(x)=h(x) for every x in x, and {a mathematical formula}h′(y)=cy for every y in y, where {a mathematical formula}cy is a fresh individual constant (a labelled null) different from all constants already used in the construction. An application of τ under h to{a mathematical formula}CΣ,Dk−1 adds the ground atoms of {a mathematical formula}h′(ψ(x,y)) to {a mathematical formula}CΣ,Dk−1 if they are not there yet. If {a mathematical formula}CΣ,Dk−1 is consistent with Σ, the algorithm constructs {a mathematical formula}CΣ,Dk as follows: it takes some enumeration of all distinct pairs {a mathematical formula}(τi,hi), {a mathematical formula}i≤n, such that {a mathematical formula}τi∈Σ is applicable to {a mathematical formula}CΣ,Dk−1 via {a mathematical formula}hi, and sets {a mathematical formula}CΣ,Dk to be the result of applying each {a mathematical formula}τi under {a mathematical formula}hi to {a mathematical formula}CΣ,Dk−1. The chase{a mathematical formula}CΣ,D of {a mathematical formula}(Σ,D) is the union of all {a mathematical formula}CΣ,Dk for {a mathematical formula}k&lt;ω, provided that the {a mathematical formula}CΣ,Dk are consistent with Σ.
     </paragraph>
     <paragraph>
      For example, Fig. 1 shows the chase {a mathematical formula}CΣ,D for the ontology Σ consisting of the tgds (1), (2), (3), (4) from the introduction and the data instance {a mathematical formula}D={RA(ck),worksOn(ck,e),Project(e),isManagedBy(e,gg)} (note that, in general, the chase is not necessarily finite).
     </paragraph>
     <paragraph label="Proof">
      The model {a mathematical formula}CΣ,D is called universal because, for any model {a mathematical formula}M of {a mathematical formula}(Σ,D), there is a homomorphism from {a mathematical formula}CΣ,D to {a mathematical formula}M. It is this property of the universal models that makes sure that all certain answers to CQs over {a mathematical formula}(Σ,D) are contained in {a mathematical formula}CΣ,D. Furthermore, we say that an ontology has the bounded derivation depth property (BDDP, for short) if there is a function {a mathematical formula}d:N→N such that, for any CQ {a mathematical formula}q(x) and any data instance D, a tuple a from {a mathematical formula}ΔD is a certain answer to q over {a mathematical formula}(Σ,D) if and only if {a mathematical formula}CΣ,Dd(|q|)⊨q(a). (Note that {a mathematical formula}d(|q|) does not depend on D but can depend on Σ.) The following theorem gives a characterisation of ontologies enjoying FO-rewritability: An ontology has the BDDP if and only if it enjoys FO-rewritability.For a proof of {a mathematical formula}(⇒) see [11, Theorem 9]. To show {a mathematical formula}(⇐), we use [9, Proposition 4] (based on [56]) according to which, whenever there is an FO-rewriting of {a mathematical formula}q(x) and Σ, there is also a rewriting of the form {a mathematical formula}q′(x)=⋁i∃yiφi(x,yi), where each {a mathematical formula}∃yiφi(x,yi) is a CQ. Let k be the maximum number of atoms in the CQs {a mathematical formula}∃yiφi(x,yi), which depends only on q (for a fixed Σ). Clearly, every answer a to {a mathematical formula}q′(x) over D is also an answer to {a mathematical formula}q′(x) over some subset {a mathematical formula}D′⊆D with {a mathematical formula}|D′|≤k. It follows that {a mathematical formula}CΣ,D⊨q(a) if and only if {a mathematical formula}CΣ,D′⊨q(a) for some {a mathematical formula}D′⊆D with {a mathematical formula}|D′|≤k. Observe that the number of pairwise non-isomorphic D with {a mathematical formula}|D|≤k is finite and depends only on q (for a fixed Σ). Thus, we can take {a mathematical formula}d(|q|) to be a number d such that {a mathematical formula}CΣ,Dd⊨q(a) whenever {a mathematical formula}CΣ,D⊨q(a), for any D with {a mathematical formula}|D|≤k. □
     </paragraph>
     <paragraph>
      Disjunctions of CQs, used in the proof of Theorem 1, are known as unions of conjunctive queries or UCQs, for short. An FO-rewriting of q and Σ in the form of a UCQ is called a UCQ-rewriting of q and Σ. (That the BDDP of Σ is equivalent to the existence of UCQ-rewritings for all CQs over Σ can be shown using an earlier result from graph databases [57] and the fact that minimal UCQ-rewritings are unique up to isomorphism [36]; an ontology with UCQ-rewritings for all CQs is called a finite unification set by Baget et al. [6].)
     </paragraph>
     <paragraph>
      The following ontology languages ensure the BDDP:
     </paragraph>
     <list>
      <list-item label="–">
       linear tgds[11], that is, tgds with a single atom in the body;
      </list-item>
      <list-item label="–">
       OWL 2 QL-tgds, that is, linear tgds with atoms of arity ≤2 and without individual constants;
      </list-item>
      <list-item label="–">
       sticky sets of tgds[13], that is, sets of tgds such that the variables that appear more than once in the body of a tgd (join variables) are propagated (or ‘stick’) during the chase to all the inferred atoms
      </list-item>
     </list>
     <paragraph label="Remark 2">
      (other examples include sticky-join sets of tgds [13] and domain-restricted rules [7]). Each of the above ontology languages can also include negative constraints; they do not affect the chase procedure but can make a knowledge base inconsistent [11]. It is not hard to see that the standard OWL 2 QL profile of the Web Ontology Language OWL 2 can be represented in terms of OWL 2 QL-tgds and negative constraints, but not the other way round: for example, the tgd {a mathematical formula}∀x(R(x,x)→A(x)) cannot be expressed in OWL 2 QL. However, all the OWL 2 QL-tgds and negative constraints we use in this article are expressible in OWL 2 QL. Thus, the linear tgd of the form{a mathematical formula} used in (1) and (2) as well as in the construction of Section 3 can be encoded by the concept inclusion {a mathematical formula}A⊑∃R.B in the OWL 2 QL description logic syntax (where A and B are concept names and R is a role name), or as the following set of concept and role inclusions in the syntax of {a mathematical formula}DL-LitecoreH[4]:{a mathematical formula} where {a mathematical formula}RB is a fresh role name. Because of this, we slightly abuse terminology and call ontologies with OWL 2 QL-tgds simply OWL 2 QL-ontologies.
     </paragraph>
     <paragraph label="Example 3">
      We now give an example showing how one can construct FO-rewritings of CQs and OWL 2 QL-ontologies. Consider again the OWL 2 QL-ontology {a mathematical formula}Σ={(1),…,(4)} and the CQ (5) from the introduction. Suppose {a mathematical formula}a∈ΔD is a certain answer to {a mathematical formula}q(x) over {a mathematical formula}(Σ,D), for some data instance D. This means that {a mathematical formula}CΣ,D⊨q(a), and so there is a homomorphism h from {a mathematical formula}q(x) to {a mathematical formula}CΣ,D with {a mathematical formula}h(x)=a. We construct an FO-rewriting {a mathematical formula}q′(x) of {a mathematical formula}q(x) and Σ by analysing possible locations of {a mathematical formula}h(y) and {a mathematical formula}h(z) in {a mathematical formula}CΣ,D. To begin with, both of them can belong to {a mathematical formula}ΔD. To take account of such a homomorphism, we include {a mathematical formula}∃y,z(worksOn(x,y)∧(worksOn(z,y)∨isManagedBy(y,z)∨involves(y,z))∧Professor(z)) in {a mathematical formula}q′(x) as a disjunct. Another possible homomorphism, {a mathematical formula}h1, can have {a mathematical formula}h1(y) in {a mathematical formula}ΔD but {a mathematical formula}h1(z) among the labelled nulls, which can happen if {a mathematical formula}h1(y) is an instance of Project (see Fig. 2 in the middle). To take such a homomorphism into account, we include the disjunct {a mathematical formula}∃y(worksOn(x,y)∧Project(y)) in {a mathematical formula}q′. Then, there can be a homomorphism, {a mathematical formula}h2, with both {a mathematical formula}h2(y) and {a mathematical formula}h2(z) being labelled nulls, which can happen if {a mathematical formula}h2(x) is an instance of RA (see Fig. 2 on the left). This gives us the third disjunct, {a mathematical formula}RA(x), in {a mathematical formula}q′(x). Finally, there can be a homomorphism, {a mathematical formula}h3, such that {a mathematical formula}h3(y) is a labelled null but {a mathematical formula}h3(z) is in {a mathematical formula}ΔD—this can happen if {a mathematical formula}h3(z)=h3(x) is an instance of both RA and Professor (see Fig. 2 on the right). This homomorphism, however, gives a disjunct {a mathematical formula}RA(x)∧Professor(z)∧(x=z), which is subsumed by the third disjunct, {a mathematical formula}RA(x), and so is redundant. Thus, we obtain the FO-rewriting {a mathematical formula}q′(x) of {a mathematical formula}q(x) and Σ given in the introduction.
     </paragraph>
     <paragraph label="Example 4">
      Our next example gives an ontology without BDDP. Consider the ontology {a mathematical formula}Σ={∀x,y(R(x,y)∧A(y)→A(x))}, whose single tgd is not linear or OWL 2 QL (because of the two atoms in the body) and not sticky either (because of the variable y). Given a data instance D, we can again construct a universal model of {a mathematical formula}(Σ,D) using the chase procedure. However, to derive {a mathematical formula}A(a) for some {a mathematical formula}a∈ΔD, we have to find an R-chain between a and some b with {a mathematical formula}A(b)∈D. The number of chase steps producing chains of this kind may clearly depend on D. Ontologies such as Σ are allowed in the OWL 2 EL profile of OWL 2. CQ answering over OWL 2 EL-ontologies is known to be P-complete for data complexity [15], which means that in general they do not enjoy FO-rewritability. (A different approach to OBDA with OWL 2 EL was suggested by Lutz et al. [40].) On the other hand, CQs over ontologies formulated in OWL 2 EL and the description logics Horn-{a mathematical formula}SHIQ and Horn-{a mathematical formula}SROIQ can be rewritten into (recursive) datalog queries [53], [44], [20] and used together with datalog engines.
     </paragraph>
     <paragraph>
      OBDA via FO-rewritability is based on the empirical assumption that query evaluation using RDBMSs is efficient in practice. However, this assumption only works for reasonably small CQs; evaluation of large CQs can be a very hard problem for RDBMSs (see, e.g., [41]), which should not come as a surprise because CQ evaluation is {a mathematical formula}W[1]-complete{sup:2}[21]. Recall, however, that CQs of bounded treewidth can be evaluated in polynomial time in {a mathematical formula}|q| and {a mathematical formula}|ΔD|[60], [34], [17], [27]. Since such CQs occur most often in practice, this result can serve as a theoretical justification for the empirical assumption above.
     </paragraph>
     <paragraph label="Theorem 5">
      But what is the size of the existing FO-rewritings for CQs and ontologies in the languages under consideration? The following theorem summarises some of the known results: (See[16], [11], [25], [13], [24].) For any set Σ of tgds, let{a mathematical formula}KΣbe the number of predicates in Σ and let{a mathematical formula}LΣbe the maximum arity of the predicates in Σ.
     </paragraph>
     <list>
      <list-item label="(i)">
       There exist CQs q and sets Σ of OWL 2 QL-tgds any UCQ-rewritings of which have{a mathematical formula}Ω(KΣ|q|)CQs.
      </list-item>
      <list-item label="(ii)">
       Any CQ q and any set Σ of linear tgds without constants have a UCQ-rewriting with{a mathematical formula}O((KΣ⋅(LΣ⋅|q|)LΣ)|q|)CQs such that the number of atoms in each CQ does not exceed the number of atoms in q.In particular, for OWL 2 QL-tgds Σ,{a mathematical formula}LΣ≤2and the UCQ-rewriting has{a mathematical formula}O((KΣ⋅(2|q|)2)|q|)CQs.
      </list-item>
      <list-item label="(iii)">
       Any CQ q and any sticky set Σ of tgds without constants have a UCQ-rewriting with{a mathematical formula}2O(KΣ⋅(LΣ⋅|q|)LΣ)CQs, each of which has{a mathematical formula}O(KΣ⋅(LΣ⋅|q|)LΣ)atoms.
      </list-item>
     </list>
     <paragraph label="Proof">
      (i) Let {a mathematical formula}Σ={∀x(Ai(x)→A0(x))|1≤i≤n} and {a mathematical formula}q=∃x1,…,xk(A0(x1)∧⋯∧A0(xk)). It should be clear that any UCQ-rewriting of q and Σ must contain CQs with all possible combinations of {a mathematical formula}A0(xj),A1(xj),…,An(xj), for each {a mathematical formula}1≤j≤k.For (ii) and (iii), we only briefly comment on the UCQ-rewritings constructed in [16], [11], [25], [13], [24] using backward chaining. (ii) Since the tgds have a single atom in the body, the number of atoms in each of the CQs of the resulting UCQ-rewriting cannot be larger than the number of atoms in q. Thus, each of these CQs contains at most {a mathematical formula}LΣ⋅|q| terms, and we can assume that they use the same names for existentially quantified variables. The total number of atoms we can form using these terms does not exceed {a mathematical formula}KΣ⋅(LΣ⋅|q|)LΣ. Given that each CQ of the UCQ-rewriting has at most {a mathematical formula}|q| atoms, the total number of possible component CQs is bounded by {a mathematical formula}(KΣ⋅(LΣ⋅|q|)LΣ)|q|. (iii) Observe that the new variables arising in the UCQ-rewriting are all existentially quantified. Due to the stickiness condition, any such new variable must occur at most once in the body of the tgd used for the rewriting. This variable cannot interact with any other variable, and we can use a unique special symbol for it, which corresponds to the ‘don't care’ underscore symbol in Prolog. Then each term in each atom of the rewritten query is either a variable from q or the special underscore symbol (in the end, each underscore symbol is replaced by a fresh existentially quantified variable). There are at most {a mathematical formula}LΣ⋅|q|+1 such terms. It follows that there are at most {a mathematical formula}KΣ⋅(LΣ⋅|q|+1)LΣ=O(KΣ⋅(LΣ⋅|q|)LΣ) atoms in any CQ of the UCQ-rewriting. Each of the atoms is either included in a CQ or not included in it, which gives {a mathematical formula}2O(KΣ⋅(LΣ⋅|q|)LΣ) possible CQs in the UCQ-rewriting. □
     </paragraph>
     <paragraph>
      Thus, even for the weakest ontology language OWL 2 QL, the available (UCQ) rewritings are of exponential size in the worst case. The chief problem we analyse in this article is whether there exist shorter rewritings. Together with FO- and UCQ-rewritings defined above, we also consider positive existential and nonrecursive datalog rewritings.
     </paragraph>
     <paragraph>
      A positive existential rewriting (PE-rewriting, for short) of a CQ {a mathematical formula}q(x) and an ontology Σ is an FO-rewriting {a mathematical formula}q′(x) of the form {a mathematical formula}∃zψ(x,z), where ψ is built from atoms using only ∧ and ∨. (Every PE-rewriting can obviously be transformed to an equivalent UCQ-rewriting but at the expense of an exponential blowup.) To define nonrecursive datalog rewritings, we remind the reader [1] that a datalog program, Π, is a finite set of Horn clauses{a mathematical formula} where each {a mathematical formula}Ai is an atom of the form {a mathematical formula}P(t) and each term t in t is either a (universally quantified) variable or an individual constant. {a mathematical formula}A0 is called the head of the clause, and {a mathematical formula}A1,…,Am its body. All variables occurring in the head {a mathematical formula}A0 must also occur in the body in one of {a mathematical formula}A1,…,Am. A predicate P depends on a predicate Q if Π contains a clause whose head's predicate is P and whose body contains an atom with predicate Q. A datalog program Π is called nonrecursive if this dependence relation is acyclic. A nonrecursive datalog query consists of a nonrecursive datalog program Π and a goal{a mathematical formula}G(x), which is just an atom. Given a data instance D, a tuple a of elements in {a mathematical formula}ΔD is called a certain answer to {a mathematical formula}(Π,G(x)) over D if {a mathematical formula}Π∪D⊨G(a). A nonrecursive datalog query {a mathematical formula}(Π,G(x)) is called a nonrecursive datalog rewriting of a CQ {a mathematical formula}q(x) and an ontology Σ (NDL-rewriting, for short) if, for any data instance D and any tuple a of elements in {a mathematical formula}ΔD, we have {a mathematical formula}(Σ,D)⊨q(a) if and only if {a mathematical formula}Π∪D⊨G(a).
     </paragraph>
     <paragraph>
      So far we have not specified what means one is allowed to use in rewritings. The first FO-rewritings of [16], [45] were formulated in the signature that contained only constant and predicate symbols from q and Σ as well as equality. As argued by Calvanese et al. [16], FO-rewritings should be data-independent (and so applicable to all possible data instances). We start by adopting this definition for FO- and PE-rewritings; in NDL-rewritings, we can, of course, use new definable (or intensional) predicates, but no constants that do not occur in q.
     </paragraph>
     <paragraph>
      We are interested in three major questions: (i) Do there exist polynomial-size FO-, PE-, NDL-rewritings of CQs and OWL 2 QL-ontologies? (ii) Can rewritings of one type be substantially shorter than rewritings of other types? (iii) What extra means in rewritings can make them substantially shorter?
     </paragraph>
    </section>
    <section label="3">
     <section-title>
      Exponential and superpolynomial lower bounds for the size of rewritings
     </section-title>
     <paragraph>
      In this section, we give an answer to question (i). To this end, we show how the problem of constructing circuits that compute monotone Boolean functions in NP can be reduced to the problem of finding rewritings for CQs and OWL 2  QL-ontologies. This reduction coupled with the known lower bounds on the size of monotone Boolean circuits and formulas will provide us with similar lower bounds on the size of rewritings.
     </paragraph>
     <paragraph>
      We begin by reminding the reader of some basic definitions from the theory of circuit complexity (for more details see, e.g., [3], [29]). By an n-ary Boolean function, for {a mathematical formula}n≥1, we mean a function from {a mathematical formula}{0,1}n to {a mathematical formula}{0,1}. A Boolean function f is monotone if {a mathematical formula}f(α)≤f(β) for all {a mathematical formula}α≤β, where ≤ is the component-wise ≤ on vectors of {a mathematical formula}{0,1}. An n-input Boolean circuit, C, is a directed acyclic graph with n sources, inputs, and one sink, output. Every non-source node of C is called a gate and is labelled with either ∧ or ∨, in which case it has two incoming edges, or with ¬, in which case it has one incoming edge. A circuit is monotone if it contains only ∧- and ∨-gates. Boolean formulas can be thought of as circuits in which every gate has at most one outgoing edge. For an input {a mathematical formula}α∈{0,1}n, the output of C on α is denoted by {a mathematical formula}C(α), and C is said to compute an n-ary Boolean function f if {a mathematical formula}C(α)=f(α), for every {a mathematical formula}α∈{0,1}n. The size of C, denoted {a mathematical formula}|C|, is the number of nodes in C (that is, the number of inputs and gates).
     </paragraph>
     <paragraph>
      A family of Boolean functions is a sequence {a mathematical formula}f1,f2,…, where each {a mathematical formula}fn is an n-ary Boolean function. A family {a mathematical formula}f1,f2,… is in the complexity class NP if the language {a mathematical formula}{α∈{0,1}n|fn(α)=1} is in NP. For each such family, there exist polynomials p, q and Boolean circuits {a mathematical formula}C1,C2,… such that {a mathematical formula}Cn has {a mathematical formula}n+p(n) inputs, {a mathematical formula}|Cn|≤q(n) and, for any {a mathematical formula}α∈{0,1}n, we have{a mathematical formula} We call the additional {a mathematical formula}p(n) inputs for β in {a mathematical formula}Cnnondeterministic inputs (β is also known as a certificate[3]). A family {a mathematical formula}f1,f2,… is NP-complete if the corresponding language {a mathematical formula}{α∈{0,1}n|fn(α)=1} is NP-complete.
     </paragraph>
     <paragraph>
      The class of languages that are decidable by families of polynomial-size circuits is denoted by P/poly. It is known that {a mathematical formula}P⫋P/poly. Thus, we would obtain {a mathematical formula}P≠NP if we could show that {a mathematical formula}NP⊈P/poly. By the Karp–Lipton theorem (see, e.g., [3]), {a mathematical formula}NP⊆P/poly implies {a mathematical formula}PH=Σ2p.
     </paragraph>
     <paragraph>
      In this section, given a family of monotone Boolean functions {a mathematical formula}fn in NP, we first encode them—via the Tseitin transformation [59]—by means of polynomial-size CNFs, which are used to construct a sequence of OWL 2  QL-ontologies {a mathematical formula}Σfn and Boolean CQs {a mathematical formula}qfn such that{a mathematical formula} where the database instance {a mathematical formula}Dα is determined by α. Then, using the fact that the {a mathematical formula}Dα have a single domain element, we show that if we have, say, PE-rewritings of the {a mathematical formula}qfn and {a mathematical formula}Σfn, then those rewritings are in essence monotone Boolean formulas (that is, propositional PE-formulas), and so, by the known results on circuit complexity, cannot be polynomial, for example, in the case of the family of Boolean functions that check whether a given graph (encoded by arguments of the functions) contains a clique of the specified size.
     </paragraph>
     <paragraph label="Proof">
      Suppose we are given a family of Boolean functions {a mathematical formula}fn in NP and a corresponding family of Boolean circuits {a mathematical formula}Cn. We can consider the inputs (including nondeterministic ones) of the circuits {a mathematical formula}Cn as Boolean variables. Each gate of {a mathematical formula}Cn can also be thought of as a Boolean variable whose value coincides with the output of the gate on a given input. Let {a mathematical formula}g=(g1,…,g|Cn|) be the Boolean variables for the nodes of {a mathematical formula}Cn. We may assume that a Boolean circuit {a mathematical formula}Cn contains only ∧- and ¬-gates, so it can be regarded as a set of equations of the form{a mathematical formula} where {a mathematical formula}gi′ and {a mathematical formula}gi″ are the variables for the inputs of the gate {a mathematical formula}gi. We assume that {a mathematical formula}gi can depend only on {a mathematical formula}g1,…,gi−1 and that {a mathematical formula}g1,…,gn are the inputs of {a mathematical formula}Cn, {a mathematical formula}gn+1,…,gn+p(n) are the nondeterministic inputs of {a mathematical formula}Cn, and {a mathematical formula}g|Cn| its output. Now, with each {a mathematical formula}Cn we associate the following Boolean formula in CNF with the variables {a mathematical formula}h=(h1,…,hn) and g:{a mathematical formula} The clauses of the last two conjuncts encode the correct computation of the circuit: they are equivalent to {a mathematical formula}gi↔¬gi′ and {a mathematical formula}gi↔gi′∧gi″, respectively. In what follows, we denote by {a mathematical formula}ψn(α,g) the result of replacing the variables in h with the respective truth-values from a vector {a mathematical formula}α∈{0,1}n (thus, the g are the only variables of this formula). For any family of monotone Boolean functions{a mathematical formula}fninNPand any{a mathematical formula}α∈{0,1}n, we have{a mathematical formula}fn(α)=1if and only if{a mathematical formula}ψn(α,g)is satisfiable.{a mathematical formula}(⇒) If {a mathematical formula}fn(α)=1 then {a mathematical formula}Cn(α,β)=1, for some β. Consider {a mathematical formula}ψn(α,γ), where the {a mathematical formula}γi in γ are given by the output values of the respective nodes {a mathematical formula}gi in {a mathematical formula}Cn on the input {a mathematical formula}(α,β) (the output value of an input or a nondeterministic input of {a mathematical formula}Cn is the respective value itself). By definition, the last two conjuncts of {a mathematical formula}ψn(α,γ) are true under such an assignment. The first conjunct is trivially true, while the second conjunct is true because {a mathematical formula}γ|Cn|=Cn(α,β).{a mathematical formula}(⇐) Conversely, suppose {a mathematical formula}ψn(α,γ)=1, for some γ. Let {a mathematical formula}α′ be the values of the inputs of {a mathematical formula}Cn in γ. By the first conjunct, {a mathematical formula}α′≤α and, as {a mathematical formula}fn is monotone, we obtain {a mathematical formula}fn(α′)≤fn(α). So, it suffices to show that {a mathematical formula}fn(α′)=1. To this end, we prove by induction on the structure of {a mathematical formula}Cn that the values of the variables of {a mathematical formula}ψn(α,γ) are equal to the output values of the corresponding nodes of {a mathematical formula}Cn on {a mathematical formula}(α′,β), where β are the values of the nondeterministic inputs from γ: for the inputs (including nondeterministic ones), this is immediate by definition; for the gates, the claim easily follows from the last two conjuncts of {a mathematical formula}ψn. Then, by the second conjunct, {a mathematical formula}γ|Cn|=1, and so {a mathematical formula}Cn(α′,β)=1, whence {a mathematical formula}fn(α′)=1. □
     </paragraph>
     <paragraph>
      The second step of the reduction is to encode satisfiability of {a mathematical formula}ψn(α,g) by means of the CQ answering problem in OWL 2 QL. The CNF {a mathematical formula}ψn(h,g) contains {a mathematical formula}d≤3|Cn|+1 clauses {a mathematical formula}C1,…,Cd with n variables {a mathematical formula}h1,…,hn and {a mathematical formula}m=|Cn| variables {a mathematical formula}g1,…,gm. Recall that {a mathematical formula}g1,…,gn correspond to the inputs and {a mathematical formula}C1,…,Cn are clauses of the form {a mathematical formula}¬gi∨hi. We take a binary predicate {a mathematical formula}P(x,y) and unary predicates {a mathematical formula}A0(x) and {a mathematical formula}Ai(x), {a mathematical formula}Xi0(x), {a mathematical formula}Xi1(x), for each variable {a mathematical formula}gi, as well as {a mathematical formula}Z0,j(x),…,Zm,j(x), for each clause {a mathematical formula}Cj of {a mathematical formula}ψn(h,g).
     </paragraph>
     <paragraph>
      Consider an OWL 2 QL-ontology {a mathematical formula}Σfn with the following tgds, for {a mathematical formula}1≤i≤m, {a mathematical formula}1≤j≤d and {a mathematical formula}ℓ=0,1:{a mathematical formula} It is not hard to check that {a mathematical formula}|Σfn|=O(|Cn|2) and that the chase of {a mathematical formula}Σfn is finite for any data. Consider also the following tree-shaped Boolean CQ:{a mathematical formula} where {a mathematical formula}y=(y0,…,ym) and {a mathematical formula}z=(z0,1,…,zm−1,1,…,z0,d,…,zm−1,d). It should be clear that {a mathematical formula}|qfn|=O(|Cn|2).
     </paragraph>
     <paragraph>
      For each {a mathematical formula}α=(α1,…,αn)∈{0,1}n, we take the data instance{a mathematical formula}
     </paragraph>
     <paragraph label="Proof">
      We explain the intuition behind {a mathematical formula}Σfn, {a mathematical formula}qfn and {a mathematical formula}Dα using the example in Fig. 3, where the chase {a mathematical formula}CΣfn,Dα of {a mathematical formula}(Σfn,Dα) is depicted for a particular {a mathematical formula}fn and α. To answer {a mathematical formula}qfn over {a mathematical formula}(Σfn,Dα), we have to check whether {a mathematical formula}qfn can be homomorphically mapped into {a mathematical formula}CΣfn,Dα. The variables {a mathematical formula}yi are clearly mapped to one of the main branches of the model, from a to a point in {a mathematical formula}A3, say the leftmost one, which corresponds to the valuation for the variables g in {a mathematical formula}ψn(α,g) making all of them false. Consider now, for example, variables {a mathematical formula}z2,3,z1,3,z0,3 that correspond to the clause {a mathematical formula}C3=g1∨¬g3 in {a mathematical formula}ψn(α,g). Since {a mathematical formula}Z0,3(a)∉Dα, in order to map {a mathematical formula}z2,3,z1,3,z0,3 we have to choose at least one of its literals, {a mathematical formula}g1 or {a mathematical formula}¬g3, that is true under such an assignment, and then {a mathematical formula}z2,3,z1,3,z0,3 can be sent to the points in the respective ‘hanging’ branch, resulting in {a mathematical formula}z0,3↦̸a. On the other hand, there are two possible ways (depending on {a mathematical formula}α1) of mapping variables {a mathematical formula}z2,1,z1,1,z0,1 for the clause {a mathematical formula}C1=¬g1∨h of {a mathematical formula}ψn(α,g). (1) If {a mathematical formula}α1=0 then {a mathematical formula}C1 in {a mathematical formula}ψn(α,g) is equivalent to {a mathematical formula}¬g1 and, since {a mathematical formula}Z0,1(a)∉Dα, we have to be able to send {a mathematical formula}z2,1,z1,1,z0,1 to the points in a ‘hanging’ branch, resulting in {a mathematical formula}z0,1↦̸a. (2) If, however, {a mathematical formula}α1=1 then the clause {a mathematical formula}C1 is true anyway and {a mathematical formula}Z0,1(a)∈Dα, whence {a mathematical formula}z2,1,z1,1,z0,1 can be sent to the same branch from {a mathematical formula}A2 to {a mathematical formula}A0, so that {a mathematical formula}z0,1↦a. Thus, we arrive to the following: For any family of Boolean functions{a mathematical formula}fninNPand any{a mathematical formula}α∈{0,1}n, we have{a mathematical formula}(Σfn,Dα)⊨qfnif and only if{a mathematical formula}ψn(α,g)is satisfiable.{a mathematical formula}(⇒) Consider a homomorphism h from {a mathematical formula}qfn to the chase {a mathematical formula}CΣfn,Dα of {a mathematical formula}(Σfn,Dα). Clearly, {a mathematical formula}h(y0)=a and both {a mathematical formula}Ai(h(yi)) and {a mathematical formula}P(h(yi),h(yi−1)) are in {a mathematical formula}CΣfn,Dα, for all {a mathematical formula}1≤i≤m. So, for each variable {a mathematical formula}gi in g, we set {a mathematical formula}γi=1 if {a mathematical formula}Xi1(h(yi))∈CΣfn,Dα and {a mathematical formula}γi=0 otherwise (in which case {a mathematical formula}Xi0(h(yi))∈CΣfn,Dα). We claim that {a mathematical formula}ψn(α,γ)=1. Take any clause {a mathematical formula}Cj in {a mathematical formula}ψn(α,g) and consider two cases for {a mathematical formula}h(z0,j). If {a mathematical formula}h(z0,j)=a then {a mathematical formula}1≤j≤n with {a mathematical formula}Z0,j(a)∈Dα, and so {a mathematical formula}αj=1, whence the clause {a mathematical formula}Cj=¬gj∨hj is true anyway. Otherwise, {a mathematical formula}h(z0,j)≠a which means that {a mathematical formula}Zi,j(h(yi))∈CΣfn,Dα, for some {a mathematical formula}1≤i≤m, and so the clause {a mathematical formula}Cj contains {a mathematical formula}gi if {a mathematical formula}Xi1(h(yi))∈CΣfn,Dα and {a mathematical formula}¬gi if {a mathematical formula}Xi0(h(yi))∈CΣfn,Dα. The claim follows.{a mathematical formula}(⇐) Suppose {a mathematical formula}ψn(α,γ)=1, for some {a mathematical formula}γ∈{0,1}m. We construct a homomorphism h from {a mathematical formula}qfn to the chase {a mathematical formula}CΣfn,Dα of {a mathematical formula}(Σfn,Dα). Observe that {a mathematical formula}CΣfn,Dα contains a path {a mathematical formula}u0,…,um from {a mathematical formula}a=u0 to some {a mathematical formula}um such that {a mathematical formula}P(ui,ui−1)∈CΣfn,Dα, for {a mathematical formula}1≤i≤m, and the path corresponds to γ in the following sense: {a mathematical formula}Xi1(ui)∈CΣfn,Dα if {a mathematical formula}γi=1 and {a mathematical formula}Xi0(ui)∈CΣfn,Dα otherwise. So, for {a mathematical formula}0≤i≤m, we set {a mathematical formula}h(yi)=ui. For {a mathematical formula}1≤j≤d, we define {a mathematical formula}h(zm−1,j),…,h(z0,j) recursively, starting from {a mathematical formula}h(zm−1,j) and assuming that {a mathematical formula}zm,j=ym: let {a mathematical formula}h(zi,j)=ui if {a mathematical formula}Zi+1,j(h(zi+1,j))∉CΣfn,Dα; otherwise, let {a mathematical formula}h(zi,j) be the labelled null chosen for y when applying {a mathematical formula}∀x(Zi+1,j(x)→∃y(P(x,y)∧Zi,j(x))) in {a mathematical formula}h(zi+1,j). It is easy to check that h is indeed a homomorphism from {a mathematical formula}qfn into {a mathematical formula}CΣfn,Dα. □
     </paragraph>
     <paragraph label="Lemma 8">
      We now use the reduction above to show that there is a close correspondence between PE-rewritings and monotone Boolean formulas, between FO-rewritings and (not necessarily monotone) Boolean formulas, and between NDL-rewritings and monotone Boolean circuits. Suppose{a mathematical formula}f1,f2,…is a family of monotone Boolean functions inNP.
     </paragraph>
     <list>
      <list-item>
       If{a mathematical formula}qfn′is an FO-rewriting of{a mathematical formula}qfnand{a mathematical formula}Σfn, then there is a Boolean formula{a mathematical formula}φncomputing{a mathematical formula}fnwith{a mathematical formula}|φn|≤|qfn′|.
      </list-item>
      <list-item>
       If{a mathematical formula}qfn′is a PE-rewriting of{a mathematical formula}qfnand{a mathematical formula}Σfn, then there is a monotone Boolean formula{a mathematical formula}φncomputing{a mathematical formula}fnwith{a mathematical formula}|φn|≤|qfn′|.
      </list-item>
      <list-item>
       If{a mathematical formula}(Πfn,G)is an NDL-rewriting of{a mathematical formula}qfnand{a mathematical formula}Σfn, then there is a monotone Boolean circuit{a mathematical formula}Bncomputing{a mathematical formula}fnwith{a mathematical formula}|Bn|≤|Πfn|.
      </list-item>
     </list>
     <paragraph label="Proof">
      (i) By Lemma 6, Lemma 7, for any FO-rewriting {a mathematical formula}qfn′ of {a mathematical formula}qfn and {a mathematical formula}Σfn,{a mathematical formula} Since {a mathematical formula}ΔDα is a singleton, {a mathematical formula}{a}, we can remove all the quantifiers and replace all the individual variables in {a mathematical formula}qfn′ with a. The resulting Boolean FO-query {a mathematical formula}qfn″ has the same truth-value in {a mathematical formula}Dα as {a mathematical formula}qfn′. Then we observe that the ground atoms other than {a mathematical formula}a=a, {a mathematical formula}A0(a) and the {a mathematical formula}Z0,j(a), for {a mathematical formula}1≤j≤n, are false in {a mathematical formula}Dα, and so we can replace all {a mathematical formula}a=a and {a mathematical formula}A0(a) with ⊤, and all the atoms different from {a mathematical formula}a=a, {a mathematical formula}A0(a) and {a mathematical formula}Z0,j(a), for {a mathematical formula}1≤j≤n, with ⊥ without affecting the truth-value of {a mathematical formula}qfn″ in {a mathematical formula}Dα. The resulting quantifier-free query can be regarded as a Boolean formula, {a mathematical formula}φn, with ‘propositional variables’ {a mathematical formula}Z0,1(a),…,Z0,n(a). But then {a mathematical formula}φn(α)=fn(α), for each {a mathematical formula}α∈{0,1}n; that is, {a mathematical formula}φn computes {a mathematical formula}fn. Clearly, {a mathematical formula}|φn|≤|qfn′|.(ii) In the same way as above we can transform any PE-rewriting {a mathematical formula}qfn′ of {a mathematical formula}qfn and {a mathematical formula}Σfn into a monotone Boolean formula {a mathematical formula}φn (with connectives ∨ and ∧ only) and propositional variables {a mathematical formula}Z0,1(a),…,Z0,n(a) such that {a mathematical formula}φn computes {a mathematical formula}fn and {a mathematical formula}|φn|≤|qfn′|.(iii) Suppose that {a mathematical formula}(Πfn,G) is an NDL-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn, and {a mathematical formula}α∈{0,1}n. Again, since {a mathematical formula}ΔDα is a singleton, each variable in the head of a clause also occurs in its body and {a mathematical formula}Πfn does not contain constants (as {a mathematical formula}qfn does not have them), we can replace all the individual variables in {a mathematical formula}Πfn with a and the resulting NDL-query {a mathematical formula}(Πfn′,G) has the same truth-value in {a mathematical formula}Dα as {a mathematical formula}(Πfn,G). Then, in {a mathematical formula}Πfn′, we remove all {a mathematical formula}a=a and {a mathematical formula}A0(a) (as they are true) and remove all clauses containing atoms different from {a mathematical formula}a=a, {a mathematical formula}A0(a) and {a mathematical formula}Z0,j(a), for {a mathematical formula}1≤j≤n (because such atoms are false in {a mathematical formula}Dα and do not occur in the heads of the clauses). Denote the resulting propositional NDL-program by {a mathematical formula}Πfn″. It follows that {a mathematical formula}Πfn″,Dα⊨G if and only if {a mathematical formula}fn(α)=1. We can regard {a mathematical formula}(Πfn″,G) as an NDL-query in which {a mathematical formula}Z0,1(a),…,Z0,n(a) are ‘propositional variables’ and the heads of all clauses also have no arguments (i.e., are propositional variables). Such a program {a mathematical formula}Πfn″ can now be transformed into a monotone Boolean circuit computing {a mathematical formula}fn: for every propositional variable p occurring in the head of a clause in {a mathematical formula}Πfn″, we introduce a ∨-gate whose output is p and inputs are the bodies of the clauses with the head p; and for each such body, we introduce a cascade of ∧-gates whose inputs are the propositional variables in the body. The resulting monotone Boolean circuit with inputs {a mathematical formula}Z0,1(a),…,Z0,n(a) and output G is denoted by {a mathematical formula}Bn. Clearly, {a mathematical formula}|Bn|≤|Πfn|. □
     </paragraph>
     <paragraph label="Theorem 9">
      We are now in a position to prove that one cannot avoid an exponential blowup for PE- and NDL-rewritings; moreover, even FO-rewritings can blowup superpolynomially under the assumption that {a mathematical formula}NP⊈P/poly. This can be done using the function {a mathematical formula}Cliquem,k of {a mathematical formula}m(m−1)/2 variables {a mathematical formula}eij, {a mathematical formula}1≤i&lt;j≤m, which returns 1 if and only if the graph with vertices {a mathematical formula}{1,…,m} and edges {a mathematical formula}{{i,j}|eij=1} contains a k-clique. One can show that there is a Boolean circuit with m nondeterministic inputs and {a mathematical formula}O(m2) gates that computes {a mathematical formula}Cliquem,k. As {a mathematical formula}Cliquem,k is NP-complete, the question whether {a mathematical formula}Cliquem,k can be computed by polynomial-size circuits (without nondeterministic inputs) is equivalent to the open {a mathematical formula}NP⊆P/poly problem. Further, a series of papers, started by Razborov [50], gave an exponential lower bound for the size of monotone circuits computing {a mathematical formula}Cliquem,k: {a mathematical formula}2Ω(k) for {a mathematical formula}k≤14(m/logm)2/3[2]. For monotone formulas, an even better lower bound is known: {a mathematical formula}2Ω(k) for {a mathematical formula}k=2m/3[49]. There is a sequence of CQs{a mathematical formula}qnof size{a mathematical formula}O(n)and OWL 2 QL-ontologies{a mathematical formula}Σnof size{a mathematical formula}O(n)such that
     </paragraph>
     <list>
      <list-item>
       any PE-rewritings of{a mathematical formula}qnand{a mathematical formula}Σnare of size{a mathematical formula}≥2Ω(n1/4);
      </list-item>
      <list-item>
       any NDL-rewritings of{a mathematical formula}qnand{a mathematical formula}Σnare of size{a mathematical formula}≥2Ω((n/logn)1/12);
      </list-item>
      <list-item>
       there are no polynomial-size FO-rewritings of{a mathematical formula}qnand{a mathematical formula}Σnunless{a mathematical formula}NP⊆P/polyor{a mathematical formula}PH=Σ2p.
      </list-item>
     </list>
     <paragraph label="Proof">
      Consider the family of Boolean functions {a mathematical formula}fn=Cliquem,k with {a mathematical formula}m=⌊n1/4⌋ and {a mathematical formula}k=⌊2m/3⌋=Ω(n1/4). As the size of the circuits {a mathematical formula}Cn (with nondeterministic inputs) is {a mathematical formula}O(m2), the size of {a mathematical formula}qn=qfn and {a mathematical formula}Σn=Σfn is {a mathematical formula}O(n). So, claim (i) follows from Lemma 8 (ii) and the lower bound for the size of monotone formulas computing {a mathematical formula}Cliquem,k. Then we take the same family {a mathematical formula}fn and redefine its elements {a mathematical formula}fn with even n: take {a mathematical formula}fn=Cliquem,k with m as above and {a mathematical formula}k=⌊(m/logm)2/3⌋=Ω((n/logn)1/6). Claim (ii) follows from Lemma 8 (iii) and the lower bound on the size of monotone circuits computing {a mathematical formula}Cliquem,k. If we assume that {a mathematical formula}NP⊈P/poly then there is no polynomial-size circuit for {a mathematical formula}Cliquem,k, and so (iii) follows for the constructed {a mathematical formula}fn by Lemma 8 (i). □
     </paragraph>
     <paragraph label="Proof">
      Using a similar argument we can also prove the following: Suppose{a mathematical formula}f1,f2,…is anNP-complete family of monotone Boolean functions. If{a mathematical formula}NP⊈P/polythen{a mathematical formula}qfnand{a mathematical formula}Σfndo not have polynomial-size FO- and NDL-rewritings.Suppose to the contrary that there are polynomial-size FO- or NDL-rewritings of {a mathematical formula}qfn and {a mathematical formula}Σfn. Then, by Lemma 8 (i) and (iii), there is a family of polynomial-size circuits computing {a mathematical formula}f1,f2,…. Since the family {a mathematical formula}fn is NP-complete, it follows that all families of Boolean functions in NP can be computed by polynomial-size circuits, that is {a mathematical formula}NP⊆P/poly. □
     </paragraph>
     <paragraph>
      The construction of this section also reveals the overhead of CQ answering via OWL 2 QL-ontologies compared to CQ answering over plain databases in complexity-theoretic terms. Indeed, since the Boolean CQs {a mathematical formula}qfn are tree-shaped, the problem ‘{a mathematical formula}Dα⊨qfn?’ is in P for combined complexity [60], while the problem ‘{a mathematical formula}(Σfn,Dα)⊨qfn?’ is NP-hard. (On the other hand, both problems are in {a mathematical formula}AC0 for data complexity.)
     </paragraph>
     <paragraph>
      We also observe that the quantifier elimination in the proof of Lemma 8 relies on the fact that {a mathematical formula}|ΔDα|=1. As we shall see in the next two sections, if we restrict attention to data instances with at least two individuals, then Theorem 9 does not hold any longer.
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      Polynomial rewritings with two constants
     </section-title>
     <paragraph>
      To prove the exponential and superpolynomial lower bounds for the size of rewritings in the previous section, we established a connection between monotone circuits for Boolean functions and rewritings of certain CQs and OWL 2 QL-ontologies. In fact, this connection also suggests a way of making rewritings substantially shorter. Indeed, recall from Section 3 that although no family of monotone Boolean circuits of polynomial size can compute {a mathematical formula}Cliquem,k, there exists a family of polynomial-size circuits with nondeterministic inputs computing {a mathematical formula}Cliquem,k. Nondeterministic inputs make Boolean circuits exponentially more succinct—in the same way as nondeterministic automata are exponentially more succinct than deterministic ones [42]. To introduce the corresponding nondeterministic guesses into query rewritings, we can use additional existentially quantified variables—provided that the domain of quantification contains at least two elements (cf. [5]). For this purpose, we can extend the signature of PE-, FO- and NDL-rewritings with a set X of constant symbols assuming that they occur in every relevant data instance, in which case we are talking about {a mathematical formula}PEX-, {a mathematical formula}FOX- and {a mathematical formula}NDLX-rewritings. In this section, we show that allowing additional constants in rewritings really makes them exponentially more succinct.
     </paragraph>
     <paragraph>
      We say that a family of ontologies has the polynomial witness property (PWP, for short) if there is a polynomial {a mathematical formula}d(m,n) such that, for any ontology Σ in the family, any CQ {a mathematical formula}q(x) and any data instance D, whenever {a mathematical formula}(Σ,D)⊨q(a), for a tuple a from {a mathematical formula}ΔD, then there is a sequence of {a mathematical formula}d(|q|,|Σ|) applications of tgds from Σ to D that entails {a mathematical formula}q(a) (in the sense that there is a homomorphism from {a mathematical formula}q(a) to the set of atoms generated by those tgd applications). Clearly, PWP implies BDDP (but not the other way round). The following are examples of ontology languages with the PWP:
     </paragraph>
     <list>
      <list-item label="–">
       linear tgds with predicates of bounded arity [26] and, in particular, OWL 2 QL[16],
      </list-item>
      <list-item label="–">
       sticky sets of tgds with predicates of bounded arity [23]
      </list-item>
     </list>
     <paragraph label="Theorem 11">
      (note that the degree of the polynomial depends on the maximum arity of predicates). Let{a mathematical formula}q(x)be a CQ and Σ an ontology from a family with the PWP.
     </paragraph>
     <list>
      <list-item>
       There is a{a mathematical formula}PE{0,1}-rewriting of q and Σ whose size is polynomial in{a mathematical formula}|q|and{a mathematical formula}|Σ|.
      </list-item>
      <list-item>
       There is an{a mathematical formula}NDL{0,1}-rewriting of q and Σ whose size is polynomial in{a mathematical formula}|q|and{a mathematical formula}|Σ|.
      </list-item>
     </list>
     <paragraph label="Proof">
      Without loss of generality we assume that all predicates in Σ and q are of some arity L and that all tgds in Σ have precisely m atoms in the body and one atom in the head, and the head contains at most one existentially quantified variable. In other words, all our tgds are of the form{a mathematical formula} where each term in the {a mathematical formula}ti=(ti1,…,tiL), for {a mathematical formula}1≤i≤m, is a (universally quantified) variable from x or a constant and each term in {a mathematical formula}t0=(t01,…,t0L) either belongs to x (in which case it is universally quantified) or is a constant or coincides with z (in which case it is existentially quantified). To simplify notation, we assume that q is a Boolean CQ:{a mathematical formula} We also assume that Σ contains no negative constraints (for a reduction of the general case, see [11]). In view of the PWP, there is a number {a mathematical formula}d(|q|,|Σ|) polynomial in {a mathematical formula}|q| and {a mathematical formula}|Σ| such that, for any data instance D with {a mathematical formula}(Σ,D)⊨q, there is a sequence of {a mathematical formula}d(|q|,|Σ|) applications of tgds from Σ to D that entails q. Let {a mathematical formula}N=(m+1)⋅d(|q|,|Σ|). Denote {a mathematical formula}μ=max(K,M,N,S), where K is the number of predicates in q and Σ, and S is the number of tgds in Σ. Let Q be the set of natural numbers from 0 to μ.(i) First, we give a {a mathematical formula}PEQ-rewriting {a mathematical formula}q′ of q and Σ assuming that the constants in Q cannot occur in any predicate of data instances but still are interpreted by distinct elements in every model (equality is a built-in predicate). Then we show how this rewriting can be transformed to a proper {a mathematical formula}PE{0,1}-rewriting (without any condition on 0 and 1 apart from that they must occur in all relevant data instances).In essence, our {a mathematical formula}PEQ-rewriting guesses a sequence of N ground atoms {a mathematical formula}A1,…,AN and then checks whether these atoms give a positive answer to q and the sequence can indeed be obtained by a series of applications of the tgds from Σ to D (all the data atoms required for the applications must be among the {a mathematical formula}Ai). To encode the atoms {a mathematical formula}A1,…,AN, we associate with each predicate P a unique number, denoted {a mathematical formula}[P], so that each {a mathematical formula}Ai is represented by the number of its predicate and the values of its arguments, which range over the domain {a mathematical formula}ΔD of D and the labelled nulls {a mathematical formula}nulli, for {a mathematical formula}1≤i≤N (the labelled nulls are numbers from Q, but we use this notation for readability). Thus, for each atom {a mathematical formula}Ai in the sequence, {a mathematical formula}1≤i≤N, we need the following variables:
      <list>
       {a mathematical formula}ri is the number of the predicate of {a mathematical formula}Ai and {a mathematical formula}ui1,…,uiL are the arguments of {a mathematical formula}Ai;{a mathematical formula}wi1,…,wiℓ, where ℓ is the maximum number of universally quantified variables x in tgds ({a mathematical formula}ℓ≤m⋅L), are the arguments of the predicates in the body of the tgd used to obtain {a mathematical formula}Ai.It is not hard to check that
      </list>
      <paragraph>
       {a mathematical formula}q′ can be constructed in polynomial time, {a mathematical formula}|q′|=O(|q|⋅|Σ|⋅N2⋅L) and that {a mathematical formula}(Σ,D)⊨q if and only if {a mathematical formula}q′ is true in the model of D extended with the constants in Q, which are distinct and do not belong to the interpretation of any predicate but =.We can replace the natural numbers in Q with two distinct constants, say, 0 and 1 (provided that they are present in every data instance), thus obtaining a polynomial {a mathematical formula}PE{0,1}-rewriting of q and Σ. Recall that each of the variables {a mathematical formula}uij ranges over the domain {a mathematical formula}ΔD and numbers from Q (more precisely, labelled nulls {a mathematical formula}null1,…,nullN). Thus, such a variable {a mathematical formula}uij can be modelled by means a tuple {a mathematical formula}(uˆij,uijp,…,uij0) of variables, where {a mathematical formula}uˆij ranges over the domain {a mathematical formula}ΔD, while {a mathematical formula}uijp,…,uij0, for {a mathematical formula}p=⌈log|Q|⌉, range over {a mathematical formula}{0,1} and represent a natural number from 0 to μ in binary. More precisely, if {a mathematical formula}uij has a value {a mathematical formula}d∈ΔD then {a mathematical formula}uˆij is interpreted by d and {a mathematical formula}uijp,…,uij0 are all zeros; otherwise, {a mathematical formula}uij is a labelled null, say {a mathematical formula}nullk, and so {a mathematical formula}uˆij is a fixed value, say 0, and {a mathematical formula}uijp,…,uij0 represent k in binary (note that 0 is not a labelled null). Similarly, we model the {a mathematical formula}wil; the {a mathematical formula}ri are even simpler to model as they do not have the {a mathematical formula}rˆi component. The equality atoms in the rewriting {a mathematical formula}q′ are replaced by the component-wise equalities and each {a mathematical formula}P(ui1,…,uiL) is replaced by {a mathematical formula}P(uˆi1,…,uˆiL)∧⋀j=1L⋀k=0p(uijk=0).(ii) We show how to construct a polynomial-size {a mathematical formula}NDLQ-rewriting {a mathematical formula}(Π,G) of q and Σ. Its transformation into an {a mathematical formula}NDL{0,1}-rewriting can be done similarly to {a mathematical formula}PEQ-rewritings. The program Π has one main rule that is very similar to the query {a mathematical formula}q′ in the previous construction. However, {a mathematical formula}q′ uses disjunction which is not allowed in a datalog rule. The elimination of disjunction (without an exponential blowup and with small arity of predicates) is based on the equivalence{a mathematical formula} where {a mathematical formula}ϒ⊆Q. To this end, Π uses additional rules and intensional predicates.
      </paragraph>
      <list>
       <list-item label="–">
        {a mathematical formula}OneOf(x,y,z) should hold if x is a natural number from Q in the interval from y to z (this predicate will replace the disjunction of the {a mathematical formula}(v=i) in (8)):{a mathematical formula}
       </list-item>
       <list-item label="–">
        {a mathematical formula}Dom(z) should hold if z appears in the data instance D or is one of the labelled nulls {a mathematical formula}nullk:{a mathematical formula}
       </list-item>
       <list-item label="–">
        {a mathematical formula}If(x1,x2,z1,z2) should hold if {a mathematical formula}x1=x2→z1=z2 is true, where {a mathematical formula}x1,x2 are natural numbers from Q (this predicate will replace the implication in (8)):{a mathematical formula}
       </list-item>
       <list-item label="–">
        {a mathematical formula}IfAnd(x1,x2,y1,y2,z1,z2) should hold if {a mathematical formula}(x1=x2∧y1=y2)→z1=z2 is true, where {a mathematical formula}x1,x2,y1,y2 are natural numbers from Q (the rules for IfAnd are similar to those for If);
       </list-item>
       <list-item label="–">
        {a mathematical formula}DB(x,z,y) should hold if {a mathematical formula}x=0 and z is the number {a mathematical formula}[P] of some predicate P in q or Σ such that {a mathematical formula}P(y)∈D:{a mathematical formula}
       </list-item>
      </list>
      <paragraph>
       Now we can describe the construction of the main rule of Π, which mimics {a mathematical formula}q′:{a mathematical formula} where G is a 0-ary goal predicate. The components, the {a mathematical formula}Γk and the {a mathematical formula}Φi, are defined as follows. In these definitions, we make use of the quantified variables {a mathematical formula}y,u,r,w with the same the intended meaning as in the previous construction; the meaning of additional quantified variables will be explained below. For each {a mathematical formula}1≤k≤M, let{a mathematical formula} where {a mathematical formula}sk is a fresh variable meant to be the number i of the atom {a mathematical formula}Ai to which {a mathematical formula}Rk(yk1,…,ykL) is mapped; the variable {a mathematical formula}sk encodes the choice of the disjunct of {a mathematical formula}Γk in the previous construction; cf. (8). For each {a mathematical formula}1≤i≤N, let{a mathematical formula} where {a mathematical formula}vi is meant to take the number {a mathematical formula}[τ] of the tgd ({a mathematical formula}1≤[τ]≤S) that derives the atom {a mathematical formula}Ai or 0, if {a mathematical formula}Ai is from the data instance: the second conjunct accounts for the case where {a mathematical formula}Ai is an atom of the data instance and the last group of conjuncts for the case where {a mathematical formula}Ai is obtained by an application of a tgd from Σ. Finally, for {a mathematical formula}i&gt;1, we take{a mathematical formula} where, for every {a mathematical formula}1≤i≤N and {a mathematical formula}1≤k≤m, {a mathematical formula}pik is meant to be the number {a mathematical formula}i′ of the chase step that derives the {a mathematical formula}kth atom used in the {a mathematical formula}ith chase step. We take {a mathematical formula}Ψτ,1,k=OneOf(v1,0,0), which ensures {a mathematical formula}v1=0.It is straightforward to verify that {a mathematical formula}(Π,G) is indeed equivalent to {a mathematical formula}q′, thus establishing (ii). □
      </paragraph>
     </paragraph>
     <paragraph label="Corollary 12">
      As sets of linear tgds of bounded arity and sets of sticky tgds of bounded arity enjoy the PWP, we obtain: Any CQ and any set of linear tgds of bounded arity (in particular, OWL 2 QL-ontology) have polynomial-size{a mathematical formula}PE{0,1}- and{a mathematical formula}NDL{0,1}-rewritings.Any CQ and any set of sticky tgds of bounded arity have polynomial-size{a mathematical formula}PE{0,1}- and{a mathematical formula}NDL{0,1}-rewritings.
     </paragraph>
     <paragraph label="Corollary 13">
      The following result is an immediate consequence of the proof of Theorem 11; we shall use it to prove Lemma 15 in the next section: Let{a mathematical formula}q(x)be a CQ and Σ an ontology from a family with the PWP.
     </paragraph>
     <list>
      <list-item>
       There is a polynomial-size PE-formula{a mathematical formula}γ(x,y0,y1)such that{a mathematical formula}γ(x,0,1)is a{a mathematical formula}PE{0,1}-rewriting of q and Σ.
      </list-item>
      <list-item>
       There is a polynomial-size NDL-query{a mathematical formula}(Π,G(x,y0,y1))such that{a mathematical formula}(Π,G(x,0,1))is an{a mathematical formula}NDL{0,1}-rewriting of q and Σ.
      </list-item>
     </list>
     <paragraph label="Corollary 14">
      By taking the formula {a mathematical formula}∃y0,y1{a mathematical formula}((y0≠y1)∧γ(x,y0,y1)) with γ given in Corollary 13 (i), we also obtain the following result on polynomial FO-rewritability over databases with at least two individuals: For any CQ{a mathematical formula}q(x)and any ontology Σ from a family with the PWP, there is an FO-formula{a mathematical formula}q′(x)such that its size is polynomial in{a mathematical formula}|q|and{a mathematical formula}|Σ|and{a mathematical formula}(Σ,D)⊨q(a)if and only if{a mathematical formula}D⊨q′(a), for any data instance D with{a mathematical formula}|ΔD|≥2and any tuple a of elements in{a mathematical formula}ΔD.
     </paragraph>
     <paragraph>
      Note that the compact representation of the FO-rewriting in this corollary is achieved—compared to the FO-rewritings of CQs and OWL 2 QL-ontologies known so far—with the help of polynomially-many new existentially quantified variables that are used for guessing a derivation of the given CQ in the chase.
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Separation results
     </section-title>
     <paragraph>
      In this section, we again consider ‘pure’ rewritings (without additional constants) and prove two separation results saying that NDL-rewritings can be exponentially more succinct than PE-rewritings, and that FO-rewritings can be superpolynomially more succinct than PE-rewritings. To this end we need a construction for transforming Boolean formulas and circuits into rewritings.
     </paragraph>
     <paragraph label="Lemma 15">
      Consider a family {a mathematical formula}f1,f2,… of monotone Boolean functions in NP and a corresponding family {a mathematical formula}C1,C2,… of polynomial-size Boolean circuits with nondeterministic inputs. Recall that in Section 3 we constructed a family {a mathematical formula}ψn of CNFs encoding the {a mathematical formula}Cn. The CNF {a mathematical formula}ψn, which contains {a mathematical formula}d≤3|Cn|+1 clauses with {a mathematical formula}m=|Cn| Boolean variables, was then transformed into a set {a mathematical formula}Σfn of OWL 2 QL-tgds and a Boolean CQ {a mathematical formula}qfn such that{a mathematical formula} Consider now the OWL 2 QL-ontology {a mathematical formula}Σfn⁎ that extends {a mathematical formula}Σfn with the negative constraints{a mathematical formula} where Θ is the set comprising the following formulas:{a mathematical formula} We observe that {a mathematical formula}|Σfn⁎|=O(|Cn|2) and the claims of Lemma 8 are equally applicable to {a mathematical formula}Σfn⁎ (the proof requires that the query {a mathematical formula}qfn and the ontology {a mathematical formula}Σfn/Σfn⁎ give ‘correct’ answers only for data {a mathematical formula}Dα which, by definition, are consistent with the negative constraints above). Let{a mathematical formula}f1,f2,…be a family of monotone Boolean functions inNPand{a mathematical formula}C1,C2,…a corresponding family of polynomial-size Boolean circuits with nondeterministic inputs.
     </paragraph>
     <list>
      <list-item>
       If the{a mathematical formula}fnare computed by Boolean formulas{a mathematical formula}φnthen there are a polynomial p and FO-rewritings{a mathematical formula}qfn′of{a mathematical formula}qfnand{a mathematical formula}Σfn⁎such that{a mathematical formula}|qfn′|≤|φn|+p(|Cn|).
      </list-item>
      <list-item>
       If the{a mathematical formula}fnare computed by monotone Boolean circuits{a mathematical formula}Bnthen there are a polynomial p and NDL-rewritings{a mathematical formula}(Πfn,G)of{a mathematical formula}qfnand{a mathematical formula}Σfn⁎such that{a mathematical formula}|Πfn|≤2|Bn|+p(|Cn|).
      </list-item>
     </list>
     <paragraph label="Proof">
      (i) Let {a mathematical formula}γn(0,1) be the polynomial-size {a mathematical formula}PE{0,1}-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn given by Corollary 13 (i). We denote by {a mathematical formula}φn(x) the result of replacing each propositional variable {a mathematical formula}pj in {a mathematical formula}φn with the atom {a mathematical formula}Z0,j(x), for {a mathematical formula}1≤j≤n, and consider the FO-query{a mathematical formula} Clearly, {a mathematical formula}|qfn′|=|φn|+p(|Cn|), for a polynomial p (note that the size of both {a mathematical formula}qfn and {a mathematical formula}Σfn is quadratic in {a mathematical formula}|Cn| and their {a mathematical formula}PE{0,1}-rewriting is in turn polynomial in their size). It remains to show that {a mathematical formula}qfn′ is an FO-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn⁎.Suppose {a mathematical formula}(Σfn⁎,D)⊨qfn. If {a mathematical formula}(Σfn⁎,D) is inconsistent, it can only be due to the negative constraints of {a mathematical formula}Σfn⁎, in which case there is {a mathematical formula}a∈ΔD and {a mathematical formula}B(x)∈Θ such that {a mathematical formula}D⊨A0(a)∧B(a), whence {a mathematical formula}D⊨qfn′. Otherwise, the chase of {a mathematical formula}(Σfn⁎,D) coincides with the chase of {a mathematical formula}(Σfn,D) and there is a homomorphism h from {a mathematical formula}qfn into the chase of {a mathematical formula}(Σfn,D). Let {a mathematical formula}h(y0)=a0∈ΔD (recall that {a mathematical formula}y0 is the root of the query {a mathematical formula}qfn). Clearly, {a mathematical formula}A(a0)∈D. Two cases are possible now. If there is some {a mathematical formula}a1∈ΔD∖{a0} with {a mathematical formula}P(a1,a0)∈D then, as {a mathematical formula}γn(0,1) is a {a mathematical formula}PE{0,1}-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn, we obtain {a mathematical formula}D⊨γn(a0,a1), whence {a mathematical formula}D⊨qfn′. Otherwise, {a mathematical formula}D⊭∃yP(y,a0) and {a mathematical formula}Zi,j(a0)∈D only if {a mathematical formula}i=0 and {a mathematical formula}1≤j≤n. Consider α defined by taking {a mathematical formula}αj=1 iff {a mathematical formula}Z0,j(a0)∈D, for {a mathematical formula}1≤j≤n. We obtain {a mathematical formula}(Σfn,Dα)⊨qfn, and thus, by Lemma 7, {a mathematical formula}fn(α)=1. So {a mathematical formula}Dα⊨φn(a0), whence {a mathematical formula}D⊨qfn′.Conversely, suppose {a mathematical formula}D⊨qfn′. Then there is {a mathematical formula}a0∈ΔD with {a mathematical formula}A0(a0)∈D. If the last disjunct of {a mathematical formula}qfn′ holds on {a mathematical formula}a0 then {a mathematical formula}(Σfn⁎,D) is inconsistent, whence {a mathematical formula}(Σfn⁎,D)⊨qfn. So, from now on, we assume that the last disjunct does not hold on any {a mathematical formula}a∈ΔD with {a mathematical formula}A0(a0)∈D, and so {a mathematical formula}(Σfn⁎,D) is consistent and its chase coincides with the chase of {a mathematical formula}(Σfn,D). Two cases are possible now. If the second disjunct holds then there is {a mathematical formula}a1∈ΔD∖{a0} with {a mathematical formula}P(a1,a0)∈D (note that if {a mathematical formula}a0=a1 then {a mathematical formula}P(a0,a0)∈D, and so {a mathematical formula}(Σfn⁎,D) is inconsistent, contrary to our assumption). Then, as {a mathematical formula}γn(0,1) is a {a mathematical formula}PE{0,1}-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn, we obtain {a mathematical formula}(Σfn,D)⊨qfn. Otherwise, the first disjunct, {a mathematical formula}φn(x), holds on {a mathematical formula}a0, {a mathematical formula}D⊭∃yP(y,a0) and {a mathematical formula}Zi,j(a0)∈D only if {a mathematical formula}i=0 and {a mathematical formula}1≤j≤n. Consider α defined by taking {a mathematical formula}αj=1 iff {a mathematical formula}Z0,j(a0)∈D, for {a mathematical formula}1≤j≤n. As {a mathematical formula}φn computes {a mathematical formula}fn, we have {a mathematical formula}fn(α)=1, and so, by Lemma 7, {a mathematical formula}(Σfn,D)⊨qfn. In either case, {a mathematical formula}(Σfn⁎,D)⊨qfn.(ii) Let {a mathematical formula}(Φn,F(0,1)) be the polynomial-size {a mathematical formula}NDL{0,1}-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn given by Corollary 13 (ii). We denote by {a mathematical formula}Ξn the NDL-program built from {a mathematical formula}Bn by replacing each input with the respective unary predicate atom {a mathematical formula}Z0,j(x), for {a mathematical formula}1≤j≤n. More precisely, for each gate {a mathematical formula}gi with inputs {a mathematical formula}gi′ and {a mathematical formula}gi″ in the monotone Boolean circuit {a mathematical formula}Bn, we take a unary predicate {a mathematical formula}Qi(x) and include the following rules in {a mathematical formula}Ξn:{a mathematical formula} (if {a mathematical formula}gi′ is the {a mathematical formula}jth input of {a mathematical formula}Bn then {a mathematical formula}Qi′(x) denotes {a mathematical formula}Z0,j(x); and similarly for {a mathematical formula}gi″). Consider now the NDL-query {a mathematical formula}(Πfn,G), where the goal G is a fresh 0-ary predicate, and {a mathematical formula}Πfn comprises the rules of {a mathematical formula}Φn and {a mathematical formula}Ξn as well as the following rules:{a mathematical formula}{a mathematical formula}{a mathematical formula} (recall that {a mathematical formula}Q|Bn| corresponds to the output gate of {a mathematical formula}Bn). Clearly, {a mathematical formula}|Πfn|≤2|Bn|+p(|Cn|), for a polynomial p (note that the size of both {a mathematical formula}qfn and {a mathematical formula}Σfn is quadratic in {a mathematical formula}|Cn| and their {a mathematical formula}NDL{0,1}-rewriting is in turn polynomial in their size). We claim that {a mathematical formula}(Πfn,G) is an NDL-rewriting of {a mathematical formula}qfn and {a mathematical formula}Σfn⁎; the proof is as in case (i). □
     </paragraph>
     <paragraph label="Proof">
      We are now in a position to show that NDL-rewritings can be exponentially more succinct than PE-rewritings. To this end, we use the Boolean function {a mathematical formula}Genm3 of {a mathematical formula}m3 variables {a mathematical formula}xijk, {a mathematical formula}1≤i,j,k≤m, defined as follows. We say that 1 generates{a mathematical formula}k≤m if either {a mathematical formula}k=1 or {a mathematical formula}xijk=1, for some i and j, and 1 generates both i and j. {a mathematical formula}Genm3(x111,…,xmmm) returns 1 if and only if 1 generates m. This monotone function, also known as Path System Accessibility [22], is computable by polynomial-size monotone circuits [58]. On the other hand, any monotone formula computing {a mathematical formula}Genm3 is of size at least {a mathematical formula}2mε, for some {a mathematical formula}ε&gt;0[48]. There is a sequence of CQs{a mathematical formula}qnof size{a mathematical formula}O(n)and OWL 2 QL-ontologies{a mathematical formula}Σnof size{a mathematical formula}O(n)that have polynomial-size NDL-rewritings, but any PE-rewritings of{a mathematical formula}qnand{a mathematical formula}Σnare of size{a mathematical formula}≥2nε, for some{a mathematical formula}ε&gt;0.It is known that {a mathematical formula}Genm3 can be computed by monotone Boolean circuits of size {a mathematical formula}p(m), for a polynomial p. So, for each n, we can choose a suitable {a mathematical formula}m=Θ(nδ), with a fixed {a mathematical formula}δ&gt;0, such that the family of functions {a mathematical formula}fn=Genm3 gives rise to the queries {a mathematical formula}qn=qfn and OWL 2 QL-ontologies {a mathematical formula}Σn=Σfn⁎ of size {a mathematical formula}O(n). By Lemma 15 (ii), there are NDL-rewritings of {a mathematical formula}qn and {a mathematical formula}Σn of size polynomial in n. However, by Lemma 8 (ii), any PE-rewritings for {a mathematical formula}qn and {a mathematical formula}Σn are of size {a mathematical formula}≥2mε0, for some {a mathematical formula}ε0&gt;0. Then there is {a mathematical formula}ε&gt;0 such that any PE-rewritings of {a mathematical formula}qn and {a mathematical formula}Σn are of size {a mathematical formula}≥2nε. □
     </paragraph>
     <paragraph label="Proof">
      FO-rewritings can also be substantially shorter than the PE-rewritings. To show this, we need the function {a mathematical formula}Matching2m of {a mathematical formula}m2 variables {a mathematical formula}eij, {a mathematical formula}1≤i,j≤m, that returns 1 if there is a perfect matching in the bipartite graph G with m vertices in each part, which contains an edge {a mathematical formula}{i,j} if and only if {a mathematical formula}eij=1; that is, it returns 1 if there is a subset E of edges in G such that every node of G occurs exactly once in E. It is not hard to see that {a mathematical formula}Matching2m can be computed by a Boolean circuit with {a mathematical formula}m2 nondeterministic inputs and {a mathematical formula}O(m2) gates. On the other hand, monotone Boolean formulas computing {a mathematical formula}Matching2m are exponential, {a mathematical formula}2Ω(m)[49]; but there are non-monotone Boolean formulas computing this function and having size {a mathematical formula}mO(logm)[10]. So, we can use the standard padding trick from circuit complexity [3, p. 57] to show that FO-rewritings can be superpolynomially more succinct than PE-rewritings: There is a sequence of CQs{a mathematical formula}qnof size{a mathematical formula}O(n)and OWL 2 QL-ontologies{a mathematical formula}Σnsize{a mathematical formula}O(n)that have polynomial-size FO-rewritings, but any PE-rewritings of{a mathematical formula}qnand{a mathematical formula}Σnare of size{a mathematical formula}≥2Ω(2log1/2n).We define {a mathematical formula}fn to be a slightly modified {a mathematical formula}Matching2m with {a mathematical formula}m=⌊2log1/2n⌋: namely, {a mathematical formula}fn has {a mathematical formula}max(⌊n1/4⌋,m2) variables, of which {a mathematical formula}m2 are the proper variables of {a mathematical formula}Matching2m, while the rest are dummy variables used for padding (note that {a mathematical formula}⌊n1/4⌋&gt;m2, for all sufficiently large n). Using Lemma 15 (i) and observing that {a mathematical formula}mO(logm)=nO(1), we obtain a polynomial upper bound for the size of FO-rewritings. The required superpolynomial lower bound for PE-rewritings follows from Lemma 8 (ii). □
     </paragraph>
     <paragraph>
      Unfortunately, no separation results for FO- and NDL-rewritings are known at the moment. As follows from the connection between rewritings and various computation models for monotone Boolean functions established in this article, such results would imply the corresponding separation results for formulas and monotone circuits, thereby giving solutions to major open problems in Boolean circuit complexity [29].
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>