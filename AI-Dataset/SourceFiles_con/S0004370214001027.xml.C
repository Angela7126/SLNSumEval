<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Algorithms for computing minimal equivalent subformulas.
   </title>
   <abstract>
    Knowledge representation and reasoning using propositional logic is an important component of AI systems. A propositional formula in Conjunctive Normal Form (CNF) may contain redundant clauses — clauses whose removal from the formula does not affect the set of its models. Identification of redundant clauses is important because redundancy often leads to unnecessary computation, wasted storage, and may obscure the structure of the problem. A formula obtained by the removal of all redundant clauses from a given CNF formula F is called a Minimal Equivalent Subformula (MES) of F. This paper proposes a number of efficient algorithms and optimization techniques for the computation of MESes. Previous work on MES computation proposes a simple algorithm based on iterative application of the definition of a redundant clause, similar to the well-known deletion-based approach for the computation of Minimal Unsatisfiable Subformulas (MUSes). This paper observes that, in fact, most of the existing algorithms for the computation of MUSes can be adapted to the computation of MESes. However, some of the optimization techniques that are crucial for the performance of the state-of-the-art MUS extractors cannot be applied in the context of MES computation, and thus the resulting algorithms are often not efficient in practice. To address the problem of efficient computation of MESes, the paper develops a new class of algorithms that are based on the iterative analysis of subsets of clauses, and a lightweight pruning technique based on the computation of backbones. The experimental results, obtained on representative problem instances, confirm the effectiveness of the proposed methods. The experimental results also reveal that many CNF instances obtained from the practical applications of SAT exhibit a large degree of redundancy.
   </abstract>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Knowledge representation and reasoning based on propositional logic is an important component of AI systems [1]. Conjunctive Normal Form (CNF) plays a special role in both representation and reasoning. Indeed, CNF has become a standard for the input of modern Boolean satisfiability (SAT) solvers and other reasoning engines due to its generality and its amenability to automated processing. This article is concerned with redundancy in propositional formulas in CNF. Specifically, this article addresses the problem of computing an irredundant subformula of a given CNF formula — that is, a subformula {a mathematical formula}E of {a mathematical formula}F that has exactly the same set of models as {a mathematical formula}F and is minimal in the sense that removal of any clause from {a mathematical formula}E violates this property. Such subformula {a mathematical formula}E will be referred to as a Minimal Equivalent Subformula (MES) of {a mathematical formula}F. Intuitively, an MES of {a mathematical formula}F constitutes the result of removal of all redundant clauses from {a mathematical formula}F — these are the clauses whose removal does not change the set of models of {a mathematical formula}F.
     </paragraph>
     <paragraph>
      The complexity characterization of the MES computation problem, as well as a number of additional problems related to identification of redundant clauses, has been investigated extensively by Liberatore in [2]. Previous work on algorithms for removing redundant clauses from CNF formulas proposes a direct approach [3] (and, also, [2]), which iteratively checks the definition of redundant clause and removes the clauses that are found to be redundant. While the direct approach is similar to the well-known deletion-based approach for the computation of Minimal Unsatisfiable Subformulas (MUSes), most of the techniques developed for the extraction of MUSes (e.g. see [4], [5], [6]) have not been extended to the computation of MESes.
     </paragraph>
     <paragraph>
      One specific application of the MES computation problem, and the extended version called the group-MES computation problem (also discussed in this article), is the removal of some or all redundant clauses from CNF formulas. Although in some settings redundancy in a formula might be desirable, in many others it is not. One example of desirable redundancy is that introduced by CNF encodings of various CSP constraints, where redundant clauses help to maintain higher levels of consistency (see, for example, [7] for an overview of work on this topic). Another important example of desirable redundancy is the modern Conflict-Driven Clause Learning (CDCL) SAT solvers. In this setting, all clauses learned during SAT solving are redundant [8], [9], and are often essential for solving practical instances of SAT. However, redundancy can also be undesirable. For example, in knowledge bases formula redundancy leads to the use of unnecessary storage and computational resources [2]. Another example is the undesirable redundant clauses in the CNF representation of belief states in a conformant planner [10], [11]. In the context of probabilistic reasoning systems, concise representation of conditional independence information can be computed by removing redundant clauses from certain propositional encodings [12].
     </paragraph>
     <paragraph>
      More generally, given the wide range of applications of SAT, one can pose the following question: does a given problem domain encoder introduce an undesirable, or an unintended, redundancy, and if so, which clauses are redundant, and how significant is the percentage of these redundant clauses? The algorithms and techniques for computation of MESes and group-MESes presented in this article are intended to assist in answering this question.
     </paragraph>
     <paragraph>
      Removal of redundancies can also find application in solving problems from different complexity classes, for example in Quantified Boolean Formulas (QBF) [13]. It has been shown that simplifications of the propositional part of a QBF often lead to a performance improvement in the QBF solver [14], [15]. Besides propositional logic formulas, the problem of the identification of redundant constraints is relevant in other domains. Concrete examples include Constraint Satisfaction Problems (CSP) [16], [17], [18], Satisfiability Modulo Theories (SMT) [19], and Ontologies [20].
     </paragraph>
     <paragraph>
      The article makes the following contributions. First, it shows that many of the existing MUS extraction algorithms can be extended to the computation of MESes. Since efficient MUS extraction uses a number of key techniques for reducing the total number of SAT solver calls — namely, clause set refinement [21], [22], [23] and model rotation [23], [24] — this article analyzes these techniques in the context of MES extraction. The second contribution of the article is, then, to show that model rotation can be integrated, and, in fact, improved, in MES extraction. However, clause set refinement cannot be used in MES algorithms derived from the existing MUS algorithms. Third, the article proposes a reduction from MES computation problem to group-MUS computation problem [25], [22]; this reduction enables the use of both model rotation and clause set refinement for MES extraction. Fourth, given that the approach of reduction to group-MUS can result in hard instances of SAT, the article proposes an incremental reduction of MES to group-MUS extraction, that involves the separate analysis of subsets of clauses. Though the proposed algorithms already significantly outperform the direct approach, the article also proposes a very effective and light-weight incomplete technique for pruning redundant clauses based on the computation of backbones of propositional formulas. Finally, the article extends the techniques to a group-MES computation problem, and develops solutions for checking that computed MESes are correct. These solutions find application in settings where independent certification is required.
     </paragraph>
     <paragraph>
      Experimental results, obtained on representative satisfiable instances from past SAT competitions, show that the new algorithms for MES computation achieve significant performance gains over the basic algorithms, and allow targeting redundancy removal for reasonably sized formulas. In addition, the experimental results show that many CNF formulas, from a wide range of application domains, contain a significant percentage of redundant clauses, in some cases exceeding 90% of the original clauses.
     </paragraph>
     <paragraph>
      This article is an extended version of the publication that appeared in the proceedings of 18th International Conference on Principles and Practice of Constraint Programming (CP 2012) [26]. With respect to the original publication, this article introduces the novel backbone-based pruning technique (Section 4), and presents the experimental evaluation results that confirm its effectiveness. Furthermore, the article formalizes the group-MES computation problem, and presents the generalizations of the new techniques for the computation of MESes to the group-MES setting (Section 6).
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      Standard definitions for propositional logic are assumed. Propositional formulas are defined over a set of propositional variables {a mathematical formula}X={x1,…,xn}. A CNF formula {a mathematical formula}F is a conjunction of disjunctions of literals (clauses), where a literal is a variable or its complement. Unless otherwise stated, a CNF formula will be referred to as a formula. Formulas are represented by letters with calligraphic fonts, e.g. {a mathematical formula}F, {a mathematical formula}E, {a mathematical formula}S, {a mathematical formula}W, etc. When necessary, subscripts are used. Clauses are represented by c or {a mathematical formula}ci, {a mathematical formula}i=1,…,m. A CNF formula can also be viewed as a multiset of non-tautologous clauses where a clause is a (multi)set of literals. The two representations are used interchangeably, and are clear from the context. A truth assignment μ is a mapping from X to {a mathematical formula}{0,1}, {a mathematical formula}μ:X→{0,1}. For a truth assignment μ we write {a mathematical formula}F[μ] to denote the substitution of each variable x in the domain of μ with the constant {a mathematical formula}μ(x); additionally, trivial simplifications are applied ({a mathematical formula}F∨0=F, {a mathematical formula}F∨1=1, etc.). Note that whenever μ assigns a value to all variables occurring in a formula {a mathematical formula}F, the formula {a mathematical formula}F[μ] is equal to either 1 or 0. A truth assignment μ satisfies (resp. falsifies) a clause c if {a mathematical formula}c[μ]=1 (resp. {a mathematical formula}c[μ]=0). A truth assignment μ is a model of F if it satisfies all clauses in {a mathematical formula}F, i.e. {a mathematical formula}F[μ]=1. Two formulas {a mathematical formula}F1 and {a mathematical formula}F2 are equivalent, {a mathematical formula}F1≡F2, if they have the same set of models. Note that models are always defined on a fixed set of variables X, which ensures that equivalence is well-defined even for cases when some variables are present only in one of the formulas. The negation of a clause c, denoted by ¬c represents a conjunction of unit clauses, one for each literal in c. It will also be necessary to negate CNF formulas, e.g. {a mathematical formula}¬F. The following CNF encoding for {a mathematical formula}¬F is used [27]. An auxiliary variable {a mathematical formula}ui is associated with each {a mathematical formula}ci∈F, defining a set of variables U. For each {a mathematical formula}li,j∈ci, create binary clauses {a mathematical formula}(¬li,j∨¬ui). Finally, create a clause {a mathematical formula}(⋁ui∈Uui). This CNF encoding is represented as {a mathematical formula}CNF(⋅). For example, {a mathematical formula}CNF(¬c) and {a mathematical formula}CNF(¬F) denote, respectively, the CNF encoding of ¬c and {a mathematical formula}¬F described above; both {a mathematical formula}CNF(¬c) and {a mathematical formula}CNF(¬F) can be used in set context to denote sets of clauses. Calls to a SAT solver are represented with {a mathematical formula}SAT(F) and unless specified otherwise, the return value is true if and only if the given formula {a mathematical formula}F is satisfiable.
     </paragraph>
     <section label="2.1">
      <section-title>
       MUSes and MESes
      </section-title>
      <paragraph label="Definition 1">
       The following definition of Minimal Unsatisfiable Subformulas (MUSes) is used [28]. MUS{a mathematical formula}M⊆F is a Minimal Unsatisfiable Subformula (MUS) of {a mathematical formula}F iff {a mathematical formula}M is unsatisfiable and {a mathematical formula}∀S⊊MS is satisfiable. MUS extraction algorithms can be broadly characterized as deletion-based[29], [30] or insertion-based. Moreover, insertion-based algorithms can be characterized as linear search[31], dichotomic search[32], or QuickXplain [33]. Recent work proposed a theoretically-optimal, and also efficient in practice, progression-based algorithm [34]. The most practically efficient MUS extraction algorithms — the hybrid[23] and the progression-based — employ a number of pruning techniques that allow to significantly reduce the number of SAT solver calls. Such techniques include clause set trimming (during preprocessing), clause set refinement and model rotation[21], [22], [23], [24]. Clause set refinement [21], [23] exploits the SAT solver false (or unsatisfiable) outcomes to reduce the set of clauses that need to be analyzed. This consists of removing clauses that are not included in the MUS being constructed, e.g. by restricting the target set of clauses to the unsatisfiable subset computed by the SAT solver. In contrast, model rotation exploits the SAT solver true (or satisfiable) outcomes to also reduce the set of clauses that need to be analyzed. In this case, models are used to identify clauses that must be included in the MUS being constructed. Recent experimental data [23] indicates that these two techniques are essential for MUS extraction on large application problem instances.
      </paragraph>
      <paragraph label="Definition 2">
       Motivated by several applications, MUSes and related concepts have been extended to CNF formulas where clauses are partitioned into disjoint sets called groups[25], [22]. Group-oriented MUSGiven an explicitly partitioned unsatisfiable CNF formula {a mathematical formula}F=D∪G1∪…∪Gn, a group oriented MUS (or, group-MUS) of {a mathematical formula}F is a subset {a mathematical formula}F′=D∪Gi1∪…∪Gik of {a mathematical formula}F (with {a mathematical formula}1≤ij≤n for {a mathematical formula}1≤j≤k≤n) such that {a mathematical formula}F′ is unsatisfiable and, for every {a mathematical formula}1≤j≤k, {a mathematical formula}F′∖Gij is satisfiable. The group {a mathematical formula}D in the above definition is called a don't care group, and the explicitly partitioned CNF formulas as above are referred to as group-CNF formulas.
      </paragraph>
      <paragraph label="Definition 4">
       MUSes are a special case (for unsatisfiable formulas) of irredundant subformulas [2]. The following definitions will be used throughout. Redundant/irredundant clause/formulaA clause {a mathematical formula}c∈F is said to be redundant in {a mathematical formula}F if {a mathematical formula}F∖{c}⊨c or, equivalently, {a mathematical formula}F∖{c}∪CNF(¬c)⊨⊥. Otherwise, c is said to be irredundant in {a mathematical formula}F. A formula {a mathematical formula}F is redundant if it has at least one redundant clause; otherwise it is irredundant. Irredundant subformulas of (redundant) formulas are referred to as irredundant equivalent subsets[2] and as irredundant cores[35]. In this paper, irredundant subformulas are referred to as Minimal Equivalent Subformulas (MESes), by analogy with MUSes. MES{a mathematical formula}E⊆F is a Minimal Equivalent Subformula (MES) of {a mathematical formula}F iff {a mathematical formula}E≡F and {a mathematical formula}∀Q⊊EQ≢F. Clearly, an MES of any formula {a mathematical formula}F is irredundant. Moreover, deciding whether a CNF formula is an MES is {a mathematical formula}DP-complete [2]. In the case of group-CNF formulas, the concept of group-oriented MES (group-MES) can be defined analogously to Definition 2 — Section 6 contains the necessary details.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Existing techniques
      </section-title>
      <paragraph>
       This subsection overviews several techniques referred to throughout the article, namely, unsatisfiable cores, model rotation, and clause set refinement. These are described in detail in the references [36], [37], [23], [24], [38], [21], [22].
      </paragraph>
      <paragraph>
       Some of the presented algorithms avail of unsatisfiable cores[36], [37]. For an unsatisfiable formula {a mathematical formula}F an unsatisfiable core is a formula {a mathematical formula}C that is unsatisfiable and such that {a mathematical formula}C⊆F. To obtain an unsatisfiable core, one can use either a proof-tracing SAT solver, such as picosat[39], or an assumption-based SAT solver, cf. [40], [41]. In theory, an unsatisfiable core does not guarantee any minimality — it can for instance be equal to the whole formula. In practice, however, unsatisfiable cores are often significantly smaller than the input formula.
      </paragraph>
      <paragraph>
       In MUS computation a clause c is necessary for unsatisfiability of {a mathematical formula}F if removing c from {a mathematical formula}F yields satisfiability. When this is detected by a SAT solver, the solver provides us with a model μ of {a mathematical formula}F∖{c}. The technique of model rotation tries to obtain a model {a mathematical formula}μ′ of {a mathematical formula}F∖{c′} for some different clause {a mathematical formula}c′ from μ by flipping the value of variables that appear in c. Once such {a mathematical formula}μ′ and {a mathematical formula}c′ are found, the clause {a mathematical formula}c′ is also marked as necessary for unsatisfiability [23], [24], [38]. This technique in practice allows to significantly reduce the number of calls to SAT solver and results in multiple orders of magnitude reduction in run-times of hybrid MUS extraction algorithms on industrial problem instances (cf. [38]).
      </paragraph>
      <paragraph>
       In MUS computation a SAT solver is commonly invoked. Often, the unsatisfiable core of an unsatisfiable call is useful. For instance, given a formula {a mathematical formula}F, one can inspect each clause c at a time and test whether removing it from {a mathematical formula}F is satisfiable or not. If {a mathematical formula}F∖{c} satisfiable, the clause is put back into {a mathematical formula}F. If it is unsatisfiable, the clause c is discarded. Moreover, if the underlying SAT solver provides an unsatisfiable core {a mathematical formula}C⊆(F∖{c}), the algorithm continues with {a mathematical formula}C as it is an unsatisfiable subset of {a mathematical formula}F (which is guaranteed to not contain c). This technique is called the clause set refinement[21], [22], [23]. Note that clause set refinement and model rotation complement one another.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Related work
      </section-title>
      <paragraph>
       MUSes find a wide range of practical applications, and have been extensively studied (see [4], [5], [6] for recent overviews, and [33], [32], [42], [43] for connections with CSP). The problem of computing minimal (or irredundant) representations of CNF formulas (and related problems) has been the subject of extensive research [44], [45], [3], [2], [46], [47], [35], with applications in the compression of Horn knowledge bases [45], and minimal representation of hypergraphs [44]. Complexity characterizations of redundancy problems in logic can be found in [2]. An algorithm for computing an MES based on the direct application of the definition of clause redundancy is studied in [3]. More recently, properties of MESes are studied in [35].
      </paragraph>
      <paragraph>
       Approximate solutions for redundancy removal based on unit propagation are proposed in [48], [49]. A number of applications (of restricted forms) of redundancy removal have been proposed in recent years [50], [10], [11], [48], [2], [12], including contingent planning [10], [11], conditional independence [12], and CNF formula preprocessing [50] The importance of redundant clauses in CDCL SAT solvers is addressed in [8], [9].
      </paragraph>
      <paragraph>
       The removal of redundancy in propositional formulas finds important applications in combinational and sequential circuit design [51], [52], including both computing minimum size DNF representations [53], [54], [55], [56], or minimal DNF representations [51], [52]. Nevertheless, the decision problem of exact minimization of propositional formulas is located in the second level of the polynomial hierarchy [57], even for the case of DNF representations [58]. As a result, the computation of a minimal DNF representation finds application in the design of most modern computing systems. Recent work in propositional formula minimization has addressed the removal of variables and connections between variables [59], [60].
      </paragraph>
      <paragraph>
       Redundancy problems have been studied in many other settings, e.g. [16], [17], [18], [19], [20], including constraint networks [16], [17], [18], satisfiability modulo theories [19], and ontologies [20].
      </paragraph>
      <paragraph>
       Backbones find a number of applications in other analyses, e.g. product configuration [61], [62], [63] or problem encoding [64].
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      MES extraction algorithms
     </section-title>
     <paragraph>
      This section develops several new approaches for computing one MES of a CNF formula {a mathematical formula}F. The first solution consists of adapting any MUS extraction algorithm based on identification of so-called transition clauses, for MES extraction. Afterwards, key techniques used in MUS extraction are studied. Model rotation [23], [24] is applied to MES extraction, and it is argued that clause set refinement [21], [22], [23] cannot be directly applied to MES extraction algorithms resulting from adapting existing MUS extraction algorithms. Next, a reduction from MES to group-MUS formulation [25], [22] is developed, which enables the use of both model rotation and clause set refinement. Although the reduction of MES to group-MUS extraction enables the integration of key techniques, it is also the case that the resulting instances of SAT are hard to solve. This section concludes by developing an incremental reduction from MES to group-MUS extraction, which produces much easier instances of SAT. Fig. 1 summarizes the approaches to MES extraction described in the remainder of this section.
     </paragraph>
     <section label="3.1">
      <section-title>
       From MUS extraction to MES extraction
      </section-title>
      <paragraph>
       A key definition in MUS extraction algorithms is that of transition clause[4]. A transition clause c is such that, if added to a satisfiable subformula {a mathematical formula}R, the resulting subformula is unsatisfiable. This definition can be generalized for MES extraction as follows. Let {a mathematical formula}R⊊F denote a (reference) subformula of {a mathematical formula}F which is to be extended to be equivalent to {a mathematical formula}F. Observe that {a mathematical formula}F⊨R, and so, in case {a mathematical formula}R⊨;̸F, our goal is to extend {a mathematical formula}R with a clause {a mathematical formula}c∈F∖R, such that {a mathematical formula}R∪{c}⊨F, and so {a mathematical formula}R∪{c}≡F. We will refer to such clauses c as witnesses of equivalence of the formulas {a mathematical formula}R∪{c} and {a mathematical formula}F, since they are required for the certification of the equivalence of the two formulas.
      </paragraph>
      <paragraph label="Definition 5">
       Witness of equivalenceLet {a mathematical formula}S be a subformula of {a mathematical formula}F, {a mathematical formula}S⊊F, with {a mathematical formula}S⊭F, and let {a mathematical formula}c∈F. If {a mathematical formula}S∪{c}⊨F, then c is a witness of {a mathematical formula}S∪{c}≡F.
      </paragraph>
      <paragraph label="Observation 1">
       If c is a witness of{a mathematical formula}S∪{c}≡F, then the clause c is irredundant in the formula{a mathematical formula}S∪{c}(seeDefinition 3).
      </paragraph>
      <paragraph>
       When constructing an MES, Definition 5 identifies a clause that is necessary for the MES being constructed (Observation 1). Hence, this definition enables us to adapt any MUS extraction algorithm for MES extraction. The remainder of this section illustrates how this can be achieved. Let {a mathematical formula}F be a CNF formula partitioned as follows, {a mathematical formula}F=E∪R∪S. A subformula {a mathematical formula}R is redundant in {a mathematical formula}F iff {a mathematical formula}F≡E∪S, or, equivalently, {a mathematical formula}E∪S⊨R. Given an under-approximation {a mathematical formula}E of an MES of {a mathematical formula}F, and a working subformula {a mathematical formula}S⊊F, the objective is to decide whether {a mathematical formula}E and {a mathematical formula}S entail all the other clauses of {a mathematical formula}F. Current MUS extraction algorithms can be organized as (see Section 2.1): (i) deletion-based [29], [30], (ii) insertion-based [31], [65], (iii) insertion-based with dichotomic search [32], (iv) QuickXplain [33], and (v) progression-based [34].
      </paragraph>
      <paragraph label="Proof">
       The pseudo-code for deletion-based MES extraction is shown in Algorithm 1. Note that throughout the article we use the function SelectRemoveClause{a mathematical formula}(S), which returns some arbitrary clause from the given set {a mathematical formula}S and as a side-effect it removes it from the set. At each step, the algorithm uses an MES under-approximation {a mathematical formula}E, a set of (remaining) clauses {a mathematical formula}S, and a target clause c, to check whether {a mathematical formula}E∪S⊨c. If this is not the case, i.e. if {a mathematical formula}E∪S⊭c, then c is witness of {a mathematical formula}E∪S∪{c}≡F, and so c is added to {a mathematical formula}E; otherwise, c is discarded. Observe that the deletion-based MES extraction algorithm corresponds to a direct implementation of the definition of redundant clause (e.g. see [3]). Correctness of the algorithm is shown by the following theorem. Algorithm 1is correct.The algorithm is terminating as the size of the set {a mathematical formula}S decreases by 1 in each iteration and the algorithm stops when the set is empty.To prove partial correctness consider the invariant that {a mathematical formula}E∪S≡F and all clauses in {a mathematical formula}E are irredundant w.r.t. {a mathematical formula}E∪S. The invariant is established by the initialization since {a mathematical formula}S=F and {a mathematical formula}E=∅. To prove that the invariant is preserved by the loop consider the sets {a mathematical formula}S0 and {a mathematical formula}E0 at beginning of an iteration and the sets {a mathematical formula}S1, {a mathematical formula}E1 at the end of the iteration. Note that {a mathematical formula}S1=S0∖{c} for {a mathematical formula}c=SelectRemoveClause(S0). By induction hypothesis, {a mathematical formula}E0∪S0=E0∪S1∪{c}≡F and all clauses in {a mathematical formula}E0 are irredundant w.r.t. {a mathematical formula}E0∪S0. The invariant is preserved as c is added to {a mathematical formula}E0 only if it is irredundant w.r.t. {a mathematical formula}E0∪{c}∪S1. Partial correctness of the algorithm follows from the invariant since upon the loop's termination, {a mathematical formula}S=∅ and therefore {a mathematical formula}E is equivalent to {a mathematical formula}F and does not contain any irredundant clause.  □
      </paragraph>
      <paragraph>
       It is worth to note that the performance of the deletion-based algorithm, as well as other algorithms for MES extraction presented in this paper, is affected to a large degree by the clause-selection heuristic used in the implementation of the function SelectRemoveClause. This is similar to the case of the algorithms for the computation of MUSes, where a number of clause selection heuristics have been developed (e.g. [5], [66]). In the implementation of the MES algorithms evaluated in this paper SelectRemoveClause returns clauses in the order of appearance in the input formula, however, clearly, the development of intelligent clause-selection heuristics for MES computation is an important objective, and is a subject of future research.
      </paragraph>
      <paragraph label="Proof">
       The pseudo-code for insertion-based linear and dichotomic search MES extraction are shown in Algorithm 2, Algorithm 3, respectively. Both algorithms iteratively add clauses to set {a mathematical formula}S while {a mathematical formula}E∪S⊭W. The last clause included in {a mathematical formula}S such that {a mathematical formula}E∪S⊨W is the witness of equivalence. The main difference between Algorithm 2, Algorithm 3 is how the witness of equivalence is searched for. The following theorem shows correctness of Algorithm 2, correctness of Algorithm 3 is shown similarly. Algorithm 2is correct.The inner loop of the algorithm is terminating as the size of {a mathematical formula}W decreases by 1 in each iteration and therefore the loop is guaranteed to stop when {a mathematical formula}W=∅ because {a mathematical formula}E∪S∪CNF(¬W) is necessarily unsatisfiable for {a mathematical formula}W=∅ as {a mathematical formula}¬W=⊥ in such case. Note, however, that the loop might stop earlier. The outer loop is terminating as at least one clause is removed from {a mathematical formula}W and added to {a mathematical formula}E in each iteration of the outer loop (the clause {a mathematical formula}cr). Hence, the loop is guaranteed to terminate when {a mathematical formula}W=∅. Again, the loop might terminate earlier, which is when the inner loop performs no iterations and leaves the set {a mathematical formula}S empty, which breaks the outer loop on line 9.To prove partial correctness consider the invariant that {a mathematical formula}E∪W≡F, {a mathematical formula}E∪W⊆F, and that all clauses in {a mathematical formula}E are irredundant w.r.t. {a mathematical formula}E∪W. The invariant is established by the initialization since {a mathematical formula}W=F and {a mathematical formula}E=∅. To prove that the invariant is preserved by the outer loop, consider the sets {a mathematical formula}W0 and {a mathematical formula}E0 at the beginning of an iteration and the sets {a mathematical formula}W1 and {a mathematical formula}E1 at the end of the iteration. Note that {a mathematical formula}E1=E0∪{cr} for {a mathematical formula}cr obtained from the inner loop. We observe that the inner loop moves clauses from {a mathematical formula}W0 into the intermediate set {a mathematical formula}S until the SAT tests returns “no”. When the SAT test returns “no”, then the negation of the argument formula is a tautology. Hence {a mathematical formula}E0∪S⊨(W0∖S) once the inner loop terminates. This guarantees that {a mathematical formula}E0∪S≡E0∪W0. From induction hypothesis we have {a mathematical formula}E0∪S≡F. Hence, {a mathematical formula}E1∪W1≡F since {a mathematical formula}E1∪W1=E0∪S. To establish that all clauses in {a mathematical formula}E1 are irredundant for {a mathematical formula}E1∪W1 we first consider the clauses in {a mathematical formula}E0. Since {a mathematical formula}E1∪W1⊆E0∪W0, no clause in {a mathematical formula}E0 could have become redundant. The clause {a mathematical formula}cr is irredundant due to the inner loop, which guarantees that {a mathematical formula}E0∪S≡F and {a mathematical formula}E0∪S∖{cr}≢F ({a mathematical formula}cr is a witness of equivalence for {a mathematical formula}E0∪S). Partial correctness of the algorithm follows directly from the invariant as {a mathematical formula}W is empty upon termination and therefore {a mathematical formula}E≡F with no redundant clauses.  □
      </paragraph>
      <paragraph>
       Recent experimental data indicates that deletion-based MUS extraction algorithms (cf. the variant in [23]), as well as progression-based [34], are the most efficient currently available algorithms for practical instances. This is despite the fact that the insertion-based algorithms have a number of theoretical advantages over the deletion-based (see [23] for a detailed discussion). Since insertion-based MES algorithms require SAT solver calls with (possibly large) complemented formulas, deletion-based MES extraction algorithms are expected to outperform the insertion-based ones. This is confirmed by the results in Section 7.
      </paragraph>
      <paragraph label="Example 1">
       Efficient MUS extraction algorithms [21], [22], [23]must use a number of additional techniques for reducing the number of SAT solver calls. These techniques include clause set refinement[21], [23] and model rotation[23], [24]. The next section shows how model rotation can be used in MES extraction. In contrast, clause set refinement cannot be applied in the algorithms described above. Let {a mathematical formula}F=(x1)∧(x1∨x3)∧(x2), and consider the execution of Algorithm 1. First, clause {a mathematical formula}(x1) is removed and the resulting formula is satisfiable with {a mathematical formula}x1=0, {a mathematical formula}x2=x3=1; hence {a mathematical formula}(x1) is irredundant. Second, clause {a mathematical formula}(x1∨x3) is removed and the resulting formula is unsatisfiable; hence {a mathematical formula}(x1∨x3) is redundant. Moreover, the computed unsatisfiable core is {a mathematical formula}{(x1),(¬x1)}, where {a mathematical formula}(¬x1) is taken from {a mathematical formula}¬(x1∨x3). However, {a mathematical formula}(x2) is not in the unsatisfiable core, but it cannot be removed. Subsequently, {a mathematical formula}(x1∨x3) is forgotten while {a mathematical formula}(x2) is deemed irredundant, which results in the output of the algorithm: {a mathematical formula}(x1)∧(x2). As illustrated by the previous example, since MES extraction algorithms require adding the negation of a subformula of {a mathematical formula}F, the computed unsatisfiable cores depend on this negation, which changes as the algorithm executes. Thus, a computed unsatisfiable core provides no information about which clauses need not be considered further. Despite this negative result, Sections 3.3 and 3.4 develop solutions for MES extraction that enable clause set refinement.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       Using model rotation in MES extraction
      </section-title>
      <paragraph label="Proof">
       The definition of irredundant clause (see Definition 3) can be associated with specific truth assignments, that can serve as witnesses of irredundancy. A clause{a mathematical formula}c∈Fis irredundant in{a mathematical formula}Fif and only if there exists a truth assignment μ, such that{a mathematical formula}(F∖{c})[μ]=1and{a mathematical formula}c[μ]=0.Follows directly from the definition of an irredundant clause and the semantics of {a mathematical formula}F∖{c}⊭c. □
      </paragraph>
      <paragraph>
       In the context of MUS extraction, Proposition 1 is used as a basis of model rotation, cf. Section 2.2. Proposition 1 has also been used in the context of local search for MUS extraction [67].
      </paragraph>
      <paragraph>
       In the context of MES extraction, model rotation can be instrumented as follows. If a SAT solver call returns satisfiable (see, for example, line 6 in Algorithm 1), then we use the model computed by the solver to look for other irredundant clauses using Proposition 1. For instance in Algorithm 1 once we obtain a model μ of {a mathematical formula}E∪S∪{¬c}, we modify μ to {a mathematical formula}μl by flipping the value of a literal of {a mathematical formula}l∈c and look for a clause {a mathematical formula}d∈S so that {a mathematical formula}(E∪S∖{d})[μl]=1 and {a mathematical formula}d[μl]=0 (note that {a mathematical formula}c[μl]=1). Such clause d is deemed irredundant due to Proposition 1. Note that such clause can be discovered without a second SAT call. This process goes over all literals {a mathematical formula}l∈c and it continues recursively from the newly detected irredundant clause (if any).
      </paragraph>
      <paragraph>
       Model rotation for MES extraction can be improved further. Since the formula is satisfiable, model rotation may reach assignments where all clauses are satisfied (note that this situation is not possible in MUS extraction). In this case, rather than terminating the process, clauses with the smallest number of satisfied literals are selected, the satisfied literals are flipped, and again one checks whether the formula has a single falsified clause. As demonstrated in Section 7, this improved model rotation is very effective for redundancy removal.
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       A reduction of MES to group-MUS
      </section-title>
      <paragraph>
       As argued in Section 3.1, although MUS extraction algorithms can be modified for MES extraction, clause set refinement [21], [22], [23] cannot be used. In the context of MUS computation, this technique is paramount for reducing the number of SAT solver calls in instances with many redundant clauses. This section develops a reduction of MES computation problem to group-MUS computation problem [25], [22] — recall Definition 2. A key advantage of this reduction is that it enables clause set refinement.
      </paragraph>
      <paragraph label="Proof">
       MES to group-MUS reductionGiven a CNF formula{a mathematical formula}F, and any{a mathematical formula}E⊆F, let{a mathematical formula}RF(E)be the group-CNF formula{a mathematical formula}D∪⋃c∈EGc, where{a mathematical formula}D=CNF(¬F)is the don't care group, and{a mathematical formula}Gc={c}. Then,{a mathematical formula}Eis an MES of{a mathematical formula}Fif and only if{a mathematical formula}RF(E)is a group-MUS of{a mathematical formula}RF(F).We prove both directions simultaneously. Since {a mathematical formula}RF(E)=CNF(¬F)∪E, we have that {a mathematical formula}E⊨F (and so {a mathematical formula}E≡F), if and only if {a mathematical formula}RF(E) is unsatisfiable. Let c be any clause of {a mathematical formula}E. Then, by Proposition 1, c is irredundant in {a mathematical formula}E if and only if there exists an assignment μ, such that {a mathematical formula}(E∖{c})[μ]=1 and {a mathematical formula}c[μ]=0. Equivalently, there is an extension {a mathematical formula}μ′ of μ such that {a mathematical formula}CNF(¬F)[μ′]=1 and {a mathematical formula}(E∖{c})[μ′]=1, i.e. {a mathematical formula}RF(E∖{c}) is satisfiable. □
      </paragraph>
      <paragraph>
       Expressing the MES computation problem as a group-MUS computation problem enables the use of optimization techniques for (group-)MUS extraction in computing irredundant CNF formulas. Most importantly, the clause-set refinement becomes usable and effective again. We demonstrate this with the following example.
      </paragraph>
      <paragraph label="Example 2">
       Consider the CNF formula {a mathematical formula}F=(x1)∧(x1∨yi∨yj), with {a mathematical formula}1≤i&lt;j≤k, and {a mathematical formula}k≥2. All clauses with a literal in the y variables are redundant, for a total of {a mathematical formula}k(k−1)/2 redundant clauses. The reduction in Proposition 2 produces the group-CNF formula {a mathematical formula}RF(F) with the don't care group {a mathematical formula}D=CNF(¬F), and a singleton group for each clause in {a mathematical formula}F, i.e. {a mathematical formula}G11={(x1)}, {a mathematical formula}Gij={(x1∨yi∨yj)}, with {a mathematical formula}1≤i&lt;j≤k. For this example, let us assume that the group-MUS of {a mathematical formula}RF(F) is computed using a deletion-based algorithm. Let {a mathematical formula}G11 be the first group to be analyzed. This is done by removing the clause in {a mathematical formula}G11 from the formula. The resulting formula has a model μ, with {a mathematical formula}μ(x1)=0 and {a mathematical formula}μ(yi)=μ(yj)=1, with {a mathematical formula}1≤i&lt;j≤k. As a result, {a mathematical formula}(x1) is declared irredundant, and added back to the formula. Afterwards, pick one of the other groups, e.g. {a mathematical formula}G12. If the corresponding clause is removed from the formula, the resulting formula is unsatisfiable, and so the clause is declared redundant. More importantly, a CDCL SAT solver will produce an unsatisfiable core {a mathematical formula}U⊆{x1}∪CNF(¬F). Hence, clause set refinement serves to eliminate all of the remaining groups of clauses, and so the MES is computed with two SAT solver calls. As noted earlier, MES algorithms based on adapting existing MUS algorithms are unable to implement clause set refinement, and so cannot drop {a mathematical formula}k(k−1)/2 clauses after the second SAT solver call.
      </paragraph>
      <paragraph>
       Observe that the group-MUS approach to the MES extraction problem, i.e. using the reduction in Proposition 2, is independent of the actual group-MUS extraction algorithm used. Hence, any existing group-MUS extraction algorithm can be used for the MES extraction problem. In practice, given the significant performance difference between deletion-based and insertion-based MUS extraction algorithms [23], our implementation is based on deletion-based group-MUS extraction and its most recent instantiation, i.e. the hybrid approach in [23].
      </paragraph>
     </section>
     <section label="3.4">
      <section-title>
       Incremental reduction of MES to group-MUS
      </section-title>
      <paragraph>
       A major drawback of the group-MUS approach is that for large input formulas the resulting instances of SAT can be hard. This is due to the CNF encoding of {a mathematical formula}¬F that produces a large disjunction of auxiliary variables. A solution to this issue is based on an incremental reduction of MES extraction to group-MUS extraction. Let {a mathematical formula}T be any subset of clauses of {a mathematical formula}F — we refer to clauses of {a mathematical formula}T as target clauses, and to the set {a mathematical formula}T itself as a chunk of {a mathematical formula}F. The incremental reduction is based on the observation that in group-MUS approach the redundancy of any target clause {a mathematical formula}c∈T can be established by analyzing c with respect to {a mathematical formula}CNF(¬T) rather than {a mathematical formula}CNF(¬F). This observation is stated precisely below.
      </paragraph>
      <paragraph label="Proposition 3">
       Let{a mathematical formula}T⊆Fbe a set of target clauses. For any{a mathematical formula}E⊆T, let{a mathematical formula}RT(E)be the group-CNF formula{a mathematical formula}D∪⋃c∈EGc, where{a mathematical formula}D=F∖T∪CNF(¬T)is the don't care group, and{a mathematical formula}Gc={c}. Then,{a mathematical formula}Eis irredundant in{a mathematical formula}Fand{a mathematical formula}F∖T∪E≡Fif and only if{a mathematical formula}RT(E)is a group-MUS of{a mathematical formula}RT(T). Note that {a mathematical formula}RT(T) is unsatisfiable. Also, in the case when the chunk {a mathematical formula}T is taken to be the whole formula {a mathematical formula}F, the group-CNF formula {a mathematical formula}RT(E) is exactly the formula {a mathematical formula}RF(E) from Proposition 2, and so the claim of Proposition 2 is a special case of the claim of Proposition 3. We omit the proof of Proposition 3 as it essentially repeats the steps of the proof of Proposition 2, using the definition of {a mathematical formula}RT(E) instead of {a mathematical formula}RF(E).
      </paragraph>
      <paragraph label="Proof">
       For the general case, consider a partition {a mathematical formula}F1,…,Fk of {a mathematical formula}F into chunks. Then, an MES of {a mathematical formula}F can be computed by applying the group-MUS approach of Proposition 3 to each chunk. Proposition 3 is applied in order, with already computed irredundant subformulas replacing the original (redundant) subformulas. Explicitly, for the iteration j, {a mathematical formula}1≤j≤k, the input group-CNF formula in Proposition 3 is defined as follows:{a mathematical formula} as a don't care group, where {a mathematical formula}Ei, {a mathematical formula}1≤i&lt;j, is the computed irredundant set of clauses in {a mathematical formula}Fi, {a mathematical formula}1≤i&lt;j, and, as before, {a mathematical formula}Gc={c}. Let{a mathematical formula}F1,…,Fkbe a partition of{a mathematical formula}Finto chunks. For{a mathematical formula}1≤j≤k, let{a mathematical formula}Ejbe the set of clauses obtained from applying group-MUS extraction to the formula in(1), and by considering each{a mathematical formula}Fjas the set of target clauses. Let{a mathematical formula}E=E1∪E2∪…∪Ek. Then{a mathematical formula}Eis an MES of{a mathematical formula}F.{sup:1}For {a mathematical formula}1≤j≤k, let {a mathematical formula}Ij=(⋃r≤jEr∪⋃r&gt;jFr), with {a mathematical formula}I0=F. The proposition follows from the following inductive invariant: for {a mathematical formula}1≤j≤k, {a mathematical formula}Ij≡F, and the formula {a mathematical formula}⋃r≤jEr irredundant in {a mathematical formula}F. The claim of the proposition corresponds to the case {a mathematical formula}j=k.Base case: letting {a mathematical formula}T=F1 and {a mathematical formula}F=I0 in Proposition 3, we have that {a mathematical formula}E1 is irredundant in {a mathematical formula}F, and {a mathematical formula}I1=(F∖F1∪E1)≡F.Inductive step: we are applying Proposition 3 to the formula {a mathematical formula}Ij−1, letting the target set of clauses {a mathematical formula}T be the chunk {a mathematical formula}Fj. Then, from the proposition, {a mathematical formula}Ej is irredundant in {a mathematical formula}Ij−1, and since, by the inductive hypothesis, {a mathematical formula}Ij−1≡F, we conclude that {a mathematical formula}Ej is irredundant in {a mathematical formula}F. Also from the proposition we obtain that {a mathematical formula}Ij≡F, thus concluding the proof of the invariant.  □
      </paragraph>
      <paragraph>
       While Proposition 4 can be used to compute an MES of an input formula {a mathematical formula}F by iteratively calling a group-MUS extractor, it can also be integrated into a unified algorithm to enable certain optimizations (e.g. incremental SAT solving). Algorithm 4 shows the pseudo-code for deletion-based group-MUS approach to MES extraction using chunks. Note that the function {a mathematical formula}SAT(⋅) returns a triple {a mathematical formula}(st,ν,U), which contains the formula's satisfiability in the element st; a satisfying assignment ν when the formula is satisfiable; and an unsatisfiable core {a mathematical formula}U when the formula is unsatisfiable.
      </paragraph>
      <paragraph>
       Different chunk sizes can be considered. Concrete examples include chunks of size 1 or a single chunk aggregating all clauses (i.e. the reduction to group-MUS defined in Proposition 2). For chunks of size great than 1, the group-MUS approach has the ability to prove several clauses redundant by using clause-set refinement. Generally, the chunk size in the group-MUS approach controls the trade-off between the potential power of clause-set refinement and the difficulty of the instances of SAT given to the SAT solver.
      </paragraph>
      <paragraph>
       Nevertheless, an essential issue with Algorithm 4 is the selection of the size of the chunks. The current implementation of the algorithm uses chunks of fixed size, independently of the size of the formula. Alternative solutions include using chunk sizes dependent on the size of the formula, and also adaptive chunk sizes.
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Backbone-based pruning
     </section-title>
     <paragraph>
      What makes clause-redundancy analysis difficult in practice is the large number of clauses found in practical formulas. Typically, however, the number of variables is significantly smaller than the number of clauses. This motivates the technique presented in this section. The technique first computes for the given formula its backbone, which are literals that are true in all of the formula's models [68], [69], [70]. Having information about the backbone enables as to identify certain redundant clauses. And, it is possible to compute the backbone with a number of SAT calls proportional to the number of variables of the formula.
     </paragraph>
     <paragraph label="Definition 6">
      BackboneA literal l is a backbone literal of a formula {a mathematical formula}F if l is true in all models of the formula, i.e. {a mathematical formula}F⊨l. The backbone of a formula comprises its backbone literals.
     </paragraph>
     <paragraph>
      Note that a test whether a literal l is a backbone literal can be achieved by a single SAT call. In particular, l is a backbone literal of {a mathematical formula}F iff the formula {a mathematical formula}F∧(¬l) is unsatisfiable. This means that the whole backbone can be computed with a number of SAT calls proportional to the number of variables of the formula. However, a number of optimization for computing the backbone exist [71].
     </paragraph>
     <paragraph>
      Knowing that a literal is a backbone literal is not itself sufficient for discovering redundant clauses. If, however, we additionally know that l is a backbone literal because of some subformula {a mathematical formula}R⊆F, all clauses of {a mathematical formula}F∖R that contain l are redundant.
     </paragraph>
     <paragraph label="Proof">
      Let l be a backbone literal of a formula{a mathematical formula}F, i.e.{a mathematical formula}F⊨l. Further, let{a mathematical formula}R⊆Fbe a subformula of{a mathematical formula}Fsuch that{a mathematical formula}R⊨l. The following set{a mathematical formula}Sof clauses is redundant:{a mathematical formula}Since {a mathematical formula}S is disjoint from {a mathematical formula}R, it holds for any clause {a mathematical formula}c∈S that {a mathematical formula}F∖{c}⊨l. Because {a mathematical formula}l∈c, then also {a mathematical formula}F∖{c}⊨c (see Definition 3).  □
     </paragraph>
     <paragraph>
      Proposition 5 enables us to remove as redundant all the clauses in {a mathematical formula}S. This is because once any clause {a mathematical formula}c∈S is a removed from {a mathematical formula}F, the same proposition applies to the formula {a mathematical formula}F∖{c} and the same {a mathematical formula}R.
     </paragraph>
     <paragraph>
      Proposition 5 suggests how to modify a backbone-computation algorithm into a technique for identifying certain redundant clauses (but not necessarily all). Most complete algorithms for backbone-computation detect that l is a backbone by issuing a SAT call on the formula {a mathematical formula}Fl=F∧(¬l). Since l is a backbone, {a mathematical formula}Fl is unsatisfiable. Now let {a mathematical formula}R′⊆Fl be an unsatisfiable core of {a mathematical formula}Fl (see Section 2.2 for description of unsatisfiable cores). Since {a mathematical formula}R′ is unsatisfiable, it holds that {a mathematical formula}R′∖{¬l}⊨l. Hence, {a mathematical formula}R=R′∖{¬l} provides us with a reason for why l is a backbone at which point we can remove all clauses that contain l and are not in {a mathematical formula}R.
     </paragraph>
     <paragraph>
      A variety of techniques exist to speed up backbone computation [71]. A number of these techniques enable us to filter out literals that are certainly not backbone literals. An example of such technique is the filtering of all literals that are false in some model of {a mathematical formula}F. Such techniques can be added to our redundancy pruning algorithm. However, we should note that there is one technique that is not in general sound. If a literal l is a backbone literal, adding this literal as a unit clause to {a mathematical formula}F does not change the models of {a mathematical formula}F. Hence, whenever a backbone-computation algorithm detects that l is a backbone, it adds it to {a mathematical formula}F, which will help future SAT calls. In redundancy pruning, however, this is not sound because the newly added clause l is not part of the original formula. For instance, for the formula {a mathematical formula}(x∨y)∧(x∨¬y)∧(¬x∨y) we may detect that x is a backbone literal. Adding x to the formula enables us to derive that y is a backbone literal with the reason {a mathematical formula}(x)∧(¬x∨y). This would enable us marking the clause {a mathematical formula}x∨y as redundant.
     </paragraph>
     <paragraph>
      We should stress that the above described pruning algorithm is not complete. For instance, the formula {a mathematical formula}(x∨y)∧(x∨y∨z) is redundant but has an empty backbone. Further, the technique is highly dependent on the size of the cores that will be returned by the SAT solver. If, for instance, the reason {a mathematical formula}R is the whole formula {a mathematical formula}F, no clauses will be pruned. Nevertheless, backbone-based pruning is likely to be a method cheaper than complete MES computation because the number of a SAT calls is proportional to the total number of variables rather than clauses. Hence, it can be used as an MES approximation technique or as a preprocessing step to a complete algorithm.
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Certification of correctness
     </section-title>
     <paragraph>
      In some applications, it is paramount to guarantee that the computed subformula is indeed irredundant and, possibly more importantly, that each computed irredundant subformula {a mathematical formula}E is equivalent to the original CNF formula {a mathematical formula}F. For such applications, it is useful to protect the user from possible bugs in the reduction algorithm by independent certification.
     </paragraph>
     <paragraph>
      Given a computed CNF formula {a mathematical formula}E, it is simple to validate whether it is irredundant. Essentially, one can run one of the algorithms outlined in earlier sections. The problem of validating whether {a mathematical formula}E≡F looks more challenging.
     </paragraph>
     <paragraph>
      To check whether {a mathematical formula}E≡F, it suffices to exhibit a truth assignment that is a model of one formula and not of the other. This condition corresponds to testing the satisfiability of the following CNF formula:{a mathematical formula} Clearly, the resulting instances of SAT are expected to be hard to solve, given the disjunction and the negation of formulas in (2). Nevertheless, it is also the case that {a mathematical formula}E⊆F and so, {a mathematical formula}F⊨E. Hence it is only necessary to check whether {a mathematical formula}E⊨F. Since {a mathematical formula}F=E∧R, {a mathematical formula}E⊨F can be represented as {a mathematical formula}E⊨E∧R, or equivalently, {a mathematical formula}E∧(¬E∨¬R)⊨⊥, which simplifies to {a mathematical formula}E∧¬R⊨⊥. This condition corresponds to testing the satisfiability of the following CNF formula:{a mathematical formula} If {a mathematical formula}E∪CNF(¬R) has a model, then one can satisfy {a mathematical formula}E while unsatisfying one or more clauses in {a mathematical formula}R. Hence, the two formulas would not be equivalent.
     </paragraph>
     <paragraph>
      Although easier than (2), (3) can still result in hard instances of SAT (similarly to what happens with the reduction of MES to group-MUS extraction). A technique to reduce the complexity of the resulting instances of SAT is to partition {a mathematical formula}R into chunks, and check each chunk separately for equivalence. The objective is to check whether {a mathematical formula}E⊨R. If this condition holds, then {a mathematical formula}E≡F; otherwise {a mathematical formula}E≢F. If {a mathematical formula}R is partitioned into a number of subformulas (or chunks), we get {a mathematical formula}R=R1∧…∧Rk, and so the condition becomes, {a mathematical formula}E⊨R1∧…∧Rk, that can also be represented as {a mathematical formula}E∧(¬R1∨…∨¬Rk)⊨⊥. This condition holds if and only if, {a mathematical formula}∀1≤j≤kE∧¬Rj⊨⊥. Hence, the use of chunks allows splitting a potentially hard (and believed unsatisfiable) instance of SAT, into k (likely) easier (and also believed unsatisfiable) instances of SAT.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Extension to group-MES computation
     </section-title>
     <paragraph>
      The MES computation and certification algorithms presented in the previous sections can be extended to the computation of group-oriented MESes of CNF formulas, defined as follows.
     </paragraph>
     <paragraph label="Definition 7">
      Group-oriented MESGiven an explicitly partitioned CNF formula {a mathematical formula}F=D∪G1∪…∪Gn (a group-CNF formula), a group oriented MES (or, group-MES) of {a mathematical formula}F is a subset {a mathematical formula}F′=D∪Gi1∪…∪Gik of {a mathematical formula}F (with {a mathematical formula}1≤ij≤n for {a mathematical formula}1≤j≤k≤n) such that {a mathematical formula}F≡F′, and for every {a mathematical formula}1≤j≤k, {a mathematical formula}F≢F′∖Gij.
     </paragraph>
     <paragraph>
      Recall that the first set of MES computation algorithms presented in this paper are based on the conversion of MUS computation algorithms to MES computation via the definition of witness of equivalence (Definition 5). To adopt this set of algorithms to group-MES setting, we extend this definition to the group CNF setting in the following manner.
     </paragraph>
     <paragraph label="Definition 8">
      Witness of equivalence (group CNF)Let {a mathematical formula}F=D∪G1∪…∪Gn be a group-CNF formula, and let {a mathematical formula}S=D∪Gi1∪…∪Gik be a subformula of {a mathematical formula}F, with {a mathematical formula}S⊊F and {a mathematical formula}S⊭F∖S, and let {a mathematical formula}G⊆F∖S be one of the groups of {a mathematical formula}F. If {a mathematical formula}S∪G⊨F∖(S∪G), then {a mathematical formula}G is a witness of {a mathematical formula}S∪G≡F.
     </paragraph>
     <paragraph>
      Then, the algorithms from Section 3.1 are extended to group-MES setting by changing the “granularity” from clause-based to group-based. As an illustrative example, consider the pseudo-code of the deletion-based group-MES extraction algorithm presented in Algorithm 5 and contrast it with the deletion-based algorithm for plain MES computation problem (Algorithm 1). As with the previously described algorithms, the CNF representation of the formula {a mathematical formula}¬G is constructed as Section 2.
     </paragraph>
     <paragraph>
      Model rotation can be extended to group-MES setting via the following generalization of Proposition 1:
     </paragraph>
     <paragraph label="Proposition 6">
      Let{a mathematical formula}F=D∪G1∪…∪Gnbe a group-CNF formula. A group{a mathematical formula}Gi∈Fis irredundant in{a mathematical formula}F(i.e.{a mathematical formula}F∖Gi⊨Gi) if and only if there exists a truth assignment μ, such that{a mathematical formula}(F∖Gi)[μ]=1and{a mathematical formula}Gi[μ]=0, i.e. there exists a clause{a mathematical formula}c∈Gisuch that{a mathematical formula}c[μ]=0.
     </paragraph>
     <paragraph>
      As it is the case with the application of model rotation in the group-MUS setting, the algorithm must be adjusted so that it constructs new assignments that satisfy all clauses of the currently falsified group, and the group {a mathematical formula}D.
     </paragraph>
     <paragraph>
      The MES computation algorithms based on the reduction to group-MUS problem (see Section 3.3) can also be extended to the group-MES setting. Noteworthy is the fact that the don't care group {a mathematical formula}D=CNF(¬F) used in Proposition 2 to construct the group-CNF formula {a mathematical formula}RF(E) from a subformula {a mathematical formula}E⊆F does not need to include the negation of the don't care group on the formula used as an input to the group-MES computation problem. The following proposition provides the necessary details.
     </paragraph>
     <paragraph label="Proof">
      Group-MES to group-MUS reductionLet{a mathematical formula}F=D∪G1∪…∪Gnbe a group-CNF formula, and let{a mathematical formula}E=D∪Gi1∪…∪Gikbe a subformula of{a mathematical formula}F(possibly{a mathematical formula}Fitself). Let{a mathematical formula}RF(E)be the group-CNF formula{a mathematical formula}D⁎∪Gi1∪…∪Gik, where{a mathematical formula}D⁎=D∪CNF(¬(F∖D))is the don't care group. Then,{a mathematical formula}Eis a group-MES of{a mathematical formula}Fif and only if{a mathematical formula}RF(E)is a group-MUS of{a mathematical formula}RF(F). Notice that in plain-MES setting, the don't care group {a mathematical formula}D of the formula {a mathematical formula}F is empty, and so the don't care group {a mathematical formula}D⁎ of the formula {a mathematical formula}RF(E) is exactly the formula {a mathematical formula}CNF(¬F), as in Proposition 2. Thus, Proposition 7 is the extension of Proposition 2 to the group-MES setting. First, we show that {a mathematical formula}E⊨F if and only if the formula {a mathematical formula}RF(E) is unsatisfiable. Note that {a mathematical formula}E≡F directly follows as {a mathematical formula}F⊨E holds trivially since {a mathematical formula}E⊆F. {a mathematical formula}E⊨F if and only {a mathematical formula}E∧¬F is unsatisfiable. We have, {a mathematical formula}E∧¬F≡E∧¬(D∧(F∖D))≡(E∧¬D)∨(E∧¬(F∖D)). Since {a mathematical formula}D⊆E the first disjunct is unsatisfiable, and so {a mathematical formula}E∧¬F≡E∧¬(F∖D), and the latter formula is equisatisfiable with {a mathematical formula}RF(E).Let now, {a mathematical formula}Gi be any group of {a mathematical formula}E. Then, by Proposition 6, {a mathematical formula}Gi is irredundant in {a mathematical formula}E if and only if there exists an assignment μ, such that {a mathematical formula}(E∖Gi)[μ]=1 and {a mathematical formula}Gi[μ]=0. Since {a mathematical formula}D⊆(E∖Gi), we have {a mathematical formula}D[μ]=1, and since {a mathematical formula}Gi⊆(F∖D), {a mathematical formula}(F∖D)[μ]=0 and so for an extension {a mathematical formula}μ′ of μ, {a mathematical formula}CNF(¬(F∖D))[μ′]=1. Thus, {a mathematical formula}D⁎[μ′]=1, and so {a mathematical formula}RF(E∖Gi) is satisfiable. The “if” direction is shown by following the above steps in reverse order. □
     </paragraph>
     <paragraph>
      Proposition 3, Proposition 4, which are used to develop the group-MUS based MES extraction algorithm with chunks (Algorithm 4), can be extended to the group-MES setting analogously. We omit the cumbersome details.
     </paragraph>
    </section>
    <section label="7">
     <section-title>
      Experimental results
     </section-title>
     <paragraph>
      The algorithms described in the previous sections were implemented within the MUS extraction framework of a state-of-the-art MUS extractor MUSer2{sup:2}; the framework was configured to use SAT solver picosat-935[39] in the incremental mode. The experiments were performed on an HPC cluster, where each node is dual quad-core Intel Xeon E5450 3 GHz with 32 GB of memory. Each algorithm was run with a timeout of 1800 seconds and a memory limit of 4 GB per input instance. To evaluate the algorithms, we selected 300 problem instances from practical application domains of SAT used in past SAT competitions.{sup:3} The instances were selected using the following criteria: the instance is solvable within 1 second by picosat-935, and the number of clauses in the instance is less than 100,000. These criteria were derived from the worst-case analysis of deletion-based MES algorithms (whereby the number of SAT calls is linear in the size of the input formula) and our previous experience with the effects various optimization techniques in the context of MUS extraction.
     </paragraph>
     <paragraph>
      We will refer to the evaluated algorithms using the following abbreviations: DEL represents the implementation of the deletion-based algorithm (Algorithm 1); INS (resp. DICH) is the implementation of insertion-based (resp. dichotomic) algorithms from Section 3.1; +MR indicates the addition of model rotation, while +IMR indicates the addition of the improved version of model rotation (see Section 3.2); GRP-MUS is the implementation of the reduction of MES to group-MUS from Section 3.3; CHUNK-x is the implementation of the deletion-based chunked group-oriented MUS algorithm from Section 3.3 with chunk size x; VBS refers to a virtual best solver{sup:4} — the composition of the VBS will be described when appropriate.
     </paragraph>
     <section label="7.1">
      <section-title>
       Evaluation of algorithms' performance, and their performance profile
      </section-title>
      <paragraph>
       The cactus plot{sup:5} in Fig. 2 provides an overview of the performance of the algorithms discussed in this paper.
      </paragraph>
      <paragraph>
       A number of conclusions can be drawn from the plot in Fig. 2. First, we note that the improvements to the plain deletion-based algorithm (DEL) suggested in Section 3.1, namely the addition of model rotation (DEL+MR) and the improved model rotation (DEL+IMR), have a very significant positive effect on the performance of the algorithm; also observe that the improved model rotation provides a notable boost over model rotation. Further, it is clear that the insertion-based and the dichotomic algorithms, even with the addition of IMR, do not scale. As a side note, the gap between the performance of these and the deletion-based algorithm in the MES setting is significantly larger than that in the MUS setting (see for example [23]) — this is due to the addition of the negation of the working formula, which is unavoidable in the MES setting. We also observe the weak performance of the GRP-MUS approach — this is not surprising, since for large formulas, GRP-MUS can produce hard instances of SAT; this deficiency, in fact, was the motivation for the chunked approach. While DEL+IMR is among the best performing algorithms, on most of the instances it is significantly outperformed by the chunked group-oriented MUS algorithm with chunk size 1000. However, CHUNK-1000 loses to DEL+IMR on some of the hard instances — increasing the chunk size to 4000 pushes the performance of the algorithm ahead, however a further increase of chunk size to 8000 begins to affect the performance negatively. The VBS in Fig. 2 is constructed from DEL+IMR, GRP-MUS, CHUNK-1000 and CHUNK-4000. The former two are taken because they represent the extremes of the chunked approach — chunks of size 1 for DEL+IMR and a single chunk of the size of the input formula for GRP-MUS. The fact that the results for the VBS configuration (285 solved instances) are clearly superior to any of the individual algorithms indicates that the proposed algorithms are highly complementary, and are suitable for a multi-core/portfolio implementation. We stress that the plain deletion-based DEL is, to our knowledge, the current published state-of-the-art in MES computation, and so the algorithms proposed in this paper constitute a significant advancement, with the best algorithms solving more than twice the number of instances within the timeout.
      </paragraph>
      <paragraph>
       The scatter plots in Fig. 3 provide additional insights into the performance of some of the algorithms. The color code indicates the amount of redundant clauses in the formulas: yellow (lighter) indicates close to 100% redundant clauses, whereas blue (darker) indicates less than 20% redundant clauses.
      </paragraph>
      <paragraph>
       The top-left plot (DEL vs. DEL+IMR) demonstrates the impact of improved model rotation (IMR) on the performance of the deletion-based approach. We note that while IMR allows to solve significantly more instances (263 vs. 144 — see Fig. 2), the technique has little impact on many highly redundant instances (yellow). This behavior is expected as IMR can only help to detect irredundant clauses, and it was the motivation for the development of the group-MUS approach. The top-right plot of Fig. 3 (GRP-MUS vs. DEL+IMR) demonstrates the effectiveness of the group-MUS approach on the highly redundant instances. The plot clearly shows that the direct and the group-MUS approaches are complementary — the former excels on mostly irredundant instances, while the latter is best on highly redundant ones. This observation provides additional, empirical, justification for the development of the chunked group-oriented MUS algorithm. The bottom-left plot (CHUNK-1000 vs. DEL+IMR) confirms the effectiveness of the chunked approach — observe the significant performance improvements on instances with diverse degrees of redundancy. Finally, the plot on the bottom-right (CHUNK-1000 vs. CHUNK-4000) demonstrates that even though the increase of chunk size from 1000 to 4000 affects the performance negatively on most instances, it is essential for handling difficult, highly redundant, problems.
      </paragraph>
     </section>
     <section label="7.2">
      <section-title>
       Evaluation of backbone-based pruning
      </section-title>
      <paragraph>
       The backbone-based pruning algorithm (see Section 4) was implemented as a stand-alone preprocessor on top of the SAT solver Minisat 2.2[40]. To evaluate the effectiveness of pruning, we ran the preprocessor on the 300 selected instances (with 1800 seconds CPU time limit, and 4 GB memory limit), and re-run the experiments described in Section 7.1 on the pruned instances, treating any instance for which the total CPU time of preprocessing and MES extraction exceeded 1800 seconds as a time-out.
      </paragraph>
      <paragraph>
       The left-hand side plot on the top of Fig. 4 shows a cumulative histogram of a percentage of redundant clauses removed during the preprocessing. The plot demonstrates that despite the fact that the backbone-based pruning technique is incomplete and highly dependent on the quality of the unsatisfiable cores returned by the SAT solver, on the selected instances it is very effective: only on 20 instances out of 300, the pruning removed less than 50% of redundant clauses. Furthermore, on close to 250 instances, the technique removed 70% or more of redundant clauses, and, in some cases, eliminated the redundant clauses entirely. The plot on the top-right-hand side of Fig. 4 shows that the preprocessing is not only effective, but also very fast: all non-timed-out instances were preprocessed in under 400 seconds, with the vast majority under 100 seconds. In fact, among the 300 instances, the preprocessor timed out on a single instance only. In addition, the pruning technique appears to be very robust — this is witnessed by the fact that even on the instances with a low degree of redundancy (points with blue/dark color), the preprocessing often succeeds to remove over 60% of redundant clauses.
      </paragraph>
      <paragraph>
       Recall from Section 3.4 that the chunking MES computation algorithm is designed to strike a balance between the deletion-based approach, that performs well on instances with few redundant clauses, and the group-MUS based algorithm, geared towards the instances with high degree of redundancy. Given that on the instances selected for our experiments the backbone-based pruning succeeds to remove a large amount of redundant clauses, it comes as no surprise that the relative effectiveness of the chunking approach, compared to the deletion-based approach, diminishes — this is demonstrated by the scatter plot on the bottom-left of Fig. 4, as well as by the data in Table 1. Note that the degree of redundancy of the instances (represented by the color of points) in this plot is the degree of redundancy in the pruned instances. Even though the CHUNK-1000 algorithm succeeds to solve 4 more instances within the timeout, on most of the (pruned) instances DEL+IMR is significantly faster. The bottom-right plot of Fig. 4 demonstrates the impact of the backbone-based pruning on the overall runtime of MES extraction. The results clearly show that, at least on the instances selected for our experiments, the technique is very effective. This is particularly the case on many instances with a high degree of redundancy (yellow/light points). Although the technique might not be as effective on other classes of problems, given the fact that it is relatively inexpensive (see top-right plot of Fig. 4), it should be included in any MES computation flow.
      </paragraph>
     </section>
     <section label="7.3">
      <section-title>
       Degree of redundancy in the selected benchmarks
      </section-title>
      <paragraph>
       The scatter plot in Fig. 5 presents the cumulative histogram of the degree of redundancy in the problem instances used in our experiments.
      </paragraph>
      <paragraph>
       Note that the instances were selected from the SAT competition benchmark sets prior to the experiments, and so the selection was not biased by the degree of redundancy. Nevertheless, approximately 2/3 of the instances have between 20% and 50% redundant clauses, the remaining instances have over 50% redundant clauses, and close to 5% of the instances have in excess of 90% redundant clauses. We conclude that problem instances from practical applications may exhibit very significant levels of redundancy.
      </paragraph>
     </section>
    </section>
   </content>
  </root>
 </body>
</html>