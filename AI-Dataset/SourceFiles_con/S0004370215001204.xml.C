<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    The complexity of reasoning with FODD and GFODD.
   </title>
   <abstract>
    Recent work introduced Generalized First Order Decision Diagrams (GFODD) as a knowledge representation language that is useful in mechanizing decision theoretic planning in relational domains. GFODDs generalize function-free first order logic and include numerical values and numerical generalizations of existential and universal quantification. Previous work presented heuristic inference algorithms for GFODDs and implemented these heuristics in systems for decision theoretic planning. In this paper, we study the complexity of the computational problems addressed by such implementations. In particular, we study the evaluation problem, the satisfiability problem, and the equivalence problem for GFODDs under the assumption that the size of the intended model is given with the problem, a restriction that guarantees decidability. Our results provide a complete characterization placing these problems within the polynomial hierarchy. The same characterization applies to the corresponding restriction of problems in first order logic, giving an interesting new avenue for efficient inference when the number of objects is bounded. Our results show that for Σk formulas, and for corresponding GFODDs, evaluation and satisfiability are ΣkP complete, and equivalence is Πk+1P complete. For Πk formulas evaluation is ΠkP complete, satisfiability is one level higher and is Σk+1P complete, and equivalence is Πk+1P complete.
   </abstract>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The complexity of inference in first order logic has been investigated intensively. It is well known that the problem is undecidable, and that this holds even with strong restrictions on the types and number of predicates allowed in the logical language. For example, the problem is undecidable for quantifier prefix {a mathematical formula}∀2∃⁎ with a signature having a single binary predicate and equality [8]. Unfortunately, the problem is also undecidable if we restrict attention to satisfiability under finite structures [6], [24]. Thus, in either case, one cannot quantify the relative difficulty of problems without further specialization or assumptions. On the other hand, algorithmic progress in AI has made it possible to reason efficiently in some cases. In this paper we study such problems under the additional restriction that an upper bound on the intended model size is given explicitly. This restriction is natural for many applications, where the number of objects is either known in advance or known to be bounded by some quantity. Since the inference problem is decidable under this restriction, we can provide a more detailed complexity analysis.
     </paragraph>
     <paragraph>
      This paper is motivated by recent work on decision diagrams, known as FODDs and GFODDs, and the computational questions associated with them. Binary decision diagrams [3], [1] provide a successful representation language capturing functions over propositional variables, that allows for efficient manipulation and composition of functions, and diagrams have been used in various applications in program verification and AI [3], [1], [11]. Motivated by this success, several authors have attempted generalizations to handle relational structure and first order quantification [9], [33], [30], [16]. In particular FODDs [33] and their generalization GFODDs [16] have been introduced and shown to be useful in the context of decision theoretic planning [2], [20], [12], [13] for problems with relational structure [15], [17].
     </paragraph>
     <paragraph>
      GFODDs can be seen to generalize the function-free portion of first order logic (i.e., signatures with constants but without higher arity functions) to allow for non-binary numerical values generalizing truth values, and for numerical quantifiers generalizing existential and universal quantification in logic. Efficient heuristic inference algorithms for such diagrams have been developed focusing on the finite model case, and using the notion of “reasoning from examples” [22], [23], [21]. This paper analyzes the complexity of the evaluation, satisfiability, and equivalence problems for such diagrams, focusing on the GFODD subset with min and max aggregation that are defined in the next section. To avoid undecidability and get a more refined classification of complexity, we study a restricted form of the problem where the finite size of the intended model is given as part of the input to the problem. As we argue below, this is natural and relevant in the applications of GFODDs for solving decision theoretic control problems. The same restrictions can be used for the corresponding (evaluation, satisfiability and equivalence) problems in first order logic, but to our knowledge this has not been studied before. We provide a complete characterization of the complexity showing an interesting structure. Our results are developed for the GFODD representation and require detailed arguments about the graphical representation of formulas in that language. The same lines of argument (with simpler proof details) yield similar results for first order logic. To translate our results to the language of logic, consider the quantifier prefix of a first order logic formula using the standard notation using {a mathematical formula}Σk, {a mathematical formula}Πk to denote alternation depth of quantifiers in the formula. With this translation, our results show that:
     </paragraph>
     <paragraph>
      (1) Evaluation over finite structures spans the polynomial hierarchy, that is, evaluation of {a mathematical formula}Σk formulas is {a mathematical formula}ΣkP complete, and evaluation of {a mathematical formula}Πk formulas is {a mathematical formula}ΠkP complete.
     </paragraph>
     <paragraph>
      (2) Satisfiability, with a given bound on model size, follows a different pattern: satisfiability of {a mathematical formula}Σk formulas is {a mathematical formula}ΣkP complete, and satisfiability of {a mathematical formula}Πk formulas is {a mathematical formula}Σk+1P complete.
     </paragraph>
     <paragraph>
      (3) Equivalence, under the set of models bounded by a given size, depends only on quantifier depth: both the equivalence of {a mathematical formula}Σk formulas and equivalence of {a mathematical formula}Πk formulas are {a mathematical formula}Πk+1P complete.
     </paragraph>
     <paragraph>
      The positive results allow for constants in the signature but the hardness results, except for satisfiability for {a mathematical formula}Π1 formulas, hold even without constants. For signatures without constants, satisfiability of {a mathematical formula}Π1 formulas is in NP; when constants are allowed, it is {a mathematical formula}Σ2P complete as in the general template.
     </paragraph>
     <paragraph>
      These results are useful in that they clearly characterize the complexity of the problems solved heuristically by implementations of GFODD systems [15], [17] and can be used to partly motivate or justify the use of these heuristics. For example, the “model checking reductions” of [16] that simplify the structure of diagrams replace equivalence tests with model evaluation on a “representative” set of models. When this set is chosen heuristically, as in [15], this leads to inference that is correct with respect to these models but otherwise incomplete. Our results show that this indeed leads to a reduction of the complexity of the inference problem, so that the loss in accuracy is traded for improved worst case run time. Importantly, it shows that without compromising correctness, the complexity of equivalence tests that are used to compress the representation will be higher. These issues and further questions for future work are discussed in the concluding section of the paper.
     </paragraph>
     <paragraph>
      The rest of the paper is organized as follows. The next section defines FODDs and GFODDs and provides a more detailed motivation for the technical questions. Section 3 then develops the results for FODDs. We treat the FODD case separately for three reasons. First, this serves for an easy introduction into the results that avoids some of the more involved arguments that are required for GFODDs. Second, as will become clear, for FODDs we do not need the additional assumption on model size, so that the results are in a sense stronger. Finally, some of the proofs for GFODDs require alternation depth of at least two so that separate proofs are needed for FODDs in any case. Section 4 develops the results for GFODDs. The final section concludes with a discussion and directions for future work.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      FODDs and GFODDs and their computational problems
     </section-title>
     <paragraph>
      This section introduces the GFODD representation language and associated computational problems, and explains how they are motivated by prior work on applying GFODDs in decision theoretic planning. We assume familiarity with basic concepts and notation in predicate logic [25], [29], [4] as well as basic notions from complexity theory [14], [32], [26].
     </paragraph>
     <paragraph>
      Decision diagrams are similar to expressions in first order logic (FOL). They are defined relative to a relational signature, with a finite set of predicates {a mathematical formula}p1,p2,…,pn each with an associated arity (number of arguments), a countable set of variables {a mathematical formula}x1,x2,…, and a set of constants {a mathematical formula}c1,c2,…,cm. We do not allow function symbols other than constants (that is, functions with arity ≥1). In addition, we assume that the arity of predicates is bounded by some numerical constant. A term is a variable or constant and an atom is either an equality between two terms or a predicate with an appropriate list of terms as arguments. Intuitively, a term refers to an object in the world of interest and an atom is a property which is either true or false.
     </paragraph>
     <paragraph>
      To motivate the diagram representation consider first a simpler language of generalized expressions which we illustrate informally by some examples. In FOL we can consider open formulas that have unbound variables. For example, the atom {a mathematical formula}color(x,y) is such a formula and its truth value depends on the assignment of x and y to objects in the world. To simplify the discussion, we assume for this example that arguments are typed and x ranges over “objects” and y over “colors”. We can then quantify over these variables to get a sentence which will be evaluated to a truth value in any concrete possible world. For example, we can write {a mathematical formula}∃y,∀x,color(x,y) expressing the statement that there is a color associated with all objects. Generalized expressions allow for more general open formulas that evaluate to numerical values. For example, {a mathematical formula}E1=[if color(x,y) then 1 else 0] is similar to the logical expression and {a mathematical formula}E2=[if color(x,y) then 0.3 else 0.5] returns non-binary values. Quantifiers from logic are replaced with aggregation operators that combine numerical values and provide a generalization of the logical constructs. In particular, when the open formula is restricted to values 0 and 1, the operators max and min simulate existential and universal quantification. Thus, {a mathematical formula}[maxy⁡,minx⁡,if color(x,y) then 1 else 0] is equivalent to the logical sentence {a mathematical formula}∃y,∀x,color(x,y) given above. But we can allow for other types of aggregations. For example, {a mathematical formula}[maxy⁡,sumx,if color(x,y) then 1 else 0] evaluates to the largest number of objects associated with one color, and the expression {a mathematical formula}[sumx,miny⁡,if color(x,y) then 0 else 1] evaluates to the number of objects that have no color association. GFODDs are also related to work in statistical relational learning [28], [27], [5]. For example, if the expression {a mathematical formula}E2 captures probability of ground facts for the predicate {a mathematical formula}color() and the ground facts are mutually independent then {a mathematical formula}[productx,producty,if color(x,y) then 0.3 else 0.5] captures the joint probability of all facts for {a mathematical formula}color(). Of course, the open formulas in logic can include more than one atom and similarly expressions can be more involved. In this manner, a generalized expression represents a function from possible worlds to numerical values. GFODDs capture the same set of functions but provide an alternative representation for the open formulas through directed graphs. GFODDs were introduced together with a set of operations that can be used to manipulate and combine functions and in this way provide a tool for computation with numerical functions over possible worlds. Prior work includes implementation of the FODD fragment where the only aggregation operator allowed is max [17], [15] and more recently implementations for GFODDs with max and average aggregations [19], [18]. In this paper we investigate several computational questions for GFODDs with min and max aggregation.
     </paragraph>
     <section label="2.1">
      <section-title>
       Syntax
      </section-title>
      <paragraph>
       First order decision diagrams (FODD) and their generalization (GFODD) were defined by [33], [16] inspired by previous work in [9]. GFODDs are composed of two parts, including the aggregation functions and the open formula portion which is captured by a diagram or graph. The aggregation portion is given by a listing of the variables in the diagram in some explicit order {a mathematical formula}(wi1,…,wim) and a corresponding list of length m specifying aggregation over each {a mathematical formula}wij. In this paper we restrict aggregation operators for each variable to be min or max. To reflect the structure of GFODDs, and distinguish between aggregation list V and the graph portion of a diagram B, we sometimes denote a GFODD by {a mathematical formula}〈V,B〉. For example, in the expression {a mathematical formula}[maxy⁡,minx⁡,if color(x,y) then 1 else 0], V corresponds to {a mathematical formula}[maxy⁡,minx⁡] and B corresponds to {a mathematical formula}[if color(x,y) then 1 else 0]. However, when clear from the context we use B as a shorthand for {a mathematical formula}〈V,B〉. FODDs are a special case of GFODDs where the aggregation function is max for all variables. Due to associativity and commutativity of max, the aggregation function for FODDs does not need to be represented explicitly.
      </paragraph>
      <paragraph>
       As in propositional decision diagrams [3], [1], the diagram portion is a rooted acyclic graph with directed edges. Each node in the graph is labeled. A non-leaf node is labeled with an atom from the signature and it has exactly two outgoing edges. The directed edges correspond to the truth values of the node's atom. A leaf is labeled with a non-negative numerical value. We sometimes restrict diagrams to have only binary leaves with values 0 or 1. In this case we can consider the values to be the logical values false and true. An example diagram is shown in Fig. 1. In this diagram and all other diagrams in this paper, left going edges denote the true branch out of a node and right going edges represent the false branch.
      </paragraph>
      <paragraph>
       Similar to the propositional case [3], [1], GFODD syntax is restricted to comply with a predefined total order on atoms. In the propositional case the ordering constraint yields a normal form (a unique minimal representation for each function) which is in turn the main source of efficient reasoning. For GFODDs, a normal form has not been established but the use of ordering makes for more efficient simplification of diagrams. In particular, following [33], we assume a fixed ordering on predicate names, e.g., {a mathematical formula}p1≺p2≺…≺pn, and a fixed ordering on variable names, e.g., {a mathematical formula}x1≺x2≺… and constants {a mathematical formula}c1≺c2≺…cm and require that {a mathematical formula}ci≺xj for all i and j. The order is extended to atoms by considering them as lists. That is, {a mathematical formula}pi(…)≺pj(…) if {a mathematical formula}i&lt;j and {a mathematical formula}pi(xk1,…,xka)≺pi(xk1′,…,xka′) if {a mathematical formula}(xk1,…,xka)≺(xk1′,…,xka′) in the lexicographic ordering over lists. Node labels in the GFODD must obey this order so that if node a is above node b in the diagram then the labels satisfy {a mathematical formula}a≺b. The example of Fig. 1 is ordered with predicate ordering {a mathematical formula}E≺“=” and lexicographic variable ordering {a mathematical formula}v1≺v2≺v3.
      </paragraph>
      <paragraph>
       The ordering assumption is helpful when constructing systems using GFODDs because it simplifies the computations. Our complexity results hold in general, whether the assumption holds or not, therefore showing that while the assumption is convenient it does not fundamentally change the complexity of the problems. In particular, for the positive results, the algorithms showing membership in various complexity classes hold even in the more general case when the diagrams are not sorted. For the hardness results, the reductions developed hold even in the more restricted case when the diagrams are sorted. A significant amount of details in our analysis is devoted to handling ordering issues in hardness results.
      </paragraph>
      <paragraph>
       Our complexity analysis will use the following classification of GFODD into subclasses. We say that a GFODD is a max-k-alternating GFODD if its set of aggregation operators has k blocks of aggregation operators, where the first includes max aggregation, the second includes min aggregation, and so on. We similarly define min-k-alternating GFODD where the first block has min aggregation operators. A GFODD has aggregation depth k if it is in one of these two classes. As mentioned above, FODD is the class of max-1-alternating GFODD. We also refer to min-1-alternating GFODD as min GFODD.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Semantics
      </section-title>
      <paragraph>
       Diagrams, like first order formulas, are evaluated in possible worlds that provide an interpretation of their symbols.{sup:1} In particular, a possible world or Interpretation, I, specifies a domain of objects, an assignment of each constant in the signature to an object in the domain, and the truth values of predicates over these objects.
      </paragraph>
      <paragraph>
       The semantics assigns a value, denoted {a mathematical formula}MAPB(I), for any diagram B on any interpretation I by considering all possible valuations. A variable valuation ζ is a mapping from the set of variables in B to domain elements in the interpretation I. This mapping assigns each node label to a concrete (“ground”) atom in the interpretation and therefore to its truth value and in this way defines a single path from the root to a leaf. The value of this leaf is the value of the GFODD B under the interpretation, I, with variable valuation ζ and is denoted {a mathematical formula}MAPB(I,ζ). The final value, {a mathematical formula}MAPB(I), is defined by aggregating over {a mathematical formula}MAPB(I,ζ). In particular, considering the aggregation order {a mathematical formula}(wi1,…,wim) we loop with j taking values from m to 1 aggregating values over {a mathematical formula}wij using its aggregation operator. We denote this by {a mathematical formula}MAPB(I)=AGζMAPB(I,ζ) where for the special case of FODDs this yields {a mathematical formula}MAPB(I)=maxζ⁡MAPB(I,ζ).
      </paragraph>
      <paragraph>
       Consider evaluating the FODD example in Fig. 1 on interpretation {a mathematical formula}I=([1,2,3],{E(1,3),E(3,1),E(1,2),E(2,1)}). Then for {a mathematical formula}ζ={v1/1,v2/2,v3/3} we have {a mathematical formula}MAPB(I,ζ)=0 but for {a mathematical formula}ζ={v1/3,v2/1,v3/2} we have {a mathematical formula}MAPB(I,ζ)=1 and therefore {a mathematical formula}MAPB(I)=maxζ⁡MAPB(I,ζ)=1.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Computations with GFODDs
      </section-title>
      <paragraph>
       The GFODD representation language was introduced as a tool for mechanizing and solving decision problems given by structured Markov Decision Processes (MDP), also known as Relational MDP or First Order MDP. A detailed exposition is beyond the scope of this paper (see [33], [16]). This section provides some necessary technical details and some background to motivate the computational problems investigated in the paper. In this context, a planning problem world state can be described using an interpretation providing the objects in the world and the relations among them. An action moves the world from one state to another, where in MDPs this transition is non-deterministic. The so-called Q function {a mathematical formula}Q(s,a) provides a quality estimate of each action a in each state s. Using this function, one can control the MDP by picking {a mathematical formula}a=argmaxaQ(s,a) in state s. There are several algorithms to calculate such Q functions and previous work has introduced GFODDs as a compact representation for these functions. This is done, for example, by implementing a symbolic version of the well known Value Iteration (VI) algorithm, where the symbolic algorithm operates by manipulating GFODDs. Action selection provides our first computational question, that is, evaluating {a mathematical formula}Q(s,a). In our context, this means calculating {a mathematical formula}MAPB(I) where I captures s and a and B is the representation of the Q function. The same computational problem occurs in several other steps in the symbolic VI algorithm. We define this problem below as GFODD Evaluation.
      </paragraph>
      <paragraph>
       Recall that a GFODD represents a function from interpretations to real values. One of the main operations required for the symbolic VI algorithm is combination of such functions. In particular, let {a mathematical formula}f1 and {a mathematical formula}f2 be functions represented by two GFODDs, and let ⊙ be any binary operation over real values (e.g., addition). The combination operation returns a GFODD representing a function {a mathematical formula}f3 such that for all I we have {a mathematical formula}f3(I)=f1(I)⊙f2(I). That is, {a mathematical formula}f3 is a symbolic representation of the pointwise operation over function values of {a mathematical formula}f1 and {a mathematical formula}f2. Note that since {a mathematical formula}f1 and {a mathematical formula}f2 are closed expressions we can standardize apart their variables before taking this operation.
      </paragraph>
      <paragraph>
       Fig. 2 shows how to combine the diagram portions (i.e., the open expressions) in a semantically coherent manner using the Apply procedure of [33]. The following theorem identifies conditions for correctness of Apply when used with closed expressions. We say that a binary operation ⊙ is safe with respect to aggregation operator agg if it distributes with respect to it, that is {a mathematical formula}b⊙agg{a1,a2,…,an}=agg{(a1⊙b),(a2⊙b),…,(an⊙b)}. A list of safe pairs of binary operations and aggregation operators was provided by [16]. For the arguments of this paper we recall that the binary operations + and ∧ are safe with respect to max and min aggregation. For example {a mathematical formula}5+max⁡{1,2,3,4}=max⁡{6,7,8,9}. With this definition we have:
      </paragraph>
      <paragraph label="Theorem 1">
       (See Theorem 4 of[16].) Let{a mathematical formula}B1=〈V1,D1〉and{a mathematical formula}B2=〈V2,D2〉be GFODDs that do not share any variables and assume that{a mathematical formula}opcis safe with respect to all operators in{a mathematical formula}V1and{a mathematical formula}V2. Let{a mathematical formula}D=Apply(B1,B2,opc). Let V be any permutation of the list of variable in{a mathematical formula}V1and{a mathematical formula}V2so long as the relative order of operators in{a mathematical formula}V1and{a mathematical formula}V2remains unchanged, and let{a mathematical formula}B=〈V,D〉. Then for any interpretation I,{a mathematical formula}MAPB(I)=MAPB1(I)opcMAPB2(I).
      </paragraph>
      <paragraph>
       Therefore, when adding (or taking the logical-and of) functions represented by diagrams that are standardized apart we can use the Apply procedure on the graphical representations of these functions, and at the same time we have some flexibility in putting together their list of aggregation functions. This will be useful in our reductions.
      </paragraph>
      <paragraph>
       The Apply procedure can introduce redundancy into diagrams. By this we mean that a simpler syntactic form, often a sub-diagram, can represent the same function. To illustrate, consider the diagrams of Fig. 2 as FODDs (i.e., with max aggregation) and consider edge marked by {a mathematical formula}0_+4. It is easy to see that this edge can be redirected to a leaf with value zero without changing {a mathematical formula}MAPB(I) for any I. This is true because if we can reach the leaf with value 6 using some valuation then we can also reach the leaf with value 14 using another valuation because {a mathematical formula}x2 is not constrained. Therefore, the max aggregation will always ignore valuations reaching value 6. It is also easy to see that the edge marked {a mathematical formula}8_+4 can be redirected to value 14 without changing {a mathematical formula}MAPB(I). Simplification{sup:2} of diagrams by removing unnecessary portions is crucial for efficiency of GFODD implementations and a significant amount of previous work was devoted to mechanizing this process. Note that it is most natural to keep the aggregation portion fixed and simply manipulate the diagram portion. In this paper we abstract this process as testing for GFODD Equivalence, that is, testing whether the diagram is equivalent to a second simpler one. Motivated by the focus in the implementations on algorithms that remove one edge at a time, as illustrated in the example, we also formalize this special case.
      </paragraph>
     </section>
     <section label="2.4">
      <section-title>
       Complexity theory notation
      </section-title>
      <paragraph>
       Recall that the polynomial hierarchy is defined from P, NP, and co-NP using an inductive construction with reference to computation with oracles [14], [32], [26]. In particular we have that {a mathematical formula}Σ1P=NP, and {a mathematical formula}Π1P=co-NP. An algorithm is in the class {a mathematical formula}AB if it uses computation in A with a polynomial number of calls to an oracle for a problem in class B. Then we have {a mathematical formula}Σk+1P=NPΣkP, and {a mathematical formula}Πk+1P=co-NPΣkP. A problem is in {a mathematical formula}ΣkP iff its complement is in {a mathematical formula}ΠkP and thus (since the oracle always answers deterministically and correctly) either of these can serve as the oracle in the definition.
      </paragraph>
     </section>
     <section label="2.5">
      <section-title>
       Computational problems
      </section-title>
      <paragraph>
       Before defining the computational problems we must define the representation of inputs. We assume that GFODDs are given using a list of aggregation operators and associated variables and a labeled graph representation of the diagram. This is clearly polynomially related to the number of variables and number of nodes in the GFODD. Some of our problems require interpretations as input. Here we assume a finite domain so as to avoid issues of representing the interpretation. Thus an interpretation is given as a list of objects serving as domain elements, a list specifying the mapping of constants to objects, and the extension of each predicate on these objects. Given that the signature is fixed and the arity of each predicate is constant, this implies that the size of I is polynomially related to the number of objects in I. As illustrated in the example of Fig. 1, a graph {a mathematical formula}G=(V,E) can be seen as an interpretation with domain V and with one predicate formed by the edge relation.
      </paragraph>
      <paragraph>
       We can now define the computational problems of interest. We separate the definitions for FODDs and GFODDs because for GFODDs the unrestricted problems are undecidable and they require further refinement. The simplest problem requires us to evaluate a diagram on a given interpretation.
      </paragraph>
      <paragraph label="Definition 2">
       FODD evaluationGiven diagram B, interpretation I with finite domain, and value {a mathematical formula}V≥0: return Yes iff {a mathematical formula}MAPB(I)≥V. In the special case when the leaves are restricted to {a mathematical formula}{0,1} and {a mathematical formula}V=1 this can be seen as a returning Yes iff {a mathematical formula}MAPB(I) is true.
      </paragraph>
      <paragraph>
       To calculate {a mathematical formula}MAPB(I) we can “run” a procedure for FODD Evaluation multiple times, once for each leaf value as V, and return the highest achievable result. Thus, if FODD Evaluation is in complexity class A, we can calculate the function value in {a mathematical formula}PA. This fact is used several times in our constructions.
      </paragraph>
      <paragraph>
       Since diagrams generalize FOL it is natural to investigate satisfiability:
      </paragraph>
      <paragraph label="Definition 3">
       FODD satisfiabilityGiven diagram B with leaves in {a mathematical formula}{0,1}: return Yes iff there is some I such that {a mathematical formula}MAPB(I) is true.
      </paragraph>
      <paragraph>
       When B has more than two values in its leaves the satisfiability problem becomes:
      </paragraph>
      <paragraph label="Definition 4">
       FODD valueGiven diagram B and value {a mathematical formula}V≥0: return Yes iff there is some I such that {a mathematical formula}MAPB(I)=V.
      </paragraph>
      <paragraph>
       Notice that FODD Value requires that V is achievable but no value larger than V is achievable on the same I and, as the proofs below show, the extra requirement makes the problem harder. On the other hand, if we replace equality with ≥V in FODD Value, the problem is equivalent to FODD Satisfiability because we can simply replace leaf values in the diagram with 0, 1 according to whether they are ≥V.
      </paragraph>
      <paragraph>
       Finally, as motivated above, we investigate the simplification problem and its special case with single edge removal.
      </paragraph>
      <paragraph label="Definition 5">
       FODD equivalenceGiven diagrams {a mathematical formula}B1 and {a mathematical formula}B2: return Yes iff {a mathematical formula}MAPB1(I)=MAPB2(I) for all I.
      </paragraph>
      <paragraph label="Definition 6">
       FODD edge removalGiven diagrams {a mathematical formula}B1 and {a mathematical formula}B2, where {a mathematical formula}B2 can be obtained from {a mathematical formula}B1 by redirecting one edge to a zero valued leaf: return Yes iff {a mathematical formula}MAPB1(I)=MAPB2(I) for all I.
      </paragraph>
      <paragraph>
       Given the discussion above, GFODDs with binary leaves can be seen to capture the function free fragment of first order logic with equality. It is well known that satisfiability and therefore also equivalence of expressions in this fragment of first order logic is not decidable. In fact, the problem is undecidable even for very restricted forms of quantifier alternation (see survey and discussion in [8]). For example, the problem is undecidable for quantifier prefix {a mathematical formula}∀2∃⁎ with a single binary predicate and equality. The problem is also undecidable if we restrict attention to satisfiability under finite structures. Therefore, without further restrictions, we cannot expect much by way of classification of the complexity of the problems stated above for GFODDs.
      </paragraph>
      <paragraph>
       We therefore restrict the problems so that the size of interpretations is given as part of the input. The restriction ensures that the problems are decidable and reveals the structure promised above. There are two motivations for using such a restriction. The first is that in some applications we might know in advance that the number of relevant objects is bounded by some large constant. For example, the main application of GFODDs to date has been for solving decision theoretic planning problems; in this context the number of objects in an instance (e.g., the number of trucks or packages in a logistics transportation problem) might be bounded by some known quantity. The second is that our results show that even under such strong conditions the computational problems are hard, providing some justification for the heuristic approaches used in FODD and GFODD implementations [15], [17], [18].
      </paragraph>
      <paragraph label="Definition 7">
       GFODD model evaluationGiven diagram B, interpretation I with finite domain, and value {a mathematical formula}V≥0: return Yes iff {a mathematical formula}MAPB(I)≥V. Note that when the leaves are restricted to {a mathematical formula}{0,1} and {a mathematical formula}V=1 this can be seen as a returning Yes iff {a mathematical formula}MAPB(I) is true.
      </paragraph>
      <paragraph label="Definition 8">
       GFODD satisfiabilityGiven diagram B with leaves in {a mathematical formula}{0,1} and integer N in unary: return Yes iff there is some I, with at most N objects, such that {a mathematical formula}MAPB(I) is true.
      </paragraph>
      <paragraph label="Definition 9">
       GFODD valueGiven diagram B, integer N in unary and value {a mathematical formula}V≥0: return Yes iff there is some I, with at most N objects, such that {a mathematical formula}MAPB(I)=V.
      </paragraph>
      <paragraph label="Definition 10">
       GFODD equivalenceGiven diagrams {a mathematical formula}B1 and {a mathematical formula}B2 (with the same aggregation functions) and integer N in unary: return Yes iff for all I with at most N objects, {a mathematical formula}MAPB1(I)=MAPB2(I).
      </paragraph>
      <paragraph label="Definition 11">
       GFODD edge removalGiven diagrams {a mathematical formula}B1 and {a mathematical formula}B2 (with the same aggregation functions), where {a mathematical formula}B2 can be obtained from {a mathematical formula}B1 by redirecting one edge to a zero valued leaf, and given integer N in unary: return Yes iff for all I with at most N objects, {a mathematical formula}MAPB1(I)=MAPB2(I).
      </paragraph>
      <paragraph>
       Since we are assuming a fixed arity k, the assumption that N is in unary is convenient because it implies that the size of an intended interpretation I is polynomial in N. Therefore, an algorithm for these problems can explicitly represent an interpretation of the required size and test it. Our hardness results use N which is at most linear in the size of the corresponding diagram B.
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      The complexity of reasoning with FODD
     </section-title>
     <paragraph>
      In this section we develop the complexity results for the special case of FODDs. Evaluation of FODDs is essentially the same as evaluation of conjunctive queries in databases and can be analyzed similarly. We include the argument here for completeness.
     </paragraph>
     <paragraph label="Theorem 12">
      FODD Evaluation is NP-complete.
     </paragraph>
     <paragraph label="Proof">
      Membership in NP is shown by the algorithm that guesses a valuation ζ, calculates {a mathematical formula}MAPB(I,ζ) and returns Yes iff the leaf reached has value ≥V. Yes is returned iff some valuation yields a value ≥V as needed.For hardness we reduce the directed Hamiltonian path to this problem. As illustrated in Fig. 1, given the number of nodes in a graph we can represent a generic Hamiltonian path verifier as a FODD B. To do this we simply produce a left going path {a mathematical formula}E(x1,x2),E(x2,x3),…,E(xn−1,xn) which verifies existence of the edges, followed by equality tests to verify that all nodes are distinct. All “failure exits” on this path go to 0 and the success exit of the last test yields 1. Call this diagram B. This diagram is ordered with {a mathematical formula}E≺“=” and lexicographic ordering over arguments. Now, given any input G for Hamiltonian path, we represent it as an interpretation I and produce {a mathematical formula}(B,I,1) as the input for FODD Evaluation. Clearly, G has a Hamiltonian path iff {a mathematical formula}MAPB(I)=1.  □
     </paragraph>
     <paragraph>
      The other results for FODDs rely on the existence of small models:
     </paragraph>
     <paragraph label="Proof">
      For any FODD B with k variables and constants, if{a mathematical formula}MAPB(I)=Vfor some I then there is an interpretation{a mathematical formula}I′with at most k objects such that{a mathematical formula}MAPB(I′)=V.Let I be as in the statement. Then there is a valuation ζ such that ζ reaches a leaf valued V in B. Let {a mathematical formula}I′ be an interpretation including the objects that are used in the path traversed by ζ where the truth value of any predicate over arguments from these objects agrees with I. We have that {a mathematical formula}I′ has at most k objects, ζ is a suitable valuation for {a mathematical formula}I′ and {a mathematical formula}MAPB(I′,ζ)=V. In addition, no other valuation {a mathematical formula}ζ′ leads to a value larger than V because, if it did, the same value would be achievable in I. Hence, {a mathematical formula}MAPB(I′)=MAPB(I′,ζ)=V.  □
     </paragraph>
     <paragraph label="Theorem 14">
      FODD Satisfiability is NP-Complete.
     </paragraph>
     <paragraph label="Proof">
      For membership we can guess an interpretation I, which by the previous lemma can be small, and guess a valuation ζ for that interpretation. We return Yes if and only if {a mathematical formula}MAPB(I,ζ)=1.We show hardness with a reduction from 3SAT. Let f be an arbitrary 3CNF formula. We create a new FODD variable for each literal occurrence in the CNF so that {a mathematical formula}v(i,j) corresponds to the jth literal in the ith clause.Our FODD has three portions connected in a chain. The first portion checks that the predicate {a mathematical formula}PT() in the interpretation can be used to simulate Boolean assignments. To achieve this, we first ensure that the interpretation has at least two different objects, referred to by variables {a mathematical formula}y1 and {a mathematical formula}y2. We then use a small block that ensures that the truth value of {a mathematical formula}PT(y1) is not equal to {a mathematical formula}PT(y2). As a result {a mathematical formula}PT(y1) and {a mathematical formula}PT(y2) correspond to true and false logical values. This is shown in Fig. 3.The second portion ensures that if {a mathematical formula}v(i,j) and {a mathematical formula}v(i′,j′) correspond to the same Boolean variable then they map to the same object. For every variable {a mathematical formula}xi we create a shadow FODD variable {a mathematical formula}wi and equate it to all the {a mathematical formula}v(i′,j′) that correspond to {a mathematical formula}xi. We call this sequence of equalities a consistency block. For example, consider the CNF{a mathematical formula} where the corresponding FODD variables are{a mathematical formula}The first block, corresponding to {a mathematical formula}x1, ensures that {a mathematical formula}w1,v(1,1),v(2,1),v(3,1) are all assigned the same value. In addition to testing that the values are equivalent the block tests that each variable gets bound to the same object as {a mathematical formula}y1 or {a mathematical formula}y2. The only possible way to not get a 0 in these blocks is to ensure that each variable in the block has the same value and that it is equal to either {a mathematical formula}y1 or {a mathematical formula}y2. Fig. 4 shows the consistency blocks for our example.The third portion tracks the structure of f to guarantee the same truth value in the FODD. To follow the structure of f, we build a block for each clause and chain these blocks together. Each block has 3 nodes corresponding to the 3 literals in the clause. In particular, if the jth literal in the ith clause is positive the true edge (literal satisfied; call this success) continues to the next clause, and the false edge (literal failed) continues to the next literal. For a negative literal the true and false directions are swapped. The fail exit of the 3rd literal is attached to 0. Clause blocks have one entry and one exit and they are chained together. The success exit of the last clause is connected to the leaf 1. The only way to reach a value of 1 is if every clause block was satisfied by the valuations to {a mathematical formula}v(i,j). Fig. 5 illustrates the clause blocks for our example.Each of the portions, including the clause blocks, has one entry and one exit and we chain them together to get the diagram B. For a valuation to be mapped to 1 it must succeed in all three portions. We claim that f is satisfied if and only if there is some interpretation I such that {a mathematical formula}MAPB(I)=1.Consider first the case where f is satisfiable. We introduce the interpretation I that has two objects, a and b, where {a mathematical formula}PT(a)=true, and {a mathematical formula}PT(b)=false. Let v be a satisfying assignment for f and let {a mathematical formula}ζ(v) be a valuation for B on I where {a mathematical formula}y1=a,y2=b and if v maps {a mathematical formula}xi to 1 then {a mathematical formula}wi and its block are mapped to a and otherwise the block is mapped to b. Here, {a mathematical formula}ζ(v) succeeds in all blocks, implying that {a mathematical formula}MAPB(I,ζ(v))=1 and therefore {a mathematical formula}MAPB(I)=1.Consider next the case where {a mathematical formula}MAPB(I)=1 for some I and let ζ be such that {a mathematical formula}MAPB(I,ζ)=1. Then we claim that ζ identifies a satisfying assignment. First, since ζ succeeds in the first block we identify two objects that correspond via {a mathematical formula}PT() to truth values. Without loss of generality assume that {a mathematical formula}PT(y1) is true. Then success in the second portion implies that we can identify an assignment to the Boolean variables, if the ith block is assigned to {a mathematical formula}y1 we let {a mathematical formula}xi=1 and otherwise {a mathematical formula}xi=0. Finally, success in the third portion implies that the clauses in f are satisfied by the assignment to the {a mathematical formula}xi's. This completes the correctness proof.Finally we address node ordering in the diagram. The only violation of ordering is the use of {a mathematical formula}PT() in the first block. Otherwise, we have all equalities above {a mathematical formula}PT(), variable ordering {a mathematical formula}yi≺wj≺Va,b, and lexicographic ordering within a group. Now because our diagram forms one chain of blocks leading to a single sink leaf with value 1 we can move the three {a mathematical formula}PT() nodes to the bottom of the diagram in Fig. 4. This does not change the map value for any valuation and thus does not affect correctness. We therefore conclude that B is consistently sorted and f is satisfiable iff {a mathematical formula}MAPB(I)=1 for some I.  □
     </paragraph>
     <paragraph>
      This proof illustrates the differences in arguments needed for FODDs and GFODDs vs. First Order Logic. For the latter, we can use the sentence {a mathematical formula}∃v,(px1(v)∨px2(v)‾∨px4(v))∧(px1(v)‾…) to show the hardness result, and the proof is therefore considerably simpler. However, this cannot be easily represented as a FODD because the literals appearing in the clauses will violate predicate order and, if we try to reorder the nodes from a naive FODD encoding, the result might be exponentially larger. An alternative formulation can use {a mathematical formula}∃x1…(p(x1)∨p(x2)‾∨p(x4))∧(p(x1)‾… to avoid the problem with predicate order. However, similar ordering issues now arise for the arguments. Our reduction introduces additional variables as well as the variable consistency gadget to get around these issues. The same structure of reduction from 3SAT instances and their QBF generalizations will be used in the results for GFODD.
     </paragraph>
     <paragraph label="Proof">
      Since Edge Removal is a special case of Equivalence it suffices to show membership for Equivalence and hardness for Edge Removal. The hardness result is given in two stages; we first present a reduction which does not respect the constraint on node ordering and Edge Removal structure, and then show how to fix the construction to respect these restrictions.Membership in{a mathematical formula}Π2P. First observe that, by Lemma 13, if the diagrams are not equivalent then there is a small interpretation that serves as a witness for the difference. Using this fact, we can show that non-equivalence is in {a mathematical formula}Σ2P. Given {a mathematical formula}B1, {a mathematical formula}B2 we guess an interpretation I of the appropriate size, and then appeal to an oracle for FODD Evaluation to calculate {a mathematical formula}MAPB1(I) and {a mathematical formula}MAPB2(I). Using these values we return Yes or No accordingly. To calculate the map values, let B be one of these diagrams, and let the leaf values of the diagram be {a mathematical formula}v1,v2,…,vk. We make k calls to FODD Evaluation with {a mathematical formula}(B,I,vi) as input. {a mathematical formula}MAPB(I) is the largest value on which the oracle returns Yes. If a witness I for non-equivalence exists then this process can discover it and say No, and otherwise it will always say Yes. Therefore non-equivalence is in {a mathematical formula}Σ2P, and equivalence is in {a mathematical formula}Π2P.Reduction basics. To show hardness, consider the problem of deciding arrowing from the Ramsey theory of graphs [31]. Given two graphs {a mathematical formula}G1, {a mathematical formula}G2 we say that {a mathematical formula}G1 includes an embedding of {a mathematical formula}G2 if there is a 1–1 mapping g from nodes of {a mathematical formula}G2 to nodes of {a mathematical formula}G1, such that for every edge {a mathematical formula}(v1,v2) of {a mathematical formula}G2, the edge {a mathematical formula}(g(v1),g(v2)) is in {a mathematical formula}G1. We say that {a mathematical formula}G1 includes an isomorphic embedding of {a mathematical formula}G2 if, in addition, g satisfies that for every edge {a mathematical formula}(v1,v2) not in {a mathematical formula}G2, the edge {a mathematical formula}(g(v1),g(v2)) is not in {a mathematical formula}G1.We say that F arrows {a mathematical formula}(G,H), denoted {a mathematical formula}F→(G,H), if for every 2-color edge-coloring of F into colors red and blue, the red subgraph of F includes an embedding of G or the blue subgraph of F includes an embedding of H.The arrowing problem is as follows: Given 3 graphs {a mathematical formula}F,G,H as input, return Yes iff F arrows {a mathematical formula}(G,H). This problem was shown to be {a mathematical formula}Π2P-complete by [31]. We reduce this problem to FODD equivalence. The signature includes equality and two arity-2 predicates {a mathematical formula}EF and {a mathematical formula}EC, where {a mathematical formula}EF captures the edge relation of the main graph F and {a mathematical formula}EC captures a coloring of all possible edges such that when {a mathematical formula}EC(xi,xj) is true the edge is colored red and when it is false the edge is colored blue.The main construction. To transform arrowing into an instance of FODD equivalence we build two FODDs with binary leaves. The first FODD is satisfied iff I includes an isomorphic embedding of F in its edge relation {a mathematical formula}EF. The second FODD is satisfied iff the same condition holds and the coloring defined by {a mathematical formula}EC has a red embedding of G or a blue embedding of H. Note that, due to the 1–1 requirement, I must have at least as many objects as there are nodes in F. We illustrate the construction using the example input in Fig. 6. Here the input graphs F, G, H are a positive instance of arrowing.To build a FODD which verifies that I has an isomorphic embedding of F, we map each node to a variable in the FODD and test that each node has its correct neighbors. We first build a “node mapping” gadget that makes sure that each variable in the FODD is mapped to a different object in the interpretation. This is done by following a path of {a mathematical formula}(V2) inequalities, where off-path edges go to 0 and the final exit continues to the next portion. This gadget, for our example graph F with 5 nodes, is shown in Fig. 7. To test isomorphism to F we test the neighbors of each node in sequence to verify that edges exist iff they are in F. The FODD fragment in Fig. 8 shows how this can be tested for vertex {a mathematical formula}f1 in the example. If the edge is present in the graph we continue left (using the true branch) to the next neighbor and if the edge is not in F we continue to the right child (the false branch). Edges off this path are directed to the zero leaf. The endpoint of the path will connect to the next portion of the FODD. This construction can be done for each node and the fragments can be connected together to yield the F verifier. This is illustrated in Fig. 9. Finally, the diagram {a mathematical formula}B1 is built by connecting the F verifier at the bottom of node mapping gadget, and replacing the bottom node of the F verifier with a leaf valued 1. We refer to this diagram as the “complete F verifier” below. This construction can be done in polynomial time for any graph F. It should be clear form the construction that {a mathematical formula}MAPB1(I)=1 iff I includes an isomorphic embedding of F in its edge relation {a mathematical formula}EF. In addition, the verifier diagram is ordered where we have {a mathematical formula}“=”≺EF, and where variables are ordered lexicographically.The second diagram {a mathematical formula}B2 includes the complete F verifier and additional FODD fragments that are described next to capture the conditions on G and H respectively. In order to verify the embedding of colored subgraph G we first define a node mapping capturing the mapping of G nodes into F nodes, and then verify that the required edges exist and that they have the correct color. The FODD fragment in Fig. 10 shows how we can select a node mapping for vertex {a mathematical formula}g1. This fragment returns 0 unless {a mathematical formula}g1 is mapped to one of the nodes in F that are identified in the {a mathematical formula}B1 portion. As depicted in Fig. 11, this can be repeated for all the nodes in G, verifying that each node in G is mapped to a node in F. Next we need to verify that the mapping is one to one. This can be done by using a path of inequalities between the variables referring to nodes of G. This FODD fragment is given in Fig. 12. For correctness, we need to chain the two tests together, but this will violate node ordering. We therefore interleave the tests putting the uniqueness equality tests for a variable exactly after the equalities selecting its value. This change is possible because each such block has exactly one exit point. The resulting diagram, for our running example, is shown in Fig. 13.To complete the embedding test, we need to check that the edges are preserved and that they have the correct color. We do this by first checking that the corresponding edges in G are in F. We can do this using a left going path testing each edge in turn, where we test both {a mathematical formula}EF(gi,gj) and {a mathematical formula}EF(gj,gi) to account for the fact that the graph is undirected.{sup:3} This is illustrated on the left hand side of Fig. 14. Note that, because we are testing for an embedding (i.e., not for an isomorphic embedding) we test only for the edges in G and do not need to verify nonexistence of the edges not in G (it just happens here that G is a clique so this is not visible in the example). The same FODD structure is repeated with predicate {a mathematical formula}EC replacing {a mathematical formula}EF to verify that the edges of G are colored red, as shown on the right of Fig. 14.A similar construction with node mapping, edge verifier, and color verifier can be used for H. The node mapping construction is identical. Fig. 15 shows the edge and color verifiers. The only difference in construction is that the color verifier tests that the edge is not in {a mathematical formula}EC to capture the color blue and therefore has a mirror structure to the one verifying the {a mathematical formula}EF edges. Note that in this case H is not a complete graph and we are indeed only testing for the edges in H. This construction can be done in polynomial time for any G and H.Finally we connect the three portions together to obtain {a mathematical formula}B2 as follows. The final output of the complete F verifier is connected to the root of the G verifier. The final output of the G verifier is connected to 1. The zero leaf of the G verifier is removed and instead connected to the root of the H verifier. The final output of the H verifier is connected to 1. Therefore, there are exactly two edges leading to the 1 leaf in this diagram, corresponding to the positive outputs of the G and H verifiers. Fig. 16 shows an overview of the two FODDs, {a mathematical formula}B1 and {a mathematical formula}B2, generated by the reduction.The diagrams {a mathematical formula}B1 and {a mathematical formula}B2 are not consistent with any sorting order over node labels, and thus we need to modify them to get a consistent ordering. We show below how this can be done with only a linear growth in the size of the diagrams and without changing the semantics of {a mathematical formula}B1 and {a mathematical formula}B2. Before presenting this transformation we show that {a mathematical formula}F→(G,H) iff {a mathematical formula}B1 and {a mathematical formula}B2 are equivalent.Correctness of the construction. Consider the case when {a mathematical formula}F→(G,H), that is, for every 2-color edge-coloring of F there is a red G or a blue H. We show that the two FODDs are equivalent by way of contradiction. Assume that {a mathematical formula}B1 and {a mathematical formula}B2 are not equivalent and let I be any witness to this fact. Now, {a mathematical formula}MAPB1(I)=0 implies {a mathematical formula}MAPB2(I)=0 because the only paths to 1 in {a mathematical formula}B2 go through a copy of {a mathematical formula}B1. Therefore, for the assumed witness I, it must be the case that {a mathematical formula}MAPB1(I)=1 and {a mathematical formula}MAPB2(I)=0.By construction, {a mathematical formula}MAPB1(I)=1 implies that I has an isomorphic embedding of F. Because {a mathematical formula}F→(G,H), any coloring of that embedding, including the coloring captured by {a mathematical formula}EC in I, has a red G or a blue H. Assume that the embedding in I has a red G. Then we can construct the appropriate node mapping in a valuation ζ to show that {a mathematical formula}MAPB2(I,ζ)=1, contradicting the assumption. The same argument handles the case when the embedding has a blue H.Consider the case when F does not arrow {a mathematical formula}(G,H). Then there is a valid 2-color edge-coloring of F which does not have a red G and does not have a blue H. Construct the corresponding interpretation I that represents F and this edge-coloring. We claim that {a mathematical formula}MAPB1(I)=1 and {a mathematical formula}MAPB2(I)=0. The fact {a mathematical formula}MAPB1(I)=1 follows by mapping the nodes in F to the variables that represent them. Now if {a mathematical formula}MAPB2(I)=1 then {a mathematical formula}MAPB2(I,ζ)=1 for some ζ and we can trace the path that ζ traverses in {a mathematical formula}B2. This path together with ζ can be used to identify either a red G or a blue H in I and therefore in the corresponding coloring of F. This contradicts the assumption that the coloring is a witness for non-arrowing.Fixing the construction to handle ordering and edge removal special case. We next consider the node ordering in {a mathematical formula}B1 and {a mathematical formula}B2. The diagram {a mathematical formula}B1 is sorted, where predicate order puts equalities above {a mathematical formula}EF and arguments are lexicographically ordered. For {a mathematical formula}B2 we consider the sub-block structure of the construction. Expanding each of the sub-blocks of F, G, H in Fig. 16 we observe that {a mathematical formula}B2 has the structure shown in Fig. 17. We further observe that each block is internally sorted, but blocks of equalities {a mathematical formula}EF and {a mathematical formula}EC are interleaved. By analyzing this structure we see that the blocks can be reordered at the cost of duplicating some portions yielding the structure in Fig. 18. It is easy to see that {a mathematical formula}B2 is satisfied in I if and only if the reordered diagram is satisfied in I. The diagrams yield the same value for any valuation ζ which does not exit to 0 due to bad node mapping for G or H. Thus the original version might yield 1 (e.g., through G path) when the reordered diagram yields 0 on such a valuation (e.g., via the H equalities). But in such a case there is another valuation that is identical to ζ except that it modifies the bad node mapping (the H equalities) and that yields 1 for the new diagram. The final diagram is consistent with predicate ordering {a mathematical formula}“=”≺EF≺EC and variable ordering where {a mathematical formula}fi≺gj≺hk for all {a mathematical formula}i,j,k.Finally, we further change {a mathematical formula}B1 by adding the equality blocks of G and H to the construction, so that the modified {a mathematical formula}B1 is as shown in Fig. 19. Using the same argument as in {a mathematical formula}B2 one can see that this does not change the semantics of {a mathematical formula}B1. Moreover, with this change {a mathematical formula}B1 can be obtained from {a mathematical formula}B2 by one edge removal (of the edge below the F verifier in {a mathematical formula}B2) so that the reduction holds for this more restricted case.  □
     </paragraph>
     <paragraph>
      As mentioned above, FODD Value is defined similarly to FODD Satisfiability but requires more stringent conditions. The next result shows that this difference is important and FODD Value is one level higher in the hierarchy.
     </paragraph>
     <paragraph label="Proof">
      FODD Value is{a mathematical formula}Σ2P-complete.The algorithm showing membership is as follows. We first observe that by Lemma 13 we can restrict our attention to small interpretations. Given input B and V we guess an interpretation I of the appropriate size. We then make two calls to an oracle for FODD Evaluation. Let {a mathematical formula}V′ be either the least leaf value greater than V or any value greater than the max leaf if V is the maximum. We query the oracle for FODD Evaluation on {a mathematical formula}(B,I,V) and {a mathematical formula}(B,I,V′) and return Yes iff the oracle returns Yes on the first and No on the second. The algorithm returns Yes iff there is an interpretation I with value V.For hardness we present a reduction from non-Equivalence of FODDs with binary leaves, which was shown to be {a mathematical formula}Σ2P-hard in Theorem 15. We are given {a mathematical formula}B1=maxx1⁡B1(x1) and {a mathematical formula}B2=maxx2⁡B2(x2) as input for FODD non-Equivalence where {a mathematical formula}B1 and {a mathematical formula}B2 are standardized apart so that {a mathematical formula}x1, {a mathematical formula}x2 stand for disjoint sets of variables. We construct the diagram {a mathematical formula}B=maxx1⁡maxx2⁡B(x1,x2) where {a mathematical formula}B(x1,x2)=B1(x1)+B2(x2) can be calculated directly on the graph representation of {a mathematical formula}B1 and {a mathematical formula}B2 using the Apply procedure of [33] (see Fig. 2). Because {a mathematical formula}x1 and {a mathematical formula}x2 are disjoint, the diagram B has the following behavior for any interpretation I: if {a mathematical formula}MAPB1(I)=1 and {a mathematical formula}MAPB2(I)=1 then {a mathematical formula}MAPB(I)=2; otherwise if exactly one of them evaluates to 1 then {a mathematical formula}MAPB(I)=1; and otherwise {a mathematical formula}MAPB(I)=0. We produce {a mathematical formula}(B,V=1) as input for FODD Value.Now, if {a mathematical formula}B1 and {a mathematical formula}B2 are not equivalent then there is an interpretation such that their maps are different, and without loss of generality we may assume {a mathematical formula}MAPB1(I)=1 and {a mathematical formula}MAPB2(I)=0. As argued above in this case {a mathematical formula}MAPB(I)=1 as needed. For the other direction let I be such that {a mathematical formula}MAPB(I)=1. Then, again using the argument above, we have {a mathematical formula}MAPB1(I)=1 and {a mathematical formula}MAPB2(I)=0 or vice versa and the diagrams are not equivalent.  □
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      The complexity of reasoning with GFODD
     </section-title>
     <paragraph>
      In this section we analyze the computational problems for GFODD. We start with some observations on a notion of “complement” for GFODDs. Let B be a GFODD associated with the ordered list of variables {a mathematical formula}(wi1,…,wim), and aggregation list {a mathematical formula}(A1,…,Am) where each {a mathematical formula}Ai is min or max. Let {a mathematical formula}B′=complement(B) (with respect to maximum value M) be the diagram corresponding to B where we change leaf values and aggregation operators as follows: Let M be any value greater or equal to the max leaf value in B. Any leaf value v is replaced with {a mathematical formula}M−v. Each aggregation operator {a mathematical formula}Ai is replaced with {a mathematical formula}Ai′ where if {a mathematical formula}Ai is min then {a mathematical formula}Ai′ is max and vice versa.
     </paragraph>
     <paragraph label="Proof">
      Let B be a GFODD with min and max aggregation and maximum leaf value ≤M, and let{a mathematical formula}B′=complement(B). For any interpretation I,{a mathematical formula}MAPB(I)=M−MAPB′(I).By the construction of {a mathematical formula}B′, for any valuation ζ, we have that {a mathematical formula}MAPB(I,ζ)=M−MAPB′(I,ζ). Considering the aggregation process, note that {a mathematical formula}AiMAPB(…wi)=Ai[M−MAPB′(…wi)]=M−Ai′MAPB′(…wi). Now using this fact, we can argue by induction backward from the innermost (rightmost) aggregation that for any prefix of variables {a mathematical formula}P=wi1,…,wip, valuation {a mathematical formula}ζp for these variables, and remaining variables {a mathematical formula}R=wip+1,…,wim, we have {a mathematical formula}ARMAPB(I,(P=ζp;R))=M−AR′MAPB′(I,(P=ζp;R)). When the prefix is empty we get the statement of the theorem.  □
     </paragraph>
     <paragraph>
      Notice that for diagrams with binary leaves this yields {a mathematical formula}MAPB(I)=1−MAPB′(I), that is, negation. As immediate applications we get:
     </paragraph>
     <paragraph label="Proof">
      The complexity of GFODD Equivalence for min-k-alternating GFODD is the same as the complexity of GFODD Equivalence for max-k-alternating GFODD.By Theorem 17, two min diagrams {a mathematical formula}B1,B2 are equivalent if and only if their complements {a mathematical formula}B1′,B2′ are equivalent where we can use the maximum among the leaf values of the two diagrams as M.  □
     </paragraph>
     <paragraph label="Corollary 19">
      The equivalence problem for min-GFODD is{a mathematical formula}Π2P-complete.
     </paragraph>
     <paragraph>
      We can now turn to analysis of the computational problems. Evaluation is similar to the FODD case but the hardness proof is more involved due to the interaction between quantifier order and node ordering in the diagram.
     </paragraph>
     <paragraph label="Claim 1">
      GFODD Evaluation for max-k-alternating GFODDs is{a mathematical formula}ΣkP-complete. GFODD Evaluation for min-k-alternating GFODDs is{a mathematical formula}ΠkP-complete.We prove membership by induction on k. Since the inductive step includes diagrams that do not satisfy the sorting order we show that the claim holds in this more general case. Consider the input {a mathematical formula}(B,I,V). For the base case, {a mathematical formula}k=1, we guess a valuation ζ, calculate {a mathematical formula}v=MAPB(I,ζ), and return Yes iff {a mathematical formula}v≥V. In the max case, if the true value is at least V then we say Yes for some ζ, and if the true value is less than V then {a mathematical formula}MAPB(I,ζ)&lt;v for all ζ and therefore we always say No. Thus the problem is in NP. In the min case, if the true value is at least V then all ζ yield Yes, and if the true value is less than V then some ζ yields No. Thus the problem is in co-NP.For the inductive step assume that the claim holds for {a mathematical formula}k−1 and consider the input {a mathematical formula}(B,I,V) with an interpretation I, value bound V and a max-k-alternating diagram {a mathematical formula}B=maxw1⁡minw2⁡…QwkAB(w1,…,wk) where in order to simplify the notation each {a mathematical formula}wi may be a single variable or a set of variables and we use the boldface notation to denote this fact.Now for each tuple i of domain objects in I (which is appropriate for the number of variables in {a mathematical formula}w1) let diagram {a mathematical formula}B′ be {a mathematical formula}B′=minw2⁡…QwkAB(w1=i,…,wk). Clearly {a mathematical formula}B′ is appropriate for evaluation on I and by the inductive hypothesis we can appeal to a {a mathematical formula}Πk−1P oracle to solve GFODD Evaluation on {a mathematical formula}(B′,I,V). Our algorithm guesses a value i, calculates {a mathematical formula}B′, appeals to the oracle, and returns the same answer. Now, if the true value is &lt;V then by definition any call to the oracle would yield No and we correctly answer No. If the true value is ≥V then for some i the oracle would return Yes. Therefore we nondeterministically return Yes and our algorithm is in {a mathematical formula}NPΣk−1P. The argument for the other aggregation prefix is symmetric and argued in the same manner yielding an algorithm in {a mathematical formula}co-NPΣk−1P.To show hardness we give a reduction from {a mathematical formula}QBFk. Given a quantified 3CNF Boolean formula we transform this into a GFODD B and interpretation I such that the following claim holds:B evaluates to 1 in I if and only if the quantified Boolean formula is satisfied.This claim establishes the theorem. The reduction uses a similar structure to the one used for FODD satisfiability with two main differences. First because here we consider evaluation and we can control I we do not need to test for an embedding of a Boolean predicate in I, that is, the first portion in that construction is not needed. On the other hand the construction and proof are more involved because of the alternation of quantifiers.The interpretation I has two objects, a and b, where {a mathematical formula}PT(a)=true, and {a mathematical formula}PT(b)=false. Namely, {a mathematical formula}I={[a,b],PT(a)=true, andPT(b)=false}.Let the QBF formula be {a mathematical formula}Q1x1Q2x2…Qmxmf where Q is a quantifier ∀ or ∃ and the quantifiers come in k alternating blocks. As above, we start the construction by creating a set of “shadow variables” corresponding to each QBF variable {a mathematical formula}xi. The corresponding GFODD variables include {a mathematical formula}wi and the set of {a mathematical formula}v(a,b) that refer to {a mathematical formula}xi or {a mathematical formula}xi‾ in the QBF. We define {a mathematical formula}wi to be the set of variables in the block corresponding to {a mathematical formula}xi and associate these variables with an aggregation operator {a mathematical formula}QiA where if {a mathematical formula}Qi is a ∃ then {a mathematical formula}QiA is max and if {a mathematical formula}Qi is a ∀ then {a mathematical formula}QiA is min. Using these variables, we build GFODD fragments we call variable consistency blocks. For each {a mathematical formula}xi, this gadget ensures that if two literals in the QBF refer to the same variable then the corresponding variables in the GFODD will have the same value. If this holds then a valuation goes through the block and continues to the next block. Otherwise, it exits to a default value, where for max blocks the default value is 0, and for min blocks the default value is 1.Consider the expression{a mathematical formula} which has the same clauses as in the previous proof but where we have changed the quantification. Fig. 20 shows the variable consistency blocks for this example. Since, {a mathematical formula}v(1,1), {a mathematical formula}v(2,1), and {a mathematical formula}v(3,1) refer to {a mathematical formula}x1 we need to ensure that when they are evaluated they are evaluated consistently and this is done by the first block. Because {a mathematical formula}x1 is a ∀ variable the default output value is 1. The consistency blocks are chained in the same order as in the quantification of the QBF. Once every consistency block has been checked, we continue to the clause blocks whose construction is exactly the same as in the previous proof (see Fig. 5). This yields the diagram B where we set the aggregation function to be {a mathematical formula}Q1Aw1,Q2Aw2,…,QmAwm. Note that if the QBF has k alternating blocks of quantifiers then B has aggregation depth k. The output of the reduction is the pair {a mathematical formula}(B,I). The diagram is ordered with {a mathematical formula}“=”≺PT and variables ordered lexicographically.We next show that Claim 1 holds. We start by showing a correspondence between assignments to the Boolean formula f and object assignments from B to I. Let v be a Boolean assignment. If v assigns {a mathematical formula}xi to 1 then {a mathematical formula}ζ(v) maps the entire {a mathematical formula}wi block to a. Otherwise {a mathematical formula}ζ(v) maps the block to b. It is then easy to see that for all v, {a mathematical formula}ζ(v) satisfies the consistency blocks and {a mathematical formula}f(v)=1 if and only if {a mathematical formula}MAPB(I,ζ(v))=1. This, however, does not complete the proof because {a mathematical formula}MAPB(I) must also consider valuations ζ that do not arise as maps of assignments v.We divide the set of valuations to the GFODD into two groups. The first group of legal valuations, called Group 1 below, is the set of valuations that is consistent with some v.The second group, Group 2, includes valuations that do not arise as {a mathematical formula}ζ(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let {a mathematical formula}QjA be the first block from the left whose constraint is violated. By the construction of B, in particular the order of equality blocks along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. Therefore, if {a mathematical formula}Qj is a ∀ then {a mathematical formula}MAPB(I,ζ)=1 and if {a mathematical formula}Qj is a ∃ then {a mathematical formula}MAPB(I,ζ)=0.We can now show the correspondence in truth values. Consider any partition of the blocks {a mathematical formula}1,…,m into a prefix {a mathematical formula}1,…,j and remainder {a mathematical formula}(j+1),…,m, and any Boolean assignment v to the prefix blocks. We claim that for all such partitions{a mathematical formula}Note that when {a mathematical formula}j=0, that is, the prefix is empty, the claim implies that {a mathematical formula}MAPB(I) is equal to {a mathematical formula}Q1x1,…,Qmxm,f, completing the proof. We prove the claim by induction, backwards from m to 0. For the base case, {a mathematical formula}j=m, and the second part is empty. The claim then follows because the prefix includes all variables and there is a 1–1 correspondence in truth values for substitutions in group 1.For the inductive step, the valuation v covers the first {a mathematical formula}j−1 blocks. Note that, by the inductive assumption, for any group 1 substitution {a mathematical formula}vj for {a mathematical formula}xj and corresponding, {a mathematical formula}ζ(vj) for {a mathematical formula}wj,{a mathematical formula}On the other hand, for any group 2 substitution {a mathematical formula}ζj for {a mathematical formula}wj and any values for {a mathematical formula}(wj+1,…,wm) we have that the leftmost block whose constraint is violated for the corresponding combined ζ is block j and therefore {a mathematical formula}MAPB(I,[(w2,…,wj−1)=ζ(v),(wj=ζj),(wj+1,…,wm)]) gets the default value for that block. Therefore, the aggregation over the jth block is determined by group 1 valuations, which are in turn identical to the QBF value and{a mathematical formula} as required.  □
     </paragraph>
     <paragraph>
      It turns out that the complexity of satisfiability is different for min and max diagrams, and their analysis requires different proofs. We therefore start with max-k-alternating GFODDs. The case of min-k-alternating GFODDs is analyzed after the analysis of equivalence because it is using similar techniques.
     </paragraph>
     <paragraph label="Proof">
      GFODD Satisfiability for max-k-alternating GFODDs (where{a mathematical formula}k≥2) is{a mathematical formula}ΣkP-complete.We first show membership. Let B be a GFODD with aggregation {a mathematical formula}max⁡w1,min⁡w2,…,QkAwk. Our algorithm nondeterministically chooses an interpretation I and a tuple of values for {a mathematical formula}w1, from the domain of objects for I. Let i refer to this tuple of objects. We create a new GFODD, {a mathematical formula}B′=min⁡w2…QkAB(w1=i,…,wk) and appeal to a {a mathematical formula}Πk−1P oracle to solve GFODD evaluation on {a mathematical formula}(B′,I). If the oracle query returns 1 then we accept and otherwise we reject. The result is clearly correct using an algorithm in {a mathematical formula}NPΣk−1P.The hardness argument is similar to the proof for GFODD evaluation. The main extension is that in the current proof we verify that any satisfying I embeds the interpretation from the previous proof. The reduction gets a {a mathematical formula}QBFk formula, {a mathematical formula}Q1x1Q2x2…Qmxmf, with {a mathematical formula}Qi either a ∀ or ∃ quantifier. We first construct two diagrams {a mathematical formula}B1 and {a mathematical formula}B2, where {a mathematical formula}B2, the QBF validation diagram, is exactly as in the proof of Theorem 20, that is, it includes consistency blocks followed by clause blocks. The diagram {a mathematical formula}B1 has two portions. The first verifies that I has at least two objects and the truth values of {a mathematical formula}PT() on these objects are different. The second portion verifies that I has at most two objects. This is implemented using min variables such that if we identify three distinct objects we set the value to 0. The two portions are put together so as to respect predicate order, and the final diagram {a mathematical formula}B1 is shown in Fig. 21. The aggregation function for {a mathematical formula}B1 is {a mathematical formula}maxy1⁡maxy2⁡minz1⁡minz2⁡minz3.Let {a mathematical formula}I⁎={[a,b],PT(a)=true, andPT(b)=false} be the intended interpretation. We have the following two claims:
      <list>
       For all I, {a mathematical formula}MAPB1(I)=1 if and only if I is isomorphic to {a mathematical formula}I⁎.If I is isomorphic to {a mathematical formula}I⁎ then {a mathematical formula}MAPB2(I)=1 if and only if {a mathematical formula}(Q1x1Q2x2…Qmxmf)=1.C2 is exactly the same as Claim 1 in the proof of
      </list>
      <paragraph>
       Theorem 20. For C1, given I which is isomorphic to {a mathematical formula}I⁎, the valuation of {a mathematical formula}y1,y2 to {a mathematical formula}a,b and any valuation to the z's yields a map value of 1. Therefore, considering the aggregation order we see that for {a mathematical formula}(y1,y2)=(a,b) in {a mathematical formula}B1 the minimum over z yields 1, and then the maximum over y's is 1. For the other direction, we need to consider interpretations not isomorphic to {a mathematical formula}I⁎. If I has only one object then its map is 0 for all valuations, and therefore the aggregated value is 0. If I has at least 3 objects then for any fixed valuation for y the minimum over z is 0, implying that the maximum over y also yields 0 and {a mathematical formula}MAPB1(I)=0. Finally consider any I with two objects where {a mathematical formula}PT() has the same truth value on the two objects. In this case the map is 0 for any valuation and thus the final map value is 0. We have therefore shown that C1 holds.For our reduction, we produce {a mathematical formula}B=Apply(B1,B2,∧) where for the aggregation we make use of Theorem 1 and interleave the aggregation functions of {a mathematical formula}B1 and {a mathematical formula}B2 so that B has at most k alternations of quantifiers. This is always possible because the QBF starts with a ∃ quantifier and {a mathematical formula}k≥2.By the claims C1 and C2 and Theorem 1 we get that {a mathematical formula}MAPB(I)=1 if and only if I is isomorphic to {a mathematical formula}I⁎ and {a mathematical formula}(Q1x1Q2x2…Qmxmf)=1. Therefore, the QBF is true if and only if there exists an interpretation I (which must be isomorphic to {a mathematical formula}I⁎) that satisfies B.  □
      </paragraph>
     </paragraph>
     <paragraph>
      Equivalence is one level higher in the hierarchy; using a reduction from QBF we show how to “peel off” one level of quantifiers and push that into the “existential quantification” over interpretations that potentially witness non-equivalence.
     </paragraph>
     <paragraph label="Proof">
      GFODD Equivalence and GFODD Edge Removal for diagrams with aggregation depth k (where{a mathematical formula}k≥2) are{a mathematical formula}Πk+1P-complete.By Corollary 18, it suffices to show that this holds for max-k-alternating GFODDs. Since Edge Removal is a special case of Equivalence it suffices to show membership for Equivalence and hardness for Edge Removal.To show membership we show that the complement, nonequivalence, is in {a mathematical formula}Σk+1P. Given two max-k-alternating GFODDs {a mathematical formula}B1 and {a mathematical formula}B2 as input, we guess an interpretation I of the appropriate size, and then appeal to an oracle for GFODD Evaluation to calculate {a mathematical formula}MAPB1(I) and {a mathematical formula}MAPB2(I). Using these values we return Yes or No accordingly. To calculate the map values, let B be one of these diagrams, and let the leaf values of the diagram be {a mathematical formula}v1,v2,…,vℓ. We make ℓ calls to GFODD Evaluation with {a mathematical formula}(B,I,vi) as input. Each call requires an oracle in {a mathematical formula}ΣkP and {a mathematical formula}MAPB(I) is the largest value on which the oracle returns Yes. Clearly if a witness for nonequivalence exists then this process can discover it and say Yes (per non-equivalence), and otherwise it will always say No. Therefore non-equivalence is in {a mathematical formula}NPΣkP, that is {a mathematical formula}Σk+1P and equivalence is in {a mathematical formula}Πk+1P.We reduce QBF satisfiability with {a mathematical formula}k≥3 alternations of quantifiers to equivalence of max-{a mathematical formula}(k−1)-alternating GFODDs. The reduction is conceptually similar to the one from the previous theorem but the details are more involved. In particular, here we assume a QBF whose first quantifier is ∀, that is, {a mathematical formula}∀x1,Q2x2…Qmxmf(x1,x2,…,xm) where this form has k blocks of quantifiers. To simplify the notation it is convenient to collect adjacent variables having the same quantifiers into groups so that the QBF has the form {a mathematical formula}∀x1…Qkxkf(x1,x2,…,xk) where {a mathematical formula}xi refers to a set of variables.We next define a notion of “legal interpretations” for our diagrams. A legal interpretation embeds the binary interpretation {a mathematical formula}I⁎ from the previous proof and in addition includes a truth setting for all the variables in the first ∀ block of the QBF. The reduction constructs diagrams {a mathematical formula}B1, {a mathematical formula}B2, and {a mathematical formula}B=Apply(B1,B2,∧) such that the following claims hold:
      <list>
       For all I, {a mathematical formula}MAPB1(I)=1 if and only if I is legal.If I is legal and it embeds the substitution {a mathematical formula}x1=α then {a mathematical formula}MAPB2(I)=1 if and only if {a mathematical formula}Q2x2…Qkxkf((x1=α),x2,…,xk)=1.We then output the diagrams
      </list>
      <paragraph>
       {a mathematical formula}(B1,B) for GFODD equivalence. Note that, by C1 and Theorem 1, for non-legal interpretations we have {a mathematical formula}MAPB1(I)=MAPB(I)=0 and therefore if the diagrams are not equivalent it must be because of legal interpretations. Now, if the QBF is satisfied then, by definition, for all {a mathematical formula}x1=α we have that {a mathematical formula}Q2x2…Qkxkf((x1=α),x2,…,xk)=1. Therefore, by C2, for all legal I, {a mathematical formula}MAPB2(I)=1 and by C1 and the construction {a mathematical formula}MAPB(I)=1. Thus B and {a mathematical formula}B1 are equivalent.On the other hand, if the QBF is not satisfied then there is a substitution {a mathematical formula}x1=α where {a mathematical formula}Q2x2…Qkxkf((x1=α),x2,…,xk)=0. Therefore, by C2, for the corresponding interpretation {a mathematical formula}I′, {a mathematical formula}MAPB2(I′)=0 and by Theorem 1 we also have {a mathematical formula}MAPB(I′)=0. But by C1, {a mathematical formula}MAPB1(I′)=1 and therefore {a mathematical formula}B1 and B are not equivalent.We now proceed with the reduction, starting first with a simplified construction ignoring ordering of node labels and edge removal structure, and then elaborating to enforce these constraints. The set of predicates includes {a mathematical formula}PT() and for every QBF variable {a mathematical formula}xi in the first ∀ block we use a predicates {a mathematical formula}Pxi(). Notice that each {a mathematical formula}xi is a member of {a mathematical formula}x1 (the first ∀ group) where the typeface distinguishes the individual variables in the first block, from blocks of variables. In the simplified construction, a legal interpretation has exactly two objects, say a and b, where {a mathematical formula}PT(a)≠PT(b) and where for each {a mathematical formula}Pxi() we have {a mathematical formula}Pxi(a)=Pxi(b). In other words, the assignment of an object to v in {a mathematical formula}PT(v) simulates an assignment to Boolean values, but the truth value of {a mathematical formula}Pxi(v) is the same regardless of which object is assigned to v.In our example QBF {a mathematical formula}∀x1∃x2∀x3∃x4(x1∨x2‾∨x4)∧(x1‾∨x2∨x3)∧(x1∨x3∨x4‾) the first block includes only the variable {a mathematical formula}x1 and the following interpretation is legal: {a mathematical formula}I={[a,b],PT(a)=true,PT(b)=false,Px1(a)=Px1(b)=false}.The diagram {a mathematical formula}B1 has three portions where the first two are exactly as in the previous proof, thus verifying that I has two objects and that {a mathematical formula}PT() behaves as stated. The third portion verifies that each {a mathematical formula}Pxi() behaves as stated, where we use a sequence of blocks, one for each {a mathematical formula}Pxi(). The combined diagram {a mathematical formula}B1 for our example is shown in Fig. 22 and the aggregation function is {a mathematical formula}maxy1,y2⁡,minz1,z2,z3.To see that C1 holds consider all possible cases for non-legal interpretations. If I has at most one object the map is 0 for all valuations and thus the aggregation is 0. If I has at least 3 objects, then for any values for {a mathematical formula}y1,y2 the min aggregation over z yields 0, and therefore the map is 0. If I has 2 objects but it violates the condition on {a mathematical formula}PT or {a mathematical formula}Pxi then again the map is 0 for any valuation and the aggregation is 0. On the other hand, if I is legal, then the z block never yields 0 and the correct mapping to {a mathematical formula}y1,y2 yields 1. Therefore the aggregation is 1.The diagram {a mathematical formula}B2 is constructed by modifying {a mathematical formula}B2 from the proof of Theorem 20. The first modification is to handle the first ∀ block differently. As it turns out, all we need to do is replace the min aggregation for the {a mathematical formula}w1 block with maximum aggregation and accordingly replace the default value on that block with 0. To avoid confusion we recall that the current proof uses a slightly different notation from the previous one. In the current proof {a mathematical formula}xi is a set of variables from the QBF and therefore {a mathematical formula}wi is a set of blocks of variables, all of which have the same aggregation function. The modified variable consistency diagram is shown in Fig. 23. The clause blocks have the same structure as in the previous construction but use {a mathematical formula}Pxi(V(i1,i2)) when {a mathematical formula}xi is a ∀ variable from the first block and use {a mathematical formula}PT(V(i1,i2)) otherwise. This is shown in Fig. 24. {a mathematical formula}B2 includes the variable consistency blocks followed by the clause blocks. Note that the new clause blocks are not sorted in any consistent order because the predicates {a mathematical formula}Pxi() and {a mathematical formula}PT() appear in an arbitrary ordering determined by the appearance of literals in the QBF. Other than this violation, all other portions of the diagrams described are sorted where the predicate order has {a mathematical formula}=≺PT≺Pxi and where variables {a mathematical formula}wi are before {a mathematical formula}v(i1,i2) and variables within group are sorted lexicographically. The combined aggregation function is {a mathematical formula}maxw1⁡,maxw2⁡,minw3⁡,…,QwkA.We next show that claim C2 holds, which will complete the proof of the simplified construction. Consider any legal I, let the corresponding truth values for variables in {a mathematical formula}x1 be denoted α, and consider valuations for the QBF extending {a mathematical formula}x1=α. In particular, consider any valuation v to the remaining variables in the QBF and the induced substitution to the GFODD variables {a mathematical formula}ζ(v) that is easily identified from the construction. Add any consistent group assignment to {a mathematical formula}w1 (that is, we assign a or b to each subgroup of variables in that group) to {a mathematical formula}ζ(v) to get {a mathematical formula}ζˆ(v). By the construction of {a mathematical formula}B2 we have that {a mathematical formula}f([x1=α,(x2,…,xk)=v])=MAPB2(I,ζˆ(v)). To see this note that there are no quantifiers in this expression, there is a 1–1 correspondence between the valuations of {a mathematical formula}x2,…,xk and {a mathematical formula}w2,…,wk, and that as long as the assignment to the {a mathematical formula}w1 block is group consistent it does not affect the value returned. We call this set of valuations, that arise as translations of substitutions for QBF variables, Group 1.The second group, Group 2, includes valuations that do not arise as {a mathematical formula}ζˆ(v) and therefore they violate at least one of the consistency blocks. Let ζ be such a valuation and let {a mathematical formula}QjA be the first block from the left whose constraint is violated. By the construction of {a mathematical formula}B2, in particular the order of equality blocks along paths in the GFODD, we have that the evaluation of the diagram on ζ “exits” to a default value on the first violation. Therefore, if {a mathematical formula}j=1, that is the violation is in the block of {a mathematical formula}w1, {a mathematical formula}MAPB(I,ζ)=0 and for {a mathematical formula}j≥2 if {a mathematical formula}Qj is a ∀ then {a mathematical formula}MAPB(I,ζ)=1 and if {a mathematical formula}Qj is a ∃ then {a mathematical formula}MAPB(I,ζ)=0.We can now show the correspondence in truth values. Consider any partition of the blocks {a mathematical formula}2,…,k into a prefix {a mathematical formula}2,…,j and remainder {a mathematical formula}(j+1),…,k, and any valuation v to the prefix blocks. We claim that for all such partitions{a mathematical formula} Note that when {a mathematical formula}j=1, that is, the prefix is empty, this yields that {a mathematical formula}Q2x2,…,Qkxk,f(x1=α,x2,…,xk) is equal to {a mathematical formula}Q2Aw2,…,QkAwk,MAPB2(I,[w1=a,w2,…,wk)]). Now because the default value for violations of {a mathematical formula}w1 is 0 and because the aggregation for {a mathematical formula}w1 is max the latter expression is equal to {a mathematical formula}Q1Aw1,…,QkAwk,MAPB2(I,[w1,w2,…,wk)]). This means that {a mathematical formula}MAPB2(I) is equal to {a mathematical formula}Q2x2,…,Qkxk,f(x1=α,x2,…,xk). Therefore, the claim implies C2.We prove the claim by induction, backwards from k to 1. For the base case, {a mathematical formula}j=k, and the second part is empty. The claim then follows because the prefix includes all variables and there is a 1–1 correspondence in truth values for substitutions in group 1.For the inductive step, the valuation v covers the first {a mathematical formula}j−1 blocks. Note that, by the inductive assumption, for any group 1 substitution {a mathematical formula}vj for {a mathematical formula}xj and corresponding, {a mathematical formula}ζ(vj) for {a mathematical formula}wj, {a mathematical formula}Qj+1xj+1,…,Qkxk, {a mathematical formula}f(x1=α,(x2,…,xj−1)=v,(xj=vj),xj+1,…,xk)=Qj+1Awj+1,…,QkAwk,MAPB2(I,[w1=a,(w2,…,wj−1)=ζ(v),(wj=ζ(vj)),(wj+1,…,wk)]). On the other hand, for any group 2 substitution {a mathematical formula}ζj for {a mathematical formula}wj and any values for {a mathematical formula}(wj+1,…,wk) we have that the violating block for the corresponding combined ζ is block j and therefore {a mathematical formula}MAPB2(I,[w1=a,(w2,…,wj−1)=ζ(v),(wj=ζj),(wj+1,…,wk)]) gets the default value for that block. Therefore, the map is determined by group 1 valuations, which are in turn identical to the QBF value and {a mathematical formula}Qjxj,…,Qkxk,f(x1=α,(x2,…,xj−1)=v,(xj,…,xk))=QjAwj,…,QkAwk,MAPB2(I,[w1=a,(w2,…,wj−1)=ζ(v),(wj,…,wk)]) as required. Therefore, the claim on the correspondence of values holds. This completes the proof of C2.Extending the reduction to handle ordering and edge removal special case. The main idea in the extended construction is to replace the unary predicates {a mathematical formula}PT and {a mathematical formula}Pxi with one binary predicate {a mathematical formula}q(⋅,⋅) where the “second argument” in {a mathematical formula}q() serves to identify the corresponding predicate and hence its truth value. In addition we force {a mathematical formula}q() to be symmetric so that for any A and B the truth value of {a mathematical formula}q(A,B) is the same as the truth value of {a mathematical formula}q(B,A). In this way we have freedom to use either {a mathematical formula}q(A,B) or {a mathematical formula}q(B,A) as the node label which provides sufficient flexibility to handle the ordering issues. To implement this idea we need a few additional constructions.Let the set of variables in the first ∀ block of the QBF be {a mathematical formula}x1,x2,…,xℓ. The set of predicates in the extended reduction includes unary predicates {a mathematical formula}T(),y1(), {a mathematical formula}y2(),x1(),x2(),…,xℓ(), and one binary predicate {a mathematical formula}q(⋅,⋅). A legal interpretation includes exactly {a mathematical formula}ℓ+3 objects which are uniquely identified by the unary predicates. We therefore slightly abuse notation and use the same symbols for the objects and predicates. In particular, the atoms {a mathematical formula}y1(y1),y2(y2), {a mathematical formula}T(T), and {a mathematical formula}x1(x1),x2(x2),…,xℓ(xℓ) are true in the interpretation and only these atoms are true for these unary predicates (e.g., {a mathematical formula}x1(T) is false). The truth values of {a mathematical formula}q() reflect the simulation of {a mathematical formula}PT() and {a mathematical formula}Pxi() in addition to being symmetric. Thus the truth values of {a mathematical formula}q(y1,T) and {a mathematical formula}q(T,y1) are the same and they are the negation of the truth values of {a mathematical formula}q(y2,T) and {a mathematical formula}q(T,y2). For all i, the truth values of {a mathematical formula}q(y1,xi), {a mathematical formula}q(xi,y1), {a mathematical formula}q(y2,xi) and {a mathematical formula}q(xi,y2) are the same. The truth values of other instances of {a mathematical formula}q(), for example, {a mathematical formula}q(x2,T), can be set arbitrarily. For example, the following interpretation is legal when {a mathematical formula}ℓ=1: {a mathematical formula}I={[a,b,c,d],y1(a),y2(b),T(c),x1(d),q(c,a)=q(a,c)=true,q(c,b)=q(b,c)=false,q(d,a)=q(a,d)=q(d,b)=q(b,d)=false,q(⋅,⋅)=false} where {a mathematical formula}q(⋅,⋅) refers to any instance not explicitly mentioned in the list.We next define the diagram {a mathematical formula}B1 that is satisfied only in legal interpretations. We enforce exactly {a mathematical formula}ℓ+3 objects using two complementary parts. The first includes {a mathematical formula}(ℓ+42) inequalities on a new set of {a mathematical formula}ℓ+4 variables {a mathematical formula}z1,…,zℓ+4 with min aggregation. If we identify {a mathematical formula}ℓ+4 distinct objects we set the value to 0. This is shown in Fig. 25.To enforce at least {a mathematical formula}ℓ+3 objects and identify them we use the following gadget. For each of the unary predicates we have a diagram identifying its object and testing its uniqueness where we use both max and min variables. This is shown for the predicate {a mathematical formula}T() in Fig. 26. The node {a mathematical formula}T(T) with max variable T identifies the object T. The nodes {a mathematical formula}T(r1),T(r2) with min variables {a mathematical formula}r1,r2 make sure that T holds for at most one object. We chain the diagrams together as shown in Fig. 27 where the variables {a mathematical formula}r1,r2 are shared among all unary predicates. The corresponding aggregation function is {a mathematical formula}maxT,y1,y2,x1,…,xℓ⁡,minr1,r2. This diagram associates each of the {a mathematical formula}ℓ+3 objects with one of the unary predicates and in this way provides a reference to specific objects in the interpretation.The symmetry gadget for {a mathematical formula}q() is shown in Fig. 28 where the variables {a mathematical formula}m1,m2 are min variables. If an input interpretation has two objects {a mathematical formula}A,B where {a mathematical formula}q(A,B) has a truth value different than {a mathematical formula}q(B,A) then minimum aggregation will map the interpretation to 0.The truth value gadget for the simulation of {a mathematical formula}PT is shown in Fig. 29 and the truth value gadget for the simulation of {a mathematical formula}Pxi is shown in Fig. 30. These diagram fragments refer to variables in other portions and they will be connected and aggregated together.Finally, we add a component that is not needed for verifying that I is legal but will be useful later when we include the clauses. In particular, we include a variable consistency block which is similar to the one in the simple construction (see Fig. 23) but where we force each subgroup in {a mathematical formula}wi to bind to the same object as {a mathematical formula}y1 or {a mathematical formula}y2. This is shown in Fig. 31.We chain the diagrams together as shown in Fig. 32 to get {a mathematical formula}B1 where we have moved the node labeled {a mathematical formula}r1=r2 to be above the block consistency gadget. Note that the diagram is sorted where for predicate order we have {a mathematical formula}“=”≺T≺y1≺y2≺xi≺q and for variables we have {a mathematical formula}zi,T,yi,xi≺rj≺wl, and {a mathematical formula}yi≺v(i1,i2), and {a mathematical formula}mi≺T≺xj. The complete aggregation function is{a mathematical formula}We next show that the claim C1 holds for the extended reduction.{sup:4} We first consider all possible cases for illegal interpretations.
      </paragraph>
      <list>
       <list-item label="•">
        If the interpretation has {a mathematical formula}≥ℓ+4 objects then the top portion of the diagram yields 0 for some valuation of z's. Consider any valuation {a mathematical formula}ζp to the prefix of variables {a mathematical formula}T,y1,y2,x1,…,xℓ, {a mathematical formula}w1,w2, {a mathematical formula}m1,m2,r1,r2, and any ζ which is an extension of this valuation, has the violating combination for {a mathematical formula}z1,…,zℓ+4 and any valuation for the other variables. We have {a mathematical formula}MAPB1(I,ζ)=0. Therefore, all aggregations from {a mathematical formula}wk to {a mathematical formula}w3 yield a value of 0 for this prefix. Now continuing backwards, the minimization over z yields a value of 0 for {a mathematical formula}ζp, and this holds for any {a mathematical formula}ζp. Therefore, all remaining aggregations yield 0 and the final value is 0.
       </list-item>
       <list-item label="•">
        Next, consider the case where the interpretation has {a mathematical formula}≤ℓ+3 objects but one of the unary predicates is always false (i.e., it does not “pick” any object). The situation is similar to the previous case, but here we get a value of 1 for ζ where {a mathematical formula}r1=r2 or where there is a block violation for some {a mathematical formula}wi block with min aggregation.Consider any valuation {a mathematical formula}ζp to the prefix of variables {a mathematical formula}T,y1,y2,x1,…,xℓ, {a mathematical formula}w1,w2, {a mathematical formula}m1,m2, which is block consistent on {a mathematical formula}w1,w2 and any ζ which is an extension of this valuation, has {a mathematical formula}r1≠r2, and any valuation for the other variables. We have two cases: if ζ is in group 1 the map is 0 because the unary predicate test fails, and if ζ is in group 2 the map is the default value of the first violated block {a mathematical formula}wi. Now, because there is at least one group 1 valuation, we can argue inductively backwards from k that all aggregations from k to 3 yield 0, and the same holds for the minimization over z. Next, because the value is 0 for {a mathematical formula}r1≠r2, the minimization over r yields 0 for {a mathematical formula}ζp. Considering any variants of {a mathematical formula}ζp which are not block consistent on {a mathematical formula}w1,w2 but otherwise identical we see that their value is also 0. As a result all remaining aggregations yield 0.
       </list-item>
       <list-item label="•">
        Next consider the case where the previous two conditions are satisfied but where one of the unary predicates holds for two or more objects. The argument is identical to the previous case, except that ζ has the violating pair for {a mathematical formula}r1,r2 (instead of any {a mathematical formula}r1≠r2).
       </list-item>
       <list-item label="•">
        Next consider any interpretation that has exactly {a mathematical formula}ℓ+3 objects and where the unary predicates identify the objects corresponding to {a mathematical formula}T,y1,y2,x1,…,xℓ but where {a mathematical formula}q() is not symmetric. In this case we consider a valuation {a mathematical formula}ζp to the prefix of variables {a mathematical formula}T,y1,y2,x1,…,xℓ, {a mathematical formula}w1,w2, and extensions ζ that have the violating pair for {a mathematical formula}m1,m2. As above, starting with ζ that are block consistent on {a mathematical formula}w1,w2 and have {a mathematical formula}r1≠r2 we can argue that the aggregations down to m yield 0, and as a result that the aggregation over m yields 0. As {a mathematical formula}ζp is arbitrary, it follows that the final value is 0.
       </list-item>
       <list-item label="•">
        The only remaining cases are interpretations that are illegal only because the {a mathematical formula}q() simulation of {a mathematical formula}PT() or {a mathematical formula}Pxi() is not as required. In this case, the same argument as in the 2nd item in this list shows that the value is 0.
       </list-item>
      </list>
      <paragraph>
       Therefore, if I is illegal then {a mathematical formula}MAPB1(I)=0. Consider next any legal interpretation and the intended valuation {a mathematical formula}ζp to {a mathematical formula}T,y1,y2,x1,…,xℓ. For any group 1 extension of this valuation and any valuation of the variables {a mathematical formula}m,z,r the diagram yields 1. Therefore, we can argue inductively that all {a mathematical formula}wi aggregations down to {a mathematical formula}w3 yield 1, and the min aggregations over {a mathematical formula}m,z,r yield 1 for {a mathematical formula}ζp. Therefore, the max aggregation over {a mathematical formula}T,y1,y2,x1,…,xℓ yields 1, and {a mathematical formula}MAPB1(I)=1. This completes the proof of C1.The diagram B is obtained by adding the clause blocks below the {a mathematical formula}q() tests of {a mathematical formula}B1. The clause blocks have the same structure as above but they use {a mathematical formula}q() instead of {a mathematical formula}PT() and {a mathematical formula}Pxi(). This is shown in Fig. 33. The final diagram for B is shown in Fig. 34 and it has the same aggregation function as {a mathematical formula}B1. Note that the diagram is also sorted using the same order as in {a mathematical formula}B1 with the addition that {a mathematical formula}xi≺V(i1,i2). We next show that:
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}MAPB(I)=1 if and only if I is legal and {a mathematical formula}Q2x2…Qkxkf((x1=α),x2,…,xk)=1 where I embeds the substitution {a mathematical formula}x1=α.
       </list-item>
      </list>
      <paragraph>
       The property {a mathematical formula}C2′ is slightly different from C2 above, in that it argues directly over B and includes the condition on legal interpretations. Nonetheless, the same argument from the simple case can be used to show that C1 and {a mathematical formula}C2′ imply that {a mathematical formula}B1 and B are equivalent iff the QBF is satisfied.To prove the claim first note that by the construction B adds more tests on the path to a 1 leaf of {a mathematical formula}B1 and does not add any other paths to a value of 1. Therefore, for any I and any ζ, if {a mathematical formula}MAPB(I,ζ)=1 then {a mathematical formula}MAPB1(I,ζ)=1 and as a result if {a mathematical formula}MAPB(I)=1 then {a mathematical formula}MAPB1(I)=1. Therefore, by C1, if {a mathematical formula}MAPB(I,ζ)=1 then I is legal. Next, consider any legal I and any unintended valuation {a mathematical formula}ζp for the prefix {a mathematical formula}T,y1,y2,x1,…,xℓ. Any valuation extending this prefix with a block consistent assignment for all {a mathematical formula}wi and with {a mathematical formula}r1≠r2 will yield a zero. Therefore, the minimization over {a mathematical formula}r1,r2 will yield 0 for this prefix, and so will the minimization over {a mathematical formula}m1,m2 and maximization over {a mathematical formula}w1,w2. We conclude that the aggregated value for this prefix is 0. Therefore, if {a mathematical formula}MAPB(I)=1 and thus the max aggregation over these prefix variables yields 1, it must be through the intended valuation {a mathematical formula}ζp for the prefix {a mathematical formula}T,y1,y2,x1,…,xℓ.However, when {a mathematical formula}T,y1,y2,x1,…,xℓ are fixed to their intended values, the portions of the diagram testing for {a mathematical formula}≤q+3 objects, the uniqueness of special objects {a mathematical formula}T,y1,y2,x1,…,xk, the symmetry of {a mathematical formula}q() and its simulation of {a mathematical formula}PT() and {a mathematical formula}Pxi do not affect the final value in the sense that a valuation reaching them always continues to the next block. Therefore, if we restrict attention to such valuations we can shrink B by removing these blocks and still obtain the same aggregated value. Now we observe that there is a 1–1 correspondence between valuations and values of the resulting B to valuations and values of {a mathematical formula}B2 in the simple construction (where we extend the notion of block consistent to enforce that {a mathematical formula}wi bind to {a mathematical formula}y1,y2). Therefore, the claim holds by C2 of the simple construction.  □
      </paragraph>
     </paragraph>
     <paragraph>
      The result for GFODD Value is similar to the FODD case.
     </paragraph>
     <paragraph label="Proof">
      GFODD Value for diagrams with aggregation depth k (where{a mathematical formula}k≥2) is{a mathematical formula}Σk+1P-complete.The proof of Theorem 16 goes through almost directly and requires only a slight wording variation. For membership we get the bound on interpretation size by the assumption on the input; then the algorithm is the same.For the reduction, we use Theorem 1 to calculate {a mathematical formula}B=Apply(B1,B2,+). As stated in that theorem, we can mesh together the aggregation lists of {a mathematical formula}B1 and {a mathematical formula}B2 interleaving the max and min blocks from each diagram without increasing quantifier depth and the diagram B has the same quantifier prefix and depth as those of {a mathematical formula}B1 and {a mathematical formula}B2.  □
     </paragraph>
     <paragraph>
      Unlike max-k-alternating GFODDs, for min diagrams the search for a satisfying interpretation cannot be absorbed into the first aggregation operator. This fact pushes the problem one level higher in the hierarchy.
     </paragraph>
     <paragraph label="Theorem 24">
      GFODD Satisfiability for min-k-alternating GFODDs (where{a mathematical formula}k≥2) is{a mathematical formula}Σk+1P-complete.
     </paragraph>
     <paragraph label="Proof Sketch">
      The hardness result uses a slight modification of the equivalence proof, which we sketch next. One can verify that all the details of the modification go through to establish the result.In particular, we reduce QBF satisfiability with {a mathematical formula}k≥3 alternations of quantifiers to satisfiability of min-{a mathematical formula}(k−1)-alternating GFODDs. Here we assume a QBF whose first quantifier is ∃, that is has the form {a mathematical formula}∃1x1…Qkxkf(x1,x2,…,xk) where {a mathematical formula}xi refers to a set of variables. We build {a mathematical formula}B1, {a mathematical formula}B2 and B exactly as in Theorem 22 with one exception: the leaf values on the diagram that checks for block consistency are flipped from the previous construction (because the corresponding aggregation operators are switched). The reduction still provides {a mathematical formula}B1, {a mathematical formula}B2, and {a mathematical formula}B=Apply(B1,B2,∧) such that the following claims hold:
      <list>
       For all I, {a mathematical formula}MAPB1(I)=1 if and only if I is legal.If I is legal and it embeds the substitution {a mathematical formula}x1=α then {a mathematical formula}MAPB2(I)=1 if and only if {a mathematical formula}Q2x2…Qkxkf((x1=α),x2,…,xk)=1.We then output the diagram
      </list>
      <paragraph>
       The construction to handle ordering and edge removal structure can be similarly modified for the current proof.  □
      </paragraph>
     </paragraph>
     <paragraph>
      Up to this point, all hardness proof in the paper use a signature without any constants, i.e., we use equality and unary and binary predicates. For min-GFODDs (the case {a mathematical formula}k=1) the use of constants affects the complexity of the satisfiability problem. In particular, for a signature without constants, if a min-GFODD is satisfied by interpretation I, then it is satisfied by the sub-interpretation of I with just one object (any object in I will do). Moreover, given diagram B and a specific I with one object, model evaluation is in P because there is only one valuation to consider. Therefore, in this case satisfiability is in NP: we can guess the interpretation (i.e. truth values of predicates) and evaluate {a mathematical formula}MAPB(I) in polynomial time. On the other hand, if we allow constants in the signature the problem follows the same scheme as above and is {a mathematical formula}Σ2P-complete.
     </paragraph>
     <paragraph label="Theorem 25">
      GFODD Satisfiability for min-GFODDs is{a mathematical formula}Σ2P-complete.
     </paragraph>
     <paragraph label="Proof Sketch">
      Membership is as in the general case. For hardness, we use the construction in the reduction of the previous proof which yields a GFODD with aggregation {a mathematical formula}min⁎⁡max⁎ (i.e., the portion starting with {a mathematical formula}w3 does not exist) where the max variables are {a mathematical formula}T,y1,y2,x1,…,xℓ. We then turn these variables into constants and remove the max aggregation to yield a min GFODD. One can verify that the proof of Theorem 24 goes through with very minor changes.  □
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>