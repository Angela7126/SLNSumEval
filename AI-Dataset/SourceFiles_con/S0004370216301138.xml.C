<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    The Configurable SAT Solver Challenge (CSSC).
   </title>
   <abstract>
    It is well known that different solution strategies work well for different types of instances of hard combinatorial problems. As a consequence, most solvers for the propositional satisfiability problem (SAT) expose parameters that allow them to be customized to a particular family of instances. In the international SAT competition series, these parameters are ignored: solvers are run using a single default parameter setting (supplied by the authors) for all benchmark instances in a given track. While this competition format rewards solvers with robust default settings, it does not reflect the situation faced by a practitioner who only cares about performance on one particular application and can invest some time into tuning solver parameters for this application. The new Configurable SAT Solver Competition (CSSC) compares solvers in this latter setting, scoring each solver by the performance it achieved after a fully automated configuration step. This article describes the CSSC in more detail, and reports the results obtained in its two instantiations so far, CSSC 2013 and 2014.
   </abstract>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The propositional satisfiability problem (SAT) is one of the most prominent problems in AI. It is relevant both for theory (having been the first problem proven to be NP-hard [27]) and for practice (having important applications in many fields, such as hardware and software verification [19], [72], [26], test-case generation [79], [24], AI planning [53], [54], scheduling [28], and graph coloring [83]). The SAT community has a long history of regularly assessing the state of the art via competitions [50]. The first SAT competition dates back to the year 2002 [76], and the event has been growing over time: in 2014, it had a record participation of 58 solvers by 79 authors in 11 tracks [13].
     </paragraph>
     <paragraph>
      In practical applications of SAT, solvers can typically be adjusted to perform well for the specific type of instances at hand, such as software verification instances generated by a particular static checker on a particular software system [3], or a particular family of bounded model checking instances [85]. To support this type of customization, most SAT solvers already expose a range of command line parameters whose settings substantially affect most parts of the solver. Solvers typically come with robust default parameter settings meant to provide good all-round performance, but it is widely known that adjusting parameter settings to particular target instance classes can yield orders-of-magnitude speedups [42], [55], [81]. Current SAT competitions do not take this possibility of customizing solvers into account, and rather evaluate solver performance with default parameters.
     </paragraph>
     <paragraph>
      Unlike the SAT competition, the Configurable SAT Solver Challenge (CSSC) evaluates SAT solver performance after application-specific customization, thereby taking into account the fact that effective algorithm configuration procedures can automatically customize solvers for a given distribution of benchmark instances. Specifically, for each type of instances T and each SAT solver S, an automated fixed-time offline configuration phase determines parameter settings of S optimized for high performance on T. Then, the performance of S on T is evaluated with these settings, and the solver with the best performance wins.
     </paragraph>
     <paragraph>
      To avoid a potential misunderstanding, we note that for winning the competition, only solver performance after configuration counts, and that it does not matter how much performance was improved by configuration. As a consequence, in principle, even a parameterless solver could win the CSSC if it was very strong: it would not benefit from configuration, but if it nevertheless outperformed all solvers that were specially configured for the instance families in a given track, it would still win that track. (In practice, we have not observed this, since the improvements resulting from configuration tend to be large.)
     </paragraph>
     <paragraph>
      The competition conceptually most closely related to the CSSC is the learning track of the international planning competition (IPC, see, e.g., the description by Fern et al. [31],{sup:1} which also features an offline time-limited learning phase on training instances from a given planning domain and an online testing phase on a disjoint set of instances from the same domain. The main difference between this IPC learning track and the CSSC (other than their focus on different problems) is that in the IPC learning track every planner uses its own learning method, and the learning methods thus vary between entries. In contrast, in the CSSC, the corresponding customization process is part of the competition setup and uses the same algorithm configuration procedure for each submitted solver. Our approach to evaluating solver performance after configuration could of course be transferred to any other competition. (In fact, the 2014 IPC learning track for non-portfolio solvers was won by FastDownward-SMAC[75], a system that employs a similar combination of general algorithm configuration and a highly parameterized solver framework as we do in the CSSC.)
     </paragraph>
     <paragraph>
      In the following, we first describe the criteria we used for the design of the CSSC (Section 2). Next, we provide some background on the automated algorithm configuration methods we used when running the competition (Section 3). Then, we discuss the two CSSCs we have held so far (in 2013 and 2014); we discuss each of these competitions in turn (Sections 4 and 5), including the specific benchmarks used, the participating solvers, and the results. We describe two main insights that we obtained from these results:
     </paragraph>
     <list>
      <list-item label="1.">
       In many cases, automated algorithm configuration found parameter settings that performed much better than the solver defaults, in several cases yielding average speedups of several orders of magnitude.
      </list-item>
      <list-item label="2.">
       Some solvers benefited more from automated configuration than others; as a result, the ranking of algorithms after configuration was often substantially different from the ranking based on the algorithm defaults (as, e.g., measured in the SAT competition).
      </list-item>
     </list>
     <paragraph>
      Finally, we analyze various aspects of these results (Section 6) and discuss the implications we see for future algorithm development (Section 7).
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Design criteria for the CSSC
     </section-title>
     <paragraph>
      We organized the CSSC 2013 and 2014 in coordination with the international SAT competition and presented them in the competition slots at the 2013 and 2014 SAT conferences (as well as in the 2014 FLoC Olympic Games, in which all SAT-related competitions took part). We coordinated solver submission deadlines with the SAT competition to minimize overhead for participants, who could submit their solver to the SAT competition using default parameters and then open up their parameter spaces for the CSSC.
     </paragraph>
     <paragraph>
      We designed the CSSC to remain close to the international SAT competition's established format; in particular, we used the same general categories: industrial, crafted, and random, and, in 2014 also random satisfiable. Furthermore, we used the same input and output formats, the SAT competition's mature code for verifying correctness of solver outputs (only for checking models of satisfiable instances; we did not have a certified UNSAT track), and the same scoring function (number of instances solved, breaking ties by average runtime).
     </paragraph>
     <paragraph>
      The main way our setup differed from that of the SAT competition was that we used a relatively small budget of five minutes per solver run. We based this choice partly on the fact that many solvers have runtime distributions with rather long tails (or even heavy tails [35]), and that practitioners often use many instances and relatively short runtimes to benchmark solvers for a new application domain. There is also evidence that SAT competition results would remain quite similar if based on shorter runtimes, but not if based on fewer instances [44]. Therefore, in order to achieve more robust performance within a fixed computational budget, we chose to use many test instances (at least 250 for each benchmark) but relatively low runtime cutoffs per solver run (five minutes). (We also note that a short time limit of five minutes has already been used in the agile track of the 2014 International Planning Competition.) Due to constraints imposed by our computational infrastructure, we used a memory limit of 3GB for each solver run.
     </paragraph>
     <paragraph>
      To simulate the situation faced by practitioners with limited computational resources, we limited the computational budget for configuring a solver on a benchmark with a given configuration procedure to two days on 4 or 5 cores (in 2014 and 2013, respectively). Our results are therefore indicative of what could be obtained by performing configuration runs over the weekend on a modern desktop machine.
     </paragraph>
     <section label="2.1">
      <section-title>
       Controlled execution of solver runs
      </section-title>
      <paragraph>
       Since all configuration procedures ran in an entirely automated fashion, they had to be robust against any kind of solver failure (segmentation faults, unsupported combinations of parameters, wrong results, infinite loops, etc.). We handled all such conditions in a generic wrapper script that used Olivier Roussel's runsolver tool [73] to limit runtime and memory, and counted any errors or limit violations as timeouts at the maximum runtime of 300 seconds. We also kept track of the rich solver runtime data we gathered in our configuration runs and made it publicly available on the competition website.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Choice of configuration pipeline
      </section-title>
      <paragraph>
       To avoid bias arising from our choice of algorithm configuration method, we independently used all three state-of-the-art methods applicable for runtime optimization (ParamILS[47], GGA[1], and SMAC[46], as described in detail in Section 3). We evaluated the configurations resulting from all configuration runs on the entire training data set and selected the configuration with the best training performance. We then executed only this configuration on the test set to determine the performance of the configured solver. Except where specifically noted otherwise, all performance data we report in this article is for this optimized configuration on previously unseen test instances from the respective benchmark set.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Pre-submission bug fixing
      </section-title>
      <paragraph>
       As part of the submission package, we provided solver authors with our configuration pipeline, so that they could run it themselves to identify bugs in their solver before submission (e.g., problems due to the choice of non-default parameters). We also provided some trivial benchmark sets for this pre-submission preparation, which were not part of the competition.
      </paragraph>
      <paragraph>
       We did not offer a bug fixing phase after solver submission, except that we ran a very simple configuration experiment (10 minutes on trivial instances) to verify that the setup of all participants was correct.
      </paragraph>
     </section>
     <section label="2.4">
      <section-title>
       Choice of benchmarks
      </section-title>
      <paragraph>
       We chose the benchmark families for the CSSC to be relatively homogeneous in terms of the origin and/or construction process of instances in the same family. Typically, we selected benchmark families that are neither too easy (since speedups are less interesting for easy instances), nor too hard (so that solvers could solve a large fraction of instances within the available computational budgets). We aimed for benchmark sets of which at least 20–40% could be solved within the maximum runtime on a recent machine by the default configuration of a SAT solver that would perform reasonably well in the SAT competition. We also aimed for benchmark sets with a sufficient number of instances to safeguard against over-tuning; in practice, the smallest datasets we used had 500 instances: 250 for training and 250 for testing.
      </paragraph>
      <paragraph>
       We did not disclose which benchmark sets we used until the competition results were announced. While we encouraged competition entrants to also contribute benchmarks, we made sure to not substantially favor any solver by using such contributed benchmarks.
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Automated algorithm configuration procedures
     </section-title>
     <paragraph>
      The problem of finding performance-optimizing algorithm parameter settings arises for many computational problems. In recent years, the AI community has developed several dedicated systems for this general algorithm configuration problem [47], [1], [57], [46].
     </paragraph>
     <paragraph>
      We now describe this problem more formally. Let A be an algorithm having n parameters with domains {a mathematical formula}Θ1,…,Θn. Parameters can be real-valued (with domains {a mathematical formula}[a,b], where {a mathematical formula}a,b∈R and {a mathematical formula}a&lt;b), integer-valued (with domains {a mathematical formula}[i,j], where {a mathematical formula}i,j∈Z and {a mathematical formula}i&lt;j), or categorical (with finite unordered domains, such as {red, blue, green}). Parameters can also be conditional on an instantiation of other (so-called parent) parameters; as an example, consider the parameters of a heuristic mechanism h, which are completely ignored unless h is chosen to be used by means of another, categorical parameter. Finally, some combinations of parameter instantiations can be labeled as forbidden.
     </paragraph>
     <paragraph>
      Algorithm A's configuration spaceΘ then consists of all possible combinations of parameter values: {a mathematical formula}Θ=Θ1×⋯×Θn. We refer to elements {a mathematical formula}θ=〈θ1,…,θn〉 of this configuration space as parameter configurations, or simply configurations. Given a benchmark set Π and a performance metric {a mathematical formula}m(θ,π) capturing the performance of configuration {a mathematical formula}θ∈Θ on problem instance {a mathematical formula}π∈Π, the algorithm configuration problem then aims to find a configuration {a mathematical formula}θ∈Θ that minimizes m over Π, i.e., that minimizes{sup:2}{a mathematical formula} In the CSSC, the specific metric m we optimized was penalized average runtime (PAR-10), which counts runs that exceed a maximal cutoff time {a mathematical formula}κmax without solving the given instance as {a mathematical formula}10⋅κmax. We terminated individual solver runs as unsuccessful after {a mathematical formula}κmax=300 seconds.
     </paragraph>
     <paragraph>
      We refer to an instance of the algorithm configuration problem as a configuration scenario and to a method for solving the algorithm configuration problem as a configuration procedure (or a configurator), in order to avoid confusion with the solver to be optimized (which we refer to as the target algorithm) and the problem instances the solver is being optimized for.
     </paragraph>
     <paragraph>
      Algorithm configuration has been demonstrated to be very effective for optimizing various SAT solvers in the literature. For example, Hutter et al. [42] configured the algorithm Spear [5] on formal verification instances, achieving a 500-fold speedup on software verification instances generated with the static checker Calysto [3] and a 4.5-fold speedup on IBM bounded model checking instances by Zarpas [85]. Algorithm configuration has also enabled the development of general frameworks for stochastic local search SAT solvers that can be automatically instantiated to yield state-of-the-art performance on new types of instances; examples for such frameworks are SATenstein [55] and Captain Jack [81].
     </paragraph>
     <paragraph>
      While all of these applications used the local-search based algorithm configuration method ParamILS[47], in the CSSC we wanted to avoid bias that could arise from commitment to one particular algorithm configuration method and thus used all three existing general algorithm configuration methods for runtime optimization: ParamILS, GGA[1], and SMAC[46].{sup:3} We refer the interested reader to Appendix B for details on each of these configurators. Here, we only mention some details that were important for the setup of the CSSC:
     </paragraph>
     <list>
      <list-item label="•">
       ParamILS does not natively support parameters specified only as real- or integer-valued intervals, but requires all parameter values to be listed explicitly; for simplicity, we refer to the transformation used to satisfy this requirement as discretization. When multiple parameter spaces were available for a solver, we only ran ParamILS on the discretized version, whereas we ran GGA and SMAC on both the discretized and the non-discretized versions.
      </list-item>
      <list-item label="•">
       ParamILS and SMAC have been shown to benefit substantially from multiple independent runs, since they are randomized algorithms. Given k cores, the usual approach is simply to execute k independent configurator runs and pick the configuration from the one with best performance on the training set. GGA, on the other hand, can use multiple cores on a single machine, and in fact requires these to run effectively. Therefore, given k available cores per configuration approach, we used k independent runs of each ParamILS and SMAC, and one run using all k cores for GGA.
      </list-item>
      <list-item label="•">
       GGA could not handle the complex parameter conditionalities found in some solvers; for those solvers, we only ran ParamILS and SMAC.
      </list-item>
     </list>
    </section>
    <section label="4">
     <section-title>
      The Configurable SAT Solver Challenge 2013
     </section-title>
     <paragraph>
      The first CSSC{sup:4} was held in 2013. It featured three tracks mirroring those of the SAT competition: Industrial SAT+UNSAT, crafted SAT+UNSAT, and Random SAT+UNSAT. Table 1 lists the benchmark families we used in each of these tracks, all of which are described in detail in Appendix A. Within each track, we used the same number of test instances for each benchmark family, thereby weighting each equally in our analysis.
     </paragraph>
     <section label="4.1">
      <section-title>
       Participating solvers and their parameters
      </section-title>
      <paragraph>
       Table 2 summarizes the solvers that participated in the CSSC 2013, along with information on their configuration spaces. The eleven submitted solvers ranged from complete solvers based on conflict-directed clause learning (CDCL; [10]) to stochastic local search (SLS; [40]) solvers. The degree of parameterization varied substantially across these submitted solvers, from 2 to 241 parameters. We briefly discuss the main features of the solvers' parameter configuration spaces, ordering solvers by their number of parameters.
      </paragraph>
      <paragraph>
       Gnovelty+GCa and Gnovelty+GCwa[29] are closely related SLS solvers. Both have two numerical parameters: the probability of selecting false clauses randomly and the probability of smoothing clause weights. The parameters were pre-discretized by the solver developer to 11 and 10 values, yielding 110 possible combinations.
      </paragraph>
      <paragraph>
       Gnovelty+PCL[29] is an SLS solver with five parameters: one binary parameter (determining whether the stagnation path is dynamic or static) and four numerical parameters: the length of the stagnation path, the size of the time window storing stagnation paths, the probability of smoothing stagnation weights, and the probability of smoothing clause weights. All numerical parameters were pre-discretized to ten values each by the solver developer, yielding 20 000 possible combinations.
      </paragraph>
      <paragraph>
       Simpsat[36] is a CDCL solver based on Cryptominisat[77], which adds additional strategies for explicitly handling XOR constraints [37]. It has five numerical parameters that govern both these XOR constraint strategies and the frequency of random decisions. All parameters were pre-discretized by the solver developer, yielding 2 400 possible combinations.
      </paragraph>
      <paragraph>
       Sat4j[14] is full-featured library of solvers for Boolean satisfiability and optimization problems. For the contest, it applied its default CDCL SAT solver with ten exposed parameters: four categorical parameters deciding between different restart strategies, phase selection strategies, simplifications, and cleaning; and six numerical parameters pre-discretized by its developer.
      </paragraph>
      <paragraph>
       Solver43[6] is a CDCL solver with 12 parameters: three categorical parameters concerning sorting heuristics used in bounded variable elimination, in definitions and in adding blocked clauses; and nine numerical parameters concerning various frequencies, factors, and limits. All parameters were pre-discretized by the solver developer.
      </paragraph>
      <paragraph>
       Forl-nodrup[78] is a CDCL solver with 44 parameters. Most notably, these control variable selection, Boolean propagation, restarts, and learned clause removal. About a third of the parameters are numerical (particularly most of those concerning restarts and learned clause removal); all parameters were pre-discretized by the solver developer.
      </paragraph>
      <paragraph>
       Clasp-2.1.3[33] is a solver for the more general answer set programming (ASP) problem, but it can also solve SAT, MAXSAT and PB problems. As a SAT solver, Clasp-2.1.3 is a CDCL solver with 83 parameters: 7 for pre-processing, 14 for the variable selection heuristic, 18 for the restart policy, 34 for the deletion policy, and 10 for a variety of other uses. The configuration space is highly conditional, with several top-level parameters enabling or disabling certain strategies. Clasp-2.1.3 exposes both a mixed continuous/discrete parameter configuration space and a manually-discretized one.
      </paragraph>
      <paragraph>
       Riss3g[63] is a CDCL solver with 125 parameters. These include 6 numerical parameters from MiniSAT [30], 10 numerical parameters from Glucose [2], 17 mostly numerical Riss3G parameters, and 92 parameters controlling preprocessing/inprocessing performed by the integrated Coprocessor [62]. The inprocessor parameters resemble those in Lingeling[16], emphasizing blocked clause elimination [51], bounded variable addition [65], and probing [61]. About 50 of the parameters are Boolean, and most others are numerical parameters pre-discretized by the solver developer. The parameter space is highly conditional, with inprocessor parameters dependent on a switch turning them on alongside various other dependencies. Indeed, there are only 18 unconditional parameters. Finally, there are also seven forbidden parameter combinations that ascertain various switches are turned on if inprocessing is used.
      </paragraph>
      <paragraph>
       Riss3gExt[63] is an experimental extension of Riss3g. It exposes all of the parameters previously discussed for Riss3g, along with an additional 11 Riss3G parameters and 57 inprocessing parameters. Its developer implemented all of these extensions in one week and did not have time for extensive testing before the CSSC; therefore, he submitted Riss3gExt as closed source, making it ineligible for medals. We discuss the results of this closed-source solver separately, in Appendix C.
      </paragraph>
      <paragraph>
       Lingeling[16] is a CDCL solver with 241 parameters (making it the solver with the largest configuration space in the CSSC 2013). 102 of these parameters are categorical, and the remaining 139 are integer-valued (76 of them with the trivial upper bound of max-integer, {a mathematical formula}231−1). Lingeling parameterizes many details of the solution process, including probing and look-ahead (about 25 mostly numerical parameters), blocked clause elimination and bounded variable elimination (about 20 mostly categorical parameters each), glue clauses (about 15 mostly numerical parameters), and a host of other mechanisms parameterized by about 5–10 parameters each. Lingeling exposes its full parameter space, a discretized version of all parameters, and a subspace of only the categorical parameters (102 of them).
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Configuration pipeline
      </section-title>
      <paragraph>
       We executed this competition on the QDR partition of the Compute Canada Westgrid cluster Orcinus. Each node in this cluster was provisioned with 24 GB memory and two 6-core, 2.66 GHz Intel Xeon X5650 CPUs with 12 MB L2 cache each, and ran Red Hat Enterprise Linux Server 5.5 (kernel 2.6.18, glibc 2.5).
      </paragraph>
      <paragraph>
       In this first edition of the CSSC, we were unfortunately unable to run GGA. This was because it requires multiple cores for effective runtime minimization, and the respective multiple-core jobs we submitted on the Orcinus cluster were stuck in the queue for months without getting started. (Single-core runs, on the other hand, were often scheduled within minutes.)
      </paragraph>
      <paragraph>
       We thus limited ourselves to using ParamILS for the discretized parameter space of each of the 11 solvers and SMAC for each of the parameter spaces that solver authors submitted (as discussed above, 9 submissions with one parameter space, 1 submission with two, and 1 submission with three, i.e., 14 in total). For each of the nine benchmark families, this gave rise to 11 configuration scenarios for ParamILS and 14 for SMAC, for a total of 225 configuration scenarios. Since our budget for each configuration procedure was two CPU days on five cores (five independent runs of ParamILS and SMAC, respectively), the competition's configuration phase required a total of 2250 CPU days (just over 6 CPU years). Thanks to a special allocation on the Orcinus cluster, we were able to complete this phase within a week.
      </paragraph>
      <paragraph>
       Following standard practice, we then evaluated the configurations resulting from all configuration runs on the entire training data set and selected the configuration with the best training performance. We then executed only this configuration on the test set to assess the performance of the configured solver. This evaluation phase required much less time than the configuration phase.
      </paragraph>
      <paragraph>
       We note that all scripts we used for performing the configuration and analysis experiments were written in Ruby and are available for download on the competition website.
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       Results
      </section-title>
      <paragraph>
       For each the three tracks of CSSC 2013, we configured each of the eleven submitted solvers for each of the benchmark families within the track and aggregated results across the respective test instances. We show the winners in Table 3 and discuss the results for each track in the following sections. Additional details, tables, and figures are provided in an accompanying technical report [43].
      </paragraph>
      <paragraph>
       We remind the reader that the CSSC score only depends on how well the configured solver did and not on the difference between default and configured performance. We nevertheless still cover default performance prominently in the following results, in order to emphasize the impact configuration had and the difference between the CSSC and standard solver competitions (e.g., the SAT competition).
      </paragraph>
      <paragraph>
       {a mathematical formula}
      </paragraph>
      <section label="4.3.1">
       Results of the Industrial SAT+UNSAT track
       <paragraph>
        Our Industrial SAT+UNSAT track consisted of the four industrial benchmarks detailed in Appendix A.1: Bounded Model Checking 2008 (BMC)[15], Circuit Fuzz[23], Hardware Verification (IBM)[85], and SWV[4].
       </paragraph>
       <paragraph>
        {a mathematical formula}
       </paragraph>
       <paragraph>
        Fig. 1 visualizes the results of the configuration process for the winning solver Lingeling on these four benchmark sets. It demonstrates that even Lingeling, a highly competitive solver in terms of default performance, can be configured for improved performance on a wide range of benchmarks. We note that for the easy benchmark SWV, configuration sped up Lingeling by a factor of 20 (average runtime 3.3 s vs 0.16 s), and that for the harder Circuit Fuzz instances, it nearly halved the number of timeouts (39 vs 20). The improvements were smaller for more traditional hardware verification instances (IBM and BMC) similar to those used to determine Lingeling's default parameter settings.
       </paragraph>
       <paragraph>
        Table 4 summarizes the results of the ten solvers that were eligible for medals. From this table, we note that, like Lingeling, many other solvers benefited from configuration. Indeed, some solvers (in particular Forl-nodrup and Clasp-3.0.4-p8) benefited much more from configuration on the BMC instances, largely because their default performance was worse on this benchmark. On the other hand, Riss3g featured stronger default performance than Lingeling but did not benefit as much from configuration.
       </paragraph>
       <paragraph>
        Table 4 also aggregates results across the four benchmark families to yield the overall results for the Industrial SAT+UNSAT track. These results show that many solvers benefited substantially from configuration, and that some benefited more than others, causing the CSSC ranking to differ substantially from the ranking according to default solver performance; for instance, based on default performance, the overall winning solver, Lingeling, would have only ranked fourth.
       </paragraph>
      </section>
      <section label="4.3.2">
       Results of the crafted SAT+UNSAT track
       <paragraph>
        The crafted SAT+UNSAT track consisted of the two crafted benchmarks detailed in Appendix A.2: Graph Isomorphism (GI) and Low Autocorrelation Binary Sequence (LABS).
       </paragraph>
       <paragraph>
        Fig. 2 visualizes the improvements algorithm configuration yielded for the best-performing solver Clasp-3.0.4-p8 on these benchmarks. Improvements were particularly large on the GI instances, where algorithm configuration decreased the number of timeouts from 42 to 6. Table 5 summarizes the results we obtained for all solvers on these benchmarks, showing that configuration also substantially improved the performance of many other solvers. The table also aggregates results across both benchmark families to yield overall results for the crafted SAT+UNSAT track. While Forl-nodrup showed the best default performance and benefited substantially from configuration (#timeouts reduced from 135 to 98), Clasp-3.0.4-p8 improved even more (#timeouts reduced from 139 to 96).
       </paragraph>
       <paragraph>
        {a mathematical formula}
       </paragraph>
      </section>
      <section label="4.3.3">
       Results of the Random SAT+UNSAT track
       <paragraph>
        The Random SAT+UNSAT track consisted of three random benchmarks detailed in Appendix A.3: 5sat500, K3, and unif-k5. The instances in 5sat500 were all satisfiable, those in unif-k5 all unsatisfiable, and those in K3 were mixed.
       </paragraph>
       <paragraph>
        Table 6 summarizes the results for these benchmarks. It shows that the unif-k5 benchmark set was very easy for complete solvers (although configuration still yielded up to 4-fold speedups), that the K3 benchmark was also quite easy for the best solvers, and that only the SLS solvers could tackle benchmark 5sat500, with configuration making a big difference to performance.
       </paragraph>
       <paragraph>
        Here again, our aggregate results demonstrate that rankings were substantially different between the default and configured versions of the solvers: the three solvers with top default performance were ranked 4th to 6th in the CSSC, and vice versa. Fig. 3 visualizes the very substantial speedups achieved by configuration for the winning solver Clasp-3.0.4-p8 on K3 and unif-k5, and for the SLS solver Gnovelty+GCa on 5sat500.
       </paragraph>
      </section>
     </section>
    </section>
    <section label="5">
     <section-title>
      The Configurable SAT Solver Challenge 2014
     </section-title>
     <paragraph>
      The second CSSC{sup:5} was held in 2014. Compared to the inaugural CSSC in 2013, we improved the competition design in several ways:
     </paragraph>
     <list>
      <list-item label="•">
       We used a different computer cluster,{sup:6} enabling us to run GGA as one of the configuration procedures.
      </list-item>
      <list-item label="•">
       We added a Random SAT track to facilitate comparisons of stochastic local search solvers.
      </list-item>
      <list-item label="•">
       We dropped the (too easy) SWV benchmark family and introduced four new benchmark families, yielding a total of three benchmark families in each of the four tracks, summarized in Table 7 and described in detail in Appendix A.
      </list-item>
      <list-item label="•">
       We let solver authors decide which tracks their solver should run in.
      </list-item>
      <list-item label="•">
       For fairness, for each solver, we performed the same number of configuration experiments. (This is in contrast to 2013, where we performed the same number of configuration runs for every configuration space of every solver, which lead to a larger combined configuration budget for solvers submitted with multiple configuration spaces).
      </list-item>
      <list-item label="•">
       We kept track of all of the (millions of) solver runs performed during the configuration process and made all information about errors available to solver developers after the competition.
      </list-item>
     </list>
     <section label="5.1">
      <section-title>
       Participating solvers
      </section-title>
      <paragraph>
       The ten solvers that participated in the CSSC 2014 are summarized in Table 8; they included CDCL, SLS and hybrid solvers. These solvers differed substantially in their degree of parameterization, with the number of parameters ranging from 1 to 323. We briefly discuss the main features of each solver's parameter configuration space, ordering solvers by their number of parameters.
      </paragraph>
      <paragraph>
       DCCASat+march-rw[60] combines the SLS solver DCCASat with the CDCL solver march-rw. It was submitted to the Random SAT+UNSAT track. Its only (continuous) parameter is the time ratio of the SLS solver. This parameter was pre-discretized to nine values.
      </paragraph>
      <paragraph>
       CSCCSat2014[59], [60] is an SLS solver based on configuration checking and dynamic local search methods. It was submitted to the Random SAT track. It features 3 continuous parameters that were pre-discretized to 7, 9, and 9 values each, giving rise to a total configuration space of 567 possible parameter configurations. The parameters control the weighting of the dynamic local search part and the probabilities for the linear make functions used in the random walk steps.
      </paragraph>
      <paragraph>
       ProbSAT[9] is a simple SLS solver based on probability distributions that are built from simple features, such as the make and break of variables [9]. ProbSAT's 9 parameters control the type and the parameters of the probability distribution, as well as the type of restart. ProbSAT was submitted to the Random SAT track.
      </paragraph>
      <paragraph>
       Minisat-HACK-999ED[71] is a CDCL solver; it was submitted to all tracks. It has one categorical parameter (whether or not to use the Luby restarting strategy) and 9 numerical parameters fine-tuning the Luby and geometric restart strategies, as well as controlling clause removal and the treatment of glue clauses. 3 of these 9 numerical parameters are conditional on the choice of the Luby restart strategy, and all numerical parameters were pre-discretized by the solver developer. There are also 3 forbidden parameter combinations derived from a weak inequality constraint between two parameter values.
      </paragraph>
      <paragraph>
       YalSAT[17] is an SLS solver; it was submitted to the tracks crafted SAT+UNSAT and Random SAT. It has 27 parameters that parameterize the solver's restart component (7 parameters) amongst many other components. 11 of the 27 parameters are numerical, with 6 of them having a trivial upper bound of max-integer ({a mathematical formula}231−1).
      </paragraph>
      <paragraph>
       Cryptominisat[77] is a CDCL solver; it was submitted to the tracks Industrial SAT+UNSAT and crafted SAT+UNSAT. It has 29 parameters that control restarts (6 mostly numerical parameters), clause removal (7 mostly numerical parameters), variable branching and polarity (3 parameters each), simplification (5 parameters), and several other mechanisms. 2 of the numerical parameters further parameterize the blocking restart mechanism and are thus conditional on that mechanism being selected.
      </paragraph>
      <paragraph>
       Clasp-3.0.4-p8[33] is a solver for the more general answer set programming (ASP) problem, but it can also solve SAT, MAXSAT and PB problems. It is fundamentally similar to the solver submitted in 2013; changes in the new version focused on the ASP solving part rather than the SAT solving part. As a SAT solver, Clasp-3.0.4-p8 has 75 parameters, of which 7 control preprocessing, 14 variable selection, 19 the restart policy, 28 the deletion policy and 7 miscellaneous other mechanisms. The configuration space is highly conditional, with several top-level parameters enabling or disabling certain strategies. Finally, there are also 2 forbidden parameter combinations that prevent certain combinations of deletion strategies. Clasp-3.0.4-p8 exposes both a mixed continuous/discrete parameter configuration space and a manually-discretized one. It was submitted to all tracks.
      </paragraph>
      <paragraph>
       Riss-4.27[64] is a CDCL solver submitted to all tracks except Random SAT. Compared to the 2013 version Riss3g, it almost doubled its number of parameters, yielding 214 parameters organized into 121 simplification and 93 search parameters. In particular, it added many new preprocessing and inprocessing techniques, including XOR handling (via Gaussian elimination [37]), and extracting cardinality constraints [20]. Roughly half of the simplification parameters and a third of the search parameters are categorical (in both cases most of the categoricals are binary). The simplification parameters comprise about 20 Boolean switches for preprocessing techniques and about 100 in-processor parameters, prominently including blocked clause elimination, bounded variable addition, equivalence elimination [34], numerical limits, probing, symmetry breaking, unhiding [39], Gaussian elimination, covered literal elimination [66], and even some stochastic local search. The search parameters parameterize a wide range of mechanisms including variable selection, clause learning and removal, restarts, clause minimization, restricted extended resolution, and interleaved clause strengthening.
      </paragraph>
      <paragraph>
       SparrowToRiss[8] combines the SLS solver Sparrow with the CDCL solver Riss-4.27 by first running Sparrow, followed by Riss-4.27. It was submitted to all tracks. SparrowToRiss's configuration space is that of Riss-4.27 plus 6 Sparrow parameters and 2 parameters controlling when to switch from Sparrow to Riss-4.27: the maximal number of flips for Sparrow (by default 500 million) and the CPU time for Sparrow (by default 150 seconds). Also, in contrast to Riss-4.27, SparrowToRiss does not pre-discretize its numerical parameters, but expresses them as 36 integer and 16 continuous parameters.
      </paragraph>
      <paragraph>
       Lingeling[17] is a successor to the 2013 version; it was submitted to the tracks Industrial SAT+UNSAT and crafted SAT+UNSAT. Compared to 2013, Lingeling's parameter space grew by roughly a third, to a total of 323 parameters (meaning that again, Lingeling was the solver with the most parameters). As in 2013, roughly 40% of these parameters were categorical and the rest integer-valued (many with a trivial upper bound of max-integer, {a mathematical formula}231−1). Notable groups of parameters that were introduced in the 2014 version include additional preprocessing/inprocessing options and new restart strategies.
      </paragraph>
     </section>
     <section label="5.2">
      <section-title>
       Configuration pipeline
      </section-title>
      <paragraph>
       In the CSSC 2014, we used the configurators ParamILS, GGA, and SMAC. For each benchmark and solver, we ran GGA and SMAC on the solver's full configuration space, which could contain an arbitrary combination of numerical and categorical parameters. We also ran all configurators on a discretized version of the configuration space (automatically constructed unless provided by the solver authors), yielding a total of five configuration approaches: ParamILS-discretized, GGA, GGA-discretized, SMAC, and SMAC-discretized. GGA could not handle the complex conditionals of some solvers; therefore, for these solvers we only ran ParamILS and the two SMAC variants.
      </paragraph>
      <paragraph>
       Due to the cost of running a third configurator on nearly every configuration scenario, we reduced the budget for each configuration approach from two CPU days on five cores in CSCC 2013 to two CPU days on four cores in CSSC 2014. In the case of ParamILS and SMAC, as in 2013, we used these four cores to perform four independent 2-day configurator runs. In the case of GGA, we performed one 2-day run using all four cores. We evaluated the configurations resulting from each of the 14 configuration runs (4 ParamILS-discretized, 4 SMAC-discretized, 4 SMAC, 1 GGA-discretized, and 1 GGA) on the entire training data set of the benchmark at hand and selected the configuration with the best performance. We then executed only this configuration on the benchmark's test set to determine the performance of the configured solver.
      </paragraph>
      <paragraph>
       In the four tracks of the CSSC (Industrial SAT+UNSAT, crafted SAT+UNSAT, Random SAT+UNSAT, Random SAT) we had 6, 6, 5, and 6 participating solvers, respectively, and since there were three benchmark families per track, we ended up with {a mathematical formula}(6+6+5+6)×3=72 pairs of solvers and benchmarks to configure them on. For each of these configuration scenarios, each of the 5 configuration approaches above required four cores for 2 days, yielding a total computational expense of {a mathematical formula}72×5×4×2=2880 CPU days (close to 8 CPU years). Thanks to a special allocation on the META cluster at the University of Freiburg, we were able to finish this process within 2 weeks.
      </paragraph>
      <paragraph>
       {a mathematical formula}
      </paragraph>
      <paragraph>
       We note that all scripts we used for performing the configuration and analysis experiments were written in Python (updated from Ruby in 2013) and are available for download on the competition website.
      </paragraph>
     </section>
     <section label="5.3">
      <section-title>
       Results
      </section-title>
      <paragraph>
       For each of the four tracks of CSSC 2014, we configured the solvers submitted to the track on each of the three benchmark families from that track and aggregated results across the respective test instances. We show the winners for each track in Table 9 and discuss the results in the following sections. Additional details, tables, and figures are provided in an accompanying technical report [48].
      </paragraph>
      <section label="5.3.1">
       Results of the Industrial SAT+UNSAT track
       <paragraph>
        The Industrial SAT+UNSAT track consisted of three industrial benchmarks detailed in Appendix A.1: BMC[15], Circuit Fuzz[23], and IBM[85]. Fig. 4 visualizes the results of applying algorithm configuration to the winning solver Lingeling on these three benchmark sets. It shows similar results as in the Industrial SAT+UNSAT track of CSSC 2013: Lingeling's strong default performance on ‘typical’ hardware verification benchmarks (IBM and BMC) could only be improved slightly by configuration, but much larger improvements were possible on less standard benchmarks, such as Circuit Fuzz.
       </paragraph>
       <paragraph>
        Table 10 summarizes the results for all six solvers that participated in the Industrial SAT+UNSAT track. These results demonstrate that, in contrast to Lingeling, several solvers (in particular, Clasp-3.0.4-p8, Riss-4.27, and SparrowToRiss) benefited largely from configuration on the BMC benchmark, but did not reach Lingeling's performance even after configuration. Minisat-HACK-999ED performed even better than Lingeling with its default parameters, but did not benefit from configuration as much as Lingeling (particularly on the Circuit Fuzz benchmark family).
       </paragraph>
       <paragraph>
        {a mathematical formula}
       </paragraph>
      </section>
      <section label="5.3.2">
       Results of the crafted SAT+UNSAT track
       <paragraph>
        The crafted SAT+UNSAT track consisted of the three crafted benchmarks detailed in Appendix A.2: Graph Isomorphism (GI), Low Autocorrelation Binary Sequence (LABS), and N-Rooks. Fig. 5 visualizes the improvements configuration yielded on these benchmarks for the best-performing solver, Clasp-3.0.4-p8. The effect of configuration was particularly large on the N-Rooks instances, where it reduced the number of timeouts from 81 to 0. Similar to the results from CSSC 2013, configuration also substantially improved performance on the GI instances, decreasing the number of timeouts from 43 to 9. In contrast to 2013, an unusual effect occurred for Clasp-3.0.4-p8 on the LABS instances, where the number of timeouts on the test set increased from 87 to 93 by configuration; we study the reasons for this in more detail in Section 6.1.
       </paragraph>
       <paragraph>
        Table 11 summarizes the results of all solvers on the crafted SAT+UNSAT track, showing that the performance of many other solvers also substantially improved on the benchmarks GI and N-Rooks, and only mildly (if at all) on the LABS benchmark. The aggregate results across these 3 benchmark families show that Lingeling had the best default performance, but only benefited mildly from configuration (#timeouts reduced from 115 to 109), whereas Clasp-3.0.4-p8 benefited much more from configuration and thus outperformed Lingeling after configuration (#timeouts reduced from 211 to 102). Once again, we note that the winning solver only showed mediocre performance based on its default: Clasp-3.0.4-p8 would have ranked 5th in a comparison based on default performance.
       </paragraph>
       <paragraph>
        {a mathematical formula}
       </paragraph>
      </section>
      <section label="5.3.3">
       Results of the Random SAT+UNSAT track
       <paragraph>
        The Random SAT+UNSAT track consisted of three random benchmarks detailed in Appendix A.3: 3cnf, K3, and unif-k5. The instances in unif-k5 are all unsatisfiable, while the other two sets contain both satisfiable and unsatisfiable instances. Fig. 6 visualizes the improvements achieved by configuration on these benchmarks for the best-performing solver Clasp-3.0.4-p8. Clasp-3.0.4-p8 benefited most from configuration on benchmark 3cnf, where it reduced the number of timeouts from 18 to 0. For the other benchmarks, it could already solve all instances in its default parameter configuration, but configuration helped reduce its average runtime by factors of 3 (K3) and 2 (unif-k5), respectively. Table 12 summarizes the results of all solvers for these benchmarks. We note that solver DCCASat+march-rw showed the best default performance, and that after configuration, it also solved all instances from the three benchmark sets, only ranking behind Clasp-3.0.4-p8 because the latter solved these instances faster.
       </paragraph>
      </section>
      <section label="5.3.4">
       Results of the Random SAT track
       <paragraph>
        The Random SAT track consisted of the three benchmarks detailed in Appendix A.3: 3sat1k, 5sat500 and 7sat90. Fig. 7 visualizes the improvements configuration achieved on these benchmarks for the best-performing solver ProbSAT. ProbSAT benefited most from configuration on benchmark 5sat500: its default did not solve a single instance in the maximum runtime of 300 seconds, while its configured version solved all instances in an average runtime below 2 seconds! Since timeouts at 300 s yield a PAR-10 score of 3000, the PAR-10 speedup factor on this benchmark was {a mathematical formula}1500, the largest we observed in the CSSC. On the other two scenarios, configuration was also very beneficial, reducing ProbSAT's number of timeouts from 24 to 0 (7sat90) and from 10 to 4 (3sat1k), respectively. Table 13 summarizes the results of all solvers for these benchmarks, showing that next to ProbSAT, only SparrowToRiss benefited from configuration. Neither of the CDCL solvers (Clasp-3.0.4-p8 and Minisat-HACK-999ED) solved a single instance in any of the three benchmarks (in either default or configured variants). For the other two SLS solvers, YalSAT and CSCCSat2014, the defaults were already well tuned for these benchmark sets. Indeed, we observed overtuning to the training sets in one case each: YalSAT for 3sat1k and CSCCSat2014 for 7sat90. Overall, the configurability of ProbSAT and SparrowToRiss allowed them to place first and second, respectively, despite their poor default performance (especially on 5sat500, where neither of them solved a single instance with default settings).
       </paragraph>
       <paragraph>
        {a mathematical formula}
       </paragraph>
      </section>
     </section>
    </section>
    <section label="6">
     <section-title>
      Post-competition analyses
     </section-title>
     <paragraph>
      While the previous sections focused on the results of the respective competitions, we now discuss several analyses we performed afterwards to study overarching phenomena and general patterns.
     </paragraph>
     <section label="6.1">
      <section-title>
       Why does configuration work so well and how can it fail?
      </section-title>
      <paragraph>
       Several practitioners have asked us why automated configuration can yield the large speedups over the default configuration we observed. We believe there are two key reasons for this:
      </paragraph>
      <list>
       <list-item label="•">
        No single algorithmic approach performs best on all types of benchmark instances; this is precisely the same reason that algorithm selection approaches (such as SATzilla [84] or 3S [52]) work so well.
       </list-item>
       <list-item label="•">
        Solver defaults are typically chosen to be robust across benchmark families. For any given benchmark family F, highly parameterized solvers can, however, typically be instantiated to exploit the idiosyncrasies of F substantially better. (These improvements only need to generalize to other instances from F, not to other benchmark families.)
       </list-item>
      </list>
      <paragraph>
       However, algorithm configuration does not necessarily work in all cases. For example, in the crafted SAT+UNSAT track of the CSSC 2014, we encountered a case in which the configured solver performed somewhat worse than the default solver: Clasp configured on benchmark family LABS timed out on 93 test instances, whereas its default only timed out on 87 test instances (see also Fig. 5b). Two obvious causes suggest themselves in the case of such a failure:
      </paragraph>
      <list>
       <list-item label="•">
        insufficiently long configuration runs (which can result in worse-than-default performance on the training set{sup:7}); and/or
       </list-item>
       <list-item label="•">
        overtuning on the training set that does not generalize to the test set.
       </list-item>
      </list>
      <paragraph>
       We investigated the configuration of Clasp on LABS further after the competition, and found that in this case both of these effects applied: In the CSSC, training performance slightly deteriorated ({a mathematical formula}86→87 timeouts); and the improved training performance we found with a larger configuration budget{sup:8} afterwards ({a mathematical formula}86→83 timeouts) also did not generalize to the test set ({a mathematical formula}87→88 timeouts).
      </paragraph>
      <paragraph>
       To contrast the conditions under which configuration can fail and under which it works well, we compared the configuration of Clasp on benchmarks LABS ({a mathematical formula}87→93 test timeouts in the CSSC) and N-Rooks ({a mathematical formula}81→0 test timeouts in the CSSC). For this analysis, we sampled 100 Clasp configurations uniformly at random and evaluated their PAR-10 training and test scores on both of the benchmarks; Fig. 8 shows the result. The first observation we make directly based on the figure is that for N-Rooks, about 20% of the random configurations outperform the default, whereas for LABS none of them do: the default is simply very good to start with for LABS and thus much harder to beat. Second, since several configurations are very good (i.e., fast) for N-Rooks, configurators can make progress much faster (and also take full advantage of adaptive capping to limit the time spent with poor configurations); indeed, in the CSSC the configurators managed to perform about 8 times more Clasp runs in the same time (2 days) for N-Rooks than for LABS (averaging about {a mathematical formula}14400 vs. {a mathematical formula}1800 runs). This explains why configurators require more time to improve training performance on LABS. Third, to assess the potential for overtuning, we studied how training and test performance correlate. Visually, Fig. 8 shows a strong overall correlation of PAR-10 training and test scores for both of the benchmarks; Spearman correlation coefficients are indeed high: 0.99 (N-Rooks) and 0.98 (LABS). However, for the top 20% of sampled configurations, the correlation is much stronger for N-Rooks (0.98) than for LABS (0.49). This explains why improvements on the LABS training set do not necessarily translate to improvements on its test set.
      </paragraph>
     </section>
     <section label="6.2">
      <section-title>
       Overall configurability of solvers
      </section-title>
      <paragraph>
       Some solvers consistently benefited more from configuration than others. Here, we quantify the configurability of a solver on a given benchmark by the PAR-10 speedup factor its configured version achieved over its default version, computed on the set of instances solved by at least one of the two. We then examine the relationship between configurability and number of parameters to determine whether solvers with many parameters consistently benefited more or less from configuration than solvers with few parameters.{sup:9}
      </paragraph>
      <paragraph>
       Fig. 9 shows that configurability was indeed high for solvers with many parameters (e.g., the variants of Lingeling, Riss, and Clasp), but that it did not increase monotonically in the number of parameters: some solvers with very few parameters were surprisingly configurable. For example, configuration sped up the single-parameter solver DCCASat+march-rw by at least a factor of four in all three benchmarks it was configured for, while the 4-parameter solver CSCCSat2014 was not improved at all by configuration. Furthermore, ProbSAT, which achieved the best single-benchmark performance improvement (as previously discussed in Section 5.3.4), has only 9 parameters.
      </paragraph>
      <paragraph>
       We note that the notion of configurability used here is strongly dependent on the time budget available for configuration. In the next section, we investigate this issue in more detail.
      </paragraph>
     </section>
     <section label="6.3">
      <section-title>
       Impact of configuration budget
      </section-title>
      <paragraph>
       The runtime budget we allow to configure each solver has an obvious impact on the results. In one extreme case, if we let this budget go towards zero, the configuration pipeline returns the solver defaults (and we are back in the setting of the standard SAT competition). For small, non-zero budgets, we can expect solvers with few parameters to benefit from configuration more, since their configuration spaces are easier to search. On the other hand, if we increase the time budget, solvers with larger parameter spaces are likely to benefit more than those with smaller parameter spaces (since larger parts of their configuration space can be searched given additional time).
      </paragraph>
      <paragraph>
       Fig. 10 illustrates this phenomenon for the two top solvers in the Random SAT+UNSAT track of CSSC 2014. With the competition's configuration budget of two days across 4 cores, Clasp-3.0.4-p8 performed better than DCCASat+march-rw (both solved all test instances, with average runtimes of 13 vs. 21 seconds). In the extreme case of no time budget for configuration, DCCASat+march-rw would have won against Clasp-3.0.4-p8, since its default version performed much better (2 vs. 18 timeouts), and, in fact, Fig. 10a shows that it required a configuration budget of at least 10{sup:4} seconds to find improving Clasp-3.0.4-p8 parameters for the 3cnf benchmark (where the default version of Clasp-3.0.4-p8 produced 18 timeouts). While the configuration of DCCASat+march-rw's single parameter had long converged by 10{sup:4} seconds, the configuration of Clasp-3.0.4-p8's 75 parameters continued to improve performance until the end of the configuration budget, and, in particular for the 3cnf benchmark, performance would have likely continued to improve further if the budget had been larger.
      </paragraph>
      <paragraph>
       We thus conclude that the solver's flexibility should be chosen in relation to the available budget for configuration: solvers with few parameters can often be improved more quickly than highly flexible solving frameworks, but, given enough computational resources and powerful configurators, the latter ones can typically offer a greater performance potential.
      </paragraph>
     </section>
     <section label="6.4">
      <section-title>
       Results with an increased cutoff time for validation
      </section-title>
      <paragraph>
       Next to the overall time budget allowed for configuration, another important time limit is the cutoff time allowed for each single solver run; due to our limited overall budget, we chose this to be quite low: 300 seconds both for solver runs during the configuration process and for the final evaluation of solvers on previously unseen test instances.
      </paragraph>
      <paragraph>
       Here, we study how using a larger cutoff time at evaluation time affects results, mimicking a situation where we care about performance with a large cutoff time but use a smaller cutoff time for the configuration process to make progress faster. In fact, several studies in the literature (e.g., [42], [55], [81]) used a smaller cutoff time for configuration than for testing, and we found that improvements with a time budget around 300 seconds often lead to improvements with larger cutoff times.
      </paragraph>
      <paragraph>
       Table 14 shows the results we obtained when using a cutoff time of 5000 seconds for validation (the same as the SAT competition) for the Industrial SAT+UNSAT track of CSSC 2014. Qualitatively, these results are quite similar to those obtained with an evaluation cutoff time of 300 s (compare Table 10), with only few differences. As expected, given the larger cutoff time, all solvers solved substantially more instances (especially for the BMC and Circuit Fuzz benchmarks). Nevertheless, with a cutoff time of 5000 seconds, for all solvers, the configured variant (configured to perform well with a cutoff time of 300 seconds) still performed better than the default version, making us more confident that configuration does not substantially overtune to achieve good performance on easy instances only.
      </paragraph>
     </section>
     <section label="6.5">
      <section-title>
       Results with a single configurator
      </section-title>
      <paragraph>
       While the CSSC addressed the performance of SAT solvers rather than the performance of configurators, we have been asked whether our complex configuration pipeline was necessary, or whether a single configurator would have produced similar or identical results. Indeed, counting the choice of discretized vs non-discretized parameter space, our pipeline used five configuration approaches (ParamILS-discretized, GGA, GGA-discretized, SMAC-discretized, and SMAC). Thus, if one of these approaches had yielded the same results all by itself, we could have reduced our overall configuration budget five-fold.
      </paragraph>
      <paragraph>
       To determine whether this was the case, we evaluated the solver performance we would have observed if we had used each configuration approach in isolation. For each configuration scenario and each approach, we computed the PAR-10 slowdown factor over the CSSC result as the PAR-10 achieved with the respective approach, divided by the PAR-10 of the approach with best training performance (which we selected in the CSSC). If a configuration approach achieves a PAR-10 slowdown factor close to one, this means that it gives rise to solver performance close to that achieved by our full CSSC configuration pipeline. For each solver, we then computed the geometric mean of these factors across the scenarios it was configured for.
      </paragraph>
      <paragraph>
       Table 15 shows that both SMAC variants performed close to best for all solvers, meaning that we would have achieved similar results had we only used SMAC in the CSSC. ParamILS yielded the next best performance, followed by GGA. Full results can be found in the accompanying technical report [48]. Despite SMAC's strong performance, we believe it will still be useful to run several configuration approaches in future CSSCs, both to ensure robustness and to assess whether some configuration scenarios are better suited to other configuration approaches.
      </paragraph>
     </section>
    </section>
   </content>
   <appendices>
    <section label="Appendix A">
     <section-title>
      Benchmark sets used
     </section-title>
     <paragraph>
      We mirrored the three main categories of instances from the SAT competition: industrial, crafted, and random. In 2014, we also included a category of satisfiable random instances from the SAT Races. For each of these categories, we used various benchmark sets, each of them split into a training set to be used for algorithm configuration and a disjoint test set.
     </paragraph>
     <paragraph>
      For each category, to weight all benchmarks equally, we used the same number of test instances from each benchmark; these test sets were subsampled uniformly at random from the respective complete test sets.
     </paragraph>
     <paragraph>
      All benchmarks are summarized in Table 1, Table 7 in the main text.
     </paragraph>
     <section label="A.1">
      <section-title>
       Industrial benchmark sets
      </section-title>
      <paragraph>
       SWV  This set of SAT-encoded software verification instances consists of 604 instances generated with the CALYSTO static checker [4], used for the verification of five programs: the spam filter Dspam, the SAT solver HyperSAT, the Wine Windows OS emulator, the gzip archiver, and a component of xinetd (a secure version of inetd). We used the same training/test split as Hutter et al. [42], containing 302 training instances and 302 test instances. We used this benchmark set in the 2013 CSSC. (In 2014, we only used it for preliminary tests since it is quite easy for modern solvers.)
      </paragraph>
      <paragraph>
       Hardware Verification (IBM)  This set of SAT-encoded bounded model checking instances consists of 765 instances generated by Zarpas [85] These instances were originally selected by Hutter et al. [42] as the instances in 40 randomly-selected folders from the IBM Formal Verification Benchmarks Library. We used their original training/test split, containing 382 training instances and 383 test instances. We used this benchmark set in both the 2013 and 2014 CSSCs.
      </paragraph>
      <paragraph>
       Circuit Fuzz  These instances were produced by a circuit-based CNF fuzzing tool, FuzzSAT[23] (version 0.1). As FuzzSAT was originally designed to produce semi-realistic test cases for debugging SAT solvers, the majority of the instances it produces are trivial; however, occasionally, it produces more challenging instances. The CircuitFuzz instances were found by generating 10 000 FuzzSAT instances and removing all those that could be solved within one second by Lingeling. This instance generator was originally described in detail by Bayless et al. [11]; we used the 300 instances from that paper as the training set (except one quite easy instance, ‘fuzz_100_25433.cnf’, which was dropped unintentionally by a script) and produced 585 additional instances using the same method, to form a testing set. We used this benchmark set in both the 2013 and 2014 CSSCs. We used these instances as part of the industrial track since they are “structured in ways that resemble (at least superficially) real-world, circuit-derived instances” [11]; a case could, however, also be made for them to be part of the crafted or random track.
      </paragraph>
      <paragraph>
       Bounded Model Checking 2008 (BMC)  This set of SAT instances was derived by unrolling the 2008 Hardware Model Checking Competition circuits [18]. Each of these instances is a sequential circuit with safety properties. Each circuit was unrolled to 50, 100, and 200 iterations using the tool aigunroll (version 1.9.4) from the AIGER tools [15]. We omitted trivial instances that were proven SAT or UNSAT during the unrolling process. While we used the entire set in 2013, in 2014 we removed the 60 instances provided by Intel in order to allow us to publicly share the instances.
      </paragraph>
     </section>
     <section label="A.2">
      <section-title>
       Crafted benchmark sets
      </section-title>
      <paragraph>
       Graph Isomorphism (GI)  These instances were first used in the 2013 SAT Competition [68] and were generated by encoding the graph isomorphism problem to SAT according to the procedure described by Torán [82]. Given two graphs {a mathematical formula}G1 and {a mathematical formula}G2 with n vertices and m edges (for whom the isomorphism problem is to be solved) the generator creates a SAT formula with {a mathematical formula}n2 variables and {a mathematical formula}O(n)+O(n3)+O(n4) clauses. Consequently, the generated instances can contain very many clauses. The 2 064 SAT instances in this set were generated from different types of graphs, with the number of vertices n ranging from 10 to 1296.{sup:10} We split the instances uniformly at random into 1 032 training and 1 032 test instances; in both the 2013 and 2014 CSSCs, we only used 351 of the test instances.
      </paragraph>
      <paragraph>
       Low Autocorrelation Binary Sequence (LABS)  This set contains 651 low-autocorrelation binary sequence (LABS) search problems that were encoded to SAT problems by first encoding them as pseudo-Boolean problems and then as SAT problems. Instances from this set were first used in the SAT Competition 2013 in the crafted category [69]. We split this benchmark set uniformly at random into 350 training and 351 test instances, and used it in both the 2013 and 2014 CSSCs.
      </paragraph>
      <paragraph>
       N-Rooks  These 835 instances [67] represent a parameterized unsatisfiable variation of the well-known n-queens problem, in which the task is to place n queens on a chess board with {a mathematical formula}n×n fields such that they do not attack each other. In the variation considered here, the (unsatisfiable) problem is to either place {a mathematical formula}n+1rooks or {a mathematical formula}n+1 queens on a board of size {a mathematical formula}n×n. Additional constraints enforcing that there is a piece in each row/column/diagonal make it easier to prove unsatisfiability, and these constraints can be enabled or disabled by generator parameters. We used the generator new-Dame provided by Norbert Manthey to generate instances with {a mathematical formula}n∈[10,50], using all rooks or all queens, using six different problem encodings, and using all combinations of enabling/disabling all types of constraints. We then removed trivial instances, ending up with 835 instances. For the CSSC 2014, we selected 484 training instances uniformly at random and used the remaining 351 as test instances.
      </paragraph>
     </section>
     <section label="A.3">
      <section-title>
       Random benchmark sets
      </section-title>
      <paragraph>
       K3  This is a set of 600 randomly-generated 3-SAT instances at the phase transition (clause to variable ratio of approximately 4.26). It includes both satisfiable and unsatisfiable instances. The set includes 100 instances each with 200 variables (853 clauses), 225 variables (960 clauses), 250 variables (1066 clauses), 275 variables (1172 clauses), 300 variables (1279 clauses), and 325 variables (1385 clauses). These 600 instances were generated by Lin Xu using the random instance generator from the 2009 SAT competition, and were previously described by Bayless et al. [11]. We employed their uniform random split into 300 training and 300 test instances, using all 300 test instances in the CSSC 2013 (random track) and only a subset of 250 test instances in the CSSC 2014 (random track).
      </paragraph>
      <paragraph>
       3cnf  This is a set of 750 random 3-SAT instances (satisfiable and unsatisfiable) at the phase transition, with 350 variables and 1493 clauses. These instances were generated by the ToughSAT instance generator [12] and split into 500 training and 250 test instances uniformly at random. We used this benchmark set in the 2014 CSSC (random track).
      </paragraph>
      <paragraph>
       unif-k5  This set contains only unsatisfiable 5-SAT instances generated uniformly at random with 50 variables and 1 056 clauses (a clause-to-variable ratio sharply on the phase transition). The instances were generated by the uniform random generator used in the SAT Challenge 2012 and SAT Competition 2013, with satisfiable instances being filtered out by running the SLS solver ProbSAT. We used this benchmark set in both the 2013 and 2014 CSSCs (random track).
      </paragraph>
      <paragraph>
       3sat1k  This is a set of 500 3-SAT instances at the phase transition, all satisfiable. Each instance has 1000 variables and 4260 clauses. These instances were previously described by Tompkins et al. [81]. We used their uniform random split into 250 training and test instances in the 2013 CSSC (random track) and in the 2014 CSSC (random satisfiable track).
      </paragraph>
      <paragraph>
       5sat500  This set contains 500 5-SAT instances generated uniformly at random with a clause-to-variable ratio of 20. Each instance is satisfiable and has 500 variables and 10000 clauses. This set was first used for tuning the SAT solver Captain Jack and other SLS solvers [81]. We used the original uniform random split into 250 training and test instances in the 2014 CSSC (random satisfiable track).
      </paragraph>
      <paragraph>
       7sat90  This set contains 500 7-SAT instances generated uniformly at random with a clause-to-variable ratio of 85. Each instance is satisfiable and has 90 variables and 7650 clauses. This set was also first used for tuning the SAT solver Captain Jack and other SLS solvers [81]. We used the original uniform random split into 250 training and test instances in the 2014 CSSC (random satisfiable track).
      </paragraph>
     </section>
     <section label="A.4">
      <section-title>
       Instance features used for these benchmark sets
      </section-title>
      <paragraph>
       As described in Appendix B.3, SMAC can use instance features to guide its search. Such instance features have predominantly been studied in the work on SATzilla for algorithm selection [70], [84] and in machine learning models for predicting algorithm runtime [49]. These features range from simple summary statistics, such as the number of variables or clauses in an instance, to the results of short, runtime-limited probes with local search solvers. In the context of algorithm configuration, we can afford somewhat more expensive features than for algorithm selection since we only require them on the training instances (not the test instances) and can compute them once, offline. Nevertheless, we kept feature computation costs low to not add substantially to the time required for algorithm configuration.
      </paragraph>
      <paragraph>
       For the instance sets where we already had available instance features from previous work, we used those features. In particular, we used the 138 features described by Hutter et al. [49] for the datasets SWV, IBM, 3sat1k, 5sat500, and 7sat90. For the set unif-k5, we did not compute features since these instances were very easy to solve even with algorithm defaults (note that SMAC also worked very well without features). For the other datasets, we computed a subset of 119 features, including basic features and feature groups based on survey propagation, clause learning, local search probing, and search space size estimates.{sup:11}
      </paragraph>
     </section>
    </section>
    <section label="Appendix B">
     <section-title>
      Configuration procedures
     </section-title>
     <paragraph>
      This appendix describes the configuration procedures we used in more detail. Configurators typically iterate the following steps: (1) execute the target algorithm on one or more instances with one or more configurations for a limited amount of time; (2) measure the resulting performance metric and (3) decide upon the next target algorithm execution. Beyond the key question of which configuration to try next, configurators also need to decide how many runs and which instances to use for each evaluation, and after which time to terminate unsuccessful runs. ParamILS, SMAC, and GGA differ in how they instantiate these components.
     </paragraph>
     <section label="B.1">
      ParamILS: local search in configuration space
      <paragraph>
       ParamILS[47], short for iterated local search in parameter configuration space, generalizes the simple (often manually performed) tuning approach of changing one parameter at a time and keeping changes if performance improves. While that simple tuning approach is a local search that terminates in the first local optimum, ParamILS carries out an iterated local search [58] that applies perturbation steps in each local optimum o in order to escape o's basin of attraction and carry out another local search that leads to another local optimum {a mathematical formula}o′. Iterated local search then decides whether to continue from the new optimum {a mathematical formula}o′ or to return to the previous optimum o, thereby performing a biased random walk over locally optimal solutions. ParamILS only supports categorical parameters, so numerical parameters need to be discretized before ParamILS is run.
      </paragraph>
      <paragraph>
       ParamILS is an algorithm framework with two different instantiations that differ in their strategy of deciding how many runs to use to evaluate each configuration. The most straightforward instantiation, BasicILS(N), resembles the approach most frequently used in manual parameter optimization: it evaluates each configuration according to a fixed number of N runs on a fixed set of instances. While this approach is simple and intuitive, it gives rise to the problem of how to set the number N. Setting N to a large value yields slow evaluations; using a small number yields fast evaluations, but the evaluations are often not representative for the instance set Π (for example, if we choose N runs we can cover at most N instances, even if we only allow a single run per instance). The second ParamILS instantiation, FocusedILS, solves this problem by allocating most of its runs to strong configurations: it starts with a single run per configuration and incrementally performs more runs for promising configurations. This means that it can often afford a large number of runs for the best configurations while rejecting most poor configurations based on a few runs. There is also a guarantee that configurations that were ‘unlucky’ can be revisited in the search, allowing for a proof that FocusedILS—if run indefinitely—will eventually identify the configuration with the best performance on the entire training set.
      </paragraph>
      <paragraph>
       Finally, ParamILS also implements a mechanism for adaptively choosing the time after which to terminate unsuccessful target algorithm runs. Intuitively, when comparing the performance of two configurations {a mathematical formula}θ1 and {a mathematical formula}θ2 on an instance, and we already know that {a mathematical formula}θ1 solves the instance in time {a mathematical formula}t1, we do not need to run {a mathematical formula}θ2 for longer than {a mathematical formula}t1: we do not need to know precisely how bad{a mathematical formula}θ2 is, as long as we know that {a mathematical formula}θ1 is better. More precisely, each comparison of configurations in ParamILS is with respect to an instance set {a mathematical formula}Πsub⊂Π, and evaluations of {a mathematical formula}θ2 can be terminated prematurely when {a mathematical formula}θ2's aggregated performance on {a mathematical formula}Πsub is provably worse than that of {a mathematical formula}θ1. In practice, this so-called adaptive capping mechanism can speed up ParamILS's progress by orders of magnitude when the best configuration solves instances much faster than the overall maximal cutoff time [47].
      </paragraph>
      <paragraph>
       For all experiments in this paper, we used the FocusedILS variant of the most recent publicly available ParamILS release 2.3.7{sup:12} with default parameters.
      </paragraph>
     </section>
     <section label="B.2">
      GGA: Gender-based Genetic Algorithm
      <paragraph>
       The Gender-based Genetic Algorithm (GGA)[1] is a configuration procedure that maintains a population of configurations and proceeds according to an evolutionary metaphor, evolving the population over a number of generations in which pairs of configurations mate and produce offspring. GGA also uses the concept of gender: each configuration is labeled with a gender chosen uniformly at random, and when configurations are selected to mate there are separate selection pressures for each gender: configurations from the first gender are selected based on their empirical performance, whereas configurations from the other gender are selected uniformly at random. The second gender thus serves as a pool of diversity, countering premature convergence to a poor parameter configuration.
      </paragraph>
      <paragraph>
       Unlike ParamILS' local search mechanism, GGA's recombination operator for combining the parameter values of two parent configurations can operate directly on numerical parameter domains, avoiding the need for discretization.
      </paragraph>
      <paragraph>
       Like ParamILS, GGA implements an adaptive capping mechanism, elegantly combining it with a parallelization mechanism that lets it effectively use multiple processing units. GGA only ever evaluates configurations in the selection step for the first gender, and its strategy is to evaluate several candidates in parallel until the first one succeeds. Here, the number of configurations to be evaluated in parallel is taken to be identical to the number of processing units available, {a mathematical formula}#units.{sup:13}
      </paragraph>
      <paragraph>
       Like the FocusedILS variant of ParamILS, GGA also implements an “intensification” mechanism for increasing the number of runs N it performs for each configuration over time. Specifically, it keeps N constant in each generation, starting with small {a mathematical formula}Nstart in the first generation, and linearly increasing N up to a larger {a mathematical formula}Ntarget in generation {a mathematical formula}Gtarget and thereafter; {a mathematical formula}Nstart, {a mathematical formula}Ntarget, and {a mathematical formula}Gtarget, are parameters of GGA.
      </paragraph>
      <paragraph>
       For all experiments in the CSSC, we used the most recent publicly available version of GGA, version {a mathematical formula}1.3.2.{sup:14}GGA's author Kevin Tierney kindly provided a script to convert the parameter configuration space description for each solver from the competition's pcs format{sup:15} to GGA's native xml format. This script allowed us to run GGA for all solvers except those with complex conditionals.
      </paragraph>
      <paragraph>
       Next to the parameters {a mathematical formula}#units, {a mathematical formula}Nstart, {a mathematical formula}Ntarget, and {a mathematical formula}Gtarget mentioned above, free GGA parameters include the maximal number of generations, {a mathematical formula}Gmax and the size of the population, {a mathematical formula}Psize. The setting of these parameters considerably affects GGA's behavior and also determines its overall runtime (when run to completion). If there is an external fixed time budget (as in the CSSC), these parameters can be modified to ensure that GGA does not finish far too early (thus not making effective use of the available configuration budget) while simultaneously ensuring that runs do not take far too long (in which case configuration would be cut off in one of the first generations, where the search is basically still random sampling). It is thus important to set GGA's parameters carefully. We set the following parameters to values hand-chosen by Kevin Tierney for the CSSC (leaving all other parameters at their default values): {a mathematical formula}#units=4, {a mathematical formula}Psize=50, {a mathematical formula}Gtarget=75, {a mathematical formula}Gmax=100, {a mathematical formula}Nstart=4, {a mathematical formula}Ntarget=#(training instances in the scenario).{sup:16}
      </paragraph>
      <paragraph>
       We performed a post hoc analysis, which suggests that these parameters may yet not be optimal: GGA often finished relatively few generations within its configuration budget. It might thus make sense to use a smaller value of {a mathematical formula}Ntarget in the future to reduce the number of instances considered per configuration. However, this means that GGA would never consider all instances and may overtune as a result. How to best set GGA's parameters is therefore an open research question.
      </paragraph>
     </section>
     <section label="B.3">
      SMAC: sequential model-based algorithm configuration
      <paragraph>
       In contrast to the model-free configurators ParamILS and GGA, SMAC[46] is a sequential model-based algorithm configuration method, which means that it uses predictive models of algorithm performance [49] to guide its search for good configurations. More specifically, it uses previously observed 〈configuration, performance〉 pairs {a mathematical formula}〈θ,f(θ)〉 to learn a random forest of regression trees (see, e.g., [22]) that express a function {a mathematical formula}fˆ:Θ→R predicting the performance of arbitrary parameter configurations (including those not yet evaluated) and then uses this function to guide its search. When instance characteristics {a mathematical formula}xπ∈F are available for each problem instance π, SMAC uses observed 〈configuration, instance characteristic, performance〉 triplets {a mathematical formula}〈θ,xπ,f(θ,π)〉 to learn a function {a mathematical formula}gˆ:Θ×F→R that predicts the performance of arbitrary parameter configurations on instances with arbitrary characteristics. These so-called empirical performance models[49] are then marginalized over the instance characteristics of all training benchmark instances in order to derive the function {a mathematical formula}fˆ that predicts average performance for each parameter configuration: {a mathematical formula}fˆ(θ)=Eπ∼Πtrain[gˆ(θ,π)].
      </paragraph>
      <paragraph>
       This performance model is used in a sequential optimization process as follows. After an initialization phase, SMAC iterates the following three steps: (1) use the performance measurements observed so far to fit a marginal random forest model {a mathematical formula}fˆ; (2) use {a mathematical formula}fˆ to select a promising configuration {a mathematical formula}θ∈Θ to evaluate next, trading off exploration in new parts of the configuration space and exploitation in parts of the space known to perform well; and (3) run θ on one or more benchmark instances and compare its performance to the best configuration observed so far.
      </paragraph>
      <paragraph>
       SMAC employs a similar criterion as FocusedILS to determine how many runs to perform for each configuration, and for finite configuration spaces in the limit it also provably converges to the best configuration on the training set. Unlike ParamILS, SMAC does not require that the parameter space be discretized.
      </paragraph>
      <paragraph>
       When used to optimize target algorithm runtime, SMAC implements an adaptive capping mechanism similar to the one used in ParamILS. When this capping mechanism prematurely terminates an algorithm run we only observe a lower bound of the algorithm's runtime. In order to construct predictive models of algorithm runtime in the presence of such so-called right-censored data points, SMAC applies model-building techniques derived from the survival analysis literature [45].
      </paragraph>
     </section>
    </section>
    <section label="Appendix C">
     Hors-concours solver Riss3gExt
     <paragraph>
      So far, we have limited our analysis to the ten open-source solvers that competed for medals. Recall that one additional solver, Riss3gExt, only participated hors concours. It was not eligible for a medal, because it had been submitted as closed source, being based on a highly experimental code branch of Riss3g that had not been exhaustively tested and was therefore likely to contain bugs.
     </paragraph>
     <paragraph>
      As discussed in Section 2.1, our experimental protocol included various safeguards against such bugs: we measured runtime and memory externally, compared reported solubility status against true solubility status where this was known, and checked returned models when an instance was reported satisfiable. Our configuration pipeline detected and penalized these crashes automatically, enabling the configuration procedures to continue their search and find Riss3gExt configurations with no or few crashes. In fact, the final best configurations identified by our configuration pipeline performed very well and would have handily won both the industrial and the crafted track of the CSSC 2013 had Riss3gExt been submitted as open source: in the industrial track, it only left 82 problem instances unsolved (compared to 115 for Lingeling); and in the crafted track only 44 (compared to 96 for Clasp-3.0.4-p8). Even though most of the instances Riss3gExt did not solve were due to it crashing, all of these were ‘legal’ crashes that simply did not output a solution (such as segmentation faults). In particular, we never observed Riss3gExt to produce an incorrect output for a CSSC test instance with known satisfiability status.
     </paragraph>
     <paragraph>
      However, empirical tests with benchmark instances are of course no substitute for formal correctness guarantees, and even seasoned solvers can have bugs. Indeed, after the competition, Riss3gExt's developer found a bug in it (in on-the-fly clause improvement [38]) that caused some satisfiable instances to be incorrectly labeled as unsatisfiable.{sup:17} This being the case, it was fortunate that Riss3gExt was ineligible for medals.
     </paragraph>
     <paragraph>
      While empirical testing on benchmark instances, as done in a competition, can never guarantee the correctness of a solver, in future CSSCs, we consider tightening solubility checks on the benchmark instances used, by either limiting the benchmark sets to contain only instances with known satisfiability status or to require (and check) proofs of unsatisfiability, as in the certified UNSAT track of the SAT competition.
     </paragraph>
    </section>
    <section label="Appendix D">
     <section-title>
      Additional results with PAR-1 score
     </section-title>
     <paragraph>
      Fig. D.11 visualizes runtime speedups obtained for each solver, counting timeouts at the cutoff time as the cutoff time itself (PAR-1). Compared to the PAR-10 results in Fig. 9, speedups with PAR-1 are up to a factor of ten smaller for benchmark/solver combinations with many timeouts for the default, but otherwise results are qualitatively similar.
     </paragraph>
    </section>
   </appendices>
  </root>
 </body>
</html>