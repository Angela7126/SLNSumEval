<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    CCEHC: An efficient local search algorithm for weighted partial maximum satisfiability.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The maximum satisfiability (MAX-SAT) problem is the optimization version of the Boolean satisfiability (SAT) problem, which is a prototypical NP-complete problem and is of great importance in a variety of fields of computer science, mathematical logic and artificial intelligence. In the context of the SAT and MAX-SAT problems, a propositional formula F is usually expressed in conjunctive normal form (CNF) [1], i.e., {a mathematical formula}F=⋀i⋁jlij, where each {a mathematical formula}lij is a literal, which is either a Boolean variable or its negation. A CNF formula can be expressed as a set of clauses, where a clause is a disjunction of literals, and each CNF formula is a conjunction of clauses.
     </paragraph>
     <paragraph>
      Given a propositional formula in conjunctive normal form (CNF), the SAT problem is to decide whether an assignment exists such that all clauses in this CNF formula are satisfied; the MAX-SAT problem is to seek out an assignment that maximizes the number of satisfied clauses in the CNF formula; the weighted MAX-SAT problem, where each clause is associated with a positive integer as its weight, is to find an assignment that maximizes the total weight of satisfied clauses, and is an important generalization of MAX-SAT; the (unweighted) partial maximum satisfiability (PMS) problem, where clauses are divided into hard ones and soft ones, is to find an assignment that satisfies all hard clauses and maximizes the number of satisfied soft clauses, and is also an important generalization of MAX-SAT. The weighted partial maximum satisfiability (WPMS) problem is the combination of both weighted MAX-SAT and PMS, and is a significant generalization of MAX-SAT: Given a CNF formula, the WPMS problem, where clauses are divided into hard ones and soft ones, and each soft clause is associated with a positive integer as its weight, is to seek out an assignment that satisfies all hard clauses and maximizes the total weight of satisfied soft clauses. In theory, MAX-SAT and its generalizations (i.e., weighted MAX-SAT, PMS and WPMS), are typically NP-hard problems, and it is well known that optimal solutions to these problems are hard to approximate [2]. Thus, it is very interesting to explore high-performance heuristic procedures to solve these hard problems. In this paper, our focus is on the WPMS problem.
     </paragraph>
     <paragraph>
      In practice, as many combinatorial problems in real-world applications usually contain hard and soft constraints [3] and also soft constraints often have different priorities, encoding such real-world problems into the WPMS problem is more natural and direct than encoding them into SAT, MAX-SAT, weighted MAX-SAT or PMS. In fact, many important realistic problems in a wide range of real-world applications, such as computational protein design [4], [5], set covering [6], coalition structure generation [7] and so on, can be encoded and solved as WPMS instances.
     </paragraph>
     <paragraph>
      There are two popular categories of practical algorithms for solving MAX-SAT: complete algorithms and stochastic local search (SLS) algorithms. Complete algorithms are able to prove the optimality of the solution, but they may not return a good-quality solution for large-sized instances within reasonable time [8]. Complete algorithms can be classified into two main classes: branch and bound MAX-SAT algorithms [9], [10], [11] which are based on DPLL procedures [12], [13], and SAT based algorithms [14], [15], [16] which successively call an efficient CDCL (Conflict-Driven Clause Learning) SAT solver [17], [18]. Although SLS algorithms are typically incomplete, i.e., they do not guarantee the optimality of the solutions they find, SLS algorithms are often able to find good-quality solutions within a reasonable time frame [19], [3]. SLS algorithms are usually evolving out of GSAT[20] and WalkSAT[21]. However, there is little work on SLS algorithms for solving WPMS, and almost all of the existing solvers for solving WPMS are complete ones.
     </paragraph>
     <paragraph>
      Recently, significant breakthroughs have been achieved on SLS algorithms for solving weighted MAX-SAT and PMS, resulting in state-of-the-art SLS algorithms namely CCLS[22] and Dist[3] as well as Dist's improvement DistUP[23]. The CCLS algorithm makes great progress in solving weighted MAX-SAT. CCLS won several categories in the incomplete solver track of the MAX-SAT Evaluations 2013 and 2014, thanks to the configuration checking strategy [24], which has been successfully applied to SAT [25] and minimum vertex cover [26]. The CCLS algorithm can be used to solve WPMS by translating WPMS into weighted MAX-SAT, as the translation can be very straightforward via setting the weight of each hard clause to the total weight of all soft clauses plus 1. However, when it comes to the WPMS problem, CCLS loses its power and shows ineffectiveness, as can be seen from the competition results of the incomplete solver track of the MAX-SAT Evaluation 2014.{sup:1} The Dist algorithm shows great success on solving PMS, and won several categories in the incomplete solver track of the MAX-SAT Evaluation 2014, and also competes well with state-of-the-art complete algorithms on some classes of PMS application instances, such as advanced encryption standard and protein [3]. Dist can also be adapted to solve WPMS, and is indeed the current best SLS algorithm for solving WPMS, winning the random WPMS category and the crafted WPMS category in the incomplete solver track of the MAX-SAT Evaluation 2014. Particularly, the competition results of the MAX-SAT Evaluation 2014 show that Dist performs better than several state-of-the-art complete algorithms on the crafted WPMS benchmark. The DistUP algorithm, an improvement of Dist by using unit propagation as its initialization procedure, shows improvement over Dist on industrial instances. However, CCLS, Dist and DistUP are not dedicated to solving WPMS specifically, and their performance for solving WPMS could be further improved. Compared to the great progress of SLS algorithms on solving weighted MAX-SAT and PMS, the performance of SLS algorithms on solving WPMS lags far behind. This motivates us to design a more efficient SLS algorithm for solving WPMS. Inspired by the success of Dist as well as DistUP, our ambition is to solve more classes of structured problems and real-world ones.
     </paragraph>
     <paragraph>
      In this work, we present a new SLS algorithm named CCEHC (Configuration Checking with Emphasis on Hard Clauses) for solving WPMS. Our CCEHC algorithm employs an extended framework of CCLS with a heuristic emphasizing hard clauses, called EHC. With strong focus on hard clauses, the EHC heuristic has three components: a variable selection mechanism focusing on a forbidding mechanism of configuration checking based only on hard clauses, a weighting scheme for hard clauses, and an approach of biased random walk. Our main contributions in this paper are summarized as follows.
     </paragraph>
     <paragraph>
      Firstly, we identify an efficient algorithm framework for solving WPMS. It is surprising that our algorithm framework is based on CCLS instead of Dist, though CCLS shows worse performance on solving WPMS compared to Dist.
     </paragraph>
     <paragraph>
      Secondly, we propose a new variable selection mechanism focusing on a new forbidding mechanism of configuration checking. This forbidding mechanism is similar to clause state based configuration checking in the context of SAT [27], [28], [29]. However, there is a major distinction that this configuration checking mechanism emphasizes hard clause, and a configuration consists of the states of hard clause rather than all clauses. Also, to the best of our knowledge, this is the first time this kind of clause states based configuration checking is applied to MAX-SAT solving, while previous configuration checking techniques in the context of MAX-SAT are all based on neighboring variables [22], [30]. We remark that, although this variable selection mechanism does not improve the performance of CCEHC on random WPMS instances, it makes contributions to the performance of CCEHC on a number of structured and real-world application WPMS instances. The related experiments, which confirms the effectiveness of this variable selection mechanism, and the detailed discussions can be found in Section 7.1.
     </paragraph>
     <paragraph>
      Finally, by adopting a weighting scheme for hard clauses (which was first exploited in Dist) and adjusting the strategy of biased random walk for partial MAX-SAT, we integrate the two with our new configuration checking mechanism in a subtle way and obtain our new EHC heuristic. The three components underlying the heuristic EHC accentuates hard clauses and, as a whole, fits into our algorithm framework very well.
     </paragraph>
     <paragraph>
      To evaluate the efficiency and the robustness of our CCEHC algorithm, we compare CCEHC against CCLS, Dist and DistUP on a broad range of WPMS benchmarks including the random, crafted and industrial benchmarks from the MAX-SAT Evaluation 2014 as well as four real-world application benchmarks. Experimental results clearly show that CCEHC generally performs much better than CCLS, Dist and DistUP, and thus establishes a new state of the art on SLS algorithms for solving WPMS. We also conduct more experiments to study the performance variability of SLS algorithms on selected instances.
     </paragraph>
     <paragraph>
      Further, we conduct more empirical evaluations to analyze each underlying component in the EHC heuristic, and the related results confirm the effectiveness of these components in the EHC heuristic. Also, we compare the CCEHC algorithm with a state-of-the-art complete algorithm, i.e., WPM-2014[15], [14] on these WPMS benchmarks. According to the experimental results, although CCEHC performs worse than WPM-2014 on the industrial benchmark from the MAX-SAT Evaluation 2014 and an application benchmark, CCEHC is able to return much better-quality solutions than WPM-2014 on other three important real-world application benchmarks as well as the random and the crafted benchmarks from the MAX-SAT Evaluation 2014. We also include the related experiments with a state-of-the-art lower-bound based complete solver Eva[16]. The experiments indicate that on a number of application instances, where Eva could not prove optimality, our CCEHC algorithm is able to return good-quality solutions fast, indicating that our CCEHC algorithm might be beneficial in practice. Additionally, we conduct empirical evaluations to analyze the efficiency of the combination of CCEHC and the unit propagation initialization [23] utilized by DistUP, and the related experiments demonstrate that the resulting solver CCEHC+UP gives a performance improvement over CCEHC on a large number of WPMS instances, which indicates that CCEHC could cooperate well with the unit propagation initialization.
     </paragraph>
     <paragraph>
      The remainder of our paper is structured as follows. In Section 2, we provide some preliminary definitions and notations. Section 3 presents a brief review of the CCLS algorithm. In Section 4, we propose the EHC heuristic and introduce those components underlying the EHC heuristic. Section 5 presents the CCEHC algorithm and describes it in detail. In Section 6, extensive experiments on a wide range of WPMS benchmarks are conducted to present the efficiency of CCEHC. In Section 7, we empirically analyze the effectiveness of each component underlying the EHC heuristic, then list the main differences between CCHEC and CCLS as well as the major differences between CCEHC and Dist, and evaluate the efficiency of the combination of CCEHC and the unit propagation initialization. Section 8 concludes this paper and lists future work.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      Given a set of n Boolean variables{a mathematical formula}V={x1,x2,⋯,xn} and the set of literals corresponding to these variables {a mathematical formula}L={x1,¬x1,x2,¬x2,⋯,xn,¬xn}, a clause is a disjunction of literals. A formula in conjunctive normal form (CNF) is a conjunction of clauses, and can be described as a set of clauses. Given a CNF formula F, we use {a mathematical formula}V(F) to denote the set of all variables in F. Two different variables are neighbors when they appear in at least one clause simultaneously, and we use the notation {a mathematical formula}N(x) to denote the set of all x's neighboring variables. A complete assignment is a mapping that assigns a Boolean value (either 0 or 1) to each variable in the formula. For SLS algorithms for solving WPMS (as well as MAX-SAT, weighted MAX-SAT and PMS), a candidate solution is a complete assignment. Given a CNF formula F and a complete assignment α corresponding to F, each clause in F under assignment α has two possible states: satisfied and unsatisfied; a clause c in F is satisfied if at least one literal in c is true under α; otherwise c is unsatisfied.
     </paragraph>
     <paragraph>
      A weighted partial CNF formula is such a CNF formula, where all clauses are divided into hard ones and soft ones, and each soft clause c is associated with a positive integer {a mathematical formula}w(c) as its weight. Given a weighted partial CNF formula F, the weighted partial maximum satisfiability (WPMS) problem is to find such a complete assignment which satisfies all hard clauses in F and maximizes the total weight of all satisfied soft clauses in F.
     </paragraph>
     <paragraph>
      Given a weighted partial CNF formula F (i.e., a WPMS instance), a complete assignment is feasible if it satisfies all hard clauses in F, and the cost of a feasible complete assignment α, denoted as {a mathematical formula}cost(α), is the total weight of all unsatisfied soft clauses under α. The optimal assignment is the feasible complete assignment with the minimum cost value.
     </paragraph>
     <paragraph>
      The basic framework of SLS algorithms for solving WPMS can be described as follows. In the initialization, the SLS algorithm randomly generates an assignment mapping to all Boolean variables; then the SLS algorithm repetitively selects and flips a Boolean variable until timeout or the number of search steps exceeds a given limit; finally, the SLS algorithm reports the feasible assignment with the lowest cost value encountered during the search process as the solution. In the search process, most SLS algorithms work between two modes: the greedy (intensification) mode and the diversification mode. In greedy mode, SLS algorithms prefer to flip those variables whose flips would decrease the number of unsatisfied hard clauses and the total weight of unsatisfied soft clauses. In diversification mode, SLS algorithms tend to diversify the search and thus explore the search space by using randomized strategies.
     </paragraph>
     <paragraph>
      In SLS algorithms for solving WPMS, for a variable x, the hard make score of x, denoted by {a mathematical formula}hmake(x), is the number (or total weight if using clause weighting scheme) of unsatisfied hard clauses that would become satisfied if x is flipped; the hard break score of x, denoted by {a mathematical formula}hbreak(x), is the number (or total weight if using clause weighting scheme) of satisfied hard clauses that would become unsatisfied if x is flipped; the hard score of x, denoted by {a mathematical formula}hscore(x), is the increment in the number (or total weight if using clause weighting scheme) of satisfied hard clauses if x is flipped, and can be understood as {a mathematical formula}hscore(x)=hmake(x)−hbreak(x)[3]; the soft make score of x, denoted by {a mathematical formula}smake(x), is the total weight of unsatisfied soft clauses that would become satisfied if x is flipped; the soft break score of x, denoted by {a mathematical formula}sbreak(x), is the total weight of satisfied soft clauses that would become unsatisfied if x is flipped; the soft score of x, denoted by {a mathematical formula}sscore(x), is the increment in the total weight of satisfied soft clauses if x is flipped, and can be understood as {a mathematical formula}sscore(x)=smake(x)−sbreak(x)[3]. Most SLS algorithms do not separate hard clauses and soft clauses, and use the concepts of general make score, break score and score properties to select variables to be flipped: for a variable x, the make score of x, denoted by {a mathematical formula}make(x), can be calculated as {a mathematical formula}make(x)=A×hmake(x)+smake(x); the break score of x, denoted by {a mathematical formula}break(x), can be calculated as {a mathematical formula}break(x)=A×hbreak(x)+sbreak(x); the score of x, denoted by {a mathematical formula}score(x), can be calculated as {a mathematical formula}score(x)=A×hscore(x)+sscore(x), and can also be seen as {a mathematical formula}score(x)=make(x)−break(x), where A in {a mathematical formula}make(x), {a mathematical formula}break(x) and {a mathematical formula}score(x) is a positive integer whose value is usually set to the total weight of all soft clauses plus 1. In our algorithm, when we use {a mathematical formula}score(x), we also adopt this definition and setting.
     </paragraph>
    </section>
    <section label="3">
     Reviewing the CCLS algorithm
     <paragraph>
      In this section, we briefly review the CCLS algorithm [22], which serves as the basis of our proposed algorithm. The CCLS algorithm is a recent breakthrough in local search for solving MAX-SAT, and shows state-of-the-art performance on solving weighted MAX-SAT.
     </paragraph>
     <paragraph>
      We would like to note that the CCLS algorithm is designed for solving weighted MAX-SAT. Thus, when CCLS is applied to solving WPMS, it first translates the WPMS instance into a weighted MAX-SAT instance by setting the weight of each hard clause to the total weight of all soft clauses plus 1 and then solves the translated weighted MAX-SAT instance. The pseudo-code of CCLS is outlined in Algorithm 1 and can also be found in the literature [22].
     </paragraph>
     <paragraph>
      In the initializing stage, the CCLS algorithm first generates a complete assignment α to all Boolean variables as the initial solution (line 1 in Algorithm 1). Then the CCLS algorithm starts the search process (i.e., executing a loop), where in each search step CCLS selects and flips a variable. During the search process, whenever a better solution is found by the CCLS algorithm, the best solution {a mathematical formula}α⁎ is updated accordingly (line 14 in Algorithm 1).
     </paragraph>
     <paragraph>
      In each search step, CCLS first checks whether the number of search steps exceeds the step limit maxSteps, time limit is exceeded or all clauses are satisfied: if one of these three terminating criterions is met, the search iteration terminates; otherwise, CCLS tries to select a flipping variable in this search step. With fixed probability p, CCLS works in diversification mode by employing the standard random walk component (lines 5–6 in Algorithm 1), i.e., it selects an unsatisfied clause c randomly and then picks a variable in c randomly; otherwise, CCLS switches to the greedy mode by activating the CCM (Configuration Checking and Make) heuristic (lines 8–12 in Algorithm 1) to select variables to be flipped. The CCM heuristic employs neighboring variables based configuration checking [24] to avoid local optima, and prefers to select the CCMP (configuration changed and make positive) variable with highest score, breaking ties randomly during the search [22]. A variable x is defined as CCMP if {a mathematical formula}make(x)&gt;0 and, since x's last flip, at least one of x's neighboring variables has been flipped [22]. The notation CCMPvars is used to denote the set of all CCMP variables during the search. After the flipping variable is selected, the CCLS algorithm flips the selected variable and then starts the next search step (line 13 in Algorithm 1).
     </paragraph>
     <paragraph>
      Finally, once the search process terminates, the CCLS algorithm reports the feasible solution with the least cost value.
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      The heuristic with emphasis on hard clauses
     </section-title>
     <paragraph>
      As can be clearly seen from Algorithm 1, the CCLS algorithm does not distinguish hard clauses and soft clauses. In our opinion, this is a disadvantage of CCLS when it is applied to solving WPMS, because hard clause is a very important feature of the WPMS problem. By treating hard clauses and soft clauses differently via different heuristics, we can make better use of this feature.
     </paragraph>
     <paragraph>
      To improve the performance of CCLS on solving WPMS, we follow this direction and design a more sophisticated heuristic called EHC (Emphasis on Hard Clauses), which separates hard clauses and soft clauses and emphasizes hard clauses. The EHC heuristic is composed of three components: a variable selection heuristic using a configuration checking mechanism based only on hard clauses, a weighting scheme for hard clauses, and a strategy of biased random walk.
     </paragraph>
     <section label="4.1">
      <section-title>
       Variable selection via hard clauses' states based configuration checking
      </section-title>
      <paragraph>
       Inspired by the success of the clause states based configuration checking (CSCC) strategy [27], [28], [29] in SLS algorithms for SAT, we adapt this CSCC strategy to solving WPMS. In the WPMS problem, hard clauses are much more important than soft clauses, as hard clauses are forced to be satisfied in feasible solutions, so we propose a new forbidding strategy of configuration checking, which is based only on the states of hard clauses, named HCSCC (Hard Clauses' States based Configuration Checking). HCSCC concerns only hard clauses and is different from the original CSCC strategy [29] which concerns all clauses. Because the definition of configuration is the most important concept in the configuration checking strategy [24], we give the formal definition of configuration in our HCSCC strategy as follows.
      </paragraph>
      <paragraph label="Definition 1">
       Given a weighted partial CNF formula F and a complete assignment α to {a mathematical formula}V(F), the configuration of a variable {a mathematical formula}x∈V(F) for HCSCC is a vector {a mathematical formula}configuration(x) consisting of the states of all hard clauses where x appears under assignment α.
      </paragraph>
      <paragraph>
       For a variable x, a change on any element of {a mathematical formula}configuration(x) is considered as a change on the whole {a mathematical formula}configuration(x) vector. The HCSCC strategy is designed to prevent flipping the variable x whose {a mathematical formula}configuration(x) has not been changed since x's last flip.
      </paragraph>
      <paragraph>
       Similar to the approximate implementation of CSCC [29], in order to implement HCSCC more efficiently, we employ a Boolean array hardConf whose size is equal to the number of variables. The array hardConf is maintained according to the following rules.
      </paragraph>
      <list>
       <list-item label="•">
        In the initializing stage, for each variable x, {a mathematical formula}hardConf(x) is set to 1.
       </list-item>
       <list-item label="•">
        Whenever a variable x is flipped, {a mathematical formula}hardConf(x) is set to 0. Then each hard clause c, where x appears, is checked whether c's state is changed (from satisfied to unsatisfied or vice versa). If c's state is indeed changed, for each variable y{a mathematical formula}(y≠x) in c, {a mathematical formula}hardConf(y) is set to 1.
       </list-item>
      </list>
      <paragraph>
       Thus, in the implementation of our HCSCC strategy, a variable x's configuration has been changed since x's last flip if {a mathematical formula}hardConf(x)=1.
      </paragraph>
      <paragraph>
       Similar to the notion of CCD (Configuration Changed and Decreasing) variables [24] in SLS algorithms for solving SAT, we define the notion of HCSCCD (Hard Clauses' States based Configuration Changed and Decreasing) variables, which combines the HCSCC strategy with the hscore property. The formal definition of an HCSCCD variable is given as follows.
      </paragraph>
      <paragraph label="Definition 2">
       Given a partial weighted CNF formula F and a complete assignment α to {a mathematical formula}V(F), a variable {a mathematical formula}x∈V(F) is HCSCCD if {a mathematical formula}hardConf(x)=1 and {a mathematical formula}hscore(x)&gt;0.
      </paragraph>
      <paragraph>
       In this work, we use the notation HCSCCDvars to denote the set of all HCSCCD variables during the search. In the search process, our CCEHC algorithm prefers to select variables to be flipped from the HCSCCDvars set.
      </paragraph>
      <paragraph>
       Here we prove an important lemma stating that, if a variable x is a HCSCCD variable, then x is a CCMP variable.
      </paragraph>
      <paragraph label="Lemma 1">
       For a given variable x, if x is a HCSCCD variable, then x is a CCMP variable.
      </paragraph>
      <paragraph label="Proof">
       For a variable x, x is a HCSCCD variable, meaning that {a mathematical formula}hscore(x)&gt;0 and, since x's last flip, there exists a hard clause c where x appears such that c's state has been changed (from satisfied to unsatisfied or vice versa). On the other hand, to change c's state, there exists one variable y{a mathematical formula}(y≠x) that has been flipped since x's last flip. As x and y appear in the same hard clause c, we derive {a mathematical formula}y∈N(x), meaning that since x's last flip, at least one of x's neighboring variables has been flipped.Since {a mathematical formula}hscore(x)&gt;0 and hscore can be calculated as {a mathematical formula}hmake(x)−hbreak(x), we have {a mathematical formula}hmake(x)&gt;hbreak(x). Since {a mathematical formula}hbreak(x) is a nonnegative integer according to its definition in Section 2, we have {a mathematical formula}hbreak(x)≥0. Therefore, we can easily obtain {a mathematical formula}hmake(x)&gt;0. Since {a mathematical formula}smake(x) is a nonnegative integer according to its definition in Section 2, we have {a mathematical formula}smake(x)≥0. As {a mathematical formula}make(x)=A×hmake(x)+smake(x), we can easily derive {a mathematical formula}make(x)&gt;0.As {a mathematical formula}make(x)&gt;0 and since x's last flip, at least one of x's neighboring variables has been flipped, x is a CCMP variable. □
      </paragraph>
      <paragraph>
       When to select HCSCCD variables: According to Lemma 1, it is easy to derive that the HCSCCDvars set is a subset of the CCMPvars set. Inspired by the success of the hierarchical combination of two different candidate variable sets in the context of SAT [31], this work adopts a hierarchical combination likewise: the CCEHC algorithm first tries to select a variable from the HCSCCDvars set with a higher priority if the HCSCCDvars set is not empty; otherwise, the algorithm selects a variable from the CCMPvars set.
      </paragraph>
      <paragraph>
       Efficient implementation of searching HCSCCD variables: When using configuration checking in local search for SAT or MAX-SAT, the concept of CCD variables [24] is important, where a variable x is defined as CCD if {a mathematical formula}score(x)&gt;0 and, since x's last flip, at least one of x's neighboring variables has been flipped [24]. The notation CCDvars denotes the set of all CCD variables during the search. In Lemma 2, we prove an important property – if a variable x is a HCSCCD variable, then x is a CCD variable. Thus, the HCSCCDvars set is a subset of the CCDvars set. The literature [22] proves that CCDvars is a subset of CCMPvars, so the key point in efficient implementation of searching HCSCCD variables is to search them in the CCDvars set rather than in the CCMPvars set.
      </paragraph>
      <paragraph label="Lemma 2">
       For a given variable x, if x is a HCSCCD variable, then x is a CCD variable.
      </paragraph>
      <paragraph label="Proof">
       For a variable x, x is a HCSCCD variable, meaning that {a mathematical formula}hscore(x)&gt;0 and, since x's last flip, there exists a hard clause c where x appears such that c's state has been changed (from satisfied to unsatisfied or vice versa). On the other hand, to change c's state, there exists one variable y{a mathematical formula}(y≠x) that has been flipped since x's last flip. As x and y appear in the same hard clause c, we derive {a mathematical formula}y∈N(x), meaning that since x's last flip, at least one of x's neighboring variables has been flipped.Since {a mathematical formula}hscore(x)&gt;0 and {a mathematical formula}hscore(x) is a nonnegative integer according to its definition in Section 2, we can easily obtain {a mathematical formula}hscore(x)≥1. Thus, we have {a mathematical formula}A×hscore(x)≥A. As {a mathematical formula}sscore(x)=smake(x)−sbreak(x), since {a mathematical formula}smake(x) is a nonnegative integer according to its definition in Section 2, we can easily obtain {a mathematical formula}sscore(x)≥−sbreak(x).As {a mathematical formula}score(x)=A×hscore(x)+sscore(x), thus {a mathematical formula}score(x)≥A−sbreak(x). According to Section 2, A is a positive integer whose value equals the total weight of all soft clauses plus 1, and the value of {a mathematical formula}sbreak(x) is not larger than the total weight of all soft clauses. Thus, we can obtain {a mathematical formula}score(x)≥1.Because {a mathematical formula}score(x)&gt;0 and since x's last flip, at least one of x's neighboring variables has been flipped, x is a CCD variable. □
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Weighting scheme for hard clauses
      </section-title>
      <paragraph>
       In the context of SAT, clause weighting schemes serve as diversification mechanisms in SLS algorithms and have been used prominently and successfully in SLS algorithms for solving SAT [32], [33], [34], [35], [36]. This motivates us to further extend the CCLS algorithm framework with an effective clause weighting scheme.
      </paragraph>
      <paragraph>
       In order to handle hard clauses with higher priority than soft clauses in the clause weighting scheme, it is natural to adopt a clause weighting scheme that only works for hard clauses. In this work, we utilize the one adopted by the Dist algorithm [3], which only adds weights to hard clauses. As stated in the literature [3], clause weighting for hard clauses helps to obtain feasible solutions and helps the algorithm to visit different satisfying assignments for hard clauses. The hard clause weighting scheme is similar to the PAWS scheme [35] and works as follows.
      </paragraph>
      <list>
       <list-item label="•">
        In the beginning of the SLS algorithm, for each hard clause c, the weight of c (i.e., {a mathematical formula}w(c)) is set to 1.
       </list-item>
       <list-item label="•">
        When the hard clause weighting scheme is activated, with probability sp (sp is a real number and {a mathematical formula}0≤sp≤1), for each satisfied hard clause c with {a mathematical formula}w(c)&gt;1, {a mathematical formula}w(c) is decreased by 1; otherwise (with probability {a mathematical formula}1−sp), for each unsatisfied hard clause c, {a mathematical formula}w(c) is increased by 1.
       </list-item>
      </list>
      <paragraph>
       Remark on the correctness of the hard clause weighting scheme: The correctness comes from two facts. (1) The final feasible solution reported by CCEHC must satisfy all hard clauses, as the algorithm verifies the solution before reporting it. (2) The hard clause weighting scheme only changes the weight of hard clauses and does not change the weight of soft clauses, so it would not influence the total weight of all unsatisfied soft clauses under the final feasible solution.
      </paragraph>
      <paragraph>
       When to activate the hard clause weighting scheme: In this work, our CCEHC algorithm activates the hard clause weighting scheme immediately when there exists no HCSCCD variable during the search. We regard the phenomenon that no HCSCCD variable exists, as evidence that CCEHC has stagnated. If an SLS algorithm has stagnated, it is important to use a diversification mechanism. As the clause weighting scheme serves as an effective diversification strategy, it is reasonable to activate the hard clause weighting scheme when no HCSCCD variable exists.
      </paragraph>
      <paragraph>
       Efficient implementation of the hard clause weighting scheme: According to the description, the hard clause weighting scheme consists of two phases: the weight-increasing phase and the weight-decreasing phase. The weight-decreasing phase concentrates on those hard satisfied clauses whose weights are greater than 1. For efficient implementation of the hard clause weighting scheme, we maintain a set of hard clauses whose weights are greater than 1. When the weight-decreasing phase is activated, the algorithm only checks the clauses in that set rather than checking all clauses, and thus saves the computation time.
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       Biased random walk
      </section-title>
      <paragraph>
       An important component of the CCLS algorithm is the random walk component, which is designed for the diversification mode. The random walk component (lines 5–6 in Algorithm 1) used in CCLS is a standard mechanism designed for SAT and MAX-SAT. However, the standard random walk component may not be suitable for SLS algorithms for WPMS, because it does not distinguish between hard and soft clauses. Since hard clauses are forced to be satisfied in feasible solutions of the WPMS problem, it is reasonable for us to employ a biased random walk component that prefers selecting a hard clause with a higher priority to choosing a soft clause. The biased random walk strategy is suggested by the literature [37] and described as follows.
      </paragraph>
      <paragraph>
       When the biased random walk component is called, if there exist any unsatisfied hard clauses, the SLS algorithm first tries to choose an unsatisfied hard clause randomly; otherwise, an unsatisfied soft clause is selected randomly. Then the SLS algorithm employs a strategy to pick a variable in the chosen hard or soft clause. In this work, this is accomplished by selecting the variable x with the greatest {a mathematical formula}sscore(x) in the chosen hard or soft clause, inspired by the literature [3].
      </paragraph>
      <paragraph>
       How to apply biased random walk in our SLS algorithm: In our CCEHC algorithm, we replace the standard random walk component (lines 5–6 in Algorithm 1) with the described biased random walk component, which is a natural way to apply the biased random walk component.
      </paragraph>
      <paragraph>
       Efficient implementation of biased random walk: As the biased random walk component would pick a clause randomly from either the set of unsatisfied hard clauses or the set of unsatisfied soft clauses in each search step, thus a key point to efficiently implement biased random walk is to maintain two clause sets during the search process: the set of current unsatisfied hard clauses and the set of current unsatisfied soft clauses.
      </paragraph>
     </section>
    </section>
    <section label="5">
     The CCEHC algorithm
     <paragraph>
      On the basis of the framework of the CCLS algorithm and three components underlying the EHC heuristic described in Section 4, here we present a new SLS algorithm called CCEHC for solving WPMS. We outline the pseudo-code of the CCEHC algorithm in Algorithm 2 and describe it in detail as follows.
     </paragraph>
     <paragraph>
      Initially, the CCEHC algorithm generates an assignment α uniformly at random as the initial solution. Then the CCEHC algorithm starts the search process, i.e., executing a loop. During the search process, whenever a better solution is found, the best solution {a mathematical formula}α⁎ is updated accordingly (line 19 in Algorithm 2).
     </paragraph>
     <paragraph>
      In each search step, CCEHC first checks whether the number of search steps exceeds the search step limit maxSteps, time limit is exceeded or all hard and soft clauses are satisfied: if one of these three terminating criterions is met, CCEHC terminates the search iteration; otherwise, CCEHC tries to select a flipping variable in this search step. With probability p, CCEHC calls the biased random walk component (lines 5–7 in Algorithm 2): if there exists any unsatisfied hard clause, an unsatisfied hard clause is selected randomly; otherwise, an unsatisfied soft clause is picked randomly; then CCEHC selects a variable x with greatest {a mathematical formula}sscore(x) in the chosen hard or soft clause as the variable to be flipped. With probability {a mathematical formula}1−p, CCEHC first checks whether the HCSCCDvars set is empty or not; if the HCSCCDvars set is not empty, CCEHC picks a variable randomly selected from HCSCCDvars (with bias towards the ones with the best hscore), inspired by the literature [3] (line 10 in Algorithm 2). Otherwise (the HCSCCDvars set is empty, meaning that the algorithm has stagnated), CCEHC updates hard clause weights according to the hard clause weighting scheme which is presented in Section 4.2 for diversification (line 12 in Algorithm 2), and then selects a variable according to the CCM-like heuristic (lines 13–17 in Algorithm 2): if the CCMPvars set is not empty, CCEHC picks the variable with the greatest score from CCMPvars, breaking ties randomly; otherwise (the CCMPvars is empty), CCEHC selects an unsatisfied clause randomly (if there exist unsatisfied hard clauses, then an unsatisfied hard clause is selected randomly; otherwise, an unsatisfied soft clause is selected randomly), and then CCEHC picks a variable randomly in the chosen hard or soft clause as the variable to be flipped. After the variable to be flipped is selected, the CCEHC algorithm flips the selected variable and then starts the next search step (line 18 in Algorithm 2).
     </paragraph>
     <paragraph>
      Finally, once the search process terminates, the CCEHC algorithm checks the feasibility of the best solution {a mathematical formula}α⁎. If {a mathematical formula}α⁎ is feasible (it satisfies all hard clauses), CCEHC reports {a mathematical formula}α⁎ as the solution; otherwise ({a mathematical formula}α⁎ is not feasible), CCEHC outputs “No feasible assignment is found”.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Experimental evaluations
     </section-title>
     <paragraph>
      In this section, we first introduce the benchmark instance sets, the competitors, and the experimental setup used in our experiments. Then, we report the experiments conducted on a broad range of WPMS benchmarks to evaluate the efficiency and the robustness of our CCEHC algorithm. Finally, we present additional empirical evaluations between CCEHC and a state-of-the-art complete solver WPM-2014 on all testing WPMS benchmark. Notably, our experimental results demonstrate the effectiveness of CCEHC on a number of application instances, where WPM-2014 as well as a state-of-the-art lower-bound based complete solver Eva could not return good-quality solutions within the cutoff time of 300 CPU seconds, indicating that CCEHC can be genuinely beneficial in practice.
     </paragraph>
     <paragraph>
      We would like to note that in the crafted WPMS category of the incomplete solver track of the MAX-SAT Evaluation 2015,{sup:2}CCEHC returns the best-quality solution on the largest number of WPMS instances, and more encouragingly finds the better-quality solution on more instances than an efficient complete solver ILP-2015-in[38], which uses the outputting format of incomplete solvers (i.e., printing the better-quality solution immediately once the solver finds one), while in that competition other SLS competitors were beaten by ILP-2015-in.
     </paragraph>
     <section label="6.1">
      <section-title>
       The benchmarks
      </section-title>
      <paragraph>
       We evaluate our CCEHC algorithm on a wide range of benchmarks including random, crafted and industrial WPMS benchmarks from the MAX-SAT Evaluation 2014 as well as four real-world application benchmarks. These testing benchmarks are described in detail below.
      </paragraph>
      <paragraph>
       The first benchmark (MSE2014_WPMS_Random) is the random WPMS benchmark from the MAX-SAT Evaluation 2014,{sup:3} which contains many random WPMS instances with a variety of clause-to-variable ratios.
      </paragraph>
      <paragraph>
       The second benchmark (MSE2014_WPMS_Crafted) is the crafted WPMS benchmark from the MAX-SAT Evaluation 2014,{sup:4} which contains many structured instances and includes many structured types such as those phase-transition ones generated according to Model RB, which have proven to be difficult both in theory [39] and in practice [40]. Solving these instances efficiently is considered to be a difficult task for SLS algorithms.
      </paragraph>
      <paragraph>
       The third benchmark (MSE2014_WPMS_Industrial) is the industrial WPMS benchmark from the MAX-SAT Evaluation 2014,{sup:5} which currently remains very difficult for SLS algorithms. On solving these industrial WPMS instances, SLS algorithms usually show poor performance. Thus, it is a challenge to improve the performance of SLS algorithms on this benchmark.
      </paragraph>
      <paragraph>
       Moreover, in order to show that our CCEHC algorithm might be beneficial in practice, we consider four real-world application benchmarks which are encoded from real-world applications, including computational protein design{sup:6}[4], [5], advanced encryption standard{sup:7} (AES) [41], the pedigree problem{sup:8}[42] and cluster expansion{sup:9}[43]. For the benchmark of computational protein design, all instances are encoded by Allouche et al. [5]. Computational protein design tries to intelligently guide the protein design process by producing a collection of proteins that is rich in functional proteins, and has been successfully applied to increase protein thermostability and solubility [5]. For the benchmark of advanced encryption standard, all instances in this benchmark are encoded by Gwynne et al. [41] using minimum box translation. These WPMS instances are translated from components of AES and small-scale variants. AES has been broadly applied in many fields, such as secure communication systems, high-performance database severs, digital video/audio recorders, RFID tags, smart cards [44] and FPGA-based designs [45], [46]. For the pedigree benchmark, all instances are translated from the model of the weighted constraint satisfaction problem, and are encoded by Sanchez et al. [42]. The objective in the NP-complete pedigree problem is to decide whether a Mendelian error exists in a given pedigree [47]; this is becoming an increasingly important problem [42]. For the benchmark of cluster expansion, all instances are translated from the model of pseudo-Boolean optimization, and are encoded by Huang et al. [48]. Cluster expansion is used to solve exact ground states for generalized Ising model [49] with certain periodicity, and is physically related to the construction of ground state phase diagram for different alloys [50] or battery materials [51].
      </paragraph>
     </section>
     <section label="6.2">
      <section-title>
       The state-of-the-art SLS competitors
      </section-title>
      <paragraph>
       Our CCEHC algorithm is compared against three state-of-the-art SLS algorithms, namely CCLS[22], Dist[3] and DistUP[23].
      </paragraph>
      <paragraph>
       The CCLS algorithm is the basic framework of CCEHC, and is the current best SLS solver for weighted MAX-SAT instances and unweighted MAX-SAT instances. CCLS won several categories in the incomplete solver tracks of the MAX-SAT Evaluations 2013 and 2014. As reported in the literature [22], on many types of MAX-SAT instances, CCLS significantly outperforms an efficient SLS solver IRoTS [2] and finds much better-quality solution than two state-of-the-art complete solvers, akmaxsat_ls [52] and New WPM2 [14]. Also, according to the results of the MAX-SAT Evaluation 2013, CCLS performs much better than iraNovelty++ [53], optimax-it, SAT4Jms-ext-i [54] and SAT4Jms-int-i [54]. In our experiments, we use the version of CCLS which is submitted to the MAX-SAT Evaluation 2015.
      </paragraph>
      <paragraph>
       The Dist algorithm is the current best SLS solver for PMS instances, and won several categories in the incomplete solver track of the MAX-SAT Evaluation 2014. Indeed, Dist is also the current best SLS solver for WPMS, and won the random WPMS category and the crafted WPMS category in the incomplete solver track of the MAX-SAT Evaluation 2014 by beating all SLS solvers and outperforming all complete solvers which participate in these categories such as WPM-2014[14], [15] and optimax. As reported in the literature [3], Dist shows superiority over CCLS and an efficient SLS solver TWO-LEVEL[55] on a wide range of PMS benchmarks, and competes well with state-of-the-art complete solvers on some classes of PMS application instances. In our experiments, we adopt the latest version of Dist[23].
      </paragraph>
      <paragraph>
       The DistUP algorithm equips Dist with an unit propagation initialization and is the most recent improvement of Dist. In our experiments, we adopt the version of DistUP presented in the literature [23].
      </paragraph>
     </section>
     <section label="6.3">
      <section-title>
       Experimental preliminaries
      </section-title>
      <paragraph>
       Our CCEHC algorithm is implemented in the programming language C++ and compiled by the compiler g++ (version 4.6.3) with the option ‘-O2’. The source codes{sup:10} of CCEHC and the detailed experimental results{sup:11} of CCEHC are both available online. In this paper, all experimental evaluations are carried out on a cluster of workstations equipped with Intel Xeon E7-8830 2.13 GHz CPU, 24 MB L3 cache and 1.0 TB RAM under the operating system CentOS (version: 7.0.1406).
      </paragraph>
      <paragraph>
       In our experiments, the evaluation methodology is the same as the one adopted in the incomplete solver track of the MAX-SAT Evaluation 2014, and is described as follows. Each solver performs one run on each instance. For each run, we record the best solution and utilize the runsolver tool (version 3.3.4) [56] to record the time for finding the best solution. For each solver on each instance class or benchmark, we report the number of instances where the solver finds the best solution among all solvers in the same table corresponding to the related experiment, denoted by ‘#win.’, and the averaged time of doing so on such winning instances, denoted by ‘time’ (the unit is CPU second). The number of instances in each instance class or benchmark is indicated in the column ‘#inst.’. The cutoff time of each run is set to 300 CPU seconds, suggested by the rules of the incomplete solvers track of the MAX-SAT Evaluation 2014, unless we clearly specify the cutoff time in the tables which present the related experimental results. The rules of the MAX-SAT Evaluation 2014 establish that the winner is the solver which finds the best solution for the most instances among all competing solvers in the related experiment, breaking ties by preferring the solver with the least averaged time. The results in the bold font indicate the best performance for the related instance class or benchmark in the related experiment.
      </paragraph>
      <paragraph>
       Additionally, in order to study the complementarity of the competing solvers, in each experiment, we also report the results of the Virtual Best Solver (VBS), i.e., the perfect selector – on each instance, the solution of VBS is the best one of the solutions reported by all competing solvers included in this experiment on solving this instance; if more than one competing solver report the best-quality solution, the computing time of VBS on this instance is the shortest one. We would like to note that VBS is not an actual solver, and it gives an upper bound on the performance of an actual per-instance selector of all competing solvers in an experiment.
      </paragraph>
     </section>
     <section label="6.4">
      <section-title>
       Parameter tuning
      </section-title>
      <paragraph>
       It is well acknowledged that parameter settings are important to the empirical behavior for many high-performance algorithms, especially heuristic algorithms for solving computationally hard problems [57]. At present, general-purpose automatic configuration tools [57], [58] have been applied to tuning the parameter settings for practical algorithms and have shown their power on solving SAT and mixed integer programming.
      </paragraph>
      <paragraph>
       In this work, in order to conduct a fair performance comparison, we utilize a powerful automatic configuration tool called SMAC (Sequential Model-based Algorithm Configuration, version: 2.10.03) [58] to tune the parameter settings for our SLS algorithm CCEHC and all the SLS competitors.
      </paragraph>
      <paragraph>
       The CCEHC algorithm has 2 parameters to be tuned: p (which is a real number and controls the balance between the greedy mode and the diversification mode) and sp (which is a real number and controls the probability of smoothing hard clause weights); the Dist algorithm has 3 parameters to be tuned: wp (which is a real number and controls the probability of activating the random walk heuristic), sp (which is a real number and controls the probability of smoothing hard clause weights) and t (which is an integer and controls the cardinality of the candidate variable set applied in the ‘Best from Multiple Selections’ strategy); the CCLS algorithm has 1 parameter to be tuned: p (which is a real number and controls the balance between the greedy mode and the diversification mode). For CCEHC, the parameter domain of real number p is {a mathematical formula}[0,0.5], and the default value of p is 0.2; the parameter domain of real number sp is {a mathematical formula}[0,0.1], and the default of sp is 0.001 for solving industrial and application instances and 0.0001 for solving random and crafted WPMS instances. For Dist, the parameter domain of real number wp is {a mathematical formula}[0,1], and the default value of wp is 0.1; the parameter domain of real number sp is {a mathematical formula}[0,1], and the default value of sp is 0.00001 for solving industrial and application WPMS instances and 0.001 for random and crafted WPMS instances; the parameter domain of integer t is {a mathematical formula}[1,100], and the default value of t is 40 for industrial and application WPMS instances and 15 for random and crafted WPMS instances. For CCLS, the parameter domain of real number p is {a mathematical formula}[0,1], and the default value of p is 0.2.
      </paragraph>
      <paragraph>
       In the parameter tuning procedure, we use the whole MSE2014_WPMS_Random benchmark, the whole MSE2014_WPMS_Crafted benchmark as well as the whole MSE2014_WPMS_Industrial benchmark as the training sets for tuning the parameter settings for each solver on solving random WPMS instances, crafted WPMS instances as well as industrial and application WPMS instances, respectively. The configuration objective for SMAC is the solution-quality (i.e., minimizing the weight of unsatisfied soft clauses). The cutoff time of each run for SMAC is 300 CPU seconds, and the time budget of all runs for SMAC is 172800 CPU seconds (i.e., 2 days).
      </paragraph>
      <paragraph>
       The parameter settings found by SMAC for CCEHC, Dist and CCLS are summarized in Table 1, and we use these parameter settings in the following experimental evaluations. As the only difference between DistUP and Dist is the initialization procedure, in our experiments DistUP uses the same parameter settings as Dist does.
      </paragraph>
     </section>
     <section label="6.5">
      <section-title>
       Experimental results with SLS competitors
      </section-title>
      <paragraph>
       In this subsection, we conduct extensive experiments of our CCEHC algorithm and its state-of-the-art SLS competitors, i.e., DistUP, Dist and CCLS on all testing benchmarks, i.e., the MSE2014_WPMS_Random, MSE2014_WPMS_Crafted and MSE2014_WPMS_Industrial benchmarks and four real-world application WPMS benchmarks.
      </paragraph>
      <section label="6.5.1">
       <section-title>
        Experiments on the MSE2014_WPMS_Random benchmark
       </section-title>
       <paragraph>
        Table 2 presents the comparative results of our CCEHC algorithm and its state-of-the-art SLS competitors DistUP, Dist and CCLS on the MSE2014_WPMS_Random benchmark. On this benchmark, CCEHC provides a performance advantage over CCLS in terms of solution-quality. On the overall performance of this benchmark, although CCEHC is slower than both DistUP and Dist in terms of averaged time, CCEHC, DistUP and Dist show the same performance in terms of solution-quality (they all find the best solution for 279 instances). The results of VBS over all random WPMS instances show that these competing SLS solvers are complementary in terms of averaged time, and indicate that it is promising to construct an algorithm-selector consisting of these competing SLS solvers.
       </paragraph>
      </section>
      <section label="6.5.2">
       <section-title>
        Experiments on the MSE2014_WPMS_Crafted benchmark
       </section-title>
       <paragraph>
        The comparative results of CCEHC and its state-of-the-art SLS competitors DistUP, Dist and CCLS on the MSE2014_WPMS_Crafted benchmark are illustrated in Table 3. According to Table 3, it is clear that our CCEHC algorithm stands out as the best solver on this benchmark. From the experimental results, on all 310 instances, CCEHC finds the best solution for 282 of them, while this figure for DistUP, Dist and CCLS is only 194, 192 and 146, respectively. In detail, on all 16 instance classes, CCEHC gives the best performance on 12 of them, while this figure for DistUP, Dist and CCLS is only 4, 5 and 4, respectively. Dist won the crafted WPMS category in the incomplete solver track of the MAX-SAT Evaluation 2014 and DistUP also exhibits good performance on this benchmark, so it is challenging to improve such performance over DistUP and Dist on the MSE2014_WPMS_Crafted benchmark. The experimental results show that our CCEHC algorithm achieves the state-of-the-art performance on crafted WPM instances.
       </paragraph>
       <paragraph>
        Then we focus on the investigation of the complementarity of all competing SLS solvers on this benchmark. The results of VBS show that these competing SLS solvers are complementary on 4 instance classes (i.e., ‘CSG’, ‘min-enc/warehouses’, ‘pseudo/miplib’ and ‘ramsey’) in terms of the solution quality, and indicate that these solvers might be complementary to each other. The experimental results also indicate that it is promising to build an algorithm-selector consisting of all competing SLS solvers on these 4 instance classes.
       </paragraph>
      </section>
      <section label="6.5.3">
       <section-title>
        Experiments on the MSE2014_WPMS_Industrial benchmark and four real-world application WPMS benchmarks
       </section-title>
       <paragraph>
        The comparative results of CCEHC and its state-of-the-art SLS competitors DistUP, Dist and CCLS on the MSE2014_WPMS_Industrial benchmark and four real-world application WPMS benchmarks are summarized in Table 4. According to the empirical results presented in Table 4, although CCEHC performs slightly slower than CCLS on the benchmark of advanced encryption standard and performs slightly slower than DistUP and Dist on the benchmark of cluster expansion, it is very apparent that, among these four competing SLS algorithms, our CCEHC algorithm performs best on the MSE2014_WPMS_Industrial benchmark and two real-world application WPMS benchmarks (i.e., ‘Computational Protein Design’ and ‘Pedigree’). Particularly, the related experimental results indicate that our CCEHC algorithm is able to return better-quality solutions compared to CCLS, Dist and DistUP on a large number of real-world application instances. In fact, SLS algorithms are considered to be ineffective on solving industrial WPMS instances and real-world application instances, so it is very difficult to improve such performance of SLS algorithms on these benchmarks.
       </paragraph>
       <paragraph>
        The results of VBS show that these competing SLS solvers are complementary on 4 benchmarks (i.e., ‘MSE2014_WPMS_Industrial’, ‘Computational Protein Design’, ‘Advanced Encryption Standard’ and ‘Pedigree’) in terms of the solution quality, and indicate the complementarity among these competing solvers. This also indicates that building an algorithm selector consisting of all competing SLS solvers could give performance advantage on these 4 benchmarks.
       </paragraph>
      </section>
      <section label="6.5.4">
       <section-title>
        Experiments on evaluating performance variability of SLS solvers
       </section-title>
       <paragraph>
        SLS solvers are randomized, and their performance (e.g., solution quality found after a fixed amount of running time) can vary substantially over multiple independent runs on the same problem instance. We conduct empirical evaluations to study the performance variability of SLS solvers. We first select 4 random WPMS instances, 11 crafted WPMS instances and 6 industrial and application WPMS instances as the testing instances. Then all SLS solvers (CCEHC, CCLS, Dist and DistUP) are run 10 times (the cutoff time of each run is set to 300 CPU seconds) on each selected instance.
       </paragraph>
       <paragraph>
        The detailed experimental results on random instances, crafted instances as well as industrial and application instances are reported in Table 5, Table 6, Table 7, respectively. In Table 5, Table 6, Table 7, for each SLS solver, ‘min.’ and ‘max.’ denote the minimum and maximum weight of unsatisfied soft clauses among all 10 runs, respectively, while ‘avg.’ denotes the averaged weight of unsatisfied soft clauses over all 10 runs; ‘time’ denotes the averaged consuming time over all 10 runs; ‘c.v.’ denotes the coefficient of variance (i.e., the standard deviation divided by the average value) in terms of consuming time over all 10 runs. According to Table 5, Table 6, Table 7, in terms of the minimum unsatisfied weight among 10 runs, CCEHC gives the best performance on 4 random WPMS instances, 11 crafted WPMS instances and 5 industrial and application instances; those of DistUP are 4, 6 and 2, respectively; those of Dist are 4, 6 and 1, respectively; those of CCLS are 4, 5 and 1, respectively. In terms of the averaged unsatisfied weight over 10 runs, CCEHC gives the best performance on 4 random WPMS instances, 10 crafted WPMS instances and 5 industrial and application WPMS instances; those of DistUP are 4, 4, and 2, respectively; those of Dist are 4, 4 and 1, respectively; those of CCLS are 4, 4 and 1, respectively. The experiments show that CCEHC stands out as the best solver in this comparison. According to the experimental results presented in Table 5, Table 6, Table 7, the metric of coefficient of variance in terms of consuming time, denoted by notation ‘c.v’, witnesses that the variability of consuming time of CCEHC on these instances is significant.
       </paragraph>
      </section>
     </section>
     <section label="6.6">
      Comparing CCEHC against state-of-the-art complete solvers
      <paragraph>
       In this subsection, we conduct more empirical analyses to evaluate our CCEHC algorithm against a state-of-the-art complete solver WPM-2014[14], [15]. In this experiment, we adopt the version of WPM-2014 which uses the outputting format of incomplete solvers (i.e., printing the better-quality solution immediately once the solver finds one). According to the competition results of the MAX-SAT Evaluation 2014, this version of WPM-2014 won the industrial WPMS category in the incomplete solver track of the MAX-SAT Evaluation 2014. Additionally, we also report the experimental results for Eva[16], which won the industrial WPMS category in the complete solver track of the MAX-SAT Evaluation 2014. As the Eva solver performs a lower bound based core-guided search, it only finds one feasible solution finally when it proves optimality. Thus, it is unfair to directly compare CCEHC with Eva, so, as a reference, here we report the experimental results for Eva just to indicate the performance of the current state-of-the-art complete solver Eva on these benchmarks. The related experimental results are reported in Table 8.
      </paragraph>
      <paragraph>
       According to Table 8, although CCEHC performs worse than WPM-2014 on the MSE2014_WPMS_Industrial benchmark and the pedigree benchmark, CCEHC significantly outperforms the complete solver WPM-2014 on the MSE2014_WPMS_Random benchmark, the MSE2014_WPMS_Crafted benchmark and three real-world application benchmarks (‘Computational Protein Design’, ‘Advanced Encryption Standard’ and ‘Cluster Expansion’). The WPM-2014 solver is a SAT-based complete MAX-SAT solver, which successively calls an efficient SAT solver. As this SAT-based technique is efficient in solving industrial problems and all state-of-the-art MAX-SAT algorithms that perform well on industrial instances are based on this technique [15], it is not surprising that WPM-2014 performs better than CCEHC on the MSE2014_WPMS_Industrial benchmark and the pedigree benchmark. However, the results of VBS present that CCEHC are complementary to WPM-2014 on the MSE2014_WPMS_Industrial benchmark and the pedigree benchmark, which indicates that the combination of SLS algorithms and complete algorithms could achieve better performance on solving industrial WPMS instances.
      </paragraph>
      <paragraph>
       More encouragingly, the results of VBS, on the MSE2014_WPMS_Crafted benchmark, the MSE2014_WPMS_Industrial benchmark and three real-world application benchmarks of computational protein design, advanced encryption standard and pedigree, show that our CCEHC algorithm is complementary to WPM-2014, and indicate that it is promising to build an algorithm-selector consisting of CCEHC and WPM-2014 to achieve better performance.
      </paragraph>
      <paragraph>
       We observe that the complete solvers perform worse than CCEHC on several groups of application instances, including the benchmarks of computational protein design, advanced encryption standard and cluster expansion, as well as instances in the MSE2014_WPMS_Random and MSE2014_WPMS_Crafted benchmarks. To study the performance of the complete solvers with longer cutoff time on these benchmarks, we test complete solvers WPM-2014 and Eva on these three application WPMS benchmarks with a longer cutoff time of 1800 CPU seconds. The experimental results are reported in Table 9, which demonstrate that WPM-2014 within the cutoff time of 1800 CPU seconds still performs worse than our CCEHC algorithm within the cutoff time of 300 CPU seconds. This confirms the effectiveness of CCEHC on these three application WPMS benchmarks, the MSE2014_WPMS_Random benchmark and the MSE2014_WPMS_Crafted benchmark.
      </paragraph>
      <paragraph>
       Additionally, we conduct more empirical evaluations of our CCEHC algorithm and the complete solver WPM-2014 on all the testing WPMS benchmarks with various cutoff time (50 CPU seconds, 1800 CPU seconds and 5400 CPU seconds), in order to further study the performance of these solvers for WPMS. We also report the experimental results of the lower bound based complete solver Eva with these various cutoff time, as a reference. The experimental results of empirical evaluations within the cutoff time of 50 CPU seconds, 1800 CPU seconds and 5400 CPU seconds are demonstrated in Table 10, Table 11, Table 12, respectively. Table 10 shows that, within the cutoff time of 50 CPU seconds, CCEHC performs better than WPM-2014 on the MSE2014_WPMS_Random benchmark, the MSE2014_WPMS_Crafted benchmark, and all four real-world application benchmarks. According to Table 11, Table 12, the experimental results present that, within the cutoff time of 1800 CPU seconds and 5400 CPU seconds, CCEHC outperforms WPM-2014 on the MSE2014_WPMS_Random benchmark, the MSE2014_WPMS_Crafted benchmark, and three real-world application benchmarks of computational protein design, advanced encryption standard and cluster expansion. In conclusion, the empirical results with various cutoff time confirm the effectiveness of CCEHC on a large number of WPMS instances, which indicates that our CCEHC algorithm can be genuinely beneficial in practice.
      </paragraph>
     </section>
    </section>
    <section label="7">
     <section-title>
      Discussion
     </section-title>
     <paragraph>
      In this section, we present a detailed discussion of our CCEHC algorithm. First, we conduct further empirical analyses to present the effectiveness of each underlying component in the EHC heuristic. Then, we discuss the major differences between CCEHC and CCLS, as well as the main differences between CCEHC and Dist. Finally, we conduct more empirical evaluations to study the performance of the combination of the CCEHC algorithm and the unit propagation initialization.
     </paragraph>
     <section label="7.1">
      <section-title>
       Effectiveness of the EHC components
      </section-title>
      <paragraph>
       As explained in Section 4, there are three components underlying the EHC heuristic, i.e., the variable selection mechanism focusing on configuration checking based only on the states of hard clauses, the weighting scheme for hard clauses, and the biased random walk component. Thus, in order to demonstrate the effectiveness of these three components in the EHC heuristic, we conduct experiments to compare CCEHC with the three alternative versions in the following.
      </paragraph>
      <list>
       <list-item label="•">
        CCEHC_alt1: This alternative version of CCEHC does not utilize the variable selection mechanism focusing on configuration checking based only on the states of hard clauses. In another word, this alternative version does not select variables to be flipped from the HCSCCDvars set during the search process (i.e., removing lines 9–10 in Algorithm 2). We note that the CCEHC_alt1 algorithm would activate the weighting scheme for hard clauses when it works in the greedy mode.
       </list-item>
       <list-item label="•">
        CCEHC_alt2: This alternative version of CCEHC does not utilize the weighting scheme for hard clauses (i.e., removing line 12 in Algorithm 2).
       </list-item>
       <list-item label="•">
        CCEHC_alt3: This alternative version of CCEHC uses the standard random walk component rather than the biased random walk component, as the CCLS algorithm does (i.e., replacing the biased random walk component, i.e., lines 5–7 in Algorithm 2, with the standard random walk component, i.e., lines 5–6 in Algorithm 1).
       </list-item>
      </list>
      <paragraph>
       Before the empirical study of CCEHC and its three alternative versions, we utilize the automatic configuration tool SMAC to tune the parameters for CCEHC's three alternative versions. We use the parameter settings of CCEHC tuned by SMAC as the default values of the parameters for CCEHC's three alternative versions. For CCEHC_alt1 and CCEHC_alt3, the parameter domain of real number p is [0, 1], and the default value of p is 0.279 for industrial and application WPMS instances, 0.2 for random WPMS instances, and 0.177 for crafted WPMS instances; the parameter domain of real number sp is [0, 1], and the default value of sp is 0.085 for industrial and application WPMS instances, 0.0001 for random WPMS instances and 0.003 for crafted WPMS instances. For CCEHC_alt2, the parameter domain of real number p is 0.279 for industrial and application WPMS instances, 0.2 for random WPMS instances, and 0.177 for crafted WPMS instances (as CCEHC_alt2 does not utilize the weighting scheme for hard clauses, thus it omits the parameter sp). We note that the configuration protocol for SMAC utilized here is the same as the one which is adopted in Section 6.4.
      </paragraph>
      <paragraph>
       The parameter settings found by SMAC for CCEHC_alt1, CCEHC_alt2 and CCEHC_alt3 are summarized in Table 13, and we use these parameter settings in the following empirical study.
      </paragraph>
      <paragraph>
       Empirical results for CCEHC and its three alternative versions on all testing WPMS benchmarks are reported in Table 14. As can be seen from Table 14, CCEHC performs generally better than its all three alternative versions, which indicates the effectiveness of all three components of our EHC heuristic. Particularly, on the MSE2014_WPMS_Crafted benchmark, the MSE2014_WPMS_Industrial benchmark and a real-world application WPMS benchmark (‘Pedigree’), CCEHC performs much better than all its three alternative versions in terms of the solution-quality, which confirms that our proposed EHC heuristic contributes to the performance of CCEHC on a number of structured WPMS instances and real-world application WPMS instances.
      </paragraph>
      <paragraph>
       Then we investigate the complementarity of CCEHC and its alternative versions. The results of VBS indicate that these competing solvers are complementary in the MSE2014_WPMS_Crafted benchmark, the MSE2014_WPMS_Industrial benchmark, and three real-world application benchmarks of computational protein design, advanced encryption standard and pedigree, which indicates that it is promising to build an algorithm-selector consisting of CCEHC and its three alternative versions to improve the empirical performance.
      </paragraph>
     </section>
     <section label="7.2">
      Main differences between CCEHC and CCLS
      <paragraph>
       Although our CCEHC algorithm is conceptually related to the CCLS algorithm [22], there exist major differences between CCEHC and CCLS. In this subsection, we summarize these major differences, and directly list them as follows.
      </paragraph>
      <list>
       <list-item label="•">
        How to deal with the input WPMS instance: The CCEHC algorithm is designed for solving WPMS, so CCEHC is able to solve the input WPMS instance directly, while the CCLS algorithm is developed for solving weighted MAX-SAT, so CCLS needs to translate the input WPMS instance to weighted MAX-SAT, and then solve the resulting encoded weighted MAX-SAT instance.
       </list-item>
       <list-item label="•">
        Variable selection mechanism: The CCEHC algorithm prefers to select the variable to be flipped by emphasizing the information of hard clauses, i.e., preferring the variable with the greatest hscore, while the CCLS algorithm does not distinguish hard clauses and soft clauses, and simply uses the general score property to choose the variable to be flipped.
       </list-item>
       <list-item label="•">
        Hard clause weighting scheme: The CCEHC algorithm employs a clause weighting scheme that only works for hard clauses to diversify the search, while the CCLS algorithm does not use any clause weighting schemes.
       </list-item>
       <list-item label="•">
        Type of the random walk component: In order to give a higher priority to hard clauses, the CCEHC algorithm applies a biased random walk component that first tries to select an unsatisfied hard clause, while the CCLS algorithm uses a standard random walk component, which is designed for non-partial MAX-SAT, and treats hard clauses and soft clauses as same.
       </list-item>
       <list-item label="•">
        Empirical performance on a wide range of WPMS benchmarks: As can be clearly seen from the extensive experiments illustrated in Table 2, Table 3, Table 4, Table 5, Table 6, Table 7 in Section 6, the CCEHC algorithm performs much better than the CCLS algorithm on a wide range of WPMS benchmarks, indicating that the significant performance improvements of CCEHC over CCLS are due to the above major differences between these two SLS algorithms.
       </list-item>
      </list>
     </section>
     <section label="7.3">
      Main differences between CCEHC and Dist
      <paragraph>
       As the Dist algorithm [3] also separates hard clauses and soft clauses (the pseudo-code of Dist can be found in the literature [3]), in this subsection, we discuss the main differences between CCEHC and Dist in detail. We would like to note that the only difference between Dist and DistUP[23] is the initialization procedure, so we here discuss the differences between CCEHC and Dist. The main differences between CCEHC and Dist are summarized below.
      </paragraph>
      <list>
       <list-item label="•">
        Basic framework: The CCEHC algorithm is based on the CCLS algorithm which has been applied successfully to solving weighted MAX-SAT, while the Dist algorithm is developed following the simple GSAT algorithm which is the earliest SLS algorithm for solving SAT.
       </list-item>
       <list-item label="•">
        Variable selection mechanism: The CCEHC algorithm utilizes the new HCSCC strategy to select variables to be flipped and thus prefers to select the HCSCCD variable, while the Dist algorithm does not use the HCSCC strategy and simply prefers choosing the decreasing variable (i.e., variable x with {a mathematical formula}hscore(x)&gt;0 or with {a mathematical formula}hscore(x)=0 and {a mathematical formula}sscore(x)&gt;0).
       </list-item>
       <list-item label="•">
        Time to activate the hard clause weighting scheme: The CCEHC algorithm activates the hard clause weighting scheme when there is no HCSCCD variable, while Dist does that when no decreasing variable exists.
       </list-item>
       <list-item label="•">
        Time to call biased random walk: The CCEHC algorithm calls the biased random walk component with a fixed probability at the start of each search step, while the Dist algorithm calls it after activating the hard clause weighting scheme.
       </list-item>
       <list-item label="•">
        Empirical performance on a broad range of WPMS benchmarks: According to the experimental results presented in Table 2, Table 3, Table 4, Table 5, Table 6, Table 7 in Section 6, it can be clearly observed that CCEHC significantly outperforms Dist as well as Dist's most recent improvement DistUP on a broad range of WPMS benchmarks, which indicates that the obvious superiority of CCEHC over Dist and DistUP is owing to these main differences.
       </list-item>
      </list>
     </section>
     <section label="7.4">
      Initializing CCEHC by unit propagation
      <paragraph>
       Inspired by the success of the DistUP solver, which equips Dist with an unit propagation initialization [23], we combine CCEHC with the unit propagation initialization, and empirically evaluate the resulting hybrid solver on all testing benchmarks. By replacing Dist with CCEHC in the DistUP solver, we obtain a new solver namely CCEHC+UP. Then we conduct experiments to show the efficiency of CCEHC+UP. The comparative results of CCEHC+UP and CCEHC are reported in Table 15. According to Table 15, CCEHC+UP performs better than CCEHC on all the testing benchmarks but one (‘Pedigree’). The results of VBS indicate that CCEHC+UP is complementary to CCEHC on the MSE2014_WPMS_Crafted benchmark, the MSE2014_WPMS_Industrial benchmark, and two real-world application benchmarks (‘Computational Protein Design’ and ‘Pedigree’), which indicates that it is promising to build an algorithm-selector consisting of CCEHC and CCEHC+UP on solving WPMS instances. The experimental results also show that CCEHC could cooperate well with the unit propagation initialization on solving WPMS instances.
      </paragraph>
     </section>
    </section>
    <section label="8">
     <section-title>
      Conclusions and future work
     </section-title>
     <paragraph>
      In this work, we design a heuristic with emphasis on hard clauses, called EHC, for SLS algorithms for solving the WPMS problem. By incorporating the EHC heuristic into CCLS, we present a new SLS algorithm named CCEHC for solving WPMS.
     </paragraph>
     <paragraph>
      To demonstrate the effectiveness and the robustness of our CCEHC algorithm, we evaluate CCEHC on a broad range of WPMS benchmarks, including random, crafted, industrial and real-world application instances. Our experimental results show that CCEHC significantly outperforms state-of-the-art SLS algorithms namely CCLS, Dist and DistUP on these WPMS benchmarks, indicating that CCEHC establishes a new state of the art on SLS algorithms for solving WPMS. Our further experimental results on evaluating CCEHC with a state-of-the-art complete solver WPM-2014 show the effectiveness of CCEHC on random WPMS instances, crafted WPMS instances and many WPMS instances based on real-world applications. Particularly, on a number of important real-world application WPMS instances, where WPM-2014 and a state-of-the-art lower-bound based complete solver Eva could not return good-quality solutions quickly (e.g., within the cutoff time of 5400 CPU seconds), our CCEHC algorithm is able to produce good-quality solutions fast, which indicates that CCEHC might be genuinely beneficial in practice. Further, we perform more empirical evaluations to analyze the effectiveness of the EHC heuristic, and the related experiments confirm the effectiveness of each underlying component in the EHC heuristic and demonstrate that our EHC heuristic contributes to the performance of CCEHC on a number of structured WPMS instances and real-world application WPMS instances. Also, we conduct empirical evaluations to study the combination of CCEHC and the unit propagation initialization and the related experiments show that CCEHC is able to cooperate well with the unit propagation initialization.
     </paragraph>
     <paragraph>
      In future work, we would like to further study the flexibility of our EHC heuristic, and improve the performance of CCEHC on solving WPMS instances by integrating other powerful algorithmic techniques, such as the ‘Best from Multiple Selections’ strategy [59]. We would also like to build an algorithm-selector consisting of our CCEHC algorithm and other solvers to achieve better performance on solving WPMS instances.
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>