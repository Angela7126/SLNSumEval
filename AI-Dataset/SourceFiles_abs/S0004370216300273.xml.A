<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    On abstract modular inference systems and solvers.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Knowledge representation and reasoning (KR&amp;R) is concerned with developing formal languages and logics to model knowledge, and with designing and implementing corresponding automated reasoning tools. The choice of specific logics and tools depends on the type of knowledge to be represented and reasoned about. Different logics are suitable for common-sense reasoning, reasoning under incomplete information and uncertainty, for temporal and spatial reasoning, and for modeling and solving Boolean constraints, or constraints over larger, even continuous domains. In applications in areas such as distributed databases, semantic web, hybrid constraint modeling and solving, to name just a few, several of these aspects come into play. Accordingly, often diverse logics have to be accommodated together.
     </paragraph>
     <paragraph>
      Modeling convenience is not the only reason why diverse logics are combined into modular hybrid KR&amp;R systems. Another motivation is to exploit in reasoning the transparent structure that comes from modularity, computational strengths of individual logics, and synergies that arise when they are put together. An early example of a successful integration of different types of reasoning is constraint logic programming (CLP) [28], [29], which exploited computational properties of different theories of constraints in a formalism centered around logic programming. About two decades later a similar idea appeared in the area of propositional satisfiability. The resulting approach, known as satisfiability modulo theories (SMT) [49], [4], consists of integrating diverse constraint theories around the “core” provided by propositional satisfiability. SMT solvers are currently among the most efficient automated reasoning tools and are widely used for computer-aided software verification [10]. Another, more recent example is constraint answer set programming (CASP) [45], [20], [2], [31], [35] that integrates answer set programming (ASP) [42], [47] with constraint modeling and solving [51]. These approaches do not impose any strong a priori restrictions on the constraint theories they allow. However, some types of theories are particularly heavily studied (for instance, equality with uninterpreted functions, forms of arithmetic, arrays). Finally, more focused hybrid systems that combine modules expressed in classical logic with modules given as answer set programs have also received substantial attention lately. Examples include the “multi-logics” PC(ID) [43], SM(ASP) [36] and ASP-FO [11].{sup:1} These multi-logic modular integrations facilitate modeling but also often lead to enormous performance gains. A good example is the problem of existence of Hamiltonian cycles in graphs. Known propositional logic encodings require that counter variables be used to represent reachability. That leads to representations of large sizes. Using propositional logic to represent non-recursive constraints and logic programs to represent reachability (which is much more direct than a counter-based propositional encoding) leads to concise encodings. East and Truszczynski [13] demonstrated that the performance of SAT solvers on propositional encodings of the problem lags dramatically behind that of the solver aspps, designed for handling together propositional and logic program modules on hybrid representations of the problem.{sup:2} The “computational” motivation behind modular KR&amp;R underlies our paper.
     </paragraph>
     <paragraph>
      The key computational task arising in KR&amp;R is that of model generation. Model Generating programs, or solvers, developed in satisfiability (SAT) and ASP proved to be effective in a broad range of KR&amp;R applications. Accordingly, model generation is of critical importance in modular multi-logic systems. Research on formalisms listed above resulted in fast solvers that demonstrate substantial gains that one can obtain from their heterogeneous nature. However, the diversity of logics considered and low-level technical details of their syntax and semantics obscure general principles that are important in the design and analysis of solvers for multi-logic systems.
     </paragraph>
     <paragraph>
      In this paper, we address this problem by proposing a language for representing modular multi-logic systems that aims to provide a general abstract view on solvers, to bring up key principles behind solver design, and to facilitate studies of their properties. As we are not concerned with the modeling aspect of a KR&amp;R system but with solving, we design our language so that it (i) abstracts away the syntactic details, (ii) can capture diverse concepts of inference, and (iii) is based only on the weakest assumptions concerning the semantics of underlying logics, in particular, this language can capture any formalism whose semantics is determined by a set of models. The basic elements of this language are abstract inference modules (or just modules) that are defined to consist of inferences. Collections of abstract inference modules constitute abstract modular inference systems (or just modular systems). We define the semantics of abstract inference modules and show that they provide a uniform language to capture inference mechanisms from different logics, and their modular combinations. Importantly, abstract inference modules and abstract modular inference systems give rise to transition graphs of the type introduced by Nieuwenhuis, Oliveras, and Tinelli [49] in their study of SAT and SMT solvers. As in that earlier work, our transition graphs provide a natural and convenient representation of solvers for modules and modular systems. They lend themselves well to extensions that capture such important solver design techniques as learning (which here comes in two flavors: local that is limited to single modules, and global that is applied across modules). In this way, abstract modular inference systems and the corresponding framework of transition graphs are useful conceptualizations clarifying computational principles behind solvers for multi-logic knowledge representation systems and facilitating systematic development of new ones. The design of transition systems based on syntax-free modules is what separates this work from earlier uses of graphs for describing model generation algorithms behind SAT, SMT, PC(ID), or ASP solvers [49], [43], [34], [36]. These earlier transition graphs are language specific and based on the syntactic constructs typical of the respective formalisms. Adding a new level of abstraction allows one a bird's eye view on the landscape of solving techniques and their usage in hybrid settings.
     </paragraph>
     <paragraph>
      To demonstrate the power of our approach, we show that it applies to answer set programming, propositional logic, multi-logic systems based on these two formalisms, and generally to satisfiability modulo theories. As SMT is a general framework for integrating diverse logics, the same expressivity claims hold true for our approach. However, in at least one aspect, our approach goes beyond the basic tenants of SMT. Namely, our modular systems have no central core, the role played by SAT in the case of SMT. Rather, all modules are viewed in exactly the same way and can pass on results of inferences directly to each other. In addition, all modules are presented in a uniform way as sets of inferences. In this way, we can ignore syntactical aspects of logics. Of course, that makes our formalism poorly tailored for modeling, as it is the syntax of logics that is typically used to provide concise representations of knowledge. Yet, our syntax-free modules make explicit the reasoning the logics of the modules support, and that is of central importance to our objective to support the design and analysis of solvers.
     </paragraph>
     <paragraph>
      The paper is organized as follows. We start by introducing abstract inference modules. We then adapt the transition graphs of Nieuwenhuis et al. [49] to the formalism of abstract inference modules and use them to describe algorithms for finding and enumerating models of modules. In Section 4, we introduce abstract modular inference systems, extend the concept of a transition graph to modular systems, and show that transition graphs can be used to formalize search for models in this setting, too. We also show in that section that abstract modular systems can be used to represent SMT. In Section 5, we discuss extensions to our framework that support representing model-finding algorithms exploiting “inference” learning, an abstract version of clause learning developed and studied in SAT. Throughout the paper, we illustrate our approach by showing how it applies to propositional logic, answer set programming, to multi-logic systems based on these two formalisms, and to SMT. We conclude by discussing related work, and recapping our contributions. All proofs are gathered in the appendix.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Abstract inference modules
     </section-title>
     <paragraph>
      We start with some notation. Let σ be a vocabulary (a set of propositional atoms). Elements of σ and their negations are literals. We write {a mathematical formula}Lit(σ) for the set of all literals over σ. For a literal l we define its dual literal{a mathematical formula}l‾ as ¬a, if {a mathematical formula}l=a, and a, if {a mathematical formula}l=¬a. For a set {a mathematical formula}M⊆Lit(σ), we define {a mathematical formula}M+=σ∩M and {a mathematical formula}M−={a∈σ:¬a∈M}. A literal {a mathematical formula}l∈Lit(σ) is unassigned by a set of literals {a mathematical formula}M⊆Lit(σ) if M contains neither l nor its dual literal {a mathematical formula}l‾. A set M of literals over σ is consistent if for every literal {a mathematical formula}l∈Lit(σ), {a mathematical formula}l∉M or {a mathematical formula}l‾∉M. We denote the set of all consistent subsets of {a mathematical formula}Lit(σ) by {a mathematical formula}C(σ). A set M of literals is complete over σ if for every atom {a mathematical formula}a∈σ, either {a mathematical formula}a∈M or {a mathematical formula}¬a∈M.
     </paragraph>
     <paragraph label="Definition 1">
      An abstract inference module over a vocabulary σ (or just a module, for short) is a finite set of pairs of the form {a mathematical formula}(M,l), where {a mathematical formula}M∈C(σ), {a mathematical formula}l∈Lit(σ) and {a mathematical formula}l∉M. These pairs are called inferences of the module. For a module S, {a mathematical formula}σS denotes the set of all atoms that appear (possibly negated) in inferences of S.
     </paragraph>
     <paragraph>
      Intuitively, an inference {a mathematical formula}(M,l) in a module indicates support for inferring l whenever all literals in M are given. We note that if {a mathematical formula}(M,l) is an inference and {a mathematical formula}l‾∈M, the inference is an explicit indication of a contradiction. Fig. 1(a) shows all inferences over the vocabulary {a mathematical formula}{a}. Figs. 1(b) and 1(c) give examples of modules over the vocabulary {a mathematical formula}{a}. Here and throughout the paper, we present inferences as directed edges and modules as bipartite graphs.
     </paragraph>
     <paragraph>
      A set {a mathematical formula}M⊆Lit(σ) is consistent with a set X (not necessarily included in σ) if {a mathematical formula}M+⊆X and {a mathematical formula}M−∩X=∅. A literal {a mathematical formula}l∈Lit(σ) is consistent with a set X if {a mathematical formula}{l} is consistent with X. Let S be an abstract inference module over a vocabulary σ. A set X is a model of S if for every inference {a mathematical formula}(M,l)∈S such that M is consistent with X, l is consistent with X, too. A module is satisfiable if it has models, and is unsatisfiable otherwise. For example, any set that contains a is a model of the module in Fig. 1(b), whereas no set that does not contain a is such. The module in Fig. 1(c) has no models due to inferences {a mathematical formula}(∅,a) and {a mathematical formula}(∅,¬a) (as well as {a mathematical formula}({a},¬a) and {a mathematical formula}({¬a},a)). The module in Fig. 1(b) is satisfiable, the one in Fig. 1(c) is unsatisfiable.
     </paragraph>
     <paragraph>
      Let S be an abstract module over some vocabulary σ. Clearly, S can also be viewed as a module over the vocabulary {a mathematical formula}σS, as any inference of S is an inference constructed of literals in {a mathematical formula}Lit(σS). Moreover, it is clear from the definitions that for a module S viewed as a module over {a mathematical formula}σS, a set X is a model of S if and only if {a mathematical formula}X∩σS is a model of S. Thus, the semantics of a module S is fully determined by its models contained in {a mathematical formula}σS. Following the same argument, we can view a module S over a vocabulary σ as a module over any vocabulary {a mathematical formula}σ′⊇σ. In this respect, modules behave exactly as formulas and theories in classical logic.
     </paragraph>
     <paragraph>
      Two modules (not necessarily over the same vocabulary) that have the same models are equivalent. Similarly to the observation made above, the following proposition shows that to test equivalence of modules one may restrict attention only to models consisting of atoms that occur in the modules in question.
     </paragraph>
     <paragraph label="Proposition 1">
      Abstract inference modules{a mathematical formula}S1and{a mathematical formula}S2are equivalent if and only if they have the same models contained in the set{a mathematical formula}σS1∪σS2.
     </paragraph>
     <paragraph>
      The semantics of modules is given by their models. Let S be a module over a vocabulary σ and l a literal in {a mathematical formula}Lit(σ). We say that S entails l, written {a mathematical formula}S|≈l, if for every model X of S, l is consistent with X. Furthermore, S entails l with respect to a set {a mathematical formula}M⊆Lit(σ) of literals, written {a mathematical formula}S|≈Ml, if whenever M is consistent with a model X of S, l is consistent with X, too. Modules are sound with respect to their semantics, which we formally state below.
     </paragraph>
     <paragraph label="Proposition 2">
      Let S be a module and{a mathematical formula}(M,l)an inference in S. Then{a mathematical formula}S|≈Ml.
     </paragraph>
     <paragraph>
      In the paper, we often consider unions of (finitely many) modules. The union of modules is a well-defined operation as modules are sets (of inferences). Thus, the union of modules {a mathematical formula}M1,…,Mn is simply the module that consists precisely of all the inferences of {a mathematical formula}M1,…,Mn. We use the symbol ∪ to denote the union of modules. The resulting module can be viewed as a module over any vocabulary σ that contains the vocabularies of all modules in the union.
     </paragraph>
     <paragraph label="Proposition 3">
      Let{a mathematical formula}S1and{a mathematical formula}S2be abstract inference modules. A set X is a model of{a mathematical formula}S1∪S2if and only if X is a model of{a mathematical formula}S1and{a mathematical formula}S2.
     </paragraph>
     <paragraph>
      Modules are not meant for modeling knowledge. Representations by means of logic theories are usually more concise. Furthermore, logic languages align closely with the natural language, which facilitates modeling and makes the correspondence between logic theories and knowledge they represent direct. Modules lack this connection. The power of modules comes from the fact that they provide a uniform, syntax-independent way to describe theories and inference methods for different logics. We illustrate this property of modules by showing that they can capture theories and inferences in classical propositional logic and in answer set programming [23], [42], [47] (where logic programs are used as theories).
     </paragraph>
     <section label="2.1">
      <section-title>
       Propositional logic via abstract inference modules
      </section-title>
      <paragraph>
       Let T be a finite propositional theory (formula) over σ, and let {a mathematical formula}σT be the set of atoms that appear in T. We first consider the inference method given by the classical entailment. By {a mathematical formula}Ent(T) we denote the module consisting of pairs {a mathematical formula}(M,l) that satisfy the following conditions: {a mathematical formula}M∈C(σT), {a mathematical formula}l∈Lit(σT)∖M, and {a mathematical formula}T∪M⊨l. Fig. 1(b) shows the module {a mathematical formula}Ent({a}). Fig. 1(c) shows the module {a mathematical formula}Ent({a∧¬a}). Similarly, Fig. 2 presents the module {a mathematical formula}Ent(T), where T is the theory in conjunctive normal form (CNF theory){sup:3}:{a mathematical formula} We note that {a mathematical formula}Ent(T) has two models contained in {a mathematical formula}{a,b}: {a mathematical formula}{a} and {a mathematical formula}{b}.{sup:4} More generally, every model X of {a mathematical formula}Ent(T) contains exactly one of a and b.
      </paragraph>
      <paragraph>
       Focusing on specific inference rules of propositional logic also gives rise to abstract modules. Unit Propagate is a standard inference rule commonly used when reasoning with CNF theories. This inference rule is essential to all satisfiability (SAT) solvers, programs that compute models of CNF theories or determine that no models exist. Let T be a finite propositional CNF theory over σ. The Unit Propagate rule gives rise to the module {a mathematical formula}UP(T) that consists of all pairs {a mathematical formula}(M,l) that satisfy the following conditions: {a mathematical formula}M∈C(σT), {a mathematical formula}l∈Lit(σT)∖M, and T has a clause {a mathematical formula}C∨l (modulo reordering of literals) such that for every literal u of C, {a mathematical formula}u‾∈M.
      </paragraph>
      <paragraph>
       Let T be the CNF theory (1). The module {a mathematical formula}Ent(T) in Fig. 2 coincides with {a mathematical formula}UP(T). Thus, for the theory (1) the Unit Propagate rule captures entailment.
      </paragraph>
      <paragraph>
       We say that a module S is equivalent to a propositional theory T if they have the same models. Clearly, the module in Fig. 2 is equivalent to the propositional theory (1). This is an instance of a general property.
      </paragraph>
      <paragraph label="Proposition 4">
       For every propositional theory T (respectively, CNF formula T containing no empty clause),{a mathematical formula}Ent(T)(respectively,{a mathematical formula}UP(T)) is equivalent to T.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Answer set programming via abstract inference modules
      </section-title>
      <paragraph>
       Unit Propagate is the primary inference rule of most SAT solvers. In the case of answer set programming, most solvers rely on several inference rules associated with reasoning under the answer set semantics. For instance, the classical answer set solver smodels[48] exploits four inference rules called the Unit Propagate rule, the Unfounded rule, the All Rules Cancelled rule, and the Backchain True rule. To state these rules we introduce some definitions and notations commonly used in logic programming.
      </paragraph>
      <paragraph>
       A logic program, or simply a program, over σ is a finite set of rules of the form{a mathematical formula} where each {a mathematical formula}ai, {a mathematical formula}0≤i≤m, is an atom from σ. The expression {a mathematical formula}a0 is the head of the rule. The expression on the right hand side of the arrow is the body. For a program Π and an atom a, {a mathematical formula}Bodies(Π,a) denotes the set of the bodies of all rules in Π with the head a. We write {a mathematical formula}σΠ for the set of atoms that occur in a program Π.
      </paragraph>
      <paragraph>
       For the body B of a rule (2), we define {a mathematical formula}s(B)={a1,…,aℓ,¬aℓ+1,…,¬am}. In some cases, we identify B with the conjunction of the elements in {a mathematical formula}s(B), and we often interpret a rule (2) as the propositional clause{a mathematical formula} For a program Π, we write {a mathematical formula}Πcl for the set of clauses (3) corresponding to all rules in Π.
      </paragraph>
      <paragraph>
       The concept of an answer set (stable model) was introduced in [22]. Saccà and Zaniolo [52] showed that answer sets can be characterized in terms of unfounded sets[56]. This characterization is the one we present here as it is especially useful in understanding inference rules of modern answer set solvers discussed here. A set U of atoms occurring in a program Π is unfounded on a consistent set M of literals with respect to Π if for every atom {a mathematical formula}a∈U and every {a mathematical formula}B∈Bodies(Π,a), there is {a mathematical formula}u∈s(B) such that {a mathematical formula}u‾∈M or {a mathematical formula}U∩s(B)+≠∅. For a program Π over σ, a set X of atoms over σ is an answer set of Π if and only if X is a model of {a mathematical formula}Πcl and X contains no element of a set that is unfounded on {a mathematical formula}X∪{¬a:a∈σ∖X} with respect to Π. For a set M of literals and a program Π, we write {a mathematical formula}Unf(M,Π) to denote the family of all sets unfounded on M w.r.t. Π.
      </paragraph>
      <paragraph>
       We are now ready to define the smodels inference rules. For a program Π, a set {a mathematical formula}M∈C(σΠ) of literals, and a literal {a mathematical formula}l∈Lit(σΠ)∖M:
      </paragraph>
      <paragraph>
       Unit Propagate: derive l if {a mathematical formula}Πcl contains clause {a mathematical formula}C∨l such that for every {a mathematical formula}u∈C, {a mathematical formula}u‾∈M;
      </paragraph>
      <paragraph>
       Unfounded: derive l if {a mathematical formula}l=¬a and {a mathematical formula}a∈U, for some {a mathematical formula}U∈Unf(M,Π);
      </paragraph>
      <paragraph>
       All Rules Cancelled: derive l if {a mathematical formula}l=¬a and for every {a mathematical formula}B∈Bodies(Π,a), there is {a mathematical formula}u∈s(B) such that {a mathematical formula}u‾∈M;
      </paragraph>
      <paragraph>
       Backchain True: derive l, if for some rule {a mathematical formula}a←B∈Π, {a mathematical formula}a∈M, {a mathematical formula}l∈s(B), and for every {a mathematical formula}B′∈Bodies(Π,a) such that {a mathematical formula}s(B′)≠s(B), there is {a mathematical formula}u∈s(B′) such that {a mathematical formula}u‾∈M.
      </paragraph>
      <paragraph>
       The four rules above give rise to abstract inference modules {a mathematical formula}UP(Π), {a mathematical formula}UF(Π), {a mathematical formula}ARC(Π) and {a mathematical formula}BC(Π), respectively, each obtained by taking the definition of the corresponding rule as the condition for {a mathematical formula}(M,l), where {a mathematical formula}M∈C(σΠ) and {a mathematical formula}l∈Lit(σΠ)∖M, to be an inference of the module. For instance, the module {a mathematical formula}UF(Π) consists of all inferences {a mathematical formula}(M,l) such that {a mathematical formula}M∈C(σΠ), {a mathematical formula}l∈Lit(σΠ)∖M, and {a mathematical formula}l=¬a, where a is any atom such that {a mathematical formula}a∈U, for some {a mathematical formula}U∈Unf(M,Π).
      </paragraph>
      <paragraph>
       We note that the inference rule All Rules Cancelled is subsumed by the inference rule Unfounded. That is, {a mathematical formula}ARC(Π)⊆UF(Π). This is the only inclusion relation between distinct modules in that set that holds for every program. We also note that {a mathematical formula}UP(Π) and {a mathematical formula}UP(Πcl) are identical (and so, equivalent) even though they concern different logics.
      </paragraph>
      <paragraph>
       We say that a module S is equivalent to a program Π if for every {a mathematical formula}X⊆σΠ, X is a model of S if and only if X is an answer set of Π.{sup:5} None of the four modules {a mathematical formula}UP(Π), {a mathematical formula}UF(Π), {a mathematical formula}ARC(Π) and {a mathematical formula}BC(Π) alone is equivalent to the underlying program Π. However, some combinations of these modules are. Let us define{a mathematical formula} and{a mathematical formula} Since {a mathematical formula}ARC(Π)⊆UF(Π), it is not necessary to list the module {a mathematical formula}ARC(Π) explicitly in the union above. We do so, as the rule All Rules Cancelled is computationally cheaper than the rule Unfounded and in practical implementations the two are distinguished.
      </paragraph>
      <paragraph label="Proposition 5">
       The following result restates well-known properties of these inference rules in terms of equivalence of modules and programs. Every logic program Π is equivalent to the modules{a mathematical formula}UPUF(Π)and{a mathematical formula}smodels(Π).
      </paragraph>
      <paragraph>
       Let Π be the program{a mathematical formula} This program has two answer sets {a mathematical formula}{a} and {a mathematical formula}{b}. Since these are also the only two models over the vocabulary {a mathematical formula}{a,b} of the module in Fig. 2, the program and the module are equivalent. This module represents the program (4) and the reasoning mechanism captured by the module {a mathematical formula}smodels(Π). Two other modules associated with program (4) are given in Fig. 3. Fig. 3(a) shows the module {a mathematical formula}UP(Π), and the reasoning mechanism based on Unit Propagate. This module is not equivalent to program (4). Indeed, {a mathematical formula}{a,b} is its model, but not an answer set of (4). Fig. 3(b) shows the module {a mathematical formula}ARC(Π) (which in this case happens to coincide with both {a mathematical formula}UF(Π) and {a mathematical formula}BC(Π)). Also this module is not equivalent to program (4) as ∅ is its model but not an answer set of Π. The union of the two modules in Fig. 3 captures all four inference rules and is indeed equal to the module in Fig. 2.
      </paragraph>
      <paragraph>
       We conclude this section with two more examples. In the first example, let Π be the program consisting of the rule{a mathematical formula} This program has no answer sets. The module {a mathematical formula}UP(Π) consists of a single inference {a mathematical formula}({¬a},a), whereas the modules {a mathematical formula}UF(Π), {a mathematical formula}ARC(Π), and {a mathematical formula}BC(Π) coincide and consist of a single inference {a mathematical formula}({a},¬a). The module resulting from the union of two last mentioned inferences is unsatisfiable.
      </paragraph>
      <paragraph>
       In the second example, we assume that Π is given by the rules{a mathematical formula} The empty set is the only answer set of this program. The inferences in Fig. 4(a) form the module {a mathematical formula}BC(Π) and those in Fig. 4(b) define the module {a mathematical formula}ARC(Π). The union of these two modules yields the module {a mathematical formula}UP(Π). The union of the inferences in Fig. 4(b) and in Fig. 5 gives the module {a mathematical formula}UF(Π).
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Transition graphs — an abstraction of model finding algorithms
     </section-title>
     <paragraph>
      Finding models of logic theories and programs is a key computational task in declarative programming. Nieuwenhuis et al. [49] proposed to use transition graphs to describe search procedures involved in model-finding algorithms commonly called solvers, and developed that approach for the case of SAT. Their transition graph framework can express dpll, the basic search procedure employed by SAT solvers, and its enhancements with techniques such as conflict-driven clause learning. Lierler and Truszczynski [34], [36] proposed a similar framework to describe and analyze the answer set solvers smodels, cmodels[25] and clasp[17], [19], as well as a PC(ID) solver minisat(id)[43]. In the previous section, we argued that theories and programs can be represented by equivalent abstract inference modules (Proposition 4, Proposition 5). We now show that the idea of a transition graph can be generalized to the setting of modules, leading to an abstract perspective on the problem of search for models of modules, and unifying the approaches to the model-finding task.
     </paragraph>
     <paragraph>
      Let σ be a finite vocabulary. A state over σ is either a special state ⊥ (the fail state) or a sequence M of distinct literals over σ, some possibly annotated by Δ, which marks them as decision literals, such that:
     </paragraph>
     <list>
      <list-item label="1.">
       the set of literals in M is consistent or {a mathematical formula}M=M′l, where the set of literals in {a mathematical formula}M′ is consistent and contains {a mathematical formula}l‾, and
      </list-item>
      <list-item label="2.">
       if {a mathematical formula}M=M′lΔM″, then l is unassigned in the set of the literals in {a mathematical formula}M′.
      </list-item>
     </list>
     <paragraph>
      For instance, if {a mathematical formula}σ={a,b}, then ∅, a, {a mathematical formula}¬aΔb, {a mathematical formula}¬abΔa and ⊥ are examples of states over σ.
     </paragraph>
     <paragraph>
      If M is a state, by {a mathematical formula}[M] we denote the set of the literals in M (that is, we drop annotations and ignore the order). Our definition of a state allows for inconsistent states. However, inconsistent states are of a very specific form — the inconsistence arises because of the last literal in the state. There is also a restriction on annotated (decision) literals. A decision literal must not appear in a state following another occurrence of that literal or its dual (annotated or not). Intuitively, a literal annotated by Δ denotes a current assumption: thus once a literal is assigned in a state, there is no point in later making an assumption concerning whether it holds or not.
     </paragraph>
     <paragraph>
      Each module S determines its transition graph{a mathematical formula}amS. The set of nodes of {a mathematical formula}amS consists of all possible states relative to {a mathematical formula}σS. The edges of the graph {a mathematical formula}amS are specified by the transition rules listed in Fig. 6. The first rule depends on the module, the last three do not. They have the same form no matter what module we consider. Hence, we omit the reference to the module from their notation. Moreover, even for the rule Inference Propagate, we often omit the reference to the module if it is implied by the context, or if the specific reference is immaterial. Finally, we call a node in a transition graph terminal if no edge originates in it (equivalently, no rule applies to it).
     </paragraph>
     <paragraph>
      The graph {a mathematical formula}amS can be used to decide whether a module S has a model. The following properties are essential.
     </paragraph>
     <paragraph label="Theorem 6">
      For every abstract inference module S,
     </paragraph>
     <list>
      <list-item>
       graph{a mathematical formula}amSis finite and acyclic,
      </list-item>
      <list-item>
       for any terminal state M of{a mathematical formula}amSother than ⊥,{a mathematical formula}[M]+is a model of S,
      </list-item>
      <list-item>
       state ⊥ is reachable from ∅ in{a mathematical formula}amSif and only if S is unsatisfiable (has no models).
      </list-item>
     </list>
     <paragraph>
      Thus, to decide whether a module S has a model it is enough to find in the graph {a mathematical formula}amS a path leading from node ∅ to a terminal node M. If {a mathematical formula}M=⊥, S is unsatisfiable. Otherwise, {a mathematical formula}[M]+ is a model of S. For instance, let S be the module in Fig. 2. Below we show a path in the transition graph {a mathematical formula}amS with every edge annotated by the corresponding transition rule:{a mathematical formula} The state {a mathematical formula}bΔ¬a is terminal. Thus, Theorem 6(b) asserts that {a mathematical formula}{b} is a model of S. There may be several paths determining the same model. For instance, the path{a mathematical formula} leads to the terminal node {a mathematical formula}¬aΔbΔ, which is different from {a mathematical formula}bΔ¬a but corresponds to the same model.
     </paragraph>
     <paragraph>
      We can view a path in the graph {a mathematical formula}amS starting in ∅ and ending in a terminal node as a description of a specific way to search for a model of module S. Each such path is determined by a function (strategy) selecting for each non-terminal state exactly one of its outgoing edges (exactly one applicable transition). Therefore, solvers based on the transition graph {a mathematical formula}amS are determined by the “select-edge-to-follow” function. Such a function can be based, in particular, on assigning strict priorities to inferences in S. Below we describe an algorithm that captures the “classical” dpll strategy. Assuming M is the current state and it is not terminal, the algorithm proceeds as follows: If M is inconsistent and has no decision literals, follow the Fail edge (this is the only applicable transition);if M is inconsistent and has decision literals, follow the Backtrack edge (this is the only applicable transition);if M is consistent and {a mathematical formula}Inference PropagateS applies, follow the edge implied by the highest priority inference of the form {a mathematical formula}(M′,l) in S such that {a mathematical formula}M′⊆[M];otherwise, follow a Decide edge.
     </paragraph>
     <paragraph>
      This is still not a complete specification of a solver, as it offers no directions on how to select a decision literal (which of many possible Decide transitions to apply). Much of research on SAT solvers design has focused on this particular aspect and several heuristics were proposed over the years. Each such heuristics for selecting a decision literal when the Decide transition applies yields an algorithm. Additional algorithms can be obtained by switching the preference between Inference Propagate and Decide rules. Earlier, we selected an Inference Propagate edge and only if impossible, we selected a Decide edge. But that order can be reversed resulting in another class of algorithms. Finally, we could even consider more complicated selection functions that, when both Decide and Inference Propagate edges are available, in some cases select an Inference Propagate edge and in others a Decide one.
     </paragraph>
     <paragraph>
      Before we proceed, we state several observations about the graph {a mathematical formula}amS. First, for every model X of an abstract module S, there is a terminal state M in {a mathematical formula}amS such that {a mathematical formula}X∩σS=[M]+ and M is reachable from ∅ in the graph {a mathematical formula}amS (in other words, every model of S is represented by some terminal state reachable from ∅ in {a mathematical formula}amS). Indeed, we can take for M any state that contains annotated atoms {a mathematical formula}xΔ, for all {a mathematical formula}x∈X∩σS, and annotated negated atoms {a mathematical formula}¬yΔ, for all {a mathematical formula}y∈σS∖X. Each such state M is reachable by a path whose edges are determined by the Decide rule. Moreover, if X is a model of S, then M is clearly a terminal state.
     </paragraph>
     <paragraph>
      Second, generally each model of a module S is represented by many terminal states in the graph {a mathematical formula}amS. Some are reachable from ∅ and some are not. However, as we just argued, the terminal states reachable from ∅ represent all models of the module. Thus, to decide satisfiability of a module (or, for satisfiable modules, to find a model) it is sufficient to consider only the states reachable from ∅. In this sense, the states reachable from ∅ determine the “essential” fragment of the transition graph. To illustrate these observations, let us consider the module {a mathematical formula}UP({a∨b}) (which simulates Unit Propagate inferences based on {a mathematical formula}a∨b). Then, ab, {a mathematical formula}aΔb, {a mathematical formula}abΔ, and {a mathematical formula}aΔbΔ all represent the same family of models — those that contain atoms a and b.{sup:6} However, only one of these four states, {a mathematical formula}aΔbΔ, is reachable from ∅. The other three are not.
     </paragraph>
     <paragraph>
      Third, one can generalize part (c) of Theorem 6 as follows. Let M be any state other than ⊥. If a terminal state other than ⊥ is reachable from M, then S has models that are consistent with {a mathematical formula}[M]. Otherwise, ⊥ is the only terminal state reachable from M and S has no models consistent with {a mathematical formula}[M] (but it may have other models). Thus, while only the fragment of the graph {a mathematical formula}amS consisting of the states reachable from ∅ is needed to determine satisfiability and find models of the module, other parts of the graph are of interest too. Incidentally, similar generalizations are possible for parts (c) in Theorem 11, Theorem 16, Theorem 17 that we state later.
     </paragraph>
     <paragraph>
      Finally, we observe that the fragment of the graph {a mathematical formula}amS reachable from ∅ contains inconsistent states also. Such states are, however, not terminal. For instance, the state {a mathematical formula}¬aΔ¬bΔa is reachable from ∅ in the transition graph of the module {a mathematical formula}UP({a∨b}) (the path is given by the edges determined by two applications of the Decide rule, followed by an application of the Unit Propagate rule). This state is not terminal as the Backtrack rule applies. Similarly, the fragment consisting of states that are not reachable may contain states that are consistent (as we mentioned above, the state ab is not reachable from ∅ yet, it is consistent).
     </paragraph>
     <section label="3.1">
      <section-title>
       Abstract SAT solvers
      </section-title>
      <paragraph>
       We now show how the approaches proposed by Nieuwenhuis et al. [49] and Lierler [34] to describe and analyze SAT and ASP solvers, respectively, fit in our abstract framework. Let F be a CNF formula that contains no empty clause. Nieuwenhuis et al. [49], defined the transition graph {a mathematical formula}dpF to capture the computation of the dpll algorithm. We now review this graph in the form convenient for our purposes. All states over the vocabulary of F form the vertexes of {a mathematical formula}dpF. The edges of {a mathematical formula}dpF are specified by the three “generic” transition rules Fail, Backtrack and Decide of the graph {a mathematical formula}amS, and the Unit Propagate rule below:{a mathematical formula}
      </paragraph>
      <paragraph>
       For example, let F be the theory consisting of a single clause a. Fig. 7 presents {a mathematical formula}dpF.
      </paragraph>
      <paragraph>
       It turns out that we can see the graph {a mathematical formula}dpF as the transition graph of the abstract module {a mathematical formula}UP(F).
      </paragraph>
      <paragraph label="Proposition 7">
       For every CNF formula F with no empty clause,{a mathematical formula}dpF=amUP(F).
      </paragraph>
      <paragraph>
       Theorem 6, Proposition 7, and the fact that a CNF formula F and the module {a mathematical formula}UP(F) are equivalent (Proposition 4) imply the following result.
      </paragraph>
      <paragraph label="Corollary 8">
       For any CNF formula F,
      </paragraph>
      <list>
       <list-item>
        graph{a mathematical formula}dpFis finite and acyclic,
       </list-item>
       <list-item>
        for any terminal state M of{a mathematical formula}dpFother than ⊥,{a mathematical formula}[M]+is a model of F,
       </list-item>
       <list-item>
        state ⊥ is reachable from ∅ in{a mathematical formula}dpFif and only if F is unsatisfiable (has no models).
       </list-item>
      </list>
      <paragraph>
       This is precisely the result stated by Nieuwenhuis et al. [49] and used to argue that the graph {a mathematical formula}dpF is an abstraction of the dpll method. To decide the satisfiability of F (and to find a model, if one exists), it is enough to find a path leading from the state ∅ to a terminal state M: If {a mathematical formula}M=⊥ then F is unsatisfiable; otherwise, {a mathematical formula}[M]+ is a model of F. In our example, the only terminal states reachable from the state ∅ in {a mathematical formula}dpF are a and {a mathematical formula}aΔ. This translates into the fact that {a mathematical formula}{a} is a model of F. Specific algorithms encapsulated by the graph {a mathematical formula}dpF (equivalently, {a mathematical formula}amUP(F)) can be obtained by deciding on a way to select an edge while in a consistent state. Typical implementations of basic backtracking SAT solvers follow a {a mathematical formula}Unit PropagateF edge whenever possible, choosing Decide edges only if nothing else applies. These algorithms differ from each other in the heuristics they use for the selection of a decision literal.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       Abstract answer set solvers
      </section-title>
      <paragraph>
       Our abstract approach to model generation in logics also applies to answer set programming [23], [42], [47]. Lierler [34] introduced a transition system {a mathematical formula}smΠ to describe and study the smodels solver. We first review the graph {a mathematical formula}smΠ and then show that Lierler's approach can be viewed as an instantiation of our general theory.
      </paragraph>
      <paragraph>
       The set of nodes of the graph {a mathematical formula}smΠ consists of all states relative to the vocabulary of program Π. The edges of {a mathematical formula}smΠ are specified by the transition rules of the graph {a mathematical formula}dpΠcl and the rules presented in Fig. 8.
      </paragraph>
      <paragraph>
       The following result shows that Lierler's approach can be viewed as an instantiation of our general theory.
      </paragraph>
      <paragraph label="Proposition 9">
       For every logic program Π,{a mathematical formula}smΠ=amsmodels(Π).
      </paragraph>
      <paragraph>
       Indeed, this proposition, Theorem 6 and the fact that Π is equivalent to the module {a mathematical formula}smodels(Π) (Proposition 5) imply the result stemming from that of Lierler [34].
      </paragraph>
      <paragraph label="Corollary 10">
       For every logic program Π,
      </paragraph>
      <list>
       <list-item>
        graph{a mathematical formula}smΠis finite and acyclic,
       </list-item>
       <list-item>
        for any terminal state M of{a mathematical formula}smΠother than ⊥,{a mathematical formula}M+is an answer set of Π,
       </list-item>
       <list-item>
        state ⊥ is reachable from ∅ in{a mathematical formula}smΠif and only if Π has no answer sets.
       </list-item>
      </list>
      <paragraph>
       Since {a mathematical formula}UPUF(Π) is also equivalent to Π, we obtain a similar corollary for the transition graph {a mathematical formula}amUPUF(Π). Intuitively, this graph is characterized by the transition rules of the graph {a mathematical formula}dpΠcl as well as the rule Unfounded presented in Fig. 8. Thus, {a mathematical formula}amUPUF(Π) is an abstraction of another class of correct algorithms for finding answer sets of programs. In fact, it is so for any module S such that {a mathematical formula}UPUF(Π)⊆S⊆smodels(Π).
      </paragraph>
      <paragraph>
       Also the graph {a mathematical formula}smΠ describes a whole family of backtracking search algorithms for finding answer sets of programs. They differ from each other by the way an edge is selected while in a consistent state.
      </paragraph>
      <paragraph>
       Our discussion of SAT and ASP solvers shows that the framework of modules uniformly encompasses different logics. Furthermore, it uniformly models diverse reasoning mechanisms (the logical entailment, reasoning under specific inference rules). Our results also show that transition graphs proposed earlier to represent and analyze SAT and ASP solvers are special cases of transition graphs for abstract inference modules.
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       Model enumeration
      </section-title>
      <paragraph>
       We showed above how the transition graph {a mathematical formula}amS can be used to conceptualize algorithms for deciding whether a module S has a model. Model enumeration is a related task of generating all models of a module S. Paper by Gebser et al. [18] is a good references for the problem. We now show that the transition graph approach can be adapted for the task of enumeration.
      </paragraph>
      <paragraph label="Theorem 11">
       To account for model enumeration for a module S, we extend the graph {a mathematical formula}amS to a graph {a mathematical formula}ameS. To this end, we introduce the transition rule{a mathematical formula} and define the transition graph {a mathematical formula}ameS for an AM S as the graph {a mathematical formula}amS extended with the transition rule Enumerate. The following theorem captures the main properties of this graph. For every abstract inference module S,
      </paragraph>
      <list>
       <list-item>
        the graph{a mathematical formula}ameSis finite and acyclic,
       </list-item>
       <list-item>
        the ⊥ state is reachable from ∅,
       </list-item>
       <list-item>
        for every path from ∅ to ⊥ in{a mathematical formula}ameS, the set of states in which the rule Enumerate applies is precisely the set of models of S over{a mathematical formula}σS, and for each model X of S over{a mathematical formula}σSthere is exactly one state M on the path such that{a mathematical formula}X=[M].
       </list-item>
      </list>
      <paragraph>
       This theorem assures us that if we follow a path from ∅ to ⊥ we will encounter all models of S over {a mathematical formula}σS.
      </paragraph>
      <paragraph>
       Another related task is model counting where one wants to find the number of models of S, rather than what they are. Gomes at al. [27] provides a good account for the task. Since methods used for model counting aim to avoid explicit enumeration, it is not clear whether transition graphs can be useful for this task.
      </paragraph>
     </section>
    </section>
    <section label="4">
     Abstract modular system and solver {a mathematical formula}amsA
     <paragraph>
      By capturing diverse logics in a single framework, abstract modules are well suited for studying modularity in declarative formalisms and for analyzing solvers for such modular formalisms. As illustrated by our examples, abstract inference modules can capture reasoning of various logics including classical reasoning with propositional theories and reasoning with programs under the answer set semantics. Putting modules together provides an abstract, uniform way to represent hybrid modular systems, in which modules represent theories from different logics.
     </paragraph>
     <paragraph>
      We now define an abstract modular declarative framework that uses the concept of a module as its basic element. We then show how abstract transition graphs for modules generalize to the new formalism.
     </paragraph>
     <paragraph label="Definition 2">
      An abstract modular inference system (AMS) over a vocabulary σ is a finite set {a mathematical formula}A of abstract inference modules over vocabularies contained in σ. A set X, is a model of {a mathematical formula}A if X is a model of every module {a mathematical formula}S∈A.
     </paragraph>
     <paragraph>
      For an abstract modular inference system {a mathematical formula}A, by {a mathematical formula}σA we denote the vocabulary {a mathematical formula}⋃S∈AσS. Recalling our comments from Section 2, we note that an AMS {a mathematical formula}A can be viewed as a modular system over any vocabulary extending {a mathematical formula}σA.
     </paragraph>
     <paragraph>
      Let {a mathematical formula}S1 be the module presented in Fig. 1(b) and {a mathematical formula}S2 be the module in Fig. 2. The vocabulary {a mathematical formula}σA of an AMS {a mathematical formula}A={S1,S2} consists of the atoms a and b. It is easy to see that the set {a mathematical formula}{a} is the only model of {a mathematical formula}A over {a mathematical formula}σA (more generally, a set X is a model of {a mathematical formula}A if and only if X contains a and does not contain b). In Section 2, we observed that (i) {a mathematical formula}S1=Ent(T) (and also {a mathematical formula}=UP(T)) for a propositional theory {a mathematical formula}T={a}, and (ii) {a mathematical formula}S2=smodels(Π) for a program Π given by (4). Thus, the AMS {a mathematical formula}A={S1,S2} illustrates how abstract modular systems can serve as an abstraction for heterogeneous multi-logic systems.
     </paragraph>
     <section label="4.1">
      <section-title>
       Modular logic programs via abstract modular inference systems
      </section-title>
      <paragraph>
       For a general example of a modular declarative formalism that can be seen as an abstract modular system we now discuss modular logic programs [37]. Modular logic programs generalize the formalism of lp-modules, an early approach to modular answer set programming proposed by Oikarinen and Janhunen [50].
      </paragraph>
      <paragraph>
       The semantics of modular logic programs relies on the notion of an input answer set of a program [36]. A set X of atoms is an input answer set of a logic program Π if X is an answer set of the program {a mathematical formula}Π∪(X∖Head(Π)), where {a mathematical formula}Head(Π) denotes the set of all head atoms of Π. Informally, input answer sets treat all atoms not occurring in the heads of program rules as open so that they can assume any logical value. These atoms are viewed as the “input.” For instance, program {a mathematical formula}a←b has two input answer sets that are subsets of set {a mathematical formula}{a,b}: namely, ∅ and set {a mathematical formula}{a,b}.
      </paragraph>
      <paragraph>
       To capture the semantics of input answer sets in terms of inferences, we introduce a modified version of the propagation rule Unfounded:
      </paragraph>
      <paragraph>
       {a mathematical formula}Unfounded′: derive l if {a mathematical formula}l=¬a and, for some {a mathematical formula}U∈Unf(M,Π), {a mathematical formula}a∈U and for every {a mathematical formula}b∈U, {a mathematical formula}b∈Head(Π) or {a mathematical formula}¬b∈M.
      </paragraph>
      <paragraph>
       The only difference from the Unfounded rule we discussed earlier is a restriction on unfounded sets that the new rule imposes.
      </paragraph>
      <paragraph>
       The {a mathematical formula}Unfounded′ rule gives rise to an inference module {a mathematical formula}UF′(Π) defined by taking the condition of the rule as a specification of when {a mathematical formula}(M,l) is to be an inference of the module. With the module {a mathematical formula}UF′(Π) at hand, we define {a mathematical formula}UPUF′(Π)=UP(Π)∪UF′(Π).
      </paragraph>
      <paragraph label="Proposition 12">
       An inference module S is input-equivalent to a logic program Π if the input answer sets of Π coincide with the models of S. We now restate Proposition 5 for the case of input-equivalence. Every program Π is input-equivalent to the module{a mathematical formula}UPUF′(Π).
      </paragraph>
      <paragraph>
       A modular (logic) program is a set of logic programs [37]. For a modular program {a mathematical formula}P, a set X of atoms is a model of {a mathematical formula}P if X is an input answer set of every program Π in {a mathematical formula}P. An AMS {a mathematical formula}A is equivalent to a modular program {a mathematical formula}P if models of {a mathematical formula}P coincide with models of {a mathematical formula}A.
      </paragraph>
      <paragraph label="Proposition 13">
       Every modular program{a mathematical formula}{Π1,…,Πn}is equivalent to the abstract modular system{a mathematical formula}{UPUF′(Π1),…,UPUF′(Πn)}.
      </paragraph>
      <paragraph>
       Theories in the logics SM(ASP) [37] and PC(ID) [43] can be viewed as abstract modular systems in the same manner.
      </paragraph>
      <paragraph>
       Remarks on modularity in ASP  We use modular logic programs in this paper only to illustrate the key aspects of our general framework. Thus, it is not the place for an extended discussion of the relationship between modular logic programs and more standard work on modularity in ASP. Nevertheless, a few comments might be in order. First, in ASP the thrust is on identifying a decomposition of a program into subprograms (“modules”) so that there is a direct correspondence between the answer sets of the subprograms and the answer sets of the program. Finding such decompositions (either explicitly by preprocessing, or implicitly during search) may have a big impact on the performance of solvers. Because of the nature of the answer set semantics, such decompositions are only possible for programs with some hierarchical structure given by stratification [1] or, more generally, splitting [41]. In this work, we use the generic term “model” of a modular system to stress that our semantics of modular logic programs is not directly related to the semantics of answer sets of the union of modules.{sup:7} In fact, our motivation is quite different. We assume an “inverse” scenario where the modular structure is given right from the beginning. The objective is to define a semantics of a collection of programs based on the semantics of the individual programs. The semantics of answer sets does not lend itself naturally to this purpose. For instance, consider a modular program{a mathematical formula} There is no set of atoms that yields an answer set to both logic programs {a mathematical formula}{a←} and {a mathematical formula}{b←} simultaneously. Therefore, in our earlier work we proposed the input answer set semantics as the semantics for individual logic programs, that lends a way to defining a meaningful semantics of modular logic programs. In this example, the set {a mathematical formula}{a,b} of atoms is a model of modular logic program (8), as it is an input answer set of each of the component programs. For another example, let as consider a modular program{a mathematical formula} Clearly, the union of the rules in the modules of (9) is exactly the program given by (5). Each of the programs {a mathematical formula}{a←b} and {a mathematical formula}{b←a} has only one answer set, ∅. However, the modular program has two models ∅ and {a mathematical formula}{a,b}. It is so because both sets are input answer sets of each module, even though only the first one is an answer set. To summarize, an important point behind input answer set semantics is that it allows us to avoid difficulties that arise in ASP in the context of substitutability of one subprogram by another [40] or when attempting to determine the answer sets of the union of programs [32].
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Satisfiability modulo theories via abstract modular inference systems
      </section-title>
      <paragraph>
       Satisfiability modulo theories (SMT) [49], [4] is a general, broadly used framework for integrating diverse logics. In this section we review the concept of SMT programs and illustrate how these programs can be seen as abstract modular systems presented in this paper.
      </paragraph>
      <paragraph>
       We start by introducing the notion of a theory in SMT. A signature Σ is a set of predicate and function symbols, each with an associated nonnegative integer called arity. We call predicate symbols of arity 0 propositional. We call a signature propositional if it only contains propositional symbols. (We note that elsewhere in the paper we refer to propositional signatures as vocabularies.) A term over Σ is either
      </paragraph>
      <list>
       <list-item label="•">
        a function symbol of arity 0 from Σ, or
       </list-item>
       <list-item label="•">
        an expression {a mathematical formula}f(t1,…,tn), where f is a function symbol from Σ of arity {a mathematical formula}n&gt;0 and {a mathematical formula}t1,…,tn are terms over Σ.
       </list-item>
      </list>
      <paragraph>
       An atomic formula is either
      </paragraph>
      <list>
       <list-item label="•">
        a propositional symbol from Σ, or
       </list-item>
       <list-item label="•">
        an expression {a mathematical formula}p(t1,…,tn), where p is a predicate symbol from Σ of arity {a mathematical formula}n&gt;0 and {a mathematical formula}t1,…,tn are terms over Σ.
       </list-item>
      </list>
      <paragraph>
       A theory literal, or t-literal, is either an atomic formula A or its negation ¬A. A theory formula (or a t-formula, for short) is a set of t-literals. An interpretation for a signature Σ (or a Σ-interpretation for short) is a pair I consisting of a non-empty set {a mathematical formula}|I|, the universe of the interpretation, and a mapping {a mathematical formula}(⋅)I assigning
      </paragraph>
      <list>
       <list-item label="•">
        to each function symbol f in Σ of arity 0, an element {a mathematical formula}fI∈|I|,
       </list-item>
       <list-item label="•">
        to each function symbol f in Σ of arity {a mathematical formula}n&gt;0, a total function {a mathematical formula}fI:|I|n→|I|,
       </list-item>
       <list-item label="•">
        to each propositional symbol p in Σ, an element in {a mathematical formula}{True,False},
       </list-item>
       <list-item label="•">
        to each predicate symbol p in Σ of arity {a mathematical formula}n&gt;0, a total function {a mathematical formula}pI:|I|n→{True,False}.
       </list-item>
      </list>
      <paragraph>
       Let I be a Σ-interpretation. We extend the mapping {a mathematical formula}(⋅)I to all terms over Σ by induction by setting for every function symbol f of arity {a mathematical formula}n&gt;0 and every sequence {a mathematical formula}t1,…,tn of terms{a mathematical formula} where {a mathematical formula}fI is the function assigned to f by the interpretation I. Similarly, we extend the mapping {a mathematical formula}(⋅)I to all t-formulas over Σ. Namely, if ϕ is a t-literal {a mathematical formula}p(t1,…,tn), we set{a mathematical formula} where {a mathematical formula}pI is the truth value function for p given by the interpretation I. Next, if ϕ is a t-literal ¬A, we set{a mathematical formula} Finally, for a t-formula ϕ,{a mathematical formula} When {a mathematical formula}ϕI=True we say that the interpretation I satisfies ϕ.
      </paragraph>
      <paragraph>
       For a signature Σ, a Σ-theory is a set of Σ-interpretations. We say that a t-formula ϕ over Σ is satisfiable in a Σ-theory ϒ (or is ϒ-satisfiable, for short) if there is an element of the set ϒ that satisfies ϕ.
      </paragraph>
      <paragraph>
       Clearly, t-formulas can be regarded simply as classical ground formulas with negation and conjunction as the only connectives allowed. Further, the semantics we introduced above is just the classical first-order logic semantics of such formulas. In the literature on SMT, a more sophisticated syntax of formulas is considered. Yet, SMT solvers often use so-called propositional abstractions of first-order formulas which, in their most commonly used case, are t-formulas of the kind discussed here [49, Section 3.1].
      </paragraph>
      <paragraph>
       For a signature Σ, a disjoint propositional signature σ, and a Σ-theory ϒ, a {a mathematical formula}[Σ,σ,ϒ]-abstraction is a mapping from atomic formulas over Σ to σ. For a {a mathematical formula}[Σ,σ,ϒ]-abstraction λ, a set M of propositional literals over the signature σ is a model of λ (or a λ-model) if a t-formula{a mathematical formula} is satisfiable in Σ-theory ϒ. Clearly, λ-models are consistent sets of literals over σ.
      </paragraph>
      <paragraph>
       An SMT program is a tuple {a mathematical formula}〈T,λ1,…,λn〉, where T is a propositional CNF formula that contains no empty clauses, and every {a mathematical formula}λi, {a mathematical formula}1≤i≤n, is a {a mathematical formula}[Σi,σT,ϒi]-abstraction. Recall that by {a mathematical formula}σT we denote the set of atoms that appear in T. A consistent and complete set M of literals over {a mathematical formula}σT is a model of an SMT program {a mathematical formula}〈T,λ1,…,λn〉 if {a mathematical formula}M+ is a model of T and M is a {a mathematical formula}λi-model, for every i, {a mathematical formula}1≤i≤n.
      </paragraph>
      <paragraph>
       We will now construct several abstract module systems that are equivalent to an SMT program {a mathematical formula}〈T,λ1,…,λn〉. The propositional formula T can be equivalently represented by modules {a mathematical formula}Ent(T) and {a mathematical formula}UP(T) introduced in Section 2.1. What remains is to construct modules to represent {a mathematical formula}[Σi,σT,ϒi]-abstractions {a mathematical formula}λi.
      </paragraph>
      <paragraph>
       We first define the notion of entailment for {a mathematical formula}[Σ,σ,ϒ]-abstractions. Let λ be a {a mathematical formula}[Σ,σ,ϒ]-abstraction, {a mathematical formula}l∈σ a literal, and M a consistent set of literals over σ. We say that λ entails l w.r.t. M when for every consistent set {a mathematical formula}M′ of literals over σ that is a superset of M it holds that if {a mathematical formula}M′ is a λ-model then {a mathematical formula}l∈M′. We denote the fact that λ entails l w.r.t. M by {a mathematical formula}λ[M]⊨l. Note that if there is no single consistent set {a mathematical formula}M′ of literals over σ such that {a mathematical formula}M⊆M′ and {a mathematical formula}M′ is a λ-model then, every literal {a mathematical formula}l∈σ is entailed by λ w.r.t. M.
      </paragraph>
      <paragraph>
       For a {a mathematical formula}[Σ,σ,ϒ]-abstraction λ, by {a mathematical formula}Ent(λ) we denote the module consisting of pairs {a mathematical formula}(M,l) that satisfy the following conditions: M is a consistent set of literals over σ (in other words, {a mathematical formula}M∈C(σ)), {a mathematical formula}l∈Lit(σ)∖M, and {a mathematical formula}λ[M]⊨l.
      </paragraph>
      <paragraph>
       For a {a mathematical formula}[Σ,σ,ϒ]-abstraction λ, by {a mathematical formula}Min(λ) we denote the module consisting of pairs {a mathematical formula}(M,l) that satisfy the following conditions: M is a consistent and complete set of literals over σ, {a mathematical formula}l∈Lit(σ)∖M, and {a mathematical formula}λ[M]⊨l. The Min module differs from the Ent module by only including inferences {a mathematical formula}(M,l), where M is complete in addition to being consistent. Thus, it serves the purpose of spotting that set {a mathematical formula}M+ is not a λ-model.
      </paragraph>
      <paragraph>
       An AMS {a mathematical formula}A and an SMT program {a mathematical formula}P=〈T,λ1,…,λn〉, are equivalent if for any consistent and complete set M of literals over {a mathematical formula}σT, M is a model of P if and only if {a mathematical formula}M+ is a model of {a mathematical formula}A. We are now ready to state a formal result relating SMT programs and abstract modular inference systems composed of introduced modules.
      </paragraph>
      <paragraph label="Proposition 14">
       Every SMT program{a mathematical formula}P=〈T,λ1,…,λn〉is equivalent to any of the following abstract modular systems (over the vocabulary{a mathematical formula}σT)
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}{Ent(T),Ent(λ1),…,Ent(λn)},
       </list-item>
       <list-item>
        {a mathematical formula}{UP(T),Ent(λ1),…,Ent(λn)},
       </list-item>
       <list-item>
        {a mathematical formula}{Ent(T),Min(λ1),…,Min(λn)},
       </list-item>
       <list-item>
        {a mathematical formula}{UP(T),Min(λ1),…,Min(λn)}.
       </list-item>
      </list>
      <paragraph>
       It is interesting to note that replacing {a mathematical formula}Ent(λi) with {a mathematical formula}Min(λi) makes no difference for the semantics. However, the modular systems that result from such replacements capture different evaluation strategies of SMT solvers. In particular, the lazy evaluation strategy of SMT solvers [49] relies on the fact that the SMT program {a mathematical formula}P=〈T,λ1,…,λn〉 is equivalent to the fourth abstract modular system in the proposition above.
      </paragraph>
      <paragraph>
       Constraint answer set programming [45], [20], [2], [31], [35] is another prominent multi-logic formalism. In SMT, theories are integrated with a propositional formula. In constraint answer set programming, theories (called constraints) are integrated with logic programs. A similar argument can be used to show that AMSs capture constraint answer set programs.
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       Abstract AMS solver
      </section-title>
      <paragraph>
       We now resume our study of general properties of abstract modular systems. For an AMS {a mathematical formula}A={S1,…,Sn}, we define {a mathematical formula}A∪=S1∪…∪Sn. We can now state the result showing that modular systems can be expressed in terms of a single abstract inference module. We say that an AMS {a mathematical formula}A is equivalent to an abstract inference module S if {a mathematical formula}A and S have the same models.
      </paragraph>
      <paragraph label="Theorem 15">
       Every abstract modular inference system{a mathematical formula}Ais equivalent to the abstract inference module{a mathematical formula}A∪.
      </paragraph>
      <paragraph>
       This theorem shows the value of our abstraction. Concrete modular systems composed from theories of different logics cannot be easily combined into single theory. In particular, the operation of union cannot be applied since the result might not belong to any well-defined formal system. However, once all modules of the system are expressed as abstract modules, the problem disappears. The corresponding abstract modules can be combined and the union operator is the right one for the task.
      </paragraph>
      <paragraph>
       We use Theorem 15 to define for each AMS {a mathematical formula}A its transition graph{a mathematical formula}amsA. Namely, we set {a mathematical formula}amsA=amA∪. Theorem 6 implies the following result.
      </paragraph>
      <paragraph label="Theorem 16">
       For every AMS{a mathematical formula}A,
      </paragraph>
      <list>
       <list-item>
        the graph{a mathematical formula}amsAis finite and acyclic,
       </list-item>
       <list-item>
        for any terminal state M of{a mathematical formula}amsAother than ⊥,{a mathematical formula}[M]+is a model of{a mathematical formula}A,
       </list-item>
       <list-item>
        the state ⊥ is reachable from ∅ in{a mathematical formula}amsAif and only if{a mathematical formula}Ais unsatisfiable.
       </list-item>
      </list>
      <paragraph>
       As in several other similar results before, Theorem 16 shows that the graph {a mathematical formula}amsA is an abstract representation of a class of algorithms to decide satisfiability of a modular system {a mathematical formula}A. An algorithm from the class searches for a path in {a mathematical formula}amsA that leads from node ∅ to a terminal node. In each step, it extends the path with a node reachable from the currently last node by some edge originating in it. Theorem 16(a) guarantees that the method terminates, the other two parts of that result ensure correctness.
      </paragraph>
      <paragraph>
       For instance, let {a mathematical formula}A be the AMS {a mathematical formula}{S1,S2}, where {a mathematical formula}S1 is a module in Fig. 1(b) and {a mathematical formula}S2 is a module in Fig. 2. Below is a valid path in the transition graph {a mathematical formula}amsA with every edge annotated by the corresponding transition rule:{a mathematical formula} The state {a mathematical formula}a¬bΔ is terminal. Thus, Theorem 16(b) asserts that {a mathematical formula}{a} is a model of {a mathematical formula}A. Let us interpret this example. Earlier we demonstrated that module {a mathematical formula}S1 can be regarded as a representation of a propositional theory consisting of a single clause a whereas {a mathematical formula}S2 corresponds to the logic program (4) under the semantics of answer sets. We then illustrated how modules {a mathematical formula}S1 and {a mathematical formula}S2 give rise to particular algorithms for implementing search procedures. The graph {a mathematical formula}amsA represents all algorithms obtained by integrating algorithms represented by the modules {a mathematical formula}S1 and {a mathematical formula}S2, respectively.
      </paragraph>
      <paragraph>
       We will now discuss some classes of algorithms captured by the graph {a mathematical formula}amsA. As before, they are more specifically determined by a strategy of selecting an outgoing edge from the current state. Let us assume that such a strategy is available for each module {a mathematical formula}S∈A. Let us also assume that modules in {a mathematical formula}A are prioritized. Since modular systems do not assume any inherent priorities among modules, we assume the priorities are provided by the user as input (or control parameter) to the algorithm. This leads to an algorithm that proceeds as follows (assuming M is the current state and it is not terminal): if M is inconsistent, we always select the Fail or Backtrack edge (whichever is applicable);if M is consistent then we select an edge determined by the edge-selection strategy for the highest priority module. Assuming that modules in {a mathematical formula}A are enumerated {a mathematical formula}S1,…,Sk according to the descending priorities, the described algorithm works as follows. It starts by moving along edges implied by inferences of the module {a mathematical formula}S1 (according to the selection strategy for that module). If we reach ⊥, the entire search is over with failure. Otherwise, we reach a consistent state, in which no further inference from module {a mathematical formula}S1 is applicable (that state represents a model of {a mathematical formula}S1). The phase of search involving module {a mathematical formula}S1 gets suspended and we continue in the same way but now following edges determined by inferences in module {a mathematical formula}S2. In other words, we start the phase of the search involving module {a mathematical formula}S2. If we reach ⊥, the search is over with failure. If we reach an inconsistent state that contains decision literals, we apply the Backtrack rule. If that rule backtracks to a literal introduced after we moved to module {a mathematical formula}S2, we remain in the module {a mathematical formula}S2 phase and continue. If the backtrack takes us back to a literal introduced while a higher priority module was considered (in this case, that must be module {a mathematical formula}S1), we resume the module {a mathematical formula}S1 phase of the search suspended earlier. If Inference Propagate or Decide edges in module {a mathematical formula}S2 are available, we select one of them following the strategy for module {a mathematical formula}S2. If we reach a consistent state with no outgoing edges implied by inferences of {a mathematical formula}S2 (that state represents a model of both {a mathematical formula}S1 and {a mathematical formula}S2) we suspend the module {a mathematical formula}S2 phase and start the module {a mathematical formula}S3 phase, and continue in that way until a terminal state is reached.
      </paragraph>
      <paragraph>
       The main advantage of such an algorithm is that each phase is concerned only with inferences coming from a single module and state changes involve only literals from the vocabulary of that module. The literals established during phases involving higher priority modules remain fixed. Thus, the search space in each phase is effectively limited to that of the module involved in that phase.
      </paragraph>
      <paragraph>
       Our goal in this discussion is not to present a complete landscape of possible algorithmic instantiation of the graph {a mathematical formula}amsA but simply to show an example of such an instantiation. Clearly, other possibilities exist. For instance, the preference order may be dynamic. That is, once a model M of modules {a mathematical formula}S1,…,Si is found, the next module to drive the search might be selected based on M. We may also alternate between modules in a more arbitrary way, possibly switching from the current module to another even in situations when the current state has outgoing edges implied by the inferences of the current module. However, such algorithms may have to work with search spaces that are larger than the search space for a single module.
      </paragraph>
      <paragraph>
       Systemdlvhex  Our results apply to a version of the dlvhex{sup:8} solver [15] restricted to logic programs. dlvhex computes models of HEX-programs by exploiting their modularity, that is, representing programs as an equivalent modular program. Answer set programs consisting of rules of the form (2) form a special class of HEX-programs. Therefore, dlvhex restricted to such programs can be seen as an answer set solver that exploits their modularity. Given a program Π, dlvhex starts its operation by constructing a modular program {a mathematical formula}P={Π1,…,Πn} so that (i) {a mathematical formula}Π=Π1∪⋯∪Πn and (ii) answer sets of {a mathematical formula}P coincide with answer sets of Π. It then processes modules one after another according to an order determined by the structure of a program. That process can be modeled in abstract terms described above. In particular, the graph {a mathematical formula}ams{UPUF′(Π1),…,UPUF′(Πn)} can be seen as an abstraction capturing the family of dlvhex-like algorithms based on Unit Propagate and {a mathematical formula}Unfounded′ inferences.{sup:9}
      </paragraph>
      <paragraph>
       Model enumeration  By Theorem 15, the problem of model enumeration for abstract modular systems can be reduced to the problem of model enumeration for a single module. Therefore, we do not discuss it here.
      </paragraph>
     </section>
    </section>
    <section label="5">
     <section-title>
      Learning in solvers for AMSs
     </section-title>
     <paragraph>
      Nieuwenhuis et al. [49, Section 2.4] defined the DPLL-System-with-Learning graph to describe SAT solvers' learning, one of the crucial features of current SAT solvers responsible for rapid success in this area of automated reasoning. Their approach extends to our abstract setting. Specifically, the graph {a mathematical formula}amsA can be extended with “learning transitions” to represent solvers for AMSs that incorporate learning.
     </paragraph>
     <paragraph>
      The intuition behind learning in SAT is to allow new propagations by extending the original set of clauses as computation proceeds. These additional “learned” clauses give rise to new inferences to a SAT solver by enabling additional applications of Unit Propagate. In abstract modules, a similar effect can be obtained by extending them with new inferences (pairs {a mathematical formula}(M,l)). These inferences give rise to new edges in the transition graph via the rule Inference Propagate. Thus, they can be seen as “shortcuts” in the original graph leading to shorter paths to a terminal state. We now state these intuitions formally for the case of abstract modular systems.
     </paragraph>
     <paragraph>
      Let S be a module and E a set of inferences over {a mathematical formula}σS. By {a mathematical formula}SE we denote the module constructed by adding to S the inferences in E. A set E of inferences over {a mathematical formula}σS is S-safe if the module {a mathematical formula}SE is equivalent to S.
     </paragraph>
     <paragraph>
      Let {a mathematical formula}A be an AMS and E a set of inferences over {a mathematical formula}σA. For a module {a mathematical formula}S∈A, we define {a mathematical formula}E|S to be the set of all inferences in E over the vocabulary {a mathematical formula}σS, and set {a mathematical formula}AE={SE|S:S∈A}. We say that E is {a mathematical formula}A-safe if {a mathematical formula}E=⋃S∈AE|S (that is, if every inference in E is an inference over {a mathematical formula}σS, for some {a mathematical formula}S∈A), and if the module {a mathematical formula}AE is equivalent to {a mathematical formula}A.
     </paragraph>
     <paragraph>
      An (augmented) state relative to an AMS {a mathematical formula}A={S1,…,Sn} is either a distinguished state ⊥ or a pair of the form {a mathematical formula}M‖Γ1,…,Γn, where M is a state over the vocabulary {a mathematical formula}σA and {a mathematical formula}Γ1,…,Γn is a sequence of sets of inferences over the vocabularies of the modules {a mathematical formula}S1,…,Sn, respectively. Sometimes we denote the sequence {a mathematical formula}Γ1,…,Γn by {a mathematical formula}G. If E is a set of inferences over the vocabulary {a mathematical formula}σA and {a mathematical formula}G=Γ1,…,Γn, we define {a mathematical formula}GE=Γ1∪E|S1,…,Γn∪E|Sn.
     </paragraph>
     <paragraph>
      Each AMS {a mathematical formula}A={S1,…,Sn} determines a graph {a mathematical formula}amslA. Its nodes are the augmented states relative to {a mathematical formula}A and its transitions are specified in Fig. 9, Fig. 10. The transitions in the first group are determined by individual modules, the transitions in the second group are “global.”
     </paragraph>
     <paragraph>
      To illustrate the rule Learn Global, consider an AMS consisting of two modules:
     </paragraph>
     <list>
      <list-item label="1.">
       F is a module over the vocabulary {a mathematical formula}{a1,a2} with no inferences. (Every consistent and complete set of literals over {a mathematical formula}{a1,a2} is its model.)
      </list-item>
      <list-item label="2.">
       S is a module over the vocabulary {a mathematical formula}{a1} of the form:{a mathematical formula}
      </list-item>
     </list>
     <paragraph>
      The inferences {a mathematical formula}(∅,a1), {a mathematical formula}(∅,¬a1), {a mathematical formula}({a1},¬a1) and {a mathematical formula}({¬a1},a1) are {a mathematical formula}{F,S}-safe. Thus, we can apply the rule Learn Global with any subset of these inferences. This allows the future applications of {a mathematical formula}Inference PropagateF to have access to these new inferences. Note that originally, {a mathematical formula}Inference PropagateF has empty set of inferences to work with. Also, no {a mathematical formula}{F}-safe inferences exist so that {a mathematical formula}Learn LocalF is inapplicable.
     </paragraph>
     <paragraph>
      We refer to the transition rules Inference Propagate, Backtrack, Decide, and Fail of the graph {a mathematical formula}amslA as basic. We say that a node in the graph is semi-terminal if no basic rule is applicable to it. The graph {a mathematical formula}amslA can be used for deciding whether an AMS {a mathematical formula}A has a model by constructing a path from {a mathematical formula}∅‖∅,…,∅ to a semi-terminal node. We make this claim precise by stating the following theorem.
     </paragraph>
     <paragraph label="Theorem 17">
      For every AMS{a mathematical formula}A,
     </paragraph>
     <list>
      <list-item>
       the graph{a mathematical formula}amslAis finite and acyclic,
      </list-item>
      <list-item>
       for any semi-terminal state{a mathematical formula}M‖Gof{a mathematical formula}amslAreachable from{a mathematical formula}∅‖∅,…,∅,{a mathematical formula}[M]+is a model of{a mathematical formula}A,
      </list-item>
      <list-item>
       state ⊥ is reachable from{a mathematical formula}∅‖∅,…,∅in{a mathematical formula}amslAif and only if{a mathematical formula}Ahas no models.
      </list-item>
     </list>
     <paragraph>
      It follows that if we are constructing a path starting in {a mathematical formula}∅‖∅,…,∅ then we will reach some semi-terminal state and at that point the task of finding a model of {a mathematical formula}A is completed.
     </paragraph>
     <paragraph>
      We stress that our discussion of learning does not aim at any specific algorithmic ways in which one could perform learning. Instead, we formulate conditions that learned inferences are to satisfy (S-safety for learning local to a module S, and {a mathematical formula}A-safety for the global learning rule), which ensure the correctness of solvers that implement learning. In this way, we provide a uniform framework for correctness proofs of multi-logic solvers incorporating learning.
     </paragraph>
     <paragraph>
      There is an important difference between Learn Local and Learn Global. The first one allows new propagations within a module but does not change its semantics as the models of the module stay the same. Moreover, it is local, that is, other modules are unaffected by it. The application of Learn Global, while preserving the overall semantics of the system, may change the semantics of individual modules by eliminating some of their models. Moreover, being global, it affects in principle all modules of the system.
     </paragraph>
     <paragraph>
      SAT researchers have demonstrated that Learn Local is crucial for the success of SAT technology both in practice and theoretically [46], [44]. In fact, local (conflict-driven) learning has become standard not only in SAT solvers [26], but also in ASP solvers [19]. Nieuwenhuis et al. [49] described a transition rule T-Learn for SMT that can be seen as a precursor of the Learn Global rule. It is a standard practice in SMT solving to implement T-Learn[49]. Eiter et al. [14] implement Learn Global in the system dlvhex and report that this significantly decreases the runtime of the system. We now present theoretical analysis showing that in some cases, Learn Global has a potential to yield substantial performance benefits for modular systems.
     </paragraph>
     <paragraph>
      Let us consider a solver modeled within our abstract solving framework by imposing two restrictions. First, the transitions determined by the rule Learn Global are not allowed. We write {a mathematical formula}amsl− for the graph obtained from the corresponding graph amsl by removing the edges corresponding to the application of the rule Learn Global. Second, we assume that the solver proceeds (applies the rules) according to the ranking given by an enumeration of modules in the input AMS {a mathematical formula}A, say {a mathematical formula}A={S1,…,Sk} (vide our discussion of solvers, and in particular of dlvhex, in an earlier section). We will now show that a solver of this type can reap significant performance benefits by incorporating the rule Learn Global. To show that let us consider a family {a mathematical formula}An={Fn,S} ({a mathematical formula}n=1,2,…) of AMSs, where:
     </paragraph>
     <list>
      <list-item label="1.">
       {a mathematical formula}Fn is a module over the vocabulary {a mathematical formula}{a1,…,an} with no inferences. In particular, every consistent and complete set of literals over {a mathematical formula}{a1,…,an} is its model.
      </list-item>
      <list-item label="2.">
       S is a module as defined in the example prior to Theorem 17.
      </list-item>
     </list>
     <paragraph>
      Assuming that the module {a mathematical formula}Fn is higher ranked than the module S, solvers modeled by the graph {a mathematical formula}amsl− and the ranking-based rule application will start with the module {a mathematical formula}Fn and by applying Decide to all its atoms, arrive at one of the models of {a mathematical formula}Fn. Next, they will move the search to module S and in constant time discover a contradiction. Once the contradiction has been reached by means of rules in S, the algorithm backtracks to module {a mathematical formula}Fn and generates another model of {a mathematical formula}Fn. Then it moves on to S again, and again discovers a contradiction. The search terminates with failure only after all{a mathematical formula}2n models of {a mathematical formula}Fn have been inspected. Consequently, the search runs in time exponential in n.
     </paragraph>
     <paragraph>
      There are two inferences that could be learned and added to S by means of the rule Learn Local: {a mathematical formula}({a1},¬a1) and {a mathematical formula}({¬a1},a1). Indeed, both are S-safe. However, incorporating these two inferences in the module S does not improve the performance of the solver. It will still try all models of {a mathematical formula}Fn and fail only after all of them were considered. Thus, local learning does not help reduce the running time.
     </paragraph>
     <paragraph>
      However, the inferences {a mathematical formula}(∅,a1), {a mathematical formula}(∅,¬a1), {a mathematical formula}({a1},¬a1) and {a mathematical formula}({¬a1},a1) are {a mathematical formula}{Fn,S}-safe. Applying the rule Learn Global with, say, {a mathematical formula}(∅,a1) and {a mathematical formula}({a1},¬a1), and incorporating these two inferences into {a mathematical formula}Fn allows the solver to immediately terminate the search (it will apply the inference {a mathematical formula}(∅,a1) followed by {a mathematical formula}({a1},¬a1), and finally reach ⊥ by applying the rule Fail). That search will run in time linear in n (essentially, the amount of time needed to reach the first conflict as all other steps take constant time). Thus, global learning results in an exponential speed up.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Related work and future research
     </section-title>
     <paragraph>
      In an important development, Brewka and Eiter [6] introduced an abstract notion of a heterogeneous nonmonotonic multi-context system (MCS). One of the key aspects of that proposal is its abstract representation of a logic that allows one to study MCSs without regard to syntactic details. The independence of contexts from syntax has allowed researchers to focus on semantic aspects of multi-context systems. Since their inception, multi-context systems have received substantial attention and inspired implementations of hybrid reasoning systems including dlvhex[15] and dmcs[16]. There are some similarities between AMSs and MCSs. However, there are also differences. First, MCSs provide an abstract framework to define semantics of hybrid systems. In contrast, AMSs explicitly represent inferences of a logic and provide an abstract framework for studying model generation algorithms.
     </paragraph>
     <paragraph>
      Second, the two formalisms differ in how they share information among modules. MCSs use to this end the so-called “bridge rules.” In AMSs information sharing is implemented by a simple notion of sharing parts of the vocabulary between the modules. Rather non-surprisingly, bridge rules can simulate it. More interestingly, as our recent research on model-based abstract modular systems shows, despite its simplicity, information sharing through vocabulary sharing is expressive enough to capture the effects of bridge rules [39].
     </paragraph>
     <paragraph>
      Modularity is one of the key techniques in principled software development. The importance of modularity has also been recognized in declarative programming languages rooted in KR&amp;R such as answer set programming. In particular, Oikarinen and Janhunen [50] proposed a modular version of answer set programs called lp-modules. In that work, the authors were primarily concerned with the decomposition of lp-modules into sets of simpler ones. They proved that under some assumptions such decompositions are possible. Dao-Tran et al. [9] extend modularity to programs under the answer set semantics, whose models may have contextually dependent input provided by other modules. Janhunen [30] proposed the composition of hybrid reasoning systems using a general modular architecture that allows to combine propositional formulas as well as logic programs. Järvisalo, Oikarinen, Janhunen, and Niemelä [33], and Tasharrofi and Ternovska [54] studied different collections of operators to combine elementary abstract modules into more complex ones. We focused on building simple (flat-structured) modular systems that can be obtained from abstract modules by means of only one composition operator, the union (which implements the standard notion of the logical conjunction connective). In contrast to the work by Järvisalo et al. [33] and Tasharrofi and Ternovska [54], the conjunction (union) can be applied to any modules, no matter their internal structure and interdependencies between them. Whether our “union-based” modular systems can represent modular systems arising when other operators to combine modules are allowed is an interesting open question.
     </paragraph>
     <paragraph>
      Tasharrofi, Wu, and Ternovska [55] proposed an algorithm for modular model expansion tasks, in particular, for the task of model generation, in the abstract multi-logic system setting developed by Tasharrofi and Ternovska [54]. They describe their algorithm by standard pseudocode and do not propose any abstract representations. Giunchiglia et al. [24] analyzed pseudocode descriptions of algorithms to study and relate several backtrack search procedures behind answer set solvers. In this work, we adapt an abstract graph-based framework for designing backtrack search algorithms for abstract modular systems. The benefits of that approach for modeling families of backtrack search procedures employed in SAT, ASP, and PC(ID) solvers were demonstrated by Nieuwenhuis et al. [49], Lierler [34], and Lierler and Truszczynski [36]. Our work provides additional support for the generality and flexibility of the graph-based framework as a finer abstraction of backtrack search algorithms than direct pseudocode representations, allowing for convenient means to prove correctness and study relationships between the families of the algorithms.
     </paragraph>
     <paragraph>
      Gebser and Schaub [21] describe a form of a tableaux system to capture inferences involved in computing answer sets. Several rules used in their approach are closely related to those we discussed in the context of modules designed to represent reasoning on logic programs. However, the two approaches are formally different. Most notably, the concepts of states in a tableaux and in an abstract module are different. Still, there seems to be a connection between them, which we plan to investigate in our future work.
     </paragraph>
     <paragraph>
      Brain [5] introduces the concept of I-spaces meant to uniformly capture states of computation of search algorithms stemming from different logical formalisms. This way search algorithms can be uniformly described and compared. Similarly, D'Silva, Haller and Kroening [12] introduce a lattice-theoretic generalization of several logic-based formalisms including propositional satisfiability. They show that a conflict-driven-clause-learning algorithm of modern satisfiability solvers can be considered and analyzed in lattice-theoretic terms. It is an interesting question whether I-spaces of Brain or the lattice-theoretic approach of D'Silva et al. could be used to study modularity of multi-logic systems.
     </paragraph>
     <paragraph>
      Brochenin et al. [7] illustrated how the graph-based framework in spirit of Nieuwenhuis et al. can be lifted from capturing DPLL-like procedures to decision procedures at the second level of polynomial hierarchy. In the future we intend to investigate the applicability of the ideas by Brochenin et al. in the context of abstract modular inference systems and solvers.
     </paragraph>
     <paragraph>
      Barrett et al. [3] proposed the transition system {a mathematical formula}DPLL(T1,…,Tn) that captures the following architecture of an SMT solver: DPLL-based SAT solver plays the role of the master system coordinating the search process of distinct specialized solvers for theories {a mathematical formula}T1,…,Tn. The {a mathematical formula}amslA transition system can be seen as a generalization of the {a mathematical formula}DPLL(T1,…,Tn) framework that (a) removes SAT solving as the distinguished component of an SMT solver, and (b) is agnostic about which theory solver plays the role of the master system.
     </paragraph>
    </section>
    <section label="7">
     <section-title>
      Conclusions
     </section-title>
     <paragraph>
      In this paper, we introduced abstract modules and abstract modular systems and showed that they provide a framework capable of capturing diverse logics and inference mechanisms integrated into modular knowledge representation systems. In particular, we showed that propositional theories and logic programs can be expressed as abstract inference modules, and that collections of propositional theories and logic programs can be represented as abstract modular systems. Even more importantly, we showed that satisfiability modulo theories can be translated to and studied in the language of abstract modular systems, too, thus demonstrating a broad scope of applicability of our formal framework.
     </paragraph>
     <paragraph>
      Next, we showed that transition graphs determined by modules and modular systems provide an elegant and effective unifying representation of model generating algorithms, or solvers, and simplify reasoning about such issues as correctness or termination. Our discussion of inference learning identified two types of learning relevant to computing models of modular systems — local and global. The former corresponds to learning studied before in SAT and SMT and shown both theoretically and practically to be essential for good performance. The latter, the global learning, is a new concept that arises in the context of modular systems. It concerns learning across modules and, as local learning, promises to lead to performance gains. In the future, we will conduct a systematic study of global learning and its impact on solvers for practical multi-logic formalisms.
     </paragraph>
     <paragraph>
      The paper provides evidence that abstract inference modules, abstract modular systems and their transition graphs can be useful in theoretical studies of solver properties, and in the development of solvers for modular systems that combine theories from different logic formalisms.
     </paragraph>
    </section>
   </content>
   <appendices>
    <section label="Appendix A">
     <section-title>
      Proofs
     </section-title>
     <paragraph label="Proposition 1">
      Abstract inference modules{a mathematical formula}S1and{a mathematical formula}S2are equivalent if and only if they have the same models contained in the set{a mathematical formula}σS1∪σS2.
     </paragraph>
     <paragraph label="Proof">
      (⇒) Evident.(⇐) Assume that {a mathematical formula}S1 and {a mathematical formula}S2 have the same models contained in the set {a mathematical formula}σS1∪σS2. To prove the implication, it suffices to show that if X is a model of {a mathematical formula}S1 then X is a model of {a mathematical formula}S2. To simplify the notation, we define {a mathematical formula}δ=σS1∪σS2 and {a mathematical formula}Xδ=X∩δ.Let {a mathematical formula}(M,l) be an inference of {a mathematical formula}S1 such that M is consistent with {a mathematical formula}Xδ. Since {a mathematical formula}M⊆Lit(δ), M is consistent with X. It follows that l is consistent with X. Since {a mathematical formula}l∈Lit(δ), l is consistent with {a mathematical formula}Xδ. Thus, {a mathematical formula}Xδ is a model of {a mathematical formula}S1. By the assumption, {a mathematical formula}Xδ is a model of {a mathematical formula}S2.Let {a mathematical formula}(M′,l′) be an inference of {a mathematical formula}S2 such that {a mathematical formula}M′ is consistent with X. Since {a mathematical formula}M′⊆Lit(δ), {a mathematical formula}M′ is consistent with {a mathematical formula}Xδ. We recall that {a mathematical formula}Xδ is a model of {a mathematical formula}S2. Thus, {a mathematical formula}l′ is consistent with {a mathematical formula}Xδ and, since {a mathematical formula}l′∈Lit(δ), also with X. It follows that X is a model of {a mathematical formula}S2.  □
     </paragraph>
     <paragraph label="Proof">
      Let S be a module and{a mathematical formula}(M,l)an inference in S. Then{a mathematical formula}S|≈Ml.Let X be a model of S such that M is consistent with X. By the definition of a model of a module, l is consistent with X and the result follows.  □
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}S1and{a mathematical formula}S2be abstract inference modules. A set X is a model of{a mathematical formula}S1∪S2if and only if X is a model of{a mathematical formula}S1and{a mathematical formula}S2.The assertion is an immediate consequence of definitions. Let X be a model of {a mathematical formula}S1∪S2 and {a mathematical formula}(M,l) be an inference of {a mathematical formula}S1 such that M is consistent with X. Since {a mathematical formula}(M,l) is an inference of {a mathematical formula}S1∪S2, l is consistent with X and so, X is a model of {a mathematical formula}S1. The case of {a mathematical formula}(M,l) being an inference of {a mathematical formula}S2 and the converse implication can be proved in a similar way.  □
     </paragraph>
     <paragraph label="Proof">
      For every propositional theory T (respectively, CNF formula T containing no empty clause),{a mathematical formula}Ent(T)(respectively,{a mathematical formula}UP(T)) is equivalent to T.We denote by {a mathematical formula}σT the vocabulary that consists of atoms occurring in T (and {a mathematical formula}Ent(T)).Statement 1: For every propositional theory T,{a mathematical formula}Ent(T)is equivalent to T. Let X be a model of T and {a mathematical formula}(M,l) an inference of {a mathematical formula}Ent(T) such that M is consistent with X. Clearly, X is a model of M. Since {a mathematical formula}T∪M⊨l and X is a model of {a mathematical formula}T∪M, X is model of l, that is, l is consistent with X. We derive that X is a model of {a mathematical formula}Ent(T).Conversely, let X be a model of {a mathematical formula}Ent(T) and let us define {a mathematical formula}M=(X∩σT)∪{¬a:a∈σT∖X}. Clearly, M is consistent with X. We now proceed by contradiction. Assume that X is not a model of T. Then, {a mathematical formula}T∪M is inconsistent. Let l be any literal in M and {a mathematical formula}M′=M∖{l}. It follows that {a mathematical formula}T∪M′⊨l‾ (indeed, since {a mathematical formula}T∪M is inconsistent, every model of {a mathematical formula}T∪M′, must be consistent with {a mathematical formula}l‾). By definition, {a mathematical formula}(M′,l‾)∈Ent(T). From the fact that M is consistent with X and {a mathematical formula}M′⊂M, we derive that {a mathematical formula}M′ is consistent with X. Since X is a model of {a mathematical formula}Ent(T), {a mathematical formula}l‾ is consistent with X. On the other hand, {a mathematical formula}l∈M and M is consistent with X. Thus, l is consistent with X, a contradiction.Statement 2: For every CNF formula T containing no empty clause,{a mathematical formula}UP(T)is equivalent to T. Let X be a model of T and {a mathematical formula}(M,l) an inference of {a mathematical formula}UP(T) such that M is consistent with X. It follows that T has a clause {a mathematical formula}C∨l such that for every literal u of C, {a mathematical formula}u‾∈M. Thus, all literals {a mathematical formula}u‾, {a mathematical formula}u∈C, are consistent with X, that is, X is a model of ¬C. Since X is a model of T, X is a model of l, that is, l is consistent with X. We derive that X is a model of {a mathematical formula}UP(T).Conversely, let X be a model of {a mathematical formula}UP(T). We proceed by contradiction. Assume that X is not a model of T. Then there is a clause C in T such that X is a model of ¬C. Let us assume that {a mathematical formula}C=u1∨…∨uk. It follows that the set {a mathematical formula}{u‾1,…,u‾k} is consistent with X. Since C is a clause of T and T contains no empty clause, {a mathematical formula}k≥1. Moreover, since C is not a tautology (we recall that X is a model of ¬C), {a mathematical formula}uk∉{u‾1,…,u‾k−1}. By the definition of {a mathematical formula}UP(T), {a mathematical formula}({u‾1,…,u‾k−1},uk)∈UP(T). Since {a mathematical formula}{u‾1,…,u‾k−1} is consistent with X and X is a model of {a mathematical formula}UP(T), {a mathematical formula}uk is consistent with X, a contradiction.  □
     </paragraph>
     <paragraph>
      We recall that if Π is a program, {a mathematical formula}σΠ denotes the vocabulary that consists of atoms occurring in Π. It is obvious that {a mathematical formula}σΠ also coincides with the set of atoms occurring in the modules {a mathematical formula}UP(Π), {a mathematical formula}UF(Π), {a mathematical formula}UPUF(Π) and {a mathematical formula}smodels(Π).
     </paragraph>
     <paragraph label="Proof">
      Every logic program Π is equivalent to the modules{a mathematical formula}UPUF(Π)and{a mathematical formula}smodels(Π).Statement 1: Every logic program Π is equivalent to the module{a mathematical formula}UPUF(Π). Let X be an answer set of Π. By definition, X is a model of {a mathematical formula}Πcl and X does not have any non-empty subset that is unfounded on X with respect to Π. We start by showing that X is a model of {a mathematical formula}UP(Π). We then demonstrate that X is a model of {a mathematical formula}UF(Π). By Proposition 3, it will immediately follow that X is a model of {a mathematical formula}UPUF(Π).Let {a mathematical formula}(M,l) be any inference in {a mathematical formula}UP(Π) such that M is consistent with X. Since {a mathematical formula}(M,l)∈UP(Π), {a mathematical formula}Πcl has a clause {a mathematical formula}C∨l (modulo a reordering of literals) such that for every literal {a mathematical formula}u∈C, {a mathematical formula}u‾∈M. Thus, all literals {a mathematical formula}u‾, {a mathematical formula}u∈C, are consistent with X, that is, X is a model of ¬C. Since X is a model of {a mathematical formula}Πcl, X is a model of l, that is, l is consistent with X. Thus, X is a model of {a mathematical formula}UP(Π).Let {a mathematical formula}(M,l) be any inference in {a mathematical formula}UF(Π) such that M is consistent with X. By the definition of {a mathematical formula}UF(Π), there is an atom {a mathematical formula}a∈σΠ such that {a mathematical formula}l=¬a and {a mathematical formula}a∈U, for some set {a mathematical formula}U∈Unf(M,Π). Since M is consistent with X, U is also unfounded on {a mathematical formula}X∪{¬a:a∈σΠ∖X} with respect to Π. By the definition of an answer set, {a mathematical formula}a∉X. Consequently, {a mathematical formula}l=¬a is consistent with X. It follows that X is a model of {a mathematical formula}UF(Π) and, by the comment above, a model of {a mathematical formula}UPUF(Π).Conversely, let {a mathematical formula}X⊆σΠ be a model of {a mathematical formula}UPUF(Π). By Proposition 3, X is a model of {a mathematical formula}UP(Π) and a model of {a mathematical formula}UF(Π). Let us assume that X is not an answer set of Π.Case 1: X is not a model of {a mathematical formula}Πcl. Then there is a clause C in {a mathematical formula}Πcl such that X is a model of ¬C. Let us assume that {a mathematical formula}C=u1∨…∨uk. It follows that the set {a mathematical formula}{u‾1,…,u‾k} is consistent with X. Since C is a clause of {a mathematical formula}Πcl, {a mathematical formula}k≥1. Moreover, since C is not a tautology, {a mathematical formula}uk∉{u‾1,…,u‾k−1}. By the definition of {a mathematical formula}UP(Π), {a mathematical formula}({u‾1,…,u‾k−1},uk)∈UP(Π). Since {a mathematical formula}{u‾1,…,u‾k−1} is consistent with X and X is a model of {a mathematical formula}UP(Π), {a mathematical formula}uk is consistent with X, a contradiction.Case 2: X contains an element, say a, that belongs to a set that is unfounded on {a mathematical formula}X∪{¬a:a∈σΠ∖X} with respect to Π. By the definition of the rule Unfounded, we conclude that {a mathematical formula}(X∪{¬a:a∈σΠ∖X},¬a)∈UF(Π). Since X is a model of {a mathematical formula}UF(Π) and is consistent with {a mathematical formula}X∪{¬a:a∈σΠ∖X}, ¬a is consistent with X, a contradiction.Statement 2: Every logic program Π is equivalent to the module{a mathematical formula}smodels(Π). Let X be an answer set of Π. By Statement 1, X is a model of {a mathematical formula}UP(Π) and {a mathematical formula}UF(Π). Since {a mathematical formula}ARC(Π)⊆UF(Π), X is a model of {a mathematical formula}ARC(Π). The proof that X is also a model of {a mathematical formula}BC(Π) uses the well-known fact that if X is an answer set of Π, X is also a supported model of Π that is, for every {a mathematical formula}a∈X, there is {a mathematical formula}B∈Bodies(Π) such that X is a model of {a mathematical formula}s(B). Let us consider an inference {a mathematical formula}(M,l)∈BC(Π) such that M is consistent with X. By the definition of {a mathematical formula}BC(Π), there is a rule {a mathematical formula}a←B in Π such that {a mathematical formula}a∈M, {a mathematical formula}l∈s(B), and for every {a mathematical formula}B′∈Bodies(Π,a) such that {a mathematical formula}s(B′)≠s(B), there is {a mathematical formula}u∈s(B′) such that {a mathematical formula}u‾∈M. Let {a mathematical formula}a←B′ be a rule in Π such that {a mathematical formula}s(B′)≠s(B) and let {a mathematical formula}u∈s(B′) be such that {a mathematical formula}u‾∈M. Since M is consistent with X, X is not a model of u (if {a mathematical formula}u=b, for some atom b, {a mathematical formula}¬b∈M and so, {a mathematical formula}b∉X; if {a mathematical formula}u=¬b, for some atom b, {a mathematical formula}b∈M and so, {a mathematical formula}b∈X). It follows that X is not a model of {a mathematical formula}s(B′) for any rule {a mathematical formula}a←B′ in Π, where {a mathematical formula}s(B′)≠s(B). Since X is a supported model of Π and {a mathematical formula}a∈X, X must be a model of {a mathematical formula}s(B). In particular, X is a model of l, that is, l is consistent with X. Thus, X is a model of the inference {a mathematical formula}(M,l) and so, a model of {a mathematical formula}BC(Π). By Proposition 3, X is a model of {a mathematical formula}smodels(Π).Conversely, let {a mathematical formula}X⊆σΠ be a model of {a mathematical formula}smodels(Π). By the definitions of {a mathematical formula}UPUF(Π) and {a mathematical formula}smodels(Π), {a mathematical formula}UPUF(Π)⊆smodels(Π). Thus, X is a model of {a mathematical formula}UPUF(Π). By Statement 1, X is an answer set of Π.  □
     </paragraph>
     <paragraph>
      Since states are sequences of literals, we will often refer to prefixes of states. Formally, given a state {a mathematical formula}l1l2…ln, every sequence {a mathematical formula}l1l2…lk, where {a mathematical formula}0≤k≤n, is its prefix. In particular, each state is its own prefix.
     </paragraph>
     <paragraph label="Proof">
      Let S be an abstract inference module and N a non-fail state in the transition system{a mathematical formula}amSreachable in{a mathematical formula}amSfrom ∅. For every prefix{a mathematical formula}M′of N and for every model X of S, if every decision literal of{a mathematical formula}M′is consistent with X, then{a mathematical formula}[M′]is consistent with X.We proceed by induction on the length of a path from ∅ to N in {a mathematical formula}amS. If that length is 0, {a mathematical formula}N=∅ and the claimed property trivially holds. Let us consider a non-fail state N reachable from ∅ by a path p of length {a mathematical formula}k&gt;0 and let us assume that every non-fail state reachable in {a mathematical formula}amS from ∅ by a path of length at most {a mathematical formula}k−1 has the claimed property. Let {a mathematical formula}M′ be the state preceding N on p. Since {a mathematical formula}M′ is reachable from ∅ by a path of length {a mathematical formula}k−1, it follows by the induction hypothesis that {a mathematical formula}M′ has the claimed property. That is, for every prefix {a mathematical formula}M″ of {a mathematical formula}M′ (including {a mathematical formula}M″=M′) and for every model X of S, if every decision literal in {a mathematical formula}M″ is consistent with X then {a mathematical formula}[M″] is consistent with X.Let N be of the form {a mathematical formula}l1…ln.{sup:10} Since N is reached from {a mathematical formula}M′ by an edge resulting from Inference Propagate, Backtrack or Decide (applying the rule Fail results in the state ⊥), {a mathematical formula}l1…ln−1 is a prefix of {a mathematical formula}M′.Let X be a model of S and {a mathematical formula}M″ a prefix of N such that all decision literals in {a mathematical formula}M″ are consistent with X. If {a mathematical formula}M″ is a prefix of {a mathematical formula}l1…ln−1, then {a mathematical formula}M″ is a prefix of {a mathematical formula}M′. By the observation above, {a mathematical formula}[M″] is consistent with X. In particular, if all decision literals in {a mathematical formula}l1…ln−1 are consistent with X, {a mathematical formula}[l1…ln−1] is consistent with X.The only other case is {a mathematical formula}M″=N. Since all decision literals in N are consistent with X, all decision literals of {a mathematical formula}l1…ln−1 are consistent with X. Thus, by the observation above, {a mathematical formula}[l1…ln−1] is consistent with X. To complete the proof, we have to show that {a mathematical formula}ln is consistent with X. The edge connecting {a mathematical formula}M′ to {a mathematical formula}N=l1…ln in {a mathematical formula}amS is not generated by the rule Fail. This leaves us with three cases to consider.Inference Propagate: In this case, {a mathematical formula}M′=l1…ln−1, {a mathematical formula}[M′] is consistent, {a mathematical formula}ln∉[M′] and for some {a mathematical formula}M″⊆[M′], {a mathematical formula}(M″,ln) is an inference of S. By Proposition 2, {a mathematical formula}S|≈M″ln. Since {a mathematical formula}[M′] is consistent with X, {a mathematical formula}M″ is consistent with X and so, {a mathematical formula}ln is consistent with X.Backtrack: In this case, {a mathematical formula}M′ has the form {a mathematical formula}l1…ln−1l‾nΔQ, where Q contains no decision literals, and {a mathematical formula}[M′]=[l1…ln−1l‾nΔQ] is inconsistent. Let us assume that {a mathematical formula}ln is not consistent with X. It follows that {a mathematical formula}l‾n is consistent with X. Consequently, all decision literals of {a mathematical formula}M′ are consistent with X. By the induction hypothesis, {a mathematical formula}[M′] is consistent with X, a contradiction. Thus, {a mathematical formula}ln is consistent with X.Decide: In this case, {a mathematical formula}M′=l1…ln−1 and {a mathematical formula}ln is a decision literal. Since all decision literals of M are consistent with X then, trivially, {a mathematical formula}[ln] is consistent with X.  □
     </paragraph>
     <paragraph label="Theorem 6">
      For every module S,
     </paragraph>
     <list>
      <list-item>
       graph{a mathematical formula}amSis finite and acyclic,
      </list-item>
      <list-item>
       for any terminal state M of{a mathematical formula}amSother than ⊥,{a mathematical formula}[M]+is a model of S,
      </list-item>
      <list-item>
       state ⊥ is reachable from ∅ in{a mathematical formula}amSif and only if S is unsatisfiable (has no models).
      </list-item>
     </list>
     <paragraph label="Proof">
      Part (a) can be proved following the argument for Proposition 1 in the paper by Lierler [34]. It also follows as a corollary from Theorem 11(a), to which we provide an explicit proof later on.(b) Let M be a terminal state of {a mathematical formula}amS other than ⊥. Since neither Fail nor Backtrack is applicable, {a mathematical formula}[M] is consistent. Since Decide is not applicable, {a mathematical formula}[M] assigns all literals, that is, {a mathematical formula}[M] is complete. Let {a mathematical formula}(M′,l) be an inference of S such that {a mathematical formula}M′ is consistent with {a mathematical formula}[M]+. It follows that {a mathematical formula}M′⊆[M]. Since Inference Propagate is not applicable, {a mathematical formula}l∈M. Thus, l is consistent with {a mathematical formula}[M]+. It follows that {a mathematical formula}[M]+ is a model of S.(c) Left-to-right: Since ⊥ is reachable from ∅, there is a state M without decision literals such that there is a path in {a mathematical formula}amS from ∅ to M, and there is an edge from M to ⊥ in {a mathematical formula}amS due to the application of Fail. It follows that {a mathematical formula}[M] is inconsistent. By Lemma 18, {a mathematical formula}[M] is consistent with every model of S (indeed, M has no decision literals). Since {a mathematical formula}[M] is inconsistent, S has no models.Right-to-left: From (a) it follows that there is a path in {a mathematical formula}amS from ∅ to some terminal state. Since S has no models, (b) implies that this state must be ⊥.  □
     </paragraph>
     <paragraph label="Proof">
      For every CNF formula F with no empty clause,{a mathematical formula}dpF=amUP(F).It is clear that the two graphs have the same sets of nodes (⊥ and all states over the vocabulary {a mathematical formula}σF). It is also clear that both graphs have the same edges arising from the generic rules Fail, Backtrack and Decide. Thus, let us consider an edge in {a mathematical formula}dpF implied by the rule {a mathematical formula}Unit PropagateF. By definition, this edge has the form {a mathematical formula}(M,Ml), where {a mathematical formula}[M]⊆Lit(σF) is consistent, {a mathematical formula}l∈Lit(σF)∖M, and there is a clause {a mathematical formula}C∨l∈F such that for every literal u of C, {a mathematical formula}u‾∈[M]. It follows that {a mathematical formula}([M],l)∈UP(F) and, by the definition of {a mathematical formula}Inference PropagateUP(F), {a mathematical formula}(M,Ml) is an edge of {a mathematical formula}amUP(F).Conversely, let us consider an edge of {a mathematical formula}amUP(F) implied by {a mathematical formula}Inference PropagateUP(F). This edge is of the form {a mathematical formula}(M,Ml), where {a mathematical formula}[M]⊆Lit(σF) is consistent, {a mathematical formula}l∈Lit(σF)∖M, and for some {a mathematical formula}M′⊆[M], {a mathematical formula}(M′,l) is an inference of {a mathematical formula}UP(F). It follows that there is a clause {a mathematical formula}C∨l∈F, such that for every literal u in C, {a mathematical formula}u‾∈M′. Consequently, for every literal u in C, {a mathematical formula}u‾∈[M] and so, {a mathematical formula}(M,Ml) is an edge of {a mathematical formula}dpF.  □
     </paragraph>
     <paragraph label="Proof">
      The proof follows the same line of argument as the previous one and is an immediate consequence of the definitions.  □
     </paragraph>
     <paragraph>
      We say that a sequence {a mathematical formula}M′extends a sequence M if M is a prefix of {a mathematical formula}M′; moreover, {a mathematical formula}M′properly extends M if {a mathematical formula}M′ extends M and {a mathematical formula}M≠M′. We recall that states other than the fail state ⊥ are sequences and note that the following lemma follows directly from the definitions of the transition rules.
     </paragraph>
     <paragraph label="Lemma 19">
      If{a mathematical formula}M≠⊥is a state in{a mathematical formula}ameSand{a mathematical formula}M′is a successor of M such that{a mathematical formula}M′≠⊥, then{a mathematical formula}M′is a proper extension of M or{a mathematical formula}M′=Pl‾, where l is the last decision literal in{a mathematical formula}M=PlΔQ.
     </paragraph>
     <paragraph label="Proof">
      Let S be an abstract module. For every path p in{a mathematical formula}ameSstarting in a state M, every state that follows M on p is equal to ⊥, or is a proper extension of M, or contains a literal{a mathematical formula}l‾, for some decision literal{a mathematical formula}lΔin M.We prove the statement by induction on the number of decision literals k in M. Let {a mathematical formula}k=0. Then, {a mathematical formula}M=⊥ or M is a sequence of non-decision literals. In the first case, path p consists of M only and the assertion is trivially true (there are no nodes on p that follow M). In the second case, Lemma 19 and a simple inductive argument imply that every state on p that follows M, other than ⊥, has M as its proper prefix.Thus, let {a mathematical formula}k≥1 and let us assume that the assertion holds for every path originating in a state with at most {a mathematical formula}k−1 decision literals. For the induction step, let us consider a state {a mathematical formula}M=P1l1ΔP2l2Δ…PklkΔPk+1, where {a mathematical formula}P1,…,Pk+1 contain no decision literals. If all states on p contain {a mathematical formula}lkΔ then, by Lemma 19 and a simple induction, all states that follow M on p are of the form MQ, for some non-empty sequence Q of literals (possibly annotated) that are unassigned in M. Thus, the assertion follows. Otherwise, let {a mathematical formula}M′ be the first state on p not containing {a mathematical formula}lkΔ. By Lemma 19 and a simple inductive argument, all states on p strictly between M and {a mathematical formula}M′ properly extend M and {a mathematical formula}M′=P1l1ΔP2l2Δ…Pkl‾k. In particular, {a mathematical formula}l‾k∈M′. Moreover, by the induction hypothesis, every state that follows {a mathematical formula}M′ on p is equal to ⊥, is an extension of {a mathematical formula}M′ and, consequently, contains {a mathematical formula}l‾k, or contains {a mathematical formula}l‾i, for some i, {a mathematical formula}1≤i≤k−1. Thus, the assertion follows in this case, too.  □
     </paragraph>
     <paragraph label="Theorem 11">
      For every abstract inference module S,
     </paragraph>
     <list>
      <list-item>
       the graph{a mathematical formula}ameSis finite and acyclic,
      </list-item>
      <list-item>
       the ⊥ state is reachable from ∅,
      </list-item>
      <list-item>
       for every path from ∅ to ⊥ in{a mathematical formula}ameS, the set of states in which the rule Enumerate applies is precisely the set of models of S over{a mathematical formula}σS, and for each model X of S over{a mathematical formula}σSthere is exactly one state M on the path such that{a mathematical formula}X=[M].
      </list-item>
     </list>
     <paragraph label="Proof">
      (a) Finiteness of {a mathematical formula}ameS is evident. Let us assume that there is a cycle in {a mathematical formula}ameS. Then, there is a path in {a mathematical formula}ameS that starts in a state M and returns to M after traversing a positive number of edges. That contradicts Lemma 20.(b) It is easy to see that every path ending in a state other than ⊥ can be extended. Since {a mathematical formula}ameS is acyclic, following outgoing edges of nodes in {a mathematical formula}ameS (breaking ties in an arbitrary way, if more than one rule applies) eventually takes us to ⊥.(c) We note that (i) the states of graphs {a mathematical formula}amS and {a mathematical formula}ameS coincide, and (ii) each edge of the graph {a mathematical formula}amS is also an edge of the graph {a mathematical formula}ameS. Also, for every terminal state M of {a mathematical formula}amS other than ⊥, the rule Enumerate is the only transition rule applicable to M in {a mathematical formula}ameS. By Theorem 6(b), it follows that {a mathematical formula}[M]+ is a model of S. Thus, if M is a state on a path p from ∅ to ⊥ in {a mathematical formula}ameS, and the edge on p leading from M out to the next state on the path is determined by Enumerate, then {a mathematical formula}[M]+ is a model of S.To conclude the proof, we show that every model of S over {a mathematical formula}σS will eventually be reached by any path from ∅ to ⊥. Let X be a model of S over {a mathematical formula}σS. Consider any path p from ∅ to ⊥ in {a mathematical formula}ameS. Let P denote the longest prefix of a state on p such that {a mathematical formula}[P]⊆X. Let M denote the first state on p such that P is a prefix of M. We will show that {a mathematical formula}M=P and {a mathematical formula}[P]=X=[M].Case 1. {a mathematical formula}M=PQ, where Q is a nonempty sequence of literals. It follows that {a mathematical formula}M≠∅ and that M was obtained from its predecessor on p, say {a mathematical formula}M′, by means of one of the rules of {a mathematical formula}ameS other than the Fail rule. It follows that P is the prefix of {a mathematical formula}M′. This contradicts the fact that M is the first state on p such that P is a prefix of M.Case 2. {a mathematical formula}M=P. It remains to show that {a mathematical formula}[P]=X. We recall that {a mathematical formula}[P]⊆X. Towards a contradiction, let us assume that {a mathematical formula}[P]⊂X. It follows that (i) P is consistent and (ii) {a mathematical formula}X∖[P] is nonempty and contains literals that are unassigned by {a mathematical formula}[P]. By (i), rules Fail and Backtrack are not applicable. By (ii), rule Decide is applicable and hence rule Enumerate is not applicable. By {a mathematical formula}P′ we denote the successor state for P on p. Let us assume that {a mathematical formula}P′ is generated by the Unit Propagate rule. Then, {a mathematical formula}P′=Pl and since P is consistent with X and X is a model of S, l is consistent with X and so, {a mathematical formula}l∈X. This contradicts the fact that P is the longest prefix of any state on p such that {a mathematical formula}[P]⊆X. Thus, {a mathematical formula}P′ is obtained from P by the Decide rule and so, {a mathematical formula}P′=PlΔ. Since P is the longest prefix of any state on p such that {a mathematical formula}[P]⊆X, {a mathematical formula}l∉X. The path p can only terminate by entering ⊥ from a state with no decision literals by an application of either Enumerate or Fail rule. Let {a mathematical formula}M′ be the first state on p after M that does not contain {a mathematical formula}lΔ. By Lemma 19 and a simple inductive argument, {a mathematical formula}M′=Pl‾. We recall that {a mathematical formula}l∉X. Thus, {a mathematical formula}l‾∈X and {a mathematical formula}[Pl‾]⊆X, a contradiction.From Lemma 20 it immediately follows that we will not encounter two states encoding the same model on any path in {a mathematical formula}ameS.  □
     </paragraph>
     <paragraph label="Proof">
      Every program Π is input-equivalent to the module{a mathematical formula}UPUF′(Π).By definition, X is an input answer set of Π if and only if X is an answer set of {a mathematical formula}Π∪(X∖Head(Π)). By Proposition 5, X is an answer set of {a mathematical formula}Π∪(X∖Head(Π)) if and only if X is a model of {a mathematical formula}UPUF(Π∪(X∖Head(Π))). Thus, to complete the proof it suffices to show that X is a model of {a mathematical formula}UPUF′(Π) if and only if X is a model of {a mathematical formula}UPUF(Π∪(X∖Head(Π))).Let us assume that X is a model of {a mathematical formula}UPUF(Π∪(X∖Head(Π))). Let {a mathematical formula}(M,l) be an inference of {a mathematical formula}UPUF′(Π) such that M is consistent with X. To prove that X is a model of {a mathematical formula}UPUF′(Π) we need to show that l is consistent with X. If {a mathematical formula}(M,l) is implied by the rule Unit Propagate then, clearly, {a mathematical formula}(M,l) is also an inference of {a mathematical formula}UPUF(Π∪(X∖Head(Π))). Since X is a model of that module and M is consistent with X, l is consistent with X.Thus, let us assume that {a mathematical formula}(M,l) is implied by the rule {a mathematical formula}Unfounded′. It follows that {a mathematical formula}l=¬a and that for some set U of atoms, U is unfounded on M w.r.t. Π, {a mathematical formula}a∈U, and for every {a mathematical formula}b∈U, {a mathematical formula}b∈Head(Π) or {a mathematical formula}¬b∈M. Let us assume that {a mathematical formula}a∈X. Since M is consistent with X and X is a model of {a mathematical formula}UPUF(Π∪(X∖Head(Π))), {a mathematical formula}(M,¬a) is not an inference of {a mathematical formula}UPUF(Π∪(X∖Head(Π))). In particular, it follows that U is not unfounded on M w.r.t. {a mathematical formula}Π∪(X∖Head(Π)). Since U is unfounded on M w.r.t. Π, we obtain that {a mathematical formula}U∩(X∖Head(Π))≠∅. Let {a mathematical formula}b∈U∩(X∖Head(Π)). Then {a mathematical formula}b∈U, {a mathematical formula}b∈X and {a mathematical formula}b∉Head(Π). By the properties of U, {a mathematical formula}¬b∈M. Since M is consistent with X, {a mathematical formula}b∉X, a contradiction. Thus, {a mathematical formula}a∉X and so, ¬a (that is, l) is consistent with X.Conversely, let us assume that X is a model of {a mathematical formula}UPUF′(Π) and let {a mathematical formula}(M,l) be an inference of {a mathematical formula}UPUF(Π∪(X∖Head(Π))) such that M is consistent with X. We will show that l is consistent with X. This property will imply that X is a model of {a mathematical formula}UPUF(Π∪(X∖Head(Π))), thus completing the argument.Case 1. The inference {a mathematical formula}(M,l) is determined by the rule Unit Propagate applied to a clause from {a mathematical formula}Πcl. It follows that {a mathematical formula}(M,l) is also an inference of the module {a mathematical formula}UPUF′(Π). Since X is a model of {a mathematical formula}UPUF′(Π) and M is consistent with X, l is consistent with M.Case 2. The inference {a mathematical formula}(M,l) is determined by the rule Unit Propagate applied to a single-atom clause a, where {a mathematical formula}a∈X∖Head(Π). It follows that {a mathematical formula}l=a. Since {a mathematical formula}a∈X∖Head(Π), then a (that is, l) is consistent with X.Case 3. The inference {a mathematical formula}(M,l) is determined by the rule Unfounded, that is, it is of the form {a mathematical formula}(M,¬a), where {a mathematical formula}a∈σΠ, a is unassigned by M, and a belongs to some set U of atoms that is unfounded on M w.r.t. {a mathematical formula}Π∪(X∖Head(Π)). It is clear that {a mathematical formula}U∩(X∖Head(Π))=∅. In particular, U is unfounded on M also w.r.t. Π.Let us define {a mathematical formula}M′=M∪{¬b:b∈σΠ∖X,b≠a}. First, it is evident that a is unassigned by {a mathematical formula}M′. Second, {a mathematical formula}M′ is consistent with X and so, {a mathematical formula}M′ is consistent. Finally, U is unfounded on {a mathematical formula}M′ w.r.t. Π (since {a mathematical formula}M⊆M′). Let {a mathematical formula}b∈U. If {a mathematical formula}b∉Head(Π), then {a mathematical formula}b∉X (otherwise, we would have {a mathematical formula}b∈U∩(X∖Head(Π))). Thus, {a mathematical formula}¬b∈M′. Since a is unassigned in {a mathematical formula}M′{a mathematical formula}(M′,¬a) is an inference of {a mathematical formula}UPUF′(Π) implied by the rule {a mathematical formula}Unfounded′ (with U as an unfounded set underlying it). Since X is a model of {a mathematical formula}UPUF′(Π) and {a mathematical formula}M′ is consistent with X, ¬a (that is, l) is consistent with X.  □
     </paragraph>
     <paragraph label="Proof">
      Every modular program{a mathematical formula}{Π1,…,Πn}is equivalent to the abstract modular system{a mathematical formula}{UPUF′(Π1),…,UPUF′(Πn)}.A set X of atoms is a model of a modular program {a mathematical formula}{Π1,…,Πn} if and only if X is an input answer set of every {a mathematical formula}Πi, {a mathematical formula}1≤i≤n. Similarly, X is a model of the abstract modular system {a mathematical formula}{UPUF′(Π1),…,UPUF′(Πn)} if and only if X is a model of every abstract module {a mathematical formula}UPUF′(Πi), {a mathematical formula}1≤i≤n. Thus, the result follows from Proposition 12.  □
     </paragraph>
     <paragraph label="Proposition 14">
      Every SMT program{a mathematical formula}P=〈T,λ1,…,λn〉is equivalent to any of the following abstract modular systems (over the vocabulary{a mathematical formula}σT)
     </paragraph>
     <list>
      <list-item>
       {a mathematical formula}{Ent(T),Ent(λ1),…,Ent(λn)},
      </list-item>
      <list-item>
       {a mathematical formula}{UP(T),Ent(λ1),…,Ent(λn)},
      </list-item>
      <list-item>
       {a mathematical formula}{Ent(T),Min(λ1),…,Min(λn)},
      </list-item>
      <list-item>
       {a mathematical formula}{UP(T),Min(λ1),…,Min(λn)}.
      </list-item>
     </list>
     <paragraph label="Proof">
      Statement 1. Let M be a consistent and complete set of literals over {a mathematical formula}σT such that M is a model of P. By the definition of a model of an SMT program, {a mathematical formula}M+ is a model of T and, for every i, {a mathematical formula}1≤i≤n, M is a {a mathematical formula}λi-model. By Proposition 4, the former implies that {a mathematical formula}M+ is a model of {a mathematical formula}Ent(T). We will now use the latter to show that for every i, {a mathematical formula}1≤i≤n, {a mathematical formula}M+ is a model of {a mathematical formula}Ent(λi). To this end, let us consider an inference {a mathematical formula}(L,l)∈Ent(λi) such that L is consistent with {a mathematical formula}M+. We need to show that l is consistent with {a mathematical formula}M+. Since L is consistent with {a mathematical formula}M+, {a mathematical formula}L+⊆M+ and {a mathematical formula}L−∩M+=∅. By the assumption that both M and L are sets of literals over {a mathematical formula}σT, we obtain {a mathematical formula}L⊆M. From the construction of {a mathematical formula}Ent(λi) it follows that {a mathematical formula}λ[L]⊨l. Since M is consistent and complete, and is also a {a mathematical formula}λi-model such that {a mathematical formula}L⊆M, {a mathematical formula}l∈M. Consequently, l is consistent with {a mathematical formula}M+.Conversely, let M be a consistent and complete set of literals over {a mathematical formula}σT such that {a mathematical formula}M+ is a model of {a mathematical formula}{Ent(T),Ent(λ1),…,Ent(λn)}. By the definition of a model of an AMS, {a mathematical formula}M+ is a model of {a mathematical formula}Ent(T) and, for every i, {a mathematical formula}1≤i≤n, a model of {a mathematical formula}Ent(λi). By Proposition 4, {a mathematical formula}M+ is a model of T. It remains to show that for every i, {a mathematical formula}1≤i≤n, M is a {a mathematical formula}λi-model. Let us fix an arbitrary i, {a mathematical formula}1≤i≤n, and proceed by contradiction. That is, let us assume that M is not a {a mathematical formula}λi-model. Since M is a consistent and complete set of literals over {a mathematical formula}σT, for every literal {a mathematical formula}l∈σT, {a mathematical formula}λi[M]⊨l. Let us consider any literal l over {a mathematical formula}σT such that {a mathematical formula}l∉M (since M is consistent, such literals exist). From the definition of {a mathematical formula}Ent(λi) it follows that {a mathematical formula}(M,l)∈Ent(λi). Since M is consistent with {a mathematical formula}M+ and {a mathematical formula}M+ is a model of {a mathematical formula}Ent(λi) it follows that l is consistent with {a mathematical formula}M+. By the completeness of M, {a mathematical formula}l∈M, a contradiction.Statement 2. The proof follows that of Statement 1. The only difference is that we now use the module {a mathematical formula}UP(T) as an equivalent abstract inference module representation of T (cf. Proposition 4).Statement 3. Let M be a consistent and complete set of literals over {a mathematical formula}σT such that M is a model of P. We reason as before and obtain that {a mathematical formula}M+ is a model of T. In the proof of Statement 1, we showed that {a mathematical formula}M+ is a model of {a mathematical formula}Ent(λi). Since {a mathematical formula}Min(λi)⊆Ent(λi), {a mathematical formula}M+ is a model of {a mathematical formula}Min(λi).The converse implication can be proved exactly as in Statement 1, as the only elements of {a mathematical formula}Ent(λi) we used in the reasoning also belong to {a mathematical formula}Min(λi).Statement 4. The proof follows the lines of the argument of Statement 3 with the same proviso that we used in Statement 2.  □
     </paragraph>
     <paragraph label="Proof">
      Every abstract modular inference system{a mathematical formula}Ais equivalent to the abstract inference module{a mathematical formula}A∪.By definition, X is a model of {a mathematical formula}A={S1,…,Sn} if and only if X is a model of every module {a mathematical formula}Si, {a mathematical formula}1≤i≤n. By Proposition 3, that latter holds if and only if X is a model of the module {a mathematical formula}A∪.  □
     </paragraph>
     <paragraph label="Theorem 16">
      For every AMS{a mathematical formula}A,
     </paragraph>
     <list>
      <list-item>
       the graph{a mathematical formula}amsAis finite and acyclic,
      </list-item>
      <list-item>
       for any terminal state M of{a mathematical formula}amsAother than ⊥,{a mathematical formula}[M]+is a model of{a mathematical formula}A,
      </list-item>
      <list-item>
       the state ⊥ is reachable from ∅ in{a mathematical formula}amsAif and only if{a mathematical formula}Ais unsatisfiable.
      </list-item>
     </list>
     <paragraph label="Proof">
      By definition, {a mathematical formula}amsA=amA∪. By Theorem 6(a), {a mathematical formula}amA∪ is finite and acyclic. Thus, the graph {a mathematical formula}amsA is finite and acyclic, too. Next, by Theorem 6(b), any terminal state of {a mathematical formula}amA∪ other than ⊥ is a model of {a mathematical formula}A∪. Thus, by Theorem 15, each such state is a model of {a mathematical formula}amsA. Part (c) follows by a similar argument.  □
     </paragraph>
     <paragraph label="Theorem 17">
      For every AMS{a mathematical formula}A,
     </paragraph>
     <list>
      <list-item>
       the graph{a mathematical formula}amslAis finite and acyclic,
      </list-item>
      <list-item>
       for any semi-terminal state{a mathematical formula}M‖Gof{a mathematical formula}amslAreachable from{a mathematical formula}∅‖∅,…,∅,{a mathematical formula}[M]+is a model of{a mathematical formula}A,
      </list-item>
      <list-item>
       state ⊥ is reachable from{a mathematical formula}∅‖∅,…,∅in{a mathematical formula}amslAif and only if{a mathematical formula}Ahas no models.
      </list-item>
     </list>
     <paragraph label="Proof (Sketch)">
      (a) The set of augmented states is obviously finite as augmented states are defined over a finite vocabulary. Thus, the graph {a mathematical formula}amslA is finite. Let us assume that {a mathematical formula}amslA contains a cycle, say C. Since transition rules either keep the second component of a state the same or extend it, C is of the form {a mathematical formula}M0‖G,M1‖G,…,Mp‖G, where {a mathematical formula}G is a sequence of sets of inferences, and each {a mathematical formula}Mi is a state over {a mathematical formula}σA. Let {a mathematical formula}G=⋃G. One can show that {a mathematical formula}M0,M1,…,Mp is a cycle in {a mathematical formula}amsAG, a contradiction with Theorem 16(a).(b) Let us assume that {a mathematical formula}M‖G is reachable from {a mathematical formula}∅‖∅,…,∅. It follows that {a mathematical formula}G=⋃G is {a mathematical formula}A-safe. Using this observation, one can show that M is reachable from ∅ in {a mathematical formula}amsAG. Moreover, since {a mathematical formula}M‖G is a semi-terminal state in {a mathematical formula}amslA, M is a terminal state in {a mathematical formula}amsAG. By Theorem 16(b), {a mathematical formula}[M]+ is a model of {a mathematical formula}AG. Since G is {a mathematical formula}A-safe, {a mathematical formula}AG and {a mathematical formula}A are equivalent and so, {a mathematical formula}[M]+ is a model of {a mathematical formula}A.(c) Let us first assume that ⊥ is reachable from {a mathematical formula}∅‖∅,…,∅ in {a mathematical formula}amslA. Let {a mathematical formula}M‖G be the direct predecessor of ⊥ on one of those reachability paths. It follows that M is inconsistent and contains no decision literals. Reasoning as before, we can show that M is reachable from ∅ in {a mathematical formula}amsAG (where {a mathematical formula}G=⋃G). Since M is inconsistent and contains no decision literals, ⊥ is reachable from ∅ in {a mathematical formula}amsAG. By Theorem 16(c), {a mathematical formula}AG is not satisfiable. Since G is {a mathematical formula}A-safe, {a mathematical formula}AG and {a mathematical formula}A are equivalent. Consequently, {a mathematical formula}A is unsatisfiable (has no models).Next, let us assume that ⊥ is not reachable from {a mathematical formula}∅‖∅,…,∅ in {a mathematical formula}amslA. Then ⊥ is not reachable from ∅ in {a mathematical formula}amsA. By Theorem 16(c), {a mathematical formula}A has models.  □
     </paragraph>
    </section>
   </appendices>
  </root>
 </body>
</html>