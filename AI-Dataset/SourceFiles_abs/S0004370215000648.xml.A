<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Structured learning modulo theories.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Research in machine learning has progressively widened its scope, from simple scalar classification and regression tasks to more complex problems involving multiple related variables. Methods developed in the related fields of statistical relational learning (SRL) [1] and structured-output learning [2] allow to perform learning, reason and inferences about relational entities characterized by both hard and soft constraints. Most methods rely on some form of (finite) First-Order Logic (FOL) to encode the learning problem, and define the constraints as weighted logical formulae. One issue with these approaches is that First-Order Logic is not suited for efficient reasoning over hybrid domains, characterized by both continuous and discrete variables. The Booleanization of an n-bit integer variable requires {a mathematical formula}2n distinct Boolean states, making naive translation impractical; for rational variables the situation is even worse. In addition, standard FOL automated reasoning techniques offer no mechanism to deal efficiently with operators among numerical variables, like comparisons (e.g. “less-than”, “equal-to”) and arithmetical operations (e.g. summation), limiting the range of realistically applicable constraints to those based solely on logical connectives. On the other hand, many real-world domains are inherently hybrid and require to reason over inter-related continuous and discrete variables. This is especially true in constructive machine learning tasks, where the focus is on the de-novo design of objects with certain characteristics to be learned from examples (e.g. a recipe for a dish, with ingredients, proportions, etc.).
     </paragraph>
     <paragraph>
      There is relatively little previous work on hybrid SRL methods. A number of approaches [3], [4], [5], [6] focused on the feature representation perspective, in order to extend statistical relational learning algorithms to deal with continuous features as inputs. On the other hand, performing inference over joint continuous–discrete relational domains is still a challenge. The few existing attempts [7], [8], [9], [10], [11], [12] aim at extending statistical relational learning methods to the hybrid domain. All these approaches focus on modeling the probabilistic relationships between variables. While this allows to compute marginal probabilities in addition to most probable configurations, it imposes strong limitations on the type of constraints they can handle. Inference is typically run by approximate methods, based on variational approximations or sampling strategies. Exact inference, support for hard numeric (in addition to Boolean) constraints and combination of diverse theories, like linear algebra over rationals and integers, are out of the scope of these approaches. Hybrid Markov Logic networks [8] and Church [7] are the two formalisms which are closer to the scope of this paper. Hybrid Markov Logic networks [8] extend Markov Logic by including continuous variables, and allow to embed numerical comparison operators (namely ≠, ≥ and ≤) into the constraints by defining an ad hoc translation of said operators to a continuous form amenable to numerical optimization. Inference relies on a stochastic local search procedure that interleaves calls to a MAX-SAT solver and to a numerical optimization procedure. This inference procedure is incapable of dealing with hard numeric constraints because of the lack of feedback from the continuous optimizer to the satisfiability module. Church [7] is a very expressive probabilistic programming language that can potentially represent arbitrary constraints on both continuous and discrete variables. Its focus is on modeling the generative process underlying the program, and inference is based on sampling techniques. This makes inference involving continuous optimization subtasks and hard constraints prohibitively expensive, as will be discussed in the experimental evaluation.
     </paragraph>
     <paragraph>
      In order to overcome the limitations of existing approaches, we focused on the most recent advances in automated reasoning over hybrid domains. Researchers in automated reasoning and formal verification have developed logical languages and reasoning tools that allow for natively reasoning over mixtures of Boolean and numerical variables (or even more complex structures). These languages are grouped under the umbrella term of Satisfiability Modulo Theories (SMT) [13]. Each such language corresponds to a decidable fragment of First-Order Logic augmented with an additional background theory {a mathematical formula}T. There are many such background theories, including those of linear arithmetic over the rationals {a mathematical formula}LRA or over the integers {a mathematical formula}LIA, among others [13]. In SMT, a formula can contain Boolean variables (i.e. 0-ary logical predicates) and connectives, mixed with symbols defined by the theory {a mathematical formula}T, e.g. rational variables and arithmetical operators. For instance, the SMT({a mathematical formula}LRA) syntax allows to write formulas such as:{a mathematical formula} where the variables are Boolean ({a mathematical formula}touching_i_j) or rational ({a mathematical formula}xi,xj,dxi,dxj).{sup:1} More specifically, SMT is a decision problem, which consists in finding an assignment to the variables of a quantifier-free formula, both Boolean and theory-specific ones, that makes the formula true, and it can be seen as an extension of SAT.
     </paragraph>
     <paragraph>
      Recently, researchers have leveraged SMT from decision to optimization. In particular, MAX-SAT Modulo Theories (MAX-SMT) [14], [15], [16] generalizes MAX-SAT [17] to SMT formulae, and consists in finding a theory-consistent truth assignment to the atoms of the input SMT formula φ which maximizes the total weight of the satisfied clauses of φ. More generally, Optimization Modulo Theories (OMT) [14], [18], [19], [20], [21], [22] consists in finding a model for φ which minimizes the value of some (arithmetical) term, and strictly subsumes MAX-SMT [19]. Most important for the scope of this paper is that there are high-quality OMT solvers which, at least for the {a mathematical formula}LRA theory, can handle problems with thousands of hybrid variables.
     </paragraph>
     <paragraph>
      In this paper we propose Learning Modulo Theories (LMT), a class of novel hybrid statistical relational learning methods. The main idea is to combine a solver able to deal with Boolean and rational variables with a structured output learning method. In particular, we rely on structured-output Support Vector Machines (SVM) [23], [24], a very flexible max-margin structured prediction method. Structured-output SVMs are a generalization of binary SVM classifiers to predict structured outputs, like sequences or trees. They generalize the max-margin principle by learning to separate correct from incorrect output structures with a large margin. Training structured-output SVMs requires a separation oracle for generating counter-examples and updating the parameters, while the prediction stage requires an inference oracle generating the highest scoring candidate structure for a certain input. In order to implement the two oracles, we leverage a state-of-the-art OMT solver. This combination enables LMT to perform learning and inference in mixed Boolean-numerical domains. Thanks to the efficiency of the underlying OMT solver, and of the cutting plane algorithm we employ for weight learning, LMT is capable of addressing constructive learning problems which cannot be efficiently tackled with existing methods. Furthermore, LMT is generic, and can in principle be applied to any of the existing background theories. This paper builds on a previous work in which MAX-SMT was used for interactive preference elicitation [25]. Here we focus on generating novel structures from a few prototypical examples, and cast the problem as supervised structured-output learning. Furthermore, we increase the expressive power from MAX-SMT to full OMT. This allows to model much richer cost functions, for instance by penalizing an unsatisfied constraint by a cost proportional to the distance from satisfaction.
     </paragraph>
     <paragraph>
      The rest of the paper is organized as follows. In Section 2 we review the relevant related work, with an in-depth discussion on all hybrid approaches and their relationships with our proposed framework. Section 3 provides an introduction to SMT and OMT technology. Section 4 reviews structured-output SVMs and shows how to cast LMT in this learning framework. Section 5 reports an experimental evaluation showing the potential of the approach. Finally, conclusions are drawn in Section 6.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Related work
     </section-title>
     <paragraph>
      There is a body of work concerning integration of relational and numerical data from a feature representation perspective, in order to effectively incorporate numerical features into statistical relational learning models. Lippi and Frasconi [3] incorporate neural networks as feature generators within Markov Logic Networks, where neural networks act as numerical functions complementing the Boolean formulae of standard MLNs. Semantic Based Regularization [6] is a framework for integrating logic constraints within kernel machines, by turning them into real-valued constraints using appropriate transformations (T-norms). The resulting optimization problem is no longer convex in general, and they suggest a stepwise approach adding constraints in an incremental fashion, in order to solve progressively more complex problems. In Probabilistic Soft Logic [4], arbitrarily complex similarity measures between objects are combined with logic constraints, again using T-norms for the continuous relaxation of Boolean operators. In Gaussian Logic [5], numeric variables are modeled with multivariate Gaussian distributions. Their parameters are tied according to logic formulae defined over these variables, and combined with weighted first order formulae modeling the discrete part of the domain (as in standard MLNs). All these approaches aim at extending statistical relational learning algorithms to deal with continuous features as inputs. On the other hand, our framework aims at allowing learning and inference over hybrid continuous–discrete domains, where continuous and discrete variables are the output of the inference process.
     </paragraph>
     <paragraph>
      While a number of efficient lifted-inference algorithms have been developed for Relational Continuous Models [26], [27], [28], performing inference over joint continuous–discrete relational domains is still a challenge. The few existing attempts aim at extending statistical relational learning methods to the hybrid domain.
     </paragraph>
     <paragraph>
      Hybrid Probabilistic Relational Models [9] extend Probabilistic Relational Models (PRM) to deal with hybrid domains by specifying templates for hybrid distributions as standard PRM specify templates for discrete distributions. A template instantiation over a database defines a Hybrid Bayesian Network [29], [30]. Inference in Hybrid BN is known to be hard, and restrictions are typically imposed on the allowed relational structure (e.g. in conditional Gaussian models, discrete nodes cannot have continuous parents). On the other hand, LMT can accommodate arbitrary combinations of predicates from the theories for which a solver is available. These currently include linear arithmetic over both rationals and integers as well as a number of other theories like strings, arrays and bit-vectors.
     </paragraph>
     <paragraph>
      Relational Hybrid Models [11] (RHM) extend Relational Continuous Models to represent combinations of discrete and continuous distributions. The authors present a family of lifted variational algorithms for performing efficient inference, showing substantial improvements over their ground counterparts. As for most hybrid SRL approaches which will be discussed further on, the authors focus on efficiently computing probabilities rather than efficiently finding optimal configurations. Exact inference, hard constraints and theories like algebra over integers, which are naturally handled by our LMT framework, are all out of the scope of these approaches. Nonetheless, lifted inference is a powerful strategy to scale up inference and equipping OMT and SMT tools with lifting capabilities is a promising direction for future improvements.
     </paragraph>
     <paragraph>
      The PRISM [31] system provides primitives for Gaussian distributions. However, inference is based on proof enumeration, which makes support for continuous variables very limited. Islam et al. [12] recently extended PRISM to perform inference over continuous random variables by a symbolic procedure which avoids the enumeration of individual proofs. The extension allows to encode models like Hybrid Bayesian Networks and Kalman Filters. Being built on top of the PRISM system, the approach assumes the exclusive explanation and independence property: no two different proofs for the same goal can be true simultaneously, and all random processes within a proof are independent (some research directions for lifting these restrictions have been suggested [32]). LMT has no assumptions on the relationships between proofs.
     </paragraph>
     <paragraph>
      Hybrid Markov Logic Networks [8] extend Markov Logic Networks to deal with numeric variables. A Hybrid Markov Logic Network consists of both First Order Logic formulae and numeric terms. Most probable explanation (MPE) inference is performed by a hybrid version of MAXWalkSAT, where optimization of numeric variables is performed by a general-purpose global optimization algorithm (L-BFGS). This approach is extremely flexible and allows to encode arbitrary numeric constraints, like soft equalities and inequalities with quadratic or exponential costs. A major drawback of this flexibility is the computational cost, as each single inference step on continuous variables requires to solve a global optimization problem, making the approach infeasible for addressing medium to large scale problems. Furthermore, this inference procedure is incapable of dealing with hard constraints involving numeric variables, as can be found for instance in layout problems (see e.g. the constraints on touching blocks or connected segments in the experimental evaluation). This is due to the lack of feedback from the continuous optimizer to the satisfiability module, which should inform about conflicting constraints and help guiding the search towards a more promising portion of the search space. Conversely, the OMT technology underlying LMT is built on top of SMT solvers and is hence specifically designed to tightly integrate theory-specific and SAT solvers [14], [15], [18], [19], [20]. Note that the tight interaction between theory-specific and modern CDCL SAT solvers, plus many techniques developed for maximizing their synergy, are widely recognized as one key reason of the success of SMT solvers [13]. Note also that previous attempts to substitute standard SAT solvers with WalkSAT inside an SMT solver have failed, producing dramatic worsening of performance [33].
     </paragraph>
     <paragraph>
      Hybrid ProbLog [10] is an extension of the probabilistic logic language ProbLog [34] to deal with continuous variables. A ProbLog program consists of a set of probabilistic Boolean facts, and a set of deterministic first order logic formulae representing the background knowledge. Hybrid ProbLog introduces a set of probabilistic continuous facts, containing both discrete and continuous variables. Each continuous variable is associated with a probability density function. The authors show how to compute the probability of success of a query, by partitioning the continuous space into admissible intervals, within which values are interchangeable with respect to the provability of the query. The drawback of this approach is that in order to make this computation feasible, severe limitations have to be imposed on the use of continuous variables. No algebraic operations or comparisons are allowed between continuous variables, which should remain uncoupled. Some of these limitations have been overcome in a recent approach [35] which performs inference by forward (i.e. from facts to rules) rather than backward reasoning, which is the typical inference process in (probabilistic) logic programming engines (SLD-resolution and its probabilistic extensions). Forward reasoning is more amenable to be adapted to sampling strategies for performing approximate inference and dealing with continuous variables. On the other hand, inference by sampling makes it prohibitively expensive to reason with hard continuous constraints.
     </paragraph>
     <paragraph>
      Church [7] is a very expressive probabilistic programming language that can easily accommodate hybrid discrete–continuous distributions and arbitrary constraints. In order to deal with the resulting complexity, inference is again performed by sampling techniques, which result in the same aforementioned limitations. Indeed, our experimental evaluation shows that Church is incapable of solving in reasonable time the simple task of generating a pair of blocks conditioned on the fact that they touch somewhere.{sup:2}
     </paragraph>
     <paragraph>
      An advantage of these probabilistic inference approaches is that they allow to return marginal probabilities in addition to most probable explanations. This is actually the main focus of these approaches, and the reason why they are less suitable for solving the latter problem when the search space becomes strongly disconnected. As with most structured-output approaches over which it builds, LMT is currently limited to the task of finding an optimal configuration, which in a probabilistic setting corresponds to generating the most probable explanation. We are planning to extend it to also perform probability computation, as discussed in the conclusions of the paper.
     </paragraph>
    </section>
    <section label="3">
     <section-title>
      From satisfiability to optimization modulo theories
     </section-title>
     <paragraph>
      Propositional satisfiability (SAT), is the problem of deciding whether a logical formula over Boolean variables and logical connectives can be satisfied by some truth value assignment of the Boolean variables.{sup:3} In the last two decades we have witnessed an impressive advance in the efficiency of SAT solvers, which nowadays can handle industrially derived formulae in the order of up to {a mathematical formula}106–107 variables. Modern SAT solvers are based on the conflict-driven clause-learning (CDCL) schema [37], and adopt a variety of very-efficient search techniques [38].
     </paragraph>
     <paragraph>
      In the contexts of automated reasoning (AR) and formal verification (FV), important decision problems are effectively encoded into and solved as Satisfiability Modulo Theories (SMT) problems [39]. SMT is the problem of deciding the satisfiability of a (typically quantifier-free) first-order formula with respect to some decidable background theory{a mathematical formula}T, which can also be a combination of theories {a mathematical formula}⋃iTi. Theories of practical interest are, e.g., those of equality and uninterpreted functions ({a mathematical formula}EUF), of linear arithmetic over the rationals ({a mathematical formula}LRA) or over the integers ({a mathematical formula}LIA), of non-linear arithmetic over the reals ({a mathematical formula}NLA), of arrays ({a mathematical formula}AR), of bit-vectors ({a mathematical formula}BV), and their combinations.
     </paragraph>
     <paragraph>
      In the last decade efficient SMT solvers have been developed following the so-called lazy approach, that combines the power of modern CDCL SAT solvers with the expressivity of dedicated decision procedures ({a mathematical formula}T-solvers) for several first-order theories of interest. Modern lazy SMT solvers—like e.g. CVC4,{sup:4}MathSAT5,{sup:5}Yices,{sup:6}Z3{sup:7}—combine a variety of solving techniques coming from very heterogeneous domains. We refer the reader to [40], [13] for an overview on lazy SMT solving, and to the URLs of the above solvers for a description of their supported theories and functionalities.
     </paragraph>
     <paragraph>
      More recently, SMT has also been leveraged from decision to optimization. Optimization Modulo Theories (OMT) [14], [18], [19], [20], is the problem of finding a model for an SMT formula φ which minimizes the value of some arithmetical cost function. References [18], [19], [20] present some general OMT procedure adding to SMT the capability of finding models minimizing cost functions in {a mathematical formula}LRA. This problem is denoted OMT({a mathematical formula}LRA) if only the {a mathematical formula}LRA theory is involved in the SMT formula, OMT({a mathematical formula}LRA∪T) if some other theories are involved. Such procedures combine standard lazy SMT-solving with LP minimization techniques. OMT({a mathematical formula}LRA∪T) procedures have been implemented into the OptiMathSAT tool,{sup:8} a sub-branch of MathSAT5.
     </paragraph>
     <paragraph label="Example 3.1">
      Consider the following toy {a mathematical formula}LRA-formula φ:{a mathematical formula} and the OMT({a mathematical formula}LRA) problem of finding the model of φ (if any) which makes the value of cost minimum. In fact, depending on the truth value of A, there are two possible alternative sets of constraints to minimize:{a mathematical formula} whose minimum-cost models are, respectively:{a mathematical formula} from which we can conclude that the latter is a minimum-cost model for φ.
     </paragraph>
     <paragraph>
      Overall, for the scope of this paper, it is important to highlight the fact that OMT solvers are available which, thanks to the underlying SAT and SMT technologies, can handle problems with a large number of hybrid variables (in the order of thousands, at least for the {a mathematical formula}LRA theory).
     </paragraph>
     <paragraph>
      To this extent, we notice that the underlying theories and {a mathematical formula}T-solvers provide the meaning and the reasoning capabilities for specific predicates and function symbols (e.g., the {a mathematical formula}LRA-specific symbols “≥” and “+”, or the {a mathematical formula}AR-specific symbols “read(...)”, “write(...)”) that would otherwise be very difficult to describe, or to reason over, with logic-based automated reasoning tools—e.g., traditional first-order theorem provers cannot handle arithmetical reasoning efficiently—or with arithmetical ones—e.g., DLP, ILP, MILP, LGDP tools [41], [42], [43] or CLP tools [44], [45], [46] do not handle symbolic theory-reasoning on theories like {a mathematical formula}EUF or {a mathematical formula}AR. Also, the underlying CDCL SAT solver allows SMT solvers to handle a large amount of Boolean reasoning very efficiently, which is typically out of the reach of both first-order theorem provers and arithmetical tools.
     </paragraph>
     <paragraph>
      These facts motivate our choice of using SMT/OMT technology, and hence the tool OptiMathSAT, as workhorse engines for reasoning in hybrid domains. Hereafter in the paper we consider only plain OMT({a mathematical formula}LRA).
     </paragraph>
     <paragraph>
      Another prospective advantage of SMT technology is that modern SMT solvers (e.g., MathSAT5, Z3, …) have an incremental interface, which allows for solving sequences of “similar” formulae without restarting the search from scratch at each new formula, and instead reusing “common” parts of the search performed for previous formulae (see, e.g., [47]). This drastically improves overall performance on sequences of similar formulae. An incremental extension of OptiMathSAT, fully exploiting that of MathSAT5, is currently available.
     </paragraph>
     <paragraph>
      Note that a current limitation of SMT solvers is that, unlike traditional theorem provers, they typically handle efficiently only quantifier-free formulae. Attempts at extending SMT to quantified formulae have been made in the literature [48], [49], [50], and a few SMT solvers (e.g., Z3) do provide some support for quantified formulae. However, the state of the art of these extensions is still far from being satisfactory. Nonetheless, the method we present in the paper can be easily adapted to deal with these types of extensions once they reach the required level of maturity.
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      Learning modulo theories using cutting planes
     </section-title>
     <section label="4.1">
      <section-title>
       An introductory example
      </section-title>
      <paragraph>
       In order to introduce the LMT framework, we start with a toy learning example. We are given a unit-length bounding box, {a mathematical formula}[0,1]×[0,1], that contains a given, fixed block (rectangle), as in Fig. 1(a). The block is identified by the four constants {a mathematical formula}(x1,y1,dx1,dy1), where {a mathematical formula}x1,y1 indicate the bottom-left corner of the rectangle, and {a mathematical formula}dx1, {a mathematical formula}dy1 its width and height, respectively. Now, suppose that we are assigned the task of fitting another block, identified by the variables {a mathematical formula}(x2,y2,dx2,dy2), in the same bounding box, so as to minimize the following cost function:{a mathematical formula} with the additional requirements that (i) the two blocks “touch” either from above, below, or sideways, and (ii) the two blocks do not overlap.
      </paragraph>
      <paragraph>
       It is easy to see that the weights {a mathematical formula}w1 and {a mathematical formula}w2 control the shape and location of the optimal solution. If both weights are positive, then the cost is minimized by any block of null size located along the perimeter of block 1. If both weights are negative and {a mathematical formula}w1≪w2, then the optimal block will be placed so as to occupy as much horizontal space as possible, while if {a mathematical formula}w1≫w2 it will prefer to occupy as much vertical space as possible, as in Fig. 1(b, c). If {a mathematical formula}w1 and {a mathematical formula}w2 are close, then the optimal solution depends on the relative amount of available vertical and horizontal space in the bounding box.
      </paragraph>
      <paragraph>
       This toy example illustrates two key points. First, the problem involves a mixture of numerical variables (coordinates, sizes of block 2) and Boolean variables, along with hard rules that control the feasible space of the optimization procedure (conditions (i) and (ii)), and costs—or soft rules—which control the shape of the optimization landscape. This is the kind of problem that can be solved in terms of Optimization Modulo Linear Arithmetic, OMT({a mathematical formula}LRA). Second, it is possible to estimate the weights {a mathematical formula}w1, {a mathematical formula}w2 from data in order to learn what kind of blocks are to be considered optimal. The goal of our learning procedure is precisely to find a good set of weights from examples. In the following we will describe how such a learning task can be framed within the structured output SVMs framework.
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Notation
      </section-title>
      <paragraph>
       We consider the problem of learning from a training set of n complex objects {a mathematical formula}{(Ii,Oi)}i=1n, where each object {a mathematical formula}(I,O) is represented as a set of Boolean and rational variables:{a mathematical formula} We indicate Boolean variables using predicates such as {a mathematical formula}touching(i,j), and write rational variables as lower-case letters, e.g. cost, distance, x, y. Please note that while we write Boolean variables using a First-Order syntax for readability, our method does require the grounding of all Boolean predicates prior to learning and inference. In the present formulation, we assume objects to be composed of two parts: I is the input (or observed) part, while O is the output (or query) part.{sup:9} The learning problem is defined by a set of m constraints{a mathematical formula}{φk}k=1m. Each constraint {a mathematical formula}φk is either a Boolean- or rational-valued function of the object {a mathematical formula}(I,O). For each Boolean-valued constraint {a mathematical formula}φk, we denote its indicator function as {a mathematical formula}1k(I,O), which evaluates to 1 if the constraint is satisfied and to −1 otherwise (the choice of −1 to represent falsity is customary in the max-margin literature). Similarly, we refer to the cost of a rational-valued constraint {a mathematical formula}φk as {a mathematical formula}ck(I,O)∈Q. The feature space representation of an object {a mathematical formula}(I,O) is given by the feature vector{a mathematical formula}ψ(I,O), which is a function of the constraints. Each soft constraint {a mathematical formula}φk has an associated finite weight {a mathematical formula}wk∈Q (to be learned from the data), while hard constraints have no associated weight. We denote the vector of learned weights as {a mathematical formula}w:=(w1,w2,…,wm), and its Euclidean norm as {a mathematical formula}‖w‖. Table 1 summarizes the notation used throughout the text.
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       A structural SVM approach to LMT
      </section-title>
      <paragraph>
       Structured-output SVMs [23] are a very flexible framework that generalizes max-margin methods to the prediction of complex outputs such as strings, trees and graphs. In this setting the association between inputs I and outputs O is controlled by a so-called compatibility function{a mathematical formula}f(I,O):=w⊤ψ(I,O) defined as a linear combination of the joint feature space representation {a mathematical formula}ψ(I,O) of the input–output pair. Inference amounts to finding the most compatible output {a mathematical formula}O⁎ for a given input I, which equates to solving the following optimization problem:{a mathematical formula} Performing inference on structured domains is non-trivial, since the maximization ranges over an exponential (and possibly unbounded) number of candidate outputs.
      </paragraph>
      <paragraph>
       Learning is formulated within the regularized empirical risk minimization framework. In order to learn the weights from a training set of n examples, one needs to define a non-negative loss function{a mathematical formula}Δ(I,O,O′) that, for any given observation I, quantifies the penalty incurred when predicting {a mathematical formula}O′ instead of the correct output O. Learning can be expressed as the problem of finding the weights w that minimize the per-instance error {a mathematical formula}ξi and the model complexity [23]:{a mathematical formula} Here the constraints require that the compatibility between any input {a mathematical formula}Ii and its corresponding correct output {a mathematical formula}Oi is always higher than that with all wrong outputs {a mathematical formula}O′ by a margin, with {a mathematical formula}ξi playing the role of per-instance violations. This formulation is called n-slack margin rescaling and it is the original and most accessible formulation of structured-output SVMs. See [51] for an extensive exposition of alternative formulations.
      </paragraph>
      <paragraph>
       Weight learning is a quadratic program, and can be solved very efficiently with a cutting-plane (CP) algorithm [23]. Since in Eq. (3) there is an exponential number of constraints, it is infeasible to naively account for all of them during learning. Based on the observations that the constraints obey a subsumption relation, the CP algorithm [51] sidesteps the issue by keeping a working set of active constraints {a mathematical formula}W: at each iteration, it augments the working set with the most violated constraint, and then solves the corresponding reduced quadratic program using a standard SVM solver. This procedure is guaranteed to find an ϵ-approximate solution to the QP in a polynomial number of iterations, independently of the cardinality of the output space and of the number of examples n[23]. The n-slack margin rescaling version of the CP algorithm can be found in Algorithm 1 (adapted from [51]). Please note that in our experiments we make use of the faster, but otherwise equivalent, 1-slack margin rescaling variant [51]. We report the n-slack margin rescaling version here for ease of exposition.
      </paragraph>
      <paragraph>
       The CP algorithm is generic, meaning that it can be adapted to any structured prediction problem as long as it is provided with: (i) a joint feature space representation ψ of input–output pairs (and consequently a compatibility function f); (ii) an oracle to perform inference, i.e. to solve Eq. (2); and (iii) an oracle to retrieve the most violated constraint of the QP, i.e. to solve the separation problem:{a mathematical formula} The two oracles are used as sub-routines during the optimization procedure. For a more detailed account, and in particular for the derivation of the separation oracle formulation, please refer to [23].
      </paragraph>
      <paragraph>
       One key aspect of the structured output SVMs is that efficient implementations of the two oracles are fundamental for the learning task to be tractable in practice. The idea behind Learning Modulo Theories is that, when a hybrid Boolean-numerical problem can be encoded in SMT, the two oracles can be implemented using an Optimization Modulo Theory solver. This is precisely what we propose in the present paper. In the following sections we show how to define a feature space for hybrid Boolean-numerical learning problems, and how to use OMT solvers to efficiently perform inference and separation.
      </paragraph>
     </section>
     <section label="4.4">
      <section-title>
       Learning modulo theories with OMT
      </section-title>
      <paragraph>
       Let us formalize the previous toy example in the language of LMT. In the following we give a step-by-step description of all the building blocks of an LMT problem: the background knowledge, the hard and soft constraints, the cost function, and the loss function.
      </paragraph>
      <section>
       <section>
        <section-title>
         Input, output, and background knowledge
        </section-title>
        <paragraph>
         Here the input I to the problem is the observed block {a mathematical formula}(x1,y1,dx1,dy1) while the output O is the generated block {a mathematical formula}(x2,y2,dx2,dy2). In order to encode the set of constraints {a mathematical formula}{φk} that underlie both the learning and the inference problems, it is convenient to first introduce a background knowledge of predicates expressing facts about the relative positioning of blocks. To this end we add a fresh predicate {a mathematical formula}left(i,j), that encodes the fact that “a generic block of index i touches a second block j from the left”, defined as follows:{a mathematical formula} Similarly, we add analogous predicates for the other directions: {a mathematical formula}right(i,j), {a mathematical formula}below(i,j), {a mathematical formula}over(i,j) (see Fig. 2 for the full definitions).
        </paragraph>
       </section>
       <section>
        <section-title>
         Hard constraints
        </section-title>
        <paragraph>
         The hard constraints represent the fact that the output O should be a valid block within the bounding box (all the constraints {a mathematical formula}φk are implicitly conjoined):{a mathematical formula} Then we require the output block O to “touch” the input block I:{a mathematical formula} Note that whenever this rule is satisfied, both conditions (i) and (ii) of the toy example hold, i.e. touching blocks never overlap.
        </paragraph>
       </section>
       <section>
        <section-title>
         Cost function
        </section-title>
        <paragraph>
         Finally, we encode the cost function {a mathematical formula}cost=w1dx2+w2dy2, completing the description of the optimization problem. In the following we will see that the definition of the cost function implicitly defines also the set of features, or equivalently the set of soft constraints, of the LMT problem.
        </paragraph>
       </section>
       <section>
        <section-title>
         Soft constraints and features
        </section-title>
        <paragraph>
         Now, suppose we were given a training set of instances analogous to those pictured in Fig. 1(c), i.e. where the supervision includes output blocks that preferentially fill as much vertical space as possible. The learning algorithm should be able to learn this preference by inferring appropriate weights. This kind of learning task can be cast within the structured SVM framework, by defining an appropriate joint feature space ψ and oracles for the inference and separation problems.
        </paragraph>
        <paragraph>
         Let us focus on the feature space first. Our definition is grounded on the concept of reward assigned to an object {a mathematical formula}(I,O) with respect to the set of formulae {a mathematical formula}{φk}k=1m. We construct the feature vector{a mathematical formula} by collating m per-formula rewards {a mathematical formula}ψk(I,O), where:{a mathematical formula} Here {a mathematical formula}1k is an indicator for the satisfaction of a Boolean constraint {a mathematical formula}φk, while {a mathematical formula}ck denotes the cost associated to real-valued constraints, please refer to Table 1 for more details. In other words, the feature representation of a complex object {a mathematical formula}(I,O) is the vector of all indicator/cost functions associated to the soft constraints. Returning to the toy example, where the cost function is{a mathematical formula} the feature space of an instance {a mathematical formula}(I,O) is simply {a mathematical formula}ψ(I,O)=(−dx2,−dy2)⊤, which reflects the size of the output block O. The negative sign here is due to interpreting the features as rewards (to be maximized), while the corresponding soft constraints can be seen as costs (to be minimized); see Eq. (5) where this relationship is made explicit.
        </paragraph>
        <paragraph>
         According to this definition both satisfied and unsatisfied rules contribute to the total reward, and two objects {a mathematical formula}(I,O), {a mathematical formula}(I′,O′) that satisfy/violate similar sets of constraints will be close in feature space. The compatibility function {a mathematical formula}f(I,O):=w⊤ψ(I,O) computes the (weighted) total reward assigned to {a mathematical formula}(I,O) with respect to the constraints. Using this definition, the maximization in the inference (Eq. (2)) can be seen as attempting to find the output O that maximizes the total reward with respect to the input I and the rules, or equivalently the one with minimum cost. Since ψ can be expressed in terms of Satisfiability Modulo Linear Arithmetic, the latter minimization problem can be readily cast as an OMT problem. Translating back to the example, maximizing the compatibility function f boils down to:{a mathematical formula} which is exactly the cost minimization problem in Eq. (1).
        </paragraph>
       </section>
       <section>
        <section-title>
         Loss function
        </section-title>
        <paragraph>
         The loss function determines the dissimilarity between output structures, which in our case contain a mixture of Boolean and rational variables. We observe that by picking a loss function expressible as an OMT({a mathematical formula}LRA) problem, we can readily use the same OMT solver used for inference to also solve the CP separation oracle (Eq. (4)). This can be achieved by selecting a loss function such as the following Hamming loss in feature space:{a mathematical formula} This loss function is piecewise-linear, and as such satisfies the desideratum.
        </paragraph>
        <paragraph>
         Since both the inference and separation oracles required by the CP algorithm can be encoded in OMT({a mathematical formula}LRA), we can apply an OMT solver to efficiently solve the learning task. In particular, our current implementation is based on a vanilla copy of {a mathematical formula}SVMstruct,{sup:10} which acts as a cutting-plane solver, whereas inference and separation are implemented with the OptiMathSAT OMT solver.
        </paragraph>
        <paragraph>
         To summarize, an LMT problem can be broken down into several components: a background knowledge, a set of soft and hard constraints, a cost function and a loss function. The background knowledge amounts to a set of SMT formulae and constants useful for encoding the problem constraints, which in turn determine the relation between inputs and outputs. The hard constraints define the space of candidate outputs, while the soft constraints correspond one-to-one to features. The overall cost function is a linear combination of the dissatisfaction/cost (or, equivalently, satisfaction/reward) associated to the individual soft constraints, and as such is controlled entirely by the choice of features. Finally, the loss function determines the dissimilarity between output structures. While in the present paper we focused on a Hamming loss in feature space, LMT can work with any loss function that can be encoded as an SMT formula.
        </paragraph>
       </section>
      </section>
     </section>
    </section>
    <section label="5">
     <section-title>
      Experimental evaluation
     </section-title>
     <paragraph>
      In the following we evaluate LMT on two novel design problems that stress the ability of LMT to deal with rather complex mixed Boolean-numerical problems.
     </paragraph>
     <section label="5.1">
      <section-title>
       Stairway to heaven
      </section-title>
      <paragraph>
       In this section we are interested in learning how to assemble different kinds of stairways from examples. For the purpose of this paper, a stairway is simply a collection of m blocks (rectangles) located within a two-dimensional, unit-sized bounding box {a mathematical formula}[0,1]×[0,1]. Clearly not all possible arrangements of blocks form a stairway; a stairway must satisfy the following conditions: (i) the first block touches either the top or the bottom corner of the left edge of the bounding box; (ii) the last block touches the opposite corner at the right edge of the bounding box; (iii) there are no gaps between consecutive blocks; (iv) consecutive blocks must actually form a step and, (v) no two blocks overlap. Note that the property of “being a stairway” is a collective property of the m blocks.
      </paragraph>
      <paragraph>
       More formally, each block {a mathematical formula}i=1,…,m consists of four rational variables: the origin {a mathematical formula}(xi,yi), which indicates the bottom-left corner of the block, a width {a mathematical formula}dxi and a height {a mathematical formula}dyi; the top-right corner of the block is {a mathematical formula}(xi+dxi,yi+dyi). A stairway is simply an assignment to all {a mathematical formula}4×m variables that satisfies the above conditions.
      </paragraph>
      <paragraph>
       Our definition does not impose any constraint on the orientation of stairways: it is perfectly legitimate to have left stairways that start at the top-left corner of the bounding box and reach the bottom-right corner, and right stairways that connect the bottom-left corner to the top-right one. For instance, a left 2-stairway can be defined with the following block assignment (see Fig. 3(a)):{a mathematical formula} Similarly, a right 2-stairway is obtained with the assignment (Fig. 3(b)):{a mathematical formula}
      </paragraph>
      <paragraph>
       We also note that the above conditions do not impose any explicit restriction on the width and height of individual blocks (as long as consecutive ones are in contact and there is no overlap). Consequently we allow for both ladder stairways, where the total amount of vertical and horizontal surface of the individual blocks is minimal, as in Fig. 3(a) and (b); and for pillar stairways, where either the vertical or horizontal block lengths are maximized, as in Fig. 3(c). There are of course an uncountable number of intermediate stairways that do not belong to either of the above categories.
      </paragraph>
      <paragraph>
       Inference amounts to generating a set of variable assignments to all blocks, so that none of conditions (i)–(v) is violated, and the cost of the soft rules is minimized.{sup:11} This can be easily encoded as an OMT({a mathematical formula}LRA) problem. As a first step, we define a background knowledge of useful predicates. We use four predicates to encode the fact that a block i may touch one of the four corners of the bounding box, namely {a mathematical formula}bottom_left(i), {a mathematical formula}bottom_right(i), {a mathematical formula}top_left(i), and {a mathematical formula}top_right(i), which can be written as, e.g.:{a mathematical formula} We also define predicates to describe the relative positions of two blocks i and j, such as {a mathematical formula}left(i,j):{a mathematical formula} encodes the fact that block i is touching block j from the left. Similarly, we also define {a mathematical formula}below(i,j) and {a mathematical formula}over(i,j). Finally, and most importantly, we combine the above predicates to define the concept of step, i.e. two blocks i and {a mathematical formula}i+1 that are both touching and positioned as to form a stair:{a mathematical formula} We define right_step({a mathematical formula}i,j) in the same manner. For a complete description of the background knowledge, see Table 2.
      </paragraph>
      <paragraph>
       The background knowledge allows to encode the property of being a left stairway as:{a mathematical formula} Analogously, any right stairway satisfies the following condition:{a mathematical formula} However, our inference procedure does not have access to this knowledge. We rather encode an appropriate set of soft rules (costs) which, along with the associated weights, should bias the optimization towards block assignments that form a stairway of the correct type.
      </paragraph>
      <paragraph>
       We include a few hard rules to constrain the space of admissible block assignments. We require that all blocks fall within the bounding box:{a mathematical formula}{a mathematical formula} We also require that blocks do not overlap:{a mathematical formula} Finally, we require (without loss of generality) blocks to be ordered from left to right, {a mathematical formula}∀ixi≤xi+1.
      </paragraph>
      <paragraph>
       Note that only condition (v) is modeled as a hard constraint. The others are implicitly part of the problem cost. Our cost model is based on the observation that it is possible to discriminate between the different stairway types using only four factors: minimum and maximum step size, and amount of horizontal and vertical material. These four factors are useful features in discriminating between the different stairway types without having to resort to quadratic terms, e.g. the areas of the individual blocks. For instance, in the cost we account for both the maximum step height of all left steps (a good stairway should not have too high steps):{a mathematical formula} and the minimum step width of all right steps (good stairways should have sufficiently large steps):{a mathematical formula} The value of these costs depends on whether a pair of blocks actually forms a left step, a right step, or no step at all. Note that these costs are multiplied by the number of blocks m. This allows to renormalize costs according to the number of steps; e.g. the step height of a stairway with m uniform steps is half that of a stairway with {a mathematical formula}m/2 steps. Finally, we write the average amount of vertical material as {a mathematical formula}vmat=1m∑idyi. All the other costs can be written similarly; see Table 3 for the complete list. As we will see, the normalization of individual costs allows to learn weights which generalize to stairways with a larger number of blocks with respect to those seen during training.
      </paragraph>
      <paragraph>
       Putting all the pieces together, the complete cost is:{a mathematical formula}
      </paragraph>
      <paragraph>
       Minimizing the weighted cost implicitly requires the inference engine to decide whether it is preferable to generate a left or a right stairway, thanks to the {a mathematical formula}minshl,…,minswr components, and whether the stairway should be a ladder or pillar, due to vmat and hmat. The actual weights are learned, allowing the learnt model to reproduce whichever stairway type is present in the training data.
      </paragraph>
      <paragraph>
       To test the stairway scenario, we focused on learning one model for each of six kinds of stairway: left ladder, right ladder, left pillar and right pillar with a preference for horizontal blocks, and left pillar and right pillar with vertical blocks. In this setting, the input I is empty, and the model should generate all m blocks as output O during test.
      </paragraph>
      <paragraph>
       We generated “perfect” stairways of 2 to 6 blocks for each stairway type to be used as training instances. We then learned a model using all training instances up to a fixed number of blocks: a model using examples with up to 3 blocks, another with examples of up to 4, etc., for a total of 4 models per stairway type. Then we analyzed the generalization ability of the learnt models by generating stairways with a larger number of blocks (up to 10) than those in the training set. The results can be found in Fig. 4.
      </paragraph>
      <paragraph>
       The experiment shows that LMT is able to solve the stairway construction problem, and can learn appropriate models for all stairway types, as expected. As can be seen in Fig. 4, the generated stairways can present some imperfections when the training set is too small (e.g., only two training examples; first row of each table), especially in the 10 output blocks case. However, the situation quickly improves when the training set increases: models learned with four training examples are always able to produce perfect 10-block stairways of the same kind. Note again that the learner has no explicit notion of what a stairway is, but just the values of step width, height and material for some training examples of stairways.
      </paragraph>
      <paragraph>
       All in all, albeit simple, this experiment showcases the ability of LMT to handle learning in hybrid Boolean-numerical domains, whereas other formalisms are not particularly suited for the task. As previously mentioned, the Church [7] language allows to encode arbitrary constraints over both numeric and Boolean variables. The stairway problem can indeed be encoded in Church in a rather straightforward way. However, the sampling strategies used for inference are not conceived for performing optimization with hard continuous constraints. Even the simple task of generating two blocks, conditioned on the fact that they form a step, is prohibitively expensive.{sup:12}
      </paragraph>
     </section>
     <section label="5.2">
      <section-title>
       Learning to draw characters
      </section-title>
      <paragraph>
       In this section we are concerned with automatic character drawing, a novel structured-output learning problem that consists in learning to translate any input noisy hand-drawn character into its symbolic representation. More specifically, given an unlabeled black-and-white image of a handwritten letter or digit, the goal is to construct an equivalent vectorial representation of the same character.
      </paragraph>
      <paragraph>
       In this paper, we assume the character to be representable by a polyline made of a given number m of directed segments, i.e. segments identified by a starting point {a mathematical formula}(xb,yb) and an ending point {a mathematical formula}(xe,ye). The input image I is seen as the set P of coordinates of the pixels belonging to the character, while the output O is a set of m directed segments {a mathematical formula}{(xib,yib,xie,yie)}i=1m. Just like in the previous section, we assume all coordinates to fall within the unit bounding box.
      </paragraph>
      <paragraph>
       Intuitively, any good output O should satisfy the following requirements: (i) it should be as similar as possible to the noisy input character; and (ii) it should actually “look like” the corresponding vectorial character. Here we interpret the first condition as implying that the generated segments should cover as many pixels of the input image as possible (although alternative interpretations are possible). Under this interpretation, we can informally write the inference problem as follows:{a mathematical formula} where the orientation term encodes information on the orientation of the segments which should be useful for computing the “looking like” condition. In the following, we will detail how to formulate and compute these two quantities.
      </paragraph>
      <paragraph>
       Since the output is supposed to be a polyline, we constrain consecutive segments to be connected, i.e. to share an endpoint:{a mathematical formula} We also want the segments to be no larger than the image, nor smaller than a pixel: {a mathematical formula}∀imin_length≤length(i)≤1. Additionally, we constrain (without loss of generality) each segment to be ordered from left to right, i.e. {a mathematical formula}xib≤xie. Finally, we restrict the segments to be either horizontal, vertical or 45° diagonal, that is:{a mathematical formula} This restriction allows us express all numerical constraints in linear terms. All the predicates used above are defined as in Table 4.
      </paragraph>
      <paragraph>
       Under these assumptions, we can encode the coverage reward as:{a mathematical formula} where {a mathematical formula}covered(p) is true if pixel p is covered by at least one of the m segments:{a mathematical formula} The fact that a segment {a mathematical formula}i=(xib,yib,xie,yie) covers pixel {a mathematical formula}p=(x,y) implicitly depends on the orientation of the segment, and is computed using constructs like:{a mathematical formula} The coverage formulae for the other segment types can be found in Table 4.
      </paragraph>
      <paragraph>
       As for the orientation term, it should contain features related to the vectorial representation of characters. These include both the direction of the individual segments and the connections between pairs of segments. As an example, consider this possible description of “looking like an A”:{a mathematical formula} Here {a mathematical formula}increasing(i) and {a mathematical formula}decreasing(i) indicate the direction of segment i, and can be written as:{a mathematical formula}{a mathematical formula} Then we have connections between pairs of segments. We encode connection types following the convention used for Bayesian Networks, where the head of a directed segment is the edge containing the arrow (represented by the ending point {a mathematical formula}(xe,ye)) and the tail is the opposite edge (the starting point {a mathematical formula}(xb,yb)). For instance, {a mathematical formula}h2t(i,j) indicates that i is head-to-tail with respect to j, {a mathematical formula}h2h(i,j) that they are head-to-head:{a mathematical formula}{a mathematical formula} For a pictorial representation of the “looking like an A” constraint, see Fig. 5(b). We include a number of other, similar predicates in the background knowledge; for a full list, see Table 4.
      </paragraph>
      <paragraph>
       For example, suppose we have an {a mathematical formula}8×8 image of an upper-case “A”, as in Fig. 5(a). A character drawing algorithm should decide how to overlay 5 segments on top of the input image according to the previous two criteria. A good output would look like the one pictured in Fig. 5(c).
      </paragraph>
      <paragraph>
       However, the formula for the “looking like an A” constraint is not available at test time and should be learned from the data. In order to do so, the orientation term includes possible directions (increasing, decreasing, right) for all m segments and all possible connection types between all segments (h2t, h2h, t2t, t2h). Note that we do not include detailed segment orientation (i.e., horizontal, vertical, diagonal) in the feature space to accommodate for alternative vectorial representations of the same letter. For instance, the first segment in an “A”, which due to the left-to-right rule necessarily fits the lower left portion of the character, is bound to be increasing, but may be equally likely vertical or diagonal (see e.g. Fig. 5(b) and (c)).
      </paragraph>
      <paragraph>
       Summing up, the orientation term can be written as:{a mathematical formula} where each feature is the indicator function of the corresponding Boolean variable, e.g. {a mathematical formula}increasing(1):=1(increasing(1)) (see Table 5).
      </paragraph>
      <paragraph>
       We evaluated LMT on the character drawing problem by carrying out an extensive experiment using a set of noisy B&amp;W {a mathematical formula}16×20 character images.{sup:13} The dataset includes 39 instances of handwritten images of each alphanumerical character. We downscaled the images to {a mathematical formula}12×12 for speeding up the experiments. Learning to draw characters is a very challenging constructive problem, made even more difficult by the low quality of the noisy images in the dataset (see, e.g. Fig. 7). In this experiment we learn a model for each of the first five letters of the alphabet (A to E), and assess the ability of LMT to generalize over unseen handwritten images of the same character.
      </paragraph>
      <paragraph>
       We selected for each letter five images at random out of the 39 available to be employed as training instances. For each of these, we used OptiMathSAT to generate a “perfect” vectorial representation according to a human-provided letter template (similar to the “looking like an A” rule above), obtaining a training set of five fully supervised images. Please note that the training outputs generated by this process may not be optimal from a “perceptual” perspective, but only with respect to the “looking like an A” rule. The resulting supervision obtained with this procedure—which can be seen in the first rows of Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10—is, in some cases, very noisy, and depends crucially on the quality of the character image. This is particularly relevant for the “B”, which is the most geometrically complex of the characters and thus more difficult to capture with bitmap images.
      </paragraph>
      <paragraph>
       For each letter, we randomly sampled a test set of 10 instances out of the 33 non-training images. Then we learned a model for each letter, and used it to infer the vectorial representation of the test images. In order to assess the robustness of the learning method with respect to the amount of available supervision, we repeated this procedure four times, each time adding a training instance to the training set: the number of instances in the training set grows from 2 (the first two training images) to 5 (all of the training images). We indicate the predictions obtained by models learned with k examples as pred@k. The number of segments m was known during both training and inference. In particular, we used 4 segments for the “D”, 5 segments for the “C” and “E”, 7 segments for the “A”, and 9 segments for the “B”. The output for all letters can be found in Fig. 6, Fig. 7, Fig. 8, Fig. 9, Fig. 10, from the second to the fifth rows of each figure.
      </paragraph>
      <paragraph>
       We sped up the computations in two ways. First, during learning we imposed a 2 minute timeout on the separation oracle used for training. Consequently most invocations to the separation routine did return an approximate solution. Analyzing the weights, we found that this change had little effect on the learned model (data not shown). This can be explained by observing that the cutting-plane algorithm does not actually require the separation oracle to be perfect: as long as the approximation is consistent with the hard rules (which is necessarily the case even in sub-optimal solutions), the constraint added to the working set {a mathematical formula}W at each iteration still restricts the quadratic program in a sound manner (see Algorithm 1). As a consequence, the learning procedure is still guaranteed to find an ϵ-approximate solution, but it may take more iterations to converge. This trick allows training to terminate very quickly (in the order of minutes for a set of five training examples). Furthermore, it enables the user to fine tune the trade-off between separation complexity and number of QP sub-problems to be solved.
      </paragraph>
      <paragraph>
       Second, prior to inference we convert the learned weights associated to the segment and connection features into hard constraints and add them to the learned model. This way we constrain OptiMathSAT to search for solutions that do respect the learned weights, while still allowing for some flexibility in the choice of the actual solution. In practice, for each per-segment feature (i.e. those associated to increasing, decreasing and right soft constraints) and connection features (i.e. h2t, t2t, etc.) with a positive weight, we add the corresponding hard rule. If more than one weight is positive for any given segment/connection, we add the disjunction of the hard rules to the model.
      </paragraph>
      <paragraph>
       As a quantitative measure of the quality of the predictions, we also report the distance between the generated vectorial representation O for each letter and a corresponding human-made gold standard {a mathematical formula}O′. Here the error is computed by first aligning the segments using an optimal translation, and then summing the distances between all corresponding segment endpoints. The human generated images respect the same “looking like an X” rule used for generating the training set, i.e. they have the same number of segments, drawn in the same order and within the same set of allowed orientations. One minor difference is they do not follow the requirement that segment endpoints match, for simplicity; this has little impact on the resulting values. The values in Fig. 11 are the average over all instances in the test set, when varying the training set size.
      </paragraph>
      <paragraph>
       The results show that LMT is able to address the character drawing problem and produce reasonable outputs for all the target letters. Please note that both the coordinates and the number of character pixels can vary widely between test instances, and our results highlight the generalization ability of our method. Furthermore, the predictions tend to get closer to the human-provided segmentations as the number of training instances increases.
      </paragraph>
      <paragraph>
       For the simplest cases (i.e. “C”, “D”, and “E”, drawn using four to five segments), the outcome is unambiguous: there are only a handful of cases for “E” where two horizontal segments are too close, and this is only due to the fact that we do not encode (soft) constraints on the segment lengths. The only real issue is with the “D”, where the fourth (blue in the web version) segment is never predicted as diagonal, despite there being two examples with that property in the training set. The main reason is that in none of the test images it is possible to draw a 45° diagonal without sacrificing pixel coverage. None of the predictions looks perceptually “wrong”.
      </paragraph>
      <paragraph>
       More complex letters like the “A” and “B”, with a higher number of segments, also show a similar behavior: the generated letters indeed generalize the given examples. However, there are a handful of predictions that are sub-optimal with respect to coverage of the bitmap character (e.g. see the first column in Fig. 6) or do not represent a “perceptually” correct character, a behavior which is less frequent for the larger training sets (e.g. second-to-last row of Fig. 6). This can be explained by (i) the complexity of the 7- and (especially) the 9-segment inference problems, (ii) the fact that more segments imply more features, and consequently may require more examples to be learned correctly, and (iii) the fact that our cost function does not fully discriminate between perceptually different solutions.
      </paragraph>
      <paragraph>
       The distance-to-human results in Fig. 11 also show how the algorithm produces more perceptually reasonable predictions as the training set increases: while the values do fluctuate, in all cases the distance at pred@5 is lower than that at pred@2. Summarizing, excluding cases of pathologically bad inputs—such as the third “B” training examples leading to the bad performance in the pred@3 and pred@4 experiments—LMT is able to learn an appropriate model for each letter and generalize the learned template over unseen inputs.
      </paragraph>
      <paragraph>
       In this paper we only consider the case where the training data is labeled with a fully observed vectorial letter. Our method, however, can in principle be extended to work with partially observed supervision, e.g. with training instances labeled only with the character type, in order to discover the vectorial representation. More on this point can be found in the next section.
      </paragraph>
     </section>
    </section>
    <section label="6">
     <section-title>
      Conclusions
     </section-title>
     <paragraph>
      In this work we presented a novel class of methods for structured learning problems with mixed Boolean and numerical variables. These methods, termed Learning Modulo Theories, are based on a combination of structured-output SVMs and Satisfiability Modulo Theories. In contrast to classical First-Order Logic, SMT allows to natively describe, and reason over, numerical variables and mixed logical/arithmetical constraints. By leveraging the existing state-of-the-art OMT solvers, LMT is well-suited for dealing with hybrid constructive learning problems, avoiding the combinatorial explosion of the state space that would affect an equivalent FOL formulation.
     </paragraph>
     <paragraph>
      Experimental results on both artificial and real world datasets show the potential of this approach. The stairway application is a simple instance of a layout problem, where the task is to find an optimal layout subject to a set of constraints. Automated or interactive layout synthesis has a broad range of potential applications, including urban pattern layout [52], decorative mosaics [53] and furniture arrangement [54], [55], [56]. Note that many spatial constraints can be encoded in terms of relationships between blocks [54]. Existing approaches typically design an energy function to be minimized by stochastic search. Our approach suggests how to automatically identify the relevant constraints and their respective weights, and can accommodate hard constraints and exact search. This is especially relevant for water-tight layouts [57], where the whole space needs to be filled (i.e. no gaps or overlaps) by deforming basic elements from a predetermined set of templates (as in residential building layout [58]). The character drawing application shows how to learn symbolic representations from a handful of very noisy training instances. Deep generative networks have been previously used for similar tasks, see for instance the work by Hinton [59] on generating images of digits with Deep Boltzmann Machines. However, these methods do not learn symbolic representations for characters and generate bitmaps rather than vectorial representations. Furthermore, they require thousands of training examples to be learned. Recent extensions have been developed addressing the problem of learning from few [60] or even single [61] examples, but they focus on clean images of the target symbols. Generally speaking, the LMT framework allows to introduce a learning stage in all application domains where SMT and OMT approaches have shown their potential, ranging, e.g., from hardware and software verification [62], [63], [39], to engineering of chemical reactions [64] and synthetic biology [65].
     </paragraph>
     <paragraph>
      This work can be extended in a number of directions. First, the current formulation assumes knowledge of the desired output for training examples. This requirement can be loosened by introducting latent variables for the unobserved part of the output, to be maximized over during training [66]. Second, OMT is currently limited to quantifier free formulae and linear algebra for what concerns numeric theories. The former requires to ground all predicates before performing inference, while the latter prevents the formulation of non-linear constraints, e.g. on areas and Euclidean distances. Some attempts to extend SMT solvers to quantified formulae [48], [49], [50] and to non-linear arithmetic [67], [68], [69] have been presented in the literature; although the state of the art of these extensions is not yet satisfactory in terms of efficiency, since they can currently handle problems which are much smaller—in terms of size, number of variables and of arithmetical operations—than the quantifier-free problems with linear constraints at the reach of current SMT solvers, these techniques are evolving rapidly and promise rapid improvements in terms of performances in the next few years; hence, we can rather easily extend our framework in these directions as soon as the underlying SMT technology is mature enough. Finally, LMT is currently focused on the task of finding the maximal configuration, and cannot compute marginal probabilities. We are planning to introduce support for probability computation by leveraging ideas from weighted model counting [70].
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>