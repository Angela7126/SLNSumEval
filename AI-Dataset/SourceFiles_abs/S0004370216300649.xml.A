<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Generating SAT instances with community structure.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The Boolean Satisfiability Problem (SAT) is one of the most studied problems in Computer Science. It is the first known NP-complete problem, as proved by S. Cook in 1971 [15]. However, many application problems are nowadays encoded into SAT instances, and efficiently solved by modern SAT solvers. Namely, these solvers are the so known Conflict-Driven Clause Learning (CDCL) SAT solvers. In the last years, these solvers have been the dominant technique in the SAT community to solve application problems, including a wide variety of domains, such as cryptography, hardware and software verification, planning, or scheduling, among others.
     </paragraph>
     <paragraph>
      It is accepted that random and industrial SAT instances have a distinct nature. While random formulas can be easily generated on demand, the set of industrial benchmarks, which encode real-world problems, is limited. The problem of generating realistic pseudo-industrial random instances is stated in [39] as one of the most important challenges for the next few years: “Challenge 10: Develop a generator for problem instances that have computational properties that are more similar to real world instances”. This challenge is also stated in [27], [16]. The main motivation of this challenge is improving the process of development and testing of SAT solvers, and their possible specialization.
     </paragraph>
     <paragraph>
      There exist a wide variety of works on the analysis of the nature of industrial SAT instances. The intuition is that these formulas have some kind of structure, which is exploited by CDCL SAT solvers. In many of these works, SAT formulas are represented as graphs, and some (graph) features are studied. The classical Erdös–Rényi model has been extensively used for generating random graphs. In this model, the degree of nodes follows a binomial distribution, with small variability. This is exactly the case of classical random formulas. However, the structure of most real-world networks cannot be described with this classical model, and therefore, new models have been defined. For instance, Preferential Attachment[12] is used to explain the scale-free structure of some real networks, where the nodes degree follows a power-law distribution, with big variability. Similarity has also been proposed as a second mechanism, that together with popularity or preferential attachment, may result into complex networks with an hyperbolic topology [38]. In [2] it is described an hyperbolic graph generator. When SAT instances are modeled as graphs, many graph properties can be analyzed, such as the small-world property [43], the scale-free structure [5], [6], the eigenvector centrality [26], or the self-similarity [3]. Moreover, some notions of structure have been already used to better understand certain components of modern SAT solvers [29], [28], [4]. The structure of industrial SAT instances has also been proposed as responsible for the smaller tree-like resolution space needed to refute them [8].
     </paragraph>
     <paragraph>
      In this paper, we focus on the notion of modularity of a graph [34]. In a graph with high modularity (i.e., clear community structure), we can find a partition of its nodes into communities such that most of its edges connect nodes of the same community. In [9], it is analyzed the modularity of the industrial benchmarks used in SAT competitions. In that paper, it is shown that most industrial SAT formulas exhibit a high modularity. On the contrary, randomly generated instances have a very low modularity. The community structure has been shown correlated with the runtime of CDCL SAT solvers [36], [37]. Moreover, it has been used to improve the performance of some solvers [31], [42], [10], [33].
     </paragraph>
     <paragraph>
      One important motivation for the development of pseudo-industrial SAT instances generators is to isolate some known properties of these real-world problems. This allows us to study the impact of these properties on the performance and behavior of SAT solvers. This approach has already been used in [7]. In that work, authors present a random SAT instances generator which takes into account the scale-free structure of real-world SAT instances to generate formulas in which the number of variable occurrences follows a power-law distribution. Using it, they observe that CDCL SAT solvers focus their decisions on the most frequent variables. In the case of community structure, similar questions also arise. For instance, do SAT solvers concentrate their decisions on variables of the same (or few) communities? Do the conflicts found by the solver relate variables of the same community? How does the activity of each community evolve along the execution of the search? Answering these questions may help to better understand the different ingredients of modern SAT solvers and their impact on the solving process, with the long-term aim of improving them.
     </paragraph>
     <paragraph>
      The main contribution of this work is a new model of generation of random SAT instances based on the notion of modularity.{sup:1} With this new model, we can generate formulas for any given value of modularity. For a high modularity, the resulting instance is more adequate to model industrial problems than classical random formulas. On the contrary, with a low modularity we can generate SAT instances very similar to classical random ones. We show that this model works appropriately for different input values of number of variables n and clauses m. We also show that, if there exists a phase transition point SAT-UNSAT when the ratio clause/variable is increased, then it does not depend on the modularity. We give empirical evidence that the performance of SAT solvers is consistent with the expected properties of the generated formulas, i.e. SAT solvers specialized in industrial problems perform better in high modular instances than SAT solvers specialized in random formulas, and vice versa. Finally, we use this generator to answer the questions stated in the previous paragraph. In particular, we analyze the relations between the community structure and the branching decision heuristics, and the mechanism of learning new clauses from the conflicts the solver finds along its execution. A preliminary version of this paper was published as [20].
     </paragraph>
     <paragraph>
      The rest of the paper proceeds as follows. We first reference some related works on the generation of pseudo-industrial SAT instances in Section 2. After some preliminaries on modularity of graphs in Section 3, we describe the generation model in Section 4. In Section 5, we show that this model works appropriately for different input values. In Section 6, we analyze the phase transition point of the instances generated by our model. In Section 7, we show the adequacy between the performance of SAT solvers and the properties of the generated instances. In Section 8, we use this generator to analyze some components of a CDCL SAT solver. Finally, we conclude in Section 9 and propose some future work.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Related work
     </section-title>
     <paragraph>
      There already exist some works facing the problem of generating pseudo-industrial random instances. We distinguish between those works focused on particular problems domains from those others that generalize common properties of industrial instances.
     </paragraph>
     <paragraph>
      In the case of particular problems domains, we have the following works. Gomes and Selman [21] proposed a new model of SAT benchmarks resulting from introducing random perturbations into structured problems. These benchmarks encode instances of the partial latin square completion problem, with some randomly selected pre-assigned values. Achlioptas et al. [1] refined the previous model to guarantee the generation of satisfiable instances. Gent et al. [18] introduced a method, called morphing, for introducing randomness into structured problems, resulting into problems with small-world topology. Järvisalo et al. [24] proposed an instance generator based on finding optimal circuits of Boolean functions. In general, these methods do not explicitly generate SAT instances with community structure. However, this feature may appear for certain input parameters.
     </paragraph>
     <paragraph>
      On the other hand, other works focus on general properties shared by the majority of real-world problems. Burg et al. [14] presented a generator that combines subparts of real-world instances to create new ones. Notice that this method may generate instances with community structure when the input formulas have such structure. Nevertheless, the modularity of the generated instances cannot be controlled. Ansótegui et al. [7] used the notion of scale-free graph to generate formulas where the number of variable occurrences follows a power-law distribution. This feature is very characteristic in real-world instances, but it is not a sufficient condition to guarantee community structure. Newsham et al. [36] proposed a random 3-CNF generator which divides the set of variables into groups, and uses a certain probability to decide for each clause whether a literal is selected from the same group than the previous one or not (randomly selected in the case of the first literal of the clause). This way, a high value in this probability generates very modular instances. Slater [41] proposed a method to generate SAT instances with small-world topology. This feature is also very common in many real-world networks, and it is characterized by a small typical distance and a high clustering coefficient. The proposed model is characterized by n variables, m clauses, c clusters and a parameter p. They generate c independent 3-SAT formulas, each one having {a mathematical formula}n/c variables and {a mathematical formula}(1−p)m/c clauses, and then add pm link clauses using the entire set of variables, in the spirit of the techniques used traditionally to generate small-world graphs. This model is quite similar to ours, and may also result into instances with high modularity. Notice, however, that this paper was written in 2002, and the notion of modularity was defined in 2004. The main difference is that the relation between the modularity of their generated instances and the parameter p is not so clear as in our model. In particular, we force link clauses to connect variables of distinct communities, and we do not require communities to have the same number of internal clauses. This way, we show the relation in our model between the modularity and the parameter p. This relation lets us to control the modularity of the generated instances, which has important effects on the performance of the solver (as shown in [36], [37]).
     </paragraph>
    </section>
    <section label="3">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      SAT is the problem of deciding if the variables of a propositional formula can be assigned in such a way that the formula is evaluated as true. A literal is either a variable or its negation, a clause is a disjunction of literals, a conjunctive normal form (CNF) formula is a conjunction of clauses, and a k-CNF is a CNF in which all clauses have exactly k literals.
     </paragraph>
     <paragraph>
      A weighted graph G is a pair {a mathematical formula}G=(V,w), where V is the set of nodes, and {a mathematical formula}w:V×V→R+ is the edge-weight function that satisfies {a mathematical formula}w(x,y)=w(y,x).
     </paragraph>
     <paragraph>
      The Variable Incidence Graph (VIG) of a SAT instance Γ is the graph whose nodes represent the variables of Γ, and there exists an edge between two variables if they both appear in a clause C. A clause with {a mathematical formula}|C| literals results into {a mathematical formula}(|C|2) edges. Thus, to give the same relevance to all clauses, we assign to edges the weight {a mathematical formula}w(x,y)=∑C∈Γx,y∈C1/(|C|2).
     </paragraph>
     <paragraph>
      The community structure of a graph is usually measured using the notion of modularity[35]. Defined for a graph G and a partition P of its vertexes into communities, the modularity Q (see Eq. (1)) measures the fraction of internal edges (edges connecting vertexes of the same community) w.r.t. a random graph with same number of vertexes and same degree. This avoids that the best partition is the one made up by an only community containing all vertexes.{a mathematical formula}
     </paragraph>
     <paragraph>
      The modularity of a graph is the maximal modularity for any possible partition: {a mathematical formula}Q(G)=max⁡{Q(G,P)|P}.
     </paragraph>
     <paragraph>
      Computing the modularity of a graph is NP-hard [13]. Due to its complexity, instead of computing the (exact) modularity, most of methods in the literature approximate the optimal modularity by providing a lower-bound on the value of Q.
     </paragraph>
    </section>
    <section label="4">
     <section-title>
      Community attachment model
     </section-title>
     <paragraph>
      In the classical random k-SAT model, a random formula {a mathematical formula}Fk(n,m) is a set of m clauses over n variables, where clauses are chosen uniformly and independently among all {a mathematical formula}2k(nk) non-trivial clauses of length k. A non-trivial clause of length k contains k distinct, non-complementary literals. In this paper we present a new model of random formulas: the Community Attachment (CA) model. This is parametric in a probability p and a number of communities c of the set of variables. It allows the generation of formulas of any desired modularity.
     </paragraph>
     <paragraph label="Definition 1">
      Community Attachment. Let N be a set of n variables, a partition P of N into c pairwise disjoint communities of the same size {a mathematical formula}n/c, with {a mathematical formula}k≤c≤n/k, and a real value {a mathematical formula}0≤p≤1. A random formula {a mathematical formula}Fk(n,m,c,p) is a set of m non-trivial clauses with k literals over the n variables, selected independently as follows. With probability p, choose a clause uniformly among all {a mathematical formula}c2k(n/ck) clauses with all literals in the same community; and with probability {a mathematical formula}1−p, a clause uniformly among all {a mathematical formula}(2nc)k(ck) clauses with all literals in distinct communities.
     </paragraph>
     <paragraph>
      Notice that in the previous definition we need to impose the restriction {a mathematical formula}k≤c≤n/k to ensure that there always exists at least one possible clause to select. Notice also that for {a mathematical formula}k=2 and {a mathematical formula}p=n/c−1n−1 we have the classical 2-SAT model: {a mathematical formula}F2(n,m)=F2(n,m,c,n/c−1n−1), but for bigger k the Community Attachment model does not subsume the classical model.
     </paragraph>
     <paragraph>
      Given a SAT formula Γ with n variables and m clauses, consider the VIG G of Γ. Our model ensures a lower-bound for the modularity of this graph.
     </paragraph>
     <paragraph label="Theorem 2">
      Given a formula{a mathematical formula}Γ∈Fk(n,m,c,p), let G be its VIG. The average modularity of G is bounded as:{a mathematical formula}
     </paragraph>
     <paragraph label="Proof">
      Recall that modularity is defined as the maximal modularity for all possible partitions of the nodes into communities. Here we consider the partition used to generate the formula. For this particular partition P, when we select a clause with all variables in the same community (with probability p), we get {a mathematical formula}(k2) internal edges. The sum of the weights of the edges generated by a single clause is always 1. Therefore, the fraction of internal edges is, on average, {a mathematical formula}pmm. The sum of nodes degrees is 2m, thus {a mathematical formula}2m/n is the expected node degree. Since {a mathematical formula}n/c is the number of nodes per community, the sum of nodes degrees in one community is on average {a mathematical formula}nc2mn.Summarizing, for this partition P, we get{a mathematical formula} that is a lower-bound for the expected modularity {a mathematical formula}E[Q(G)].  □
     </paragraph>
     <paragraph>
      When p close to 1, the expected modularity {a mathematical formula}E[Q(G)] is very close to this lower-bound {a mathematical formula}p−1/c, because the partition used in the formula generation is very similar to the optimal. Therefore, we can use the previous theorem to generate formulas with a desired modularity Q. We simply take:{a mathematical formula} which ensures at least a modularity Q. In practice, as we will see in Section 5, the formulas we obtain have a modularity {a mathematical formula}Q≈p−1/c, except when p and {a mathematical formula}m/n are small.
     </paragraph>
     <paragraph>
      Notice that the previous lower-bound of the modularity depends of the graph model used to represent the formula. For instance, the CVIG model [10] uses a bi-partite structure to represent both variables and clauses into nodes, and puts an edge between a variable-node and a clause-node when that variable appears in that clause. If, instead of the VIG model, we use the CVIG {a mathematical formula}G′,{sup:2} we can get a lower-bound {a mathematical formula}E[Q(G′)]≥p−p/c. Notice, however, that in the case we use the definition of modularity for bi-partite graphs, which is slightly different. Nevertheless, both approximations are very similar. Since most of the methods in the literature to compute the community structure are efficient for non-bi-partite graphs (as the VIG model), we use the approximation of Theorem 2.
     </paragraph>
     <paragraph>
      In Algorithm 1, there is an implementation of the Community Attachment random formulas generator from {a mathematical formula}Fk(n,m,c,p). Using {a mathematical formula}p=Q+1/c these formulas will have an expected modularity close to Q.
     </paragraph>
     <paragraph>
      In Fig. 1, we represent the VIG of an instance generated with {a mathematical formula}n=200 variables, {a mathematical formula}m=425 clauses, modularity {a mathematical formula}Q=0.8 and {a mathematical formula}c=40 communities. In this plot, variables (nodes) of the same community are plotted with the same color, and edges are scaled according to their weight. As the value of the modularity is high, it is more likely that a clause relates variables of the same community. Therefore, the weight of the edges connecting nodes (variables) of the same community is higher, as expected.
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Validation of the model
     </section-title>
     <paragraph>
      In order to analyze the community structure of the SAT instances obtained with our model, we have generated some sets of random formulas for different values of {a mathematical formula}Q∈{0.9,0.8,0.7,0.5,0.3} (hence {a mathematical formula}p=Q+1/c), and for different values of number of communities {a mathematical formula}c∈{10,20,40,80}. Each set contains 50 random instances. Remark that the modularity Q of (real) industrial SAT instances is usually greater than 0.7 [9], while no modularity greater than 0.3 is found for classical random k-CNF formulas. Moreover, the number of communities c is usually in the interval {a mathematical formula}[10,100][9].
     </paragraph>
     <paragraph>
      In Fig. 2, we analyze their modularity {a mathematical formula}Q′ (top) and their number of communities {a mathematical formula}c′ (bottom), varying the number of variables n, for a fixed clause/variable ratio {a mathematical formula}m/n=4 (left), and varying the clause/variable ratio {a mathematical formula}m/n, for a fixed number of variables {a mathematical formula}n=1000 (right). In this experiment, the number of communities c is fixed to {a mathematical formula}c=40. Notice that the main goal of this experiment is to show that our model generates instances with modularity {a mathematical formula}Q′ and number of communities {a mathematical formula}c′ similar to the input parameters Q and c, for any number of variables n and clauses m. We use the algorithm described in [9] to compute an approximation of {a mathematical formula}Q′ and {a mathematical formula}c′. In fact, this algorithm computes a lower-bound of the modularity. The dispersions of the approximated {a mathematical formula}Q′ and {a mathematical formula}c′ are very small, so they are not shown in the plots.
     </paragraph>
     <paragraph>
      We observe that the modularity {a mathematical formula}Q′ and the number of communities {a mathematical formula}c′ are almost unaffected by these variations of n and {a mathematical formula}m/n. In general, the approximation computed for {a mathematical formula}Q′ is slightly smaller than expected, and the partition into communities is also very similar to the partition used in the generation. For small values of the clause/variable ratio {a mathematical formula}m/n and the probability p, the number of clauses relating variables of the same expected community is very small. This produces the existence of some unconnected sub-communities within each expected community. Hence, {a mathematical formula}Q′ and {a mathematical formula}c′ are much greater than expected, and {a mathematical formula}Q′ cannot be estimated as {a mathematical formula}p−1/c. When we generate formulas with small values of p, e.g. {a mathematical formula}Q=0.3 and {a mathematical formula}c=40, we observe that, although the formulas have a guaranteed lower-bound of {a mathematical formula}Q≥0.3, the computed approximation of {a mathematical formula}Q′ is smaller (close to 0.2 when {a mathematical formula}n≈20000). The number of communities {a mathematical formula}c′ is also smaller than the expected c. In this case, this error is not produced by our model. It is due to the greediness of the algorithm [9] used to approximate {a mathematical formula}Q′, which is not able to find a similar partition to the one used in the generation.
     </paragraph>
     <paragraph>
      In a second experiment, we generate families of instances with the same number of variables n and the same clause/variable ratios {a mathematical formula}m/n than in the previous experiment, and varying the number of communities c with a fixed modularity {a mathematical formula}Q=0.8. In Fig. 3, we represent the results. We observe that the expected modularity {a mathematical formula}Q′ as well as the expected number of communities {a mathematical formula}c′ is almost unaffected in these families, except, as expected, for small values of n and {a mathematical formula}m/n. In fact, when the value of the number of communities c is high enough (as actual industrial SAT instances have), its relevance in our model is very small, as expressed by Equation (2). Hereinafter we use in our experiments a fixed value of number of communities {a mathematical formula}c=40, assuming that this value is representative for real application problems, and therefore without altering general conclusions observed in the empirical results.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Phase transition
     </section-title>
     <paragraph>
      In classical random k-CNF instances, some interesting properties, as the satisfiability or the hardness, are correlated to the clause/variable ratio {a mathematical formula}m/n[32]. The Satisfiability Threshold Conjecture, which remains open for {a mathematical formula}k&gt;2, suggests that it may exist a critical ratio r, such that below this point all formulas from {a mathematical formula}Fk(n,m) are SAT (under-constrained) and above it they all are UNSAT (over-constrained) with uniformly positive probability, when n tends to infinity. Experimentally, this phase transition point has been shown to be around {a mathematical formula}r≈4.26 for {a mathematical formula}k=3. Moreover, the hardness of these instances is also characterized by this parameter: closer to this ratio, harder the instance.
     </paragraph>
     <paragraph>
      In this section we check if this phenomenon also exists in the random SAT instances generated with our model, and if the new transition point, noted {a mathematical formula}r′, differs from the classical {a mathematical formula}r′≠r. In Fig. 4, we represent the fraction of UNSAT instances for some sets of random formulas with distinct Q, varying the clause/variable ratio {a mathematical formula}m/n. We observe that the fraction of UNSAT formulas increases with {a mathematical formula}m/n. Therefore, for small (big) values of {a mathematical formula}m/n, nearly all formulas are SAT (UNSAT). When Q is small, the value {a mathematical formula}r′ is close to the classical {a mathematical formula}r≈4.26. Recall that when {a mathematical formula}p≈1/c, our model is quite similar to the classical random k-SAT model. However, we also observe that, when Q increases, {a mathematical formula}r′ decreases.
     </paragraph>
     <paragraph>
      In our experimentation, for each family of instances we use the biggest value of number of variables n allowing us to get a solution in less than 3 hours. Therefore, this value may change for each family of instances. In Table 1 we report the phase transition point {a mathematical formula}r′ we found for some families of formulas with {a mathematical formula}k=3, varying the modularity Q. We also report the solver we used to solve the formulas, as well as the average and standard deviation of the runtime used by this solver. Remark that as the number of variables n of each family is different, their runtimes cannot be used to compare their hardness. We observe that the phase transition point {a mathematical formula}r′ decreases as the modularity Q increases. In Table 2, we report the phase transition point {a mathematical formula}r′ of some families of instances with {a mathematical formula}k=4. Again, the phase transition point {a mathematical formula}r′ of these families tends to decrease as the modularity Q increases. Notice that the generated formulas with a high modularity are hard, compared to industrial formulas. This is because industrial instances have other properties, like the scale-free structure, that contribute to make them easier.
     </paragraph>
     <paragraph>
      The natural question is if this decrease in {a mathematical formula}r′ is also valid for n tending to infinity. In order to explain this decrease in the phase transition point {a mathematical formula}r′, and predict the behavior when n tends to infinity, we will consider the extreme case with {a mathematical formula}p=1. In these formulas, clauses only contain variables of the same community. Therefore, the formula is composed by c unconnected sub-formulas, and the whole formula is UNSAT if, and only if, at least one of the sub-formulas is UNSAT. Moreover, in this extreme case, all sub-formulas follow the classical model {a mathematical formula}Fk(n/c,m′), for some {a mathematical formula}m′. On average, all sub-formulas contain {a mathematical formula}E[m′]=m/c clauses; and all of them contain {a mathematical formula}n/c variables. Hence, the average clause/variable fraction in sub-formulas is also {a mathematical formula}E[m′n/c]=m/cn/c=m/n. However, even when the fraction {a mathematical formula}m/n is smaller than the classical r (and so the expected clause/variable ratio of the formula), with some probability, some of the sub-formulas may get a large portion of clauses {a mathematical formula}m′ such that {a mathematical formula}m′n/c&gt;r. This makes that sub-formula UNSAT with high probability. This has the effect of decreasing the phase transition point for finite n and c.
     </paragraph>
     <paragraph label="Theorem 3">
      When {a mathematical formula}n/c tends to infinity, the situation is completely different as the following theorem states. The set of formulas{a mathematical formula}Fk(n,m,c,p), with{a mathematical formula}p=1and any value of c satisfying{a mathematical formula}n/c→∞, has a phase transition point{a mathematical formula}r′at the same clause/variable ratio r of the classical formulas{a mathematical formula}Fk(n,m).
     </paragraph>
     <paragraph label="Proof">
      There are two cases:First, we assume that the number of communities c tends to ∞ (but slower than n, hence {a mathematical formula}n/c also tends to ∞).When {a mathematical formula}m,n→∞, and {a mathematical formula}m/n→∞, the binomials {a mathematical formula}(mn), may be approximated as:{a mathematical formula} using the middle value in the numerator, and the Stirling approximation in the denominator.When {a mathematical formula}c→∞, we can also approximate{a mathematical formula}Replacing these two approximations, and {a mathematical formula}m=r′n we get{a mathematical formula}For {a mathematical formula}n/c,c→∞, this function is dominated by the exponential factor{a mathematical formula}The base of the exponentiation is strictly smaller than one except for {a mathematical formula}r=r′. Therefore, when the number of communities and their size both tend to infinity, even in the extreme case {a mathematical formula}p=1, the probability that the formula is UNSAT is zero, for {a mathematical formula}r′&lt;r, i.e. the phase transition point is the same as for the classical random formulas.In the second case, we assume that c is finite. Then, the approximation we have used for the binomial is not correct. When k is constant and {a mathematical formula}n→∞, we may use{a mathematical formula}In this case we get{a mathematical formula}As in the previous case, the base of the exponentiation is one only when {a mathematical formula}r′=r. Therefore, the phase transition point is also just the same as for classical random formulas.  □
     </paragraph>
     <paragraph>
      In the classical model, we recall that the phase transition point, if exists, is only applicable when the size of the formula goes to infinity. In the context of SAT instances, the phase transition point r is, by definition, the clause/variable ratio such that all formulas below (equivalently, above) such ratio are satisfiable (equiv., unsatisfiable). In other words, the probability that an instance is UNSAT (equiv., SAT) has a value tending to 0 (equiv., 1) for any clause/variable ratio {a mathematical formula}r−ϵ (equiv. {a mathematical formula}r+ϵ), for any {a mathematical formula}ϵ&gt;0. This abrupt change in the probability is represented as a vertical line in the point r, and this would only occur in extremely large instances, as suggested in the Satisfiability Threshold Conjecture. In the case of formulas of finite size, we observe that this abrupt change does not exist. In particular, we find an interval {a mathematical formula}(r−ϵ,r+ϵ) where the probability that an instance is UNSAT smoothly goes from 0 to 1. Empirical observations show that this change is more abrupt as the size of the formula grows, but no phase transition point has been found to date.
     </paragraph>
     <paragraph>
      In the case of the Community Attachment model, we observe the same behavior. Therefore, both empirical observations of Fig. 4 and the formal proof expressed in Theorem 3 match with the behavior expected from the classical model.
     </paragraph>
    </section>
    <section label="7">
     <section-title>
      SAT solvers performance
     </section-title>
     <paragraph>
      In this section we show that industrial-specialized SAT solvers exploit the community structure of the formula, whereas random-specialized solvers do not.
     </paragraph>
     <paragraph>
      In Fig. 5 we compare the performance of the SAT solvers Glucose [11] (version 3.0) and March [22] (version br) over some sets of SAT formulas generated with our model, with distinct modularity values. While Glucose is a CDCL SAT solver which has been shown very good for solving industrial problems, March is a Look-ahead SAT solver commonly used to solve random k-CNF instances. We use sets of instances from {a mathematical formula}Fk(n,m,c,p) with a clause/variable ratio {a mathematical formula}m/n in the phase transition point, a number of communities {a mathematical formula}c=40 and a clause length {a mathematical formula}k=3. We adjust the number of variables as in Table 1, in order to ensure that some of these solvers solve all formulas in a timeout of 3 hours.
     </paragraph>
     <paragraph>
      We observe that, for high modularities (see {a mathematical formula}Q=0.9), Glucose solves all the instances, but March is only able to solve few UNSAT instances. More precisely, they are the ones in which there exists a very small unsatisfiability core, composed of variables of one or few communities. Notice that higher the modularity, more likely to find these instances with small refutations. It is also interesting to remark that Glucose also solves UNSAT formulas faster than SAT formulas when their modularity is high. As Q decreases, March is able to solve more instances (see {a mathematical formula}Q=0.7), and it starts to be as fast as Glucose, if it is not faster, when the modularity is small enough (see {a mathematical formula}Q=0.5). Finally, when Q is very small (see {a mathematical formula}Q=0.3), March is able to solve all the instances but Glucose only solves few of them. Remark that the number of variables is not the same for every family. We can conclude that a high modularity makes formulas easier to be solved by CDCL SAT solvers.
     </paragraph>
     <paragraph>
      In Fig. 6 we compare the performance of these two solvers with the instances of Table 2, i.e. {a mathematical formula}k=4. Again, we observe that high modular formulas (see {a mathematical formula}Q=0.9) are easy for Glucose, but March is only able to solve those of them having a small unsatisfiability core. As the modularity decreases, both solvers solve all instances, but March is still some orders of magnitude slower (see {a mathematical formula}Q=0.5). Finally, when the modularity is small, March shows a better performance than Glucose (see {a mathematical formula}Q=0.3).
     </paragraph>
     <paragraph>
      These experiments suggest that the performance of the solver is affected by the structure of the formula (e.g., its community structure) independently of the sizes of the clauses.
     </paragraph>
    </section>
    <section label="8">
     <section-title>
      Analyzing the components of a CDCL SAT solver
     </section-title>
     <paragraph>
      One of the most important motivations for the development of this generator is to better understand the connections between the community structure of a SAT instance and the SAT solver components, with the long-term aim of improving them. In this section, we use our generator to study two main components of a CDCL SAT solver: the branching selection heuristics, and the conflict analysis and clause learning mechanism. Notice that these components are related. For instance, the activity of the variables participating in a conflict is increased, and the most active (and unassigned) variable is selected as the next decision variable. Even though, it seems convenient to study these components separately.
     </paragraph>
     <paragraph>
      In this section, we use MiniSAT [17] (version 2.2) as a representative CDCL SAT solver. This is a very well known SAT solver on which many other SAT solvers, as Glucose, are based. Being a less sophisticated SAT solver allows us to analyze with more precision the impact of certain CDCL techniques on the community structure, without possible noises of other components. For instance, MiniSAT uses the Luby series to determine the number of conflicts between two restarts whereas Glucose uses a dynamic LBD-based strategy for this purpose. Therefore, while one can know when restarts are performed by MiniSAT, this is unknown a priori in Glucose. Also, we use a random SAT instance of the family from our model with {a mathematical formula}n=1000 variables, {a mathematical formula}m=4200 clauses, clause length {a mathematical formula}k=3, modularity {a mathematical formula}Q=0.8 and {a mathematical formula}c=10 communities. In this case, we use this reduced number of communities to improve the visualizations of results. However, similar results can be obtained with other typical values (e.g., {a mathematical formula}c=40). We remark that, even when we only plot results for a single instance, similar behaviors are observed in all instance of the family. Therefore, the conclusions drawn in this section are general. Recall that our generator, for simplicity, assigns {a mathematical formula}n/c consecutive variables to each community. For instance, community {a mathematical formula}c1 contains variables with indexes from 1 to 100 (both communities and variables are 1-based numbered). MiniSAT solved this instances in 1.9 seconds, taking 18226 decisions and finding 11722 conflicts. In Fig. 7, Fig. 8, the X-axis represents the number of conflict, and the Y-axis the index of variables. For clarity, we only plot the first 2000 conflicts. There are horizontal lines to split the set of variables belonging to each community, and vertical lines to represent the restarts along the execution.
     </paragraph>
     <paragraph>
      First, we want to know if SAT solvers concentrate their decisions on variables of the same (of few) communities along their execution. In Fig. 7 (top) we represent which variables are used to branch, i.e., the decision variables. As the X-axis represents the number of conflicts, the Y-axis shows the set of variables decided between two consecutive conflicts. We observe that the solver tends to focus its decisions on variables of the same community, during a period of time. After a while (when all variables of this community are assigned), it changes to another community. This behavior is repeated during the whole execution. The time the solver stays deciding in the same community is indeterminate, and does not depend on the restarts.
     </paragraph>
     <paragraph>
      Second, in Fig. 7 (center) we analyze the set of assigned variables. Notice that this set contains, not only decision variables, but also implied variables. We observe that all variables of the community where the solver has been focusing get assigned, and remain assigned when the solver decides to change to another community. In the next restart, all assigned variables in modules where the solver is not focused, get unassigned. For example, after 400 conflicts, a restart occurs. Before this restart, the solver was focused on community {a mathematical formula}c9, but all variables of communities {a mathematical formula}c3 and {a mathematical formula}c5 were also assigned (because the solver had also been focusing on these communities before {a mathematical formula}c9). After the restart, only variables of {a mathematical formula}c9 are assigned again. Therefore, restarting policy has the effect of reinforcing the focus of assigned variables on the same community.
     </paragraph>
     <paragraph>
      Finally, we want to study if the conflicts found by the solver relate variables of the same community. In Fig. 7 (bottom) we plot which variables appear in the 1-UIP clause learnt after analyzing the conflict. We observe that, in general, conflicts relate variables of few communities. In fact, this clause mainly contains variables of the community where the solver is focusing its last decisions, and (very) few variables of the rest. Notice that all of these variables had to be previously assigned. We also observe that in the last steps of the search (not shown in the plot), there exist many conflicts relating almost all communities.
     </paragraph>
     <paragraph>
      In a second experiment, we want to investigate the relation between the clause learning techniques used by the SAT solver and the community structure of the formula. To this purpose, we modify the solver MiniSAT with another learning strategy: the decision-induced clause learning scheme. This strategy learns the decision variables that implies the conflict (i.e., it explores the whole implication graph of the conflict till the decision nodes). This is one of the most classical learning strategies, and it was proposed in GRASP [40].
     </paragraph>
     <paragraph>
      In Fig. 8, we solve the same instance of the previous experiment using a modified version of MiniSAT with a decision-induced clause learning scheme. As for the 1-UIP schema, we represent the decision variables (top), the assigned variables (center), and the variables belonging to the learnt clause (bottom), for the first 2000 conflicts. Using this learning strategy, the solver require 157726 decisions and 113012 conflicts to solve the instance, spending a total of 23.1 seconds. Notice that this is approximately one order of magnitude slower. The reason of this experiment is to show how CDCL techniques, when used all together, help the solver to focus on particular communities along the search. On the contrary, small changes in these techniques may provoke that community structure is not explicitly considered any more, affecting thereby the overall performance of the solver. This may explain the success of these technique on benchmarks with a clear community structure, as industrial SAT instances are.
     </paragraph>
     <paragraph>
      First, we observe that the solver also tends to focus its decisions on communities with this learning strategy. However, this phenomenon is less clear than in the previous experiment. For instance, between conflicts 200 and 400, the solver is focusing on communities {a mathematical formula}c3 and {a mathematical formula}c9 at the same time. This effect can be explained with the next observation. Second, we show that many restarts have no effect on most of the assigned variables. That means that even when restarts remove the value of all assigned variables, they are re-assigned again afterward. See, for instance, community {a mathematical formula}c10: it is assigned at the beginning of the search, and it remains assigned during most of the execution. Finally, we observe that the variables belonging to the learnt clause correspond in fact to the variables of the communities where the solver was focused at the beginning of the search. Therefore, the activity of these variables are constantly increased, and hence, they are assigned once they become unassigned (i.e., after a restart). In fact, the presence of these variable in the learnt clause explains why they are re-assigned after each restart. These observations allow us to understand how the 1-UIP, in joint with the activity-based heuristics, help the solver to focus on communities, and this may explain the different performance (e.g., number of decisions and conflicts, runtime) spent to solve an industrial instance. All these effects cannot be observed if we use a formula with a low modularity because the communities are not so well delimited.
     </paragraph>
     <paragraph label="Definition 4">
      In the last experiment, we want to analyze the locality of the solver during the search. In other words, we want to measure how much the solver focuses its decisions and learnt clauses on variables of the same community. In order to quantify this locality, we introduce the following definition, inspired by the notion of modularity. Given a subset of variables {a mathematical formula}S⊆N, and a partition P of the variables {a mathematical formula}N=∪i=1cPi, we define{a mathematical formula}
     </paragraph>
     <paragraph>
      Intuitively, this definition expresses the fraction of edges between nodes of the same community with respect to the total number of edges, if we consider all possible edges between vertexes of S (including self-loops). Notice that, if all variables of S are split into r communities of same size (i.e. {a mathematical formula}|Pi∩S|=|S|/r, for {a mathematical formula}i=1,…,r, and {a mathematical formula}|Pi∩S|=0, for {a mathematical formula}i=r+1,…,c), then {a mathematical formula}locality(S,P)=1/r. Therefore, the inverse of locality measures the number of distinct communities involved in a set of variables (when all of these communities contain the same number of variables of S).
     </paragraph>
     <paragraph>
      In Fig. 9, we represent the evolution of the locality of the set of decided variables (between two conflicts), the set of assigned variables (between two conflicts), and the set of variables on the learnt clause, along the execution of the solver for the same SAT instance as in previous experiments, using as learnt clause the 1-UIP and the decisions-induced clauses. We only represent the moving average every 100 conflicts for 1-UIP and 1000 conflicts for decisions-induced clauses. We observe that in both cases, the set of decided variables is very local, close to 1. This means that all variables decided between two conflicts almost always belong to the same community. This is not the case when we analyze the set of assigned variables. In this case, the average locality over the whole execution is 0.373 for the 1-UIP strategy and 0.281 for the other learning scheme. The locality of variables on the learnt clauses has a value in between the decision and the assigned variables. However, we clearly notice that, for the 1-UIP scheme this locality (0.782 on average) is much bigger than for decision-induced clauses (0.367 on average). We also notice that when the locality of the set of assigned variables increases (after a restart, for instance), the locality of variables on the learnt clauses also increases. Therefore, it is good for the solvers performance to increase the locality of assigned variables.
     </paragraph>
     <paragraph>
      Finally, Norbert Manthey [30] reports good results on the use of our generator to train a configurable SAT solver to improve its performance. He used the pseudo-industrial random SAT instances created by our model and used in the last SAT Race 2015 [19]. This family of instances contains 44 SAT formulas generated with {a mathematical formula}n=2200 variables, {a mathematical formula}m=9086 clauses, {a mathematical formula}c=40 communities and modularity {a mathematical formula}Q=0.8. He used this set of instances to train the SAT solver Riss 5.1.0 [25] (using the configuration tool SMAC [23]). Riss is a very configurable SAT solver. Then, this configuration was used in Riss to solve the aggregated set of industrial instances used in all SAT Competitions from 2002 to 2015, and its performance was compared to the performance of the default configuration of this solver on the same set. Interestingly, the resulting configuration (i.e., from training this solver with our pseudo-industrial SAT instances) performed better than its default configuration. This suggests that our model captures a very important feature of industrial SAT problems which is, in fact, crucial in the solving process.
     </paragraph>
    </section>
    <section label="9">
     <section-title>
      Conclusions and future work
     </section-title>
     <paragraph>
      In the SAT community, it is accepted that industrial problems exhibit some kind of structure that is exploited by CDCL SAT solvers. Nowadays, one of the most intriguing questions is how to characterize this structure, with the aim of develop random SAT instances generation models that capture realistically the features of industrial problems, for SAT solving testing/analysis purposes. Recently, the notions of community structure and modularity have been used with success to explain the structure of SAT instances [9], and their hardness [36].
     </paragraph>
     <paragraph>
      We present a modularity-based generator, which generates random k-CNF SAT instances of any desired modularity. Industrial problems are characterized by a high modularity. Therefore, our model can generate more realistic pseudo-industrial random formulas on demand. We validate the adequacy of this model checking that (i) the community structure of the resulting formulas is the expected, (ii) if there exists a phase transition point dependent on the clause/variable ratio, then it is independent on the modularity, and (iii) the SAT solvers performances are consistent to the structure of the formulas generated by our model, i.e. SAT solvers specialized in industrial (random) problems perform better in high modular (low modular) instances.
     </paragraph>
     <paragraph>
      Finally, we use our generator to study how the community structure is affected by some components of the solver. Namely, we study the variables branching heuristics and the clause learning mechanism. We observe that, for a given period of time, the solver tends to focus its decisions on variables of the same community, and learns clauses mostly relating variables of this community. We also show that restarts help to unassign variables belonging to communities where the solver is no longer focused on. Therefore, the community structure of the instance plays an important role in order to explain the success of these techniques, when they are used all together. On the contrary, we see that the solver has a worse performance when it uses instead a learning strategy that does not take into account such structure, as the learning of the decision-induced clause.
     </paragraph>
     <paragraph>
      The Community Attachment model forces some features of the resulting SAT instance to be as much regular as possible. In particular, all clauses have exactly the same number of literals (i.e., k literals), all communities approximately have the same number of variables (i.e., {a mathematical formula}⌊n/c⌋ or {a mathematical formula}⌊n/c⌋+1), and all variables approximately have the same number of occurrences. This allows us to study the real impact of certain SAT solving techniques on the community structure without any undesired secondary effect. On the other hand, real application benchmarks are characterized by a certain variability in the clause size, community size, and number of variable occurrences. Therefore, some natural extensions of the Community Attachment model may consider these cases. With respect to the number of variable occurrences, a possibility would be to assign a distinct probability to each variable, as it is described in [7]. In that work, it is proved that if variable i has probability {a mathematical formula}P(i)∼i−β to be selected, then number of variable occurrences k follows a power-law distribution {a mathematical formula}P(k)∼k−α, where {a mathematical formula}α=1/β+1, and the formula is scale-free. Applying the same idea, trying to distribute variables of higher probability among distinct communities, would result into random instances with scale-free structure and high modularity, as observed in real-world instances. There are no works on the distribution of community sizes in real-world SAT instances, although we know that they have a big variability [9]. After a study in this direction, we could modify our model to assign more realistic community sizes.
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>