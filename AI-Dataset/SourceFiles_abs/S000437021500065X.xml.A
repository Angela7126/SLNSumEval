<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Skypattern mining: From pattern condensed representations to dynamic constraint satisfaction problems.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      The process of extracting useful patterns from data, called pattern mining, is an important subfield of data mining, and has been used in a wide range of applications and domains such as bioinformatics [3], chemoinformatics [4], social network analysis [5], web mining [6] and network intrusion detection [7]. Since the key papers of Agrawal et al. [8], Mannila et al. [9], a considerable number of patterns, such as itemsets, strings, sequences, trees and graphs, have been studied and used in real-world applications. Nowadays, many pattern extraction problems like subgroup discovery [10], discriminative pattern mining [11], and tiling [12] are understood from both theoretical and computational perspectives.
     </paragraph>
     <paragraph>
      Most existing pattern mining approaches enumerate patterns with respect to a given set of constraints that range from simple to complex. For instance, given a transaction database, a well-known pattern mining task is to enumerate all itemsets (i.e. sets of items) that appear in at least s transactions. However, the output of pattern mining operations can be extremely large even for moderately sized datasets. For instance, in the worst case, the number of frequent itemsets is exponential in the number of the items in the dataset.
     </paragraph>
     <paragraph>
      So far, the community has expended much effort on developing sophisticated algorithms which push the constraints deep into the mining process [13]. But also in on compression (i.e. reduction) techniques to limit the number of output patterns depending on the application contexts [14], [15], [16]. The pattern mining community, however, has paid less attention to combining mining constraints. In practice, many constraints entail choosing threshold values such as the well-used minimal frequency. This notion of “thresholding” has serious drawbacks. Unless specific domain knowledge is available, the choice is often arbitrary and may lead to a very large number of extracted patterns which can reduce the success of any subsequent data analysis. This drawback is even more pronounced when several thresholds have to be combined. A second drawback is the stringent enumeration aspect: a pattern is either above or below a threshold. But what about patterns that respect only some thresholds? Should they be discarded? It is often very difficult to apply subtle selection mechanisms. There are very few works such as [17], [18] which propose to introduce a softness criterion into the mining process. Other studies attempt to integrate user preferences into the mining task in order to limit the number of extracted patterns such as the top-k pattern mining approaches [19], [20]. By associating each pattern with a rank score, this approach returns an ordered list of the k patterns with the highest score to the user. However, combining several measures in a single scoring function is difficult and the performance of top-k approaches is often sensitive to the size of the datasets and to the threshold value, k.
     </paragraph>
     <paragraph>
      We present a unified methodology of two approaches that aim to make the results of pattern mining useful from a user-preference point of view. To this end, we integrate into the pattern discovery process the idea of skyline queries [21] in order to mine skyline patterns in a threshold-free manner. Such queries have attracted considerable attention due to their importance in multi-criteria decision making and economics where they are usually called “Pareto efficiency or optimality queries”. Briefly, in a multidimensional space where a preference is defined for each dimension, a point a dominates another point b if a is better (i.e. more preferred) than b in at least one dimension, and a is not worse than b on every other dimension. For example, a user selecting a set of patterns may prefer a pattern with a high frequency, a large length and a high confidence. In this case, we say that pattern a dominates another pattern b if {a mathematical formula}a.frequency≥b.frequency, {a mathematical formula}a.length≥b.length, {a mathematical formula}a.confidence≥b.confidence, where at least one strict inequality holds. Given a set of patterns, the skyline set contains the patterns that are not dominated by any other pattern.
     </paragraph>
     <paragraph>
      Skyline pattern mining is interesting for several reasons. First, skyline processing does not require any threshold selection. In addition, for many pattern mining applications it is often difficult (or impossible) to find a reasonable global ranking function. Thus the idea of finding all optimal solutions in the pattern space with respect to multiple preferences is appealing. Second, the formal property of dominance satisfied by the skyline pattern defines a global interestingness measure with semantics easily understood by the user. These semantics are discussed at length in the economics literature, where the Pareto efficiency is applied to the selection of alternatives in resource distributions. However, while this notion of skylines has been extensively developed in engineering and database applications, it has remained unused for data mining purposes until recently [1]. Thirdly, skyline pattern mining is appealing from an efficiency and usability point of view. The authors of [22] established a loose upper-bound on the average number of skyline tuples {a mathematical formula}O((ln⁡n)d−1) (with n tuples and d dimensions) which contrasts with the usual worst-case number of possible itemsets {a mathematical formula}O(2|I|) (where {a mathematical formula}|I| represents the cardinality of the set of items).
     </paragraph>
     <section>
      <section>
       <section>
        <section-title>
         Contributions and roadmap
        </section-title>
        <paragraph>
         We present significant extensions of our recent papers [1], [2] on the discovery of skyline patterns, or “skypatterns”. First, we detail a static method (called Aetheris) based on the theoretical relationships with condensed representations of patterns (representations which return a subset of the patterns having the same expressiveness as the whole set of patterns [23]). Second, we describe a dynamic method (called {a mathematical formula}CP+Sky) which involves a continuous refinement of the skyline constraints based on the extracted patterns. This is achieved through a dynamic CSP (Constraint Satisfaction Problems) framework (denoted by DynCSP). Third, the key notion of “skylineability” which constitutes the cornerstone of our two methods is explained in more detail. Finally, we present an extensive empirical study which includes a wide range of datasets and comparisons of our techniques. This enables us to draw some lessons about the strengths and weaknesses of each method and to better understand the advantages/weaknesses of the CSP machinery (see Sections 7.1.2 and 7.1.3).
        </paragraph>
        <paragraph>
         The rest of this paper is organized as follows. Section 2 surveys the works related to skyline pattern analysis. Section 3 introduces some basic definitions, the formal problem statement and an overview of our work. The key notion of skylineability is then studied in Section 4. Section 5 discusses the computation of condensed representation of patterns for skypattern queries. Section 6 discusses skylineability but within a DynCSP framework. We report an empirical study on several datasets and a case study from the chemoinformatics domain in Section 7. Finally, Section 8 discusses the learnt lessons.
        </paragraph>
       </section>
      </section>
     </section>
    </section>
    <section label="2">
     <section-title>
      Related work
     </section-title>
     <section label="2.1">
      <section-title>
       Pattern mining
      </section-title>
      <paragraph>
       Frequent itemset mining was first described in [8]. The problem can be defined as follows: a transaction is a subset of a given set of items {a mathematical formula}I, and a transaction database, denoted {a mathematical formula}T, is a set of such transactions. A subset x of {a mathematical formula}I is a frequent itemset in {a mathematical formula}T if the number of transactions containing x exceeds a given threshold, denoted by σ. One of the earliest findings in the data mining literature was that a mining process usually produces large collections of patterns. Many researchers have proposed methods to reduce the size of the output. These include the constraint-based pattern mining framework [24], the condensed representations [23] and the compression of the dataset by exploiting Minimum Description Length Principle [25], to name a few. A general observation is that patterns represent “fragmented knowledge”, and often there is no clear view of how these knowledge fragments interact and combine to produce a global model. Recent approaches have therefore used schemes such as pattern teams [26], constraint-based pattern set mining [27] and pattern selection strategies [28] that aim to minimize the redundancy and the number of patterns. A common theme in these studies is to select patterns from the initial large set of patterns on the basis of their usefulness in a given context. This approach falls into the general trend to produce pattern sets i.e. sets of patterns satisfying properties on the whole set of patterns [27]. Other approaches take advantage of closed patterns to maximize a specific measure such as the growth rate for emerging patterns [29] and the area for tiling [30], [12]. Often, these methods focus on optimizing a global measure on the discovered pattern set and neglect the relationships between patterns. Moreover, these approaches suffer from a lack of flexibility to express the queries requested by the analyst. For each method, the user has to understand its semantics and express queries satisfying its algorithmic properties and constraints.
      </paragraph>
      <paragraph>
       Another class of techniques considers statistical significance of patterns. The objective is to extract patterns for which a given characteristic (usually the frequency) deviates so much from its expected value under a null model that it is unlikely to have been generated by it. The frequency of a pattern is then considered as a random variable, whose distribution under the null hypothesis has to be calculated or approximated, and the significance of the pattern is assessed through a statistical test that compares the expected frequency under the null model to the observed frequency. A number of works have explored various notions of statistical significance for itemsets and have proposed novel and efficient methods for their extraction [31], [32], [33], [34].
      </paragraph>
      <paragraph>
       Pattern mining and Constraint Programming. Pattern mining benefits from the recent cross-fertilization between data mining and Constraint Programming [35], [36], [37], [18]. Constraint Programming is a general declarative methodology for solving constraint satisfaction problems. Within this framework, the user specifies in a declarative way what the problem is by using constraints rather than a method dedicated to solve the problem. Then a general solver provides the complete set of solutions satisfying all the constraints. The approach is very expressive and allows to combine a wide range of mining constraints [36].
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Skyline
      </section-title>
      <paragraph>
       The skyline points can be viewed as compromise points with respect to a given set of criteria. Skyline computation is strongly related to mathematical and microeconomics problems such as maximum vectors [38], Pareto set [39], and multi-objective optimization [40]. Since its rediscovery within the database community by Börzsönyi et al. [21], many methods have been developed for answering skyline queries that can handle various constraints in different computational environments [41], [42]. Skyline queries focus on the extraction of tuples from a given dataset and assume that all the elements are in the dataset, while the skypattern mining task consists of extracting patterns which are elements of the frontier defined by the given measures. The skypattern problem is clearly harder because the search space for skypatterns is much larger than the search space for skylines (cf. Section 3.2). Few studies focus on skypattern mining for several pattern domains (e.g., graphs and subgroups). The published approaches are designed for particular types of patterns and consider a very limited number of measures to compute the skyline of patterns. Among them, two proposals address graph analysis. In [43], the authors compute the skyline of subgraphs according to the number of vertices and the edge connectivity. Similarly, in [44], the authors adapt the framework of the “Subdue” method [45] to compute the patterns that are dominant according to three measures (e.g., frequency, number of nodes and density). In [46], the authors introduce the skypattern mining problem in the context of subgroups. Their approach aims at discovering subgroups that maximize a quality measure and a diversity measure. The notion of dominance is at the core of the skyline processing. In [47], the notion of dominance is used to propose a novel algebra extending relational algebras towards pattern mining. It leads to a generic method for mining several kinds of patterns (including the skypatterns) according to a preorder associated to the dominance relation. The solving part in [47] is performed by using Constraint Programming with a principle similar as the technique used in our {a mathematical formula}CP+Sky method (cf. Section 6.2). The key idea is to use constraints on the dominance relation, which are dynamically added during the mining process. These constraints avoid producing solutions dominated by the solutions already extracted. In [47], the dynamically added constraints ensure that a candidate solution (i) is not dominated according to the preorder corresponding to the algebra or (ii) is equivalent to a solution already found. This last condition is required since the Pareto-dominance is a strict and partial order whereas a preorder is a reflexive relation. In {a mathematical formula}CP+Sky, the dynamically added constraints stem from the dominance relation (i.e. a candidate solution is not dominated by the previous solutions). Finally, [47] does not deal with the skylineability notion which is introduced in our work. As we will see, the skylineability allows to reduce the number of measures that have to be considered in the mining process and thus decreasing the runtime. Skylineability is associated to the theoretical relationships that we establish between the skymining problem and condensed representations of patterns. Another option for preference-based processing is the top-k procedure [19], [20]. A ranking function {a mathematical formula}fr is applied to patterns, and the k best patterns with the highest score with respect to {a mathematical formula}fr are returned. As previously mentioned, this approach suffers from some limitations. The choice of k is not trivial (i.e. the horizon problem). A low value may miss useful patterns and too high a value introduces redundancy within the produced patterns (i.e. highly similar patterns). This limitation is the main motivation for the notion of the “most informative patterns” (MIP) that were proposed in [48]. MIPs can be seen as patterns that locally dominate other patterns according to a scoring function. This approach shares a similar spirit to ours as it also limits the number of enumerated patterns to a more manageable level. However, in contrast to our approach, work on MIPs includes a notion of dominance that is local and specific only to subsets of patterns.
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Problem statement and overview of the unified methodology
     </section-title>
     <paragraph>
      We introduce in this section some basic definitions and the formal problem statement. We also give an overview of the two methods Aetheris and {a mathematical formula}CP+Sky we propose. These methods fully exploit an adequate representation of patterns dedicated to user-preferences [49]. Our study is interesting for several reasons. By carefully selecting patterns that are “the best available” for a given set of preferences, we greatly reduce the output and we limit the curse of “pattern explosion”. The user is guaranteed that only the best patterns w.r.t. his criteria are present in the final result. Last but not least, our approach is threshold-free.{sup:1} Only the preferences and the dataset are required as an input.
     </paragraph>
     <section label="3.1">
      <section-title>
       Preliminary definitions
      </section-title>
      <paragraph>
       Although the problem can be formulated for any kind of pattern, for the sake of simplicity, we will illustrate our definitions using the itemset pattern domain. Section 8 discusses the computational and theoretical aspects associated with the problem when extracting more sophisticated kinds of patterns.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}I be a set of distinct literals called items, an itemset (or pattern) corresponds to a non-empty subset of {a mathematical formula}I. These patterns are gathered together in the language {a mathematical formula}L: {a mathematical formula}L=2I\∅. A transactional dataset {a mathematical formula}T is a multi-set of patterns of {a mathematical formula}L. Each element of {a mathematical formula}T, named transaction, is a database entry. Table 1a presents a transactional dataset {a mathematical formula}T where 6 transactions denoted by {a mathematical formula}t1,…,t6 are described by 6 items denoted by {a mathematical formula}A,…,F.
      </paragraph>
      <paragraph>
       All the measures discussed in this study are based on the set of primitive-based measures{a mathematical formula}M that were defined in the context of constraint-based pattern mining [50]. Table 2 presents some general definitions of measures and Table 1b gives some specific examples (gr denotes the growth rate [11], {a mathematical formula}freq∨ the disjunctive support, measures such as bond and aconf are detailed in [51]). Interestingly, our methodology is suitable for recent mining techniques utilizing statistical significance of patterns as discussed in related work. For instance, the p-value under the null model which considers all items to be independent random variables is rewritable as a primitive-based measure (see the definition of the p-value in Table 1a). As claimed in [50], {a mathematical formula}M encompasses a very large set of interesting measures.
      </paragraph>
      <paragraph>
       In addition to the classical operators of {a mathematical formula}ℜ+ (i.e. {a mathematical formula}+,−,×,/) and {a mathematical formula}L (i.e. {a mathematical formula}∪,∩,\), the function freq denotes the frequency of a pattern (i.e. {a mathematical formula}freq(x,T)=|{t∈T|x⊆t}|), and length its cardinality. The disjunctive support is {a mathematical formula}freq∨(x)=|{t∈T|∃i∈x:i∈t}|. More atypical primitives also fit the primitive-based framework like {a mathematical formula}binomial(p,i)=∑k=in(nk)pk(1−p)n−k.
      </paragraph>
      <paragraph>
       Given a function {a mathematical formula}val:I→R+, we extend it to a pattern x and denote by {a mathematical formula}x.val the multi-set {a mathematical formula}{val(i)|i∈x}. This kind of function is used with the usual SQL-like primitives sum, min and max. For instance, {a mathematical formula}sum(x.val) is the sum of val for each item of x. Note that prod is a slightly different aggregate function due to {a mathematical formula}val:I→[0,1] (e.g., the support of each item in p-value definition). Finally, f is the intension i.e. {a mathematical formula}f(T)={i∈I|∀t∈T,i∈t}, and g is the extension i.e. {a mathematical formula}g(x)={t∈Tid|x⊆t}.
      </paragraph>
      <paragraph>
       This large variety of measures allows for more flexibility to formulate new or well-known interestingness measures that match the data analyst's objectives. Rather than using a ranking function for combining these measures and then maximizing it, we propose to use the Pareto composition:
      </paragraph>
      <paragraph label="Definition 1">
       (Pareto)-dominanceGiven a set of measures {a mathematical formula}M⊆M, a pattern x dominates another pattern y with respect to M, denoted by {a mathematical formula}x≻My, iff for any measure {a mathematical formula}m∈M, {a mathematical formula}m(x)≥m(y) and there exists {a mathematical formula}m∈M such that {a mathematical formula}m(x)&gt;m(y). Two patterns x and y are said to be indistinct with respect to M, denoted by {a mathematical formula}x=My, iff {a mathematical formula}m(x) equals {a mathematical formula}m(y) for any measure {a mathematical formula}m∈M (if {a mathematical formula}M=∅, then {a mathematical formula}x=∅y). Finally, {a mathematical formula}x⪰My denotes that {a mathematical formula}(x≻My)∨(x=My).
      </paragraph>
      <paragraph>
       Note that we define the Pareto dominance only with the greater than symbol (i.e. &gt;) assuming that the end-user wants to maximize a set of measures. The case of a minimization of a measure m is equivalent to maximizing the measure {a mathematical formula}m′=−m (this case is illustrated with the definition of p-value which contains a minus).
      </paragraph>
      <paragraph>
       Consider our running example using the data set {a mathematical formula}T in Table 1a and suppose that {a mathematical formula}M={freq,area}, then the pattern ABCDEF dominates ABC because {a mathematical formula}freq(ABC)=freq(ABCDEF)=2 and {a mathematical formula}area(ABCDEF)&gt;area(ABC). Note in this case that ABCDEF is indistinct to ABC with respect to {a mathematical formula}{freq}. Similarly, suppose that {a mathematical formula}M={freq,mean,length}, the pattern AC dominates AB because {a mathematical formula}freq(AC)=freq(AB)=3, {a mathematical formula}|AB|=|AC|=2 and {a mathematical formula}mean(AC)&gt;mean(AB).
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       The skypattern mining problem
      </section-title>
      <paragraph>
       Given a set of measures M, if a pattern is dominated by another according to all measures of M, it is irrelevant and should be discarded in the output. The notion of skyline pattern, skypattern for short, formalizes this intuition.
      </paragraph>
      <paragraph label="Definition 2">
       Skypattern operatorGiven a pattern set {a mathematical formula}P⊆L and a set of measures {a mathematical formula}M⊆M, a skypattern of P with respect to M is a pattern not dominated by any pattern in P with respect to M. The skypattern operator {a mathematical formula}Sky(P,M) returns all the skypatterns of P with respect to M:{a mathematical formula}
      </paragraph>
      <paragraph>
       Then, the skypattern problem can be stated:
      </paragraph>
      <paragraph label="Problem 1">
       Given a set of measures {a mathematical formula}M⊆M, the skypattern mining problem is to evaluate the query{a mathematical formula}Sky(L,M).
      </paragraph>
      <paragraph>
       For instance, from the running data set (cf. Table 1a), {a mathematical formula}Sky(L,{freq,length})={ABCDEF,AB,AC,A}, as illustrated in Fig. 1.
      </paragraph>
      <paragraph>
       In the general case, the skypattern mining problem is challenging because of the very high number of candidate patterns (i.e. {a mathematical formula}|L|). Indeed, a naive enumeration of {a mathematical formula}L is not feasible. For example, with 1000 items a naive approach will need to compute {a mathematical formula}(21000−1)×|M| measures and then compare them. A less naive approach based on heuristics (such as the anti-monotonicity of some measures) may give some results. However, the performance will be closely tied to the underlying properties of the data sets. For instance, in the case of the frequency measure, the density of the data set plays a major role in the performance and some algorithms are not able to extract frequent patterns at very low thresholds. Nevertheless, considering the following property provides new insights into an efficient computation of skypattern queries.
      </paragraph>
      <paragraph label="Property 1">
       Given a set of measures{a mathematical formula}M⊆M,{a mathematical formula}Sky(L,M)=Sky(P,M)for any pattern set P such that{a mathematical formula}Sky(L,M)⊆P,{a mathematical formula}
      </paragraph>
      <paragraph label="Proof">
       Let P be a set of patterns such that {a mathematical formula}Sky(L,M)⊆P⊆L. First, let x be a pattern in {a mathematical formula}Sky(L,M). Then there is no {a mathematical formula}y≠x in {a mathematical formula}L such that {a mathematical formula}y≻Mx. In particular, there is no {a mathematical formula}y≠x in P such that {a mathematical formula}y≻Mx. Note that x belongs to P which is a superset of {a mathematical formula}Sky(L,M). Thus, x is a pattern in {a mathematical formula}Sky(P,M). Suppose now that x is not in {a mathematical formula}Sky(L,M): then there exists {a mathematical formula}y′≠x in {a mathematical formula}L∖P such that {a mathematical formula}y′≻Mx and {a mathematical formula}∀y″∈P, there is {a mathematical formula}y″⊁Mx. By induction, any {a mathematical formula}y′ or another pattern dominating {a mathematical formula}y′ not in P would have to be in {a mathematical formula}Sky(L,M). □
      </paragraph>
      <paragraph>
       As {a mathematical formula}Sky(L,M)⊆P⊆L and {a mathematical formula}|P|≤|L|, we argue that evaluating {a mathematical formula}Sky(P,M) is generally much less costly than evaluating {a mathematical formula}Sky(L,M) since the cost of {a mathematical formula}Sky(x,M) generally decreases with the cardinality of x. Consequently, we aim to reduce the cost of evaluating {a mathematical formula}Sky(P,M) by finding a small but relevant set P (i.e. that includes {a mathematical formula}Sky(L,M)) by means of 1) condensed representations of patterns or 2) dynamic pruning.
      </paragraph>
      <section>
       <section>
        <section-title>
         Condensed representations of patterns
        </section-title>
        <paragraph>
         In many pattern mining tasks (e.g., association rule mining or clustering), condensed representations of patterns significantly reduce the mining effort without loss of precision. Could we use this principle in the case of skypattern mining? A direct approach would be to compute a concise representation for each measure {a mathematical formula}m∈M, but this is generally not possible because some measures, such as area or length, are not condensable (i.e., the condensed representation is equal to {a mathematical formula}|L|). Therefore, our problem can be reformulated as follows: given a set of measures M, how to identify a smaller set of measures{a mathematical formula}M′which allows the computation of a concise representation on the patterns (i.e. the pattern set P) without loss of skypatterns? In addition, how can one use this set of measures to extract efficiently the skypatterns without redundancies? We address this problem in the next sections.
        </paragraph>
       </section>
       <section>
        <section-title>
         Dynamic pruning
        </section-title>
        <paragraph>
         Instead of extracting the whole condensed representation of patterns and then applying the {a mathematical formula}Sky operator. One may consider the use of the {a mathematical formula}Sky operator locally during the extraction. Indeed, as soon as a pattern is a candidate skypattern, the search space dominated by this pattern can be directly eliminated. In other words, each new candidate skypattern adds a constraint allowing to safely prune the remaining search space. These new constraints prevent the enumeration of unnecessary patterns. Section 6 describes how CSP can be used to update constraints during the extraction and thus reduce the search space.
        </paragraph>
       </section>
      </section>
     </section>
     <section label="3.3">
      <section-title>
       Unified methodology for the two methods
      </section-title>
      <paragraph>
       To clarify our methodology, we illustrate in Fig. 2 the different processes of the two methods Aetheris and {a mathematical formula}CP+Sky we propose. These two methods share the same overall methodology and mainly differ in the specific step of the computation of representative patterns of the skypatterns.
      </paragraph>
      <paragraph>
       After the user's preferences selection, in a common first step, Aetheris and {a mathematical formula}CP+Sky automatically identify a smaller set of measures {a mathematical formula}M′ which allows for the computation of a concise representation on the patterns thanks to the use of converters (cf. Section 4). The second step (respectively 2 and 2′ for Aetheris and {a mathematical formula}CP+Sky) aims at computing an as small as possible superset that enables the retrieval of all skypatterns. For that purpose, Aetheris builds a static set of representative patterns according to the set {a mathematical formula}M′, which is based on the notion of converting the initial set of preference M (cf. Section 5). {a mathematical formula}CP+Sky builds dynamically a more concise set by pruning unpromising patterns (the set of representative patterns of {a mathematical formula}CP+Sky is included in the set of representative patterns of Aetheris) (cf. Section 6). The third step filters the set of representative patterns with the {a mathematical formula}Sky operator. This step remains efficient because the number of representative patterns is much smaller than the number of possible skypatterns. Finally, this step provides a concise representation of the skypatterns. The end-user can either output this concise representation or the entire list of skypatterns as a final step depending on the application needs. Our methodology revolves around the simple idea that to be able to efficiently extract and analyze skypatterns, one needs to be able to (statically or dynamically) exhibit a concise representation of the skypatterns that will be used as an input to the skyline operator.
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Skylineability
     </section-title>
     <paragraph>
      The set of skypatterns has no good property like downward closure or convexity. Conventional techniques used to prune the pattern search space like anti-monotone properties are thus ineffective. However, using Property 1, an efficient computation of the set of representative patterns of skypatterns becomes possible. To do so, we introduce the notion of skylineability which aims at computing a reduced collection of representative patterns of the skypatterns (cf. the end of the previous section). This efficient computation is carried out using either free [16] or closed patterns [14].
     </paragraph>
     <section label="4.1">
      <section-title>
       Skylineability of a set of measures
      </section-title>
      <paragraph>
       Intuitively, skylineability refers to the notion of local extrema in the search space. The local extrema in this case are the maximal values for each preference selected by the end-user. By definition, only these extrema may therefore be skypatterns. Thus there is no need, while mining, to take into account the other patterns which are necessarily dominated by these extrema. Assume any two patterns x and y, such that {a mathematical formula}x⊂y, have the same value for each measure of {a mathematical formula}M′: {a mathematical formula}x=M′y. If y always dominates x for a given set of measures {a mathematical formula}M⊆M, then M is said to be maximally {a mathematical formula}M′-skylineable. This information is extremely important as it allows the discarding of non-maximal patterns (here, x) which are dominated by maximal patterns (here, y). This notion of skylineability can be seen as a way of mapping domination between two different sets of measures M and {a mathematical formula}M′.
      </paragraph>
      <paragraph>
       Fig. 3 (top) depicts the benefit of skylineability in the general case where it becomes possible to focus only on a subset of patterns and measures (i.e. {a mathematical formula}M′) and have a formal guarantee that these patterns will not be dominated in the full set of measures (i.e. M). We illustrate now this notion of skylineability on our running example. Let us consider patterns from {a mathematical formula}T that maximize the frequency and area measures: {a mathematical formula}M={freq,area}. In our example (cf. Table 1a), the patterns B and AB have the same frequency (see Fig. 3 (bottom)). Thus, if we define {a mathematical formula}M′={freq}, {a mathematical formula}B=M′AB and {a mathematical formula}AB≻MB because the area of AB is greater than that of B. In fact, for any two patterns {a mathematical formula}x⊂y such that {a mathematical formula}x=freqy, we have {a mathematical formula}y≻Mx and {a mathematical formula}M={freq,area} is thus said maximally{a mathematical formula}{freq}-skylineable. The mining process can focus on only extracting patterns based on the frequency measure (i.e. {a mathematical formula}M′) without having to take into account the area measure that is present in M.
      </paragraph>
      <paragraph>
       In practice, local extrema are not necessarily the longest patterns (i.e. the closed patterns which are the maximal patterns of equivalence classes) but can also be the shortest patterns (i.e. the free patterns which are the minimal patterns of equivalence classes). Thus, the concept of skylineability is defined in a dual manner:
      </paragraph>
      <paragraph label="Definition 3">
       Minimal skylineabilityGiven a set of measures {a mathematical formula}M′⊆M, a set of measures {a mathematical formula}M⊆M is said to be (strictly) minimally {a mathematical formula}M′-skylineable iff for any patterns x and y such that {a mathematical formula}x⊂y and {a mathematical formula}x=M′y, one has {a mathematical formula}x⪰My (respectively {a mathematical formula}x≻My).
      </paragraph>
      <paragraph label="Definition 4">
       Maximal skylineabilityGiven a set of measures {a mathematical formula}M′⊆M, a set of measures {a mathematical formula}M⊆M is said to be (strictly) maximally {a mathematical formula}M′-skylineable iff for any patterns x and y such that {a mathematical formula}x⊂y and {a mathematical formula}x=M′y, one has {a mathematical formula}y⪰Mx (respectively {a mathematical formula}y≻Mx).
      </paragraph>
      <paragraph>
       From the previous definitions, given a set of measures M which is maximally {a mathematical formula}M′-skylineable, if {a mathematical formula}x=M′y and {a mathematical formula}x⊃y, it is clear that x cannot be dominated by y on M. For instance, {a mathematical formula}M={freq,area} is strictly maximally {a mathematical formula}{freq}-skylineable because {a mathematical formula}area(x) strictly increases with the cardinality of x (when the frequency remains constant). Hence, in Fig. 3 (bottom), we can deduce that ABCDEF dominates the patterns ABCDE, ABCD, …, DEF without considering the full set of measures M but only {a mathematical formula}M′. Notice that {a mathematical formula}{freq} is (weakly) maximally (or minimally) {a mathematical formula}{freq}-skylineable and that {a mathematical formula}{length(x)} is strictly maximally ∅-skylineable.
      </paragraph>
      <paragraph label="Property 2">
       Given a set of measures{a mathematical formula}M⊆M, there is at least one set{a mathematical formula}M′⊆Msuch that M is minimally and maximally{a mathematical formula}M′-skylineable.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}M⊆M be a set of measures. Let {a mathematical formula}M′⊆M be the set of all unary primitives defined on {a mathematical formula}L. Let x and y be two patterns such that {a mathematical formula}x=M′y. Let {a mathematical formula}m∈M. As {a mathematical formula}x=m′y for any primitive {a mathematical formula}m′∈M′ and m is composed of such primitives, thus {a mathematical formula}x=my. We conclude that {a mathematical formula}x=My and then, {a mathematical formula}x⪰My and {a mathematical formula}y⪰Mx. □
      </paragraph>
      <paragraph>
       Property 2 is a very important result as it means that a set of measures is always skylineable (due to the fact that M is at least M-skylineable). Obviously, for a set of measures M, the smaller{sup:2}{a mathematical formula}M′, the stronger its {a mathematical formula}M′-skylineability. For instance, {a mathematical formula}{freq}-skylineability is more interesting than {a mathematical formula}{freq,area}-skylineability because area is not a condensable function [49]: there is no pair of distinct patterns x and y such that {a mathematical formula}x={freq,area}y. How to choose automatically a subset {a mathematical formula}M′ is discussed next.
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Minimal and maximal skylineable converters
      </section-title>
      <paragraph>
       One of the disadvantages of skylineability is that it depends on a set of measures {a mathematical formula}M′ whose choice is essential to effectively reduce the search space. We propose two operators to automatically build {a mathematical formula}M′ given the initial set of measures M. Basically, the construction of {a mathematical formula}M′ consists in identifying primitives that must remain constant in order that minimal or maximal patterns are always dominant patterns. Intuitively, any primitive p that is part of the measure {a mathematical formula}m∈M that hinders the {a mathematical formula}M′-skylineability of m, has to be added to {a mathematical formula}M′. For instance, it is easy to see that the frequency decreases the area because the frequency decreases with the specialization. In order that the closed patterns maximize the area, the frequency has to belong to {a mathematical formula}M′. More generally, it is essential to take into account the monotone behavior of primitives: decreasing or increasing. For instance, the length increases with x while the frequency decreases. It is also necessary to consider the operations that combine these primitives. The result of a multiplication increases when one of its operands increases. However, the result of a division decreases with its second operand. For this purpose, we define two operators denoted {a mathematical formula}c_ and {a mathematical formula}c‾ (see Table 3).
      </paragraph>
      <paragraph>
       Given a primitive-based measure {a mathematical formula}m∈M, the minimal skylineable converter returns a set of measures {a mathematical formula}M′=c_(m) guaranteeing that for any pattern {a mathematical formula}x⊂y, if {a mathematical formula}x=M′y then {a mathematical formula}m(x)≥m(y). In other words, x dominates y with respect to m. Dually, the maximal converter {a mathematical formula}c‾ guarantees that {a mathematical formula}m(x)≤m(y) for any pattern {a mathematical formula}x⊂y such that {a mathematical formula}x=c‾(m)y.
      </paragraph>
      <paragraph>
       Let us illustrate {a mathematical formula}c_ and {a mathematical formula}c‾ on the area measure. The area is defined as a product of the frequency and length. Thus, we use the first definition in Table 3. {a mathematical formula}c_(area)=c_(freq(x))∪c_(length(x))=∅∪{length(x)}={length(x)}. Symmetrically, {a mathematical formula}c‾(area)=c‾(freq(x))∪c‾(length(x))={freq(x)}∪∅={freq(x)}. The skylineable converters enable us to automatically find optimization techniques already known for specific measures such as area [30], [12], p-value [32] or growth-rate [29] (see Table 4a). We can observe that many measures are maximized by the closed itemsets according to frequency which may explain the success of closed pattern mining. But, in this work, we generalize this principle to optimize any primitive-based measures. Note that when the converter {a mathematical formula}c_ returns no measure (e.g., bond or aconf), it means that the measure decreases with respect to the specialization. Dually, {a mathematical formula}c‾(m)=∅ means that m increases with respect to the specialization.
      </paragraph>
      <paragraph>
       In practice, as the skypatterns are computed for a set of measures, we extend the minimal and maximal converters:
      </paragraph>
      <paragraph label="Definition 5">
       Minimal and maximal skylineable convertersThe minimal and maximal skylineable converters defined by Table 3 for any primitive-based measure are naturally extended to a set of primitive-based measures {a mathematical formula}M⊆M: {a mathematical formula}c‾(M)=⋃m∈Mc‾(m) and {a mathematical formula}c_(M)=⋃m∈Mc_(m).
      </paragraph>
      <paragraph>
       For instance, {a mathematical formula}c‾({freq(x),area(x)})=c‾(freq(x))∪c‾(area(x))={freq(x)} and {a mathematical formula}c_({freq(x),area(x)})=c_(freq(x))∪c_(area(x))={length(x)}. {a mathematical formula}c‾({freq(x),area(x)})={freq(x)} means that the most specific patterns (when the frequency remains unchanged) maximize the measures {a mathematical formula}{freq(x),area(x)}. The following property formalizes this observation:
      </paragraph>
      <paragraph label="Property 3">
       A set of primitive-based measures{a mathematical formula}M⊆Mis minimally{a mathematical formula}c_(M)-skylineable and maximally{a mathematical formula}c‾(M)-skylineable.
      </paragraph>
      <paragraph label="Proof">
       The key idea relies on the monotonous property according to each variable of a primitive. The operators {a mathematical formula}c_(·) and {a mathematical formula}c‾(·) are recursively applied to return the set of primitives which must be constant in order to respectively minimize or maximize the measure. Two cases arise to be sure that an expression {a mathematical formula}p(h1,…,hk) is minimized with x. For each {a mathematical formula}i∈{1,…,k}, if the primitive p increases according to the ith variable (while the other ones remain unchanged), it is necessary to return the primitives such that {a mathematical formula}hi is also minimized according to x. For this purpose, the minimal skylineable converter is applied again. Otherwise, the primitive p decreases with the ith variable and we return the primitives such that {a mathematical formula}hi is maximized by applying the maximal skylineable converter. The dual approach is used to maximize a measure. □
      </paragraph>
      <paragraph>
       In our implementation, the set of measures M is parsed through a syntax tree. Following this step, the minimal and maximal skylineable converters are recursively applied to automatically compute {a mathematical formula}c_(M) and {a mathematical formula}c‾(M) (an example is provided in Table 4b for {a mathematical formula}M={freq(x),area(x)}). This process is illustrated in Fig. 2 with the edge labeled 1. From now on, the set of measures {a mathematical formula}M′ refers to {a mathematical formula}c_(M) or {a mathematical formula}c‾(M).
      </paragraph>
     </section>
    </section>
    <section label="5">
     <section-title>
      Condensed representations of patterns for static mining of skypatterns
     </section-title>
     <paragraph>
      This section presents our static method called Aetheris based on the theoretical relationships between condensed representations of patterns and skypatterns. Aetheris follows a two-step process (cf. Section 3.3): first, a set of representative patterns is extracted and then the {a mathematical formula}Sky operator is applied on these patterns. The technique is said to be static because the extraction of a representative pattern does not depend on the patterns already extracted, contrary to the {a mathematical formula}CP+Sky method presented in the next section.
     </paragraph>
     <paragraph>
      A major issue is how to extract representative patterns for a group of skypatterns. In the previous section, we remarked that some skypatterns share exactly the same values on the whole set of measures {a mathematical formula}M′ (e.g. {a mathematical formula}B={freq}AB). This observation enables us to properly answer the question: instead of directly evaluating the skypattern query on {a mathematical formula}L, we can compute the skypatterns on a condensed representation of {a mathematical formula}L and then generate the entire set of skypatterns. To this end, we introduce the distinct operator which is at the core of the construction of a condensed representation adequate to {a mathematical formula}M′:
     </paragraph>
     <paragraph label="Definition 6">
      Distinct operatorGiven a set of measures {a mathematical formula}M′⊆M, the distinct operator for {a mathematical formula}P⊆L with respect to {a mathematical formula}M′ and {a mathematical formula}θ∈{⊂,⊃} returns all the patterns x of P such that their generalizations (or specializations) are distinct from x with respect to {a mathematical formula}M′:{a mathematical formula} where {a mathematical formula}θ∈{⊂,⊃}.
     </paragraph>
     <paragraph>
      Given a set of measures {a mathematical formula}M′, the set of free (respectively closed) patterns adequate to {a mathematical formula}M′ corresponds exactly to {a mathematical formula}Dis⊂(L,M′) (respectively {a mathematical formula}Dis⊃(L,M′)). For instance, from our running example, {a mathematical formula}Dis⊂(L,{freq})={A,B,C,D,E,F,AD,AE,BC,BD,BE,CD,CE,DE} and {a mathematical formula}Dis⊃(L,{freq})={A,D,E,AB,AC,ABCDEF}.
     </paragraph>
     <paragraph>
      We now introduce the indistinct operator that enables the retrieval of all the indistinct patterns from their representatives:
     </paragraph>
     <paragraph label="Definition 7">
      Indistinct operatorGiven a set of measures {a mathematical formula}M′⊆M, the indistinct operator returns all the patterns of {a mathematical formula}L being indistinct with respect to {a mathematical formula}M′ with at least one pattern in P.{a mathematical formula}
     </paragraph>
     <paragraph>
      For instance, from Table 1a, the set of patterns that have exactly the same frequency as patterns B or C is {a mathematical formula}Ind(L,{freq},{AB,AC})={B,C,AB,AC}.
     </paragraph>
     <paragraph>
      Preserving functions express a property of compression and are at the core of Property 4. A preserving function is a condensable primitive (many functions are preserving: freq, {a mathematical formula}freq∨, count, min, max, sum, etc., see more details in [49]).
     </paragraph>
     <paragraph label="Property 4">
      Given a set of preserving functions{a mathematical formula}M′, one has the following relation for any{a mathematical formula}P⊆Land{a mathematical formula}θ∈{⊂,⊃}:{a mathematical formula}
     </paragraph>
     <paragraph>
      In other words, the indistinct operator is the inverse function for the distinct operator. For instance, {a mathematical formula}Ind(L,{freq},Dis⊃({B,C,AB,AC},{freq}))={B,C,AB,AC}.
     </paragraph>
     <paragraph>
      These operators are the basis of an efficient technique to compute skypatterns. The key principle is to confront only distinct patterns together instead of individually comparing each pattern. Indeed, the computation of skypatterns with respect to {a mathematical formula}M={freq,area} can be limited to {a mathematical formula}Dis⊃(L,{freq}) because maximal {a mathematical formula}{freq}-skylineability guarantees us that the other patterns are not dominant patterns. For instance, as {a mathematical formula}AB=freqB, the {a mathematical formula}{freq}-skylineability of M gives {a mathematical formula}AB≻MB and B cannot be a skypattern. More formally, we know that {a mathematical formula}Sky(Ind(L,M′,Disθ(L,M′)),M)=Sky(L,M) from Property 4. Theorem 1 now proves that the skypattern operator can be pushed into the indistinct operator:
     </paragraph>
     <paragraph label="Theorem 1">
      Operational equivalenceIf a set of measures M is{a mathematical formula}M′-skylineable with respect to{a mathematical formula}θ∈{⊂,⊃}and{a mathematical formula}M′is a set of measures, then one has:{a mathematical formula}
     </paragraph>
     <paragraph label="Proof">
      Let M be a set of measures {a mathematical formula}M′-skylineable with {a mathematical formula}θ∈{⊂,⊃}.1. {a mathematical formula}Sky(L,M)⊇Ind(L,M,Sky(Disθ(L,M′),M)).Let {a mathematical formula}x∈Ind(L,M,Sky(Disθ(L,M′),M)) and {a mathematical formula}y∈L. There exist {a mathematical formula}x′∈Sky(Disθ(L,M′),M) such that {a mathematical formula}x′=Mx and {a mathematical formula}y′∈Disθ(L,M′) such that {a mathematical formula}y′=M′y and {a mathematical formula}y′⪰My (i.e. {a mathematical formula}M′-skylineability). As {a mathematical formula}x′ belongs to {a mathematical formula}Sky(Disθ(L,M′),M), it cannot be dominated by any pattern of {a mathematical formula}Disθ(L,M′): {a mathematical formula}y′⊁Mx. Thus, x is not dominated by y (i.e. x is a skyline of {a mathematical formula}L with respect to M) because {a mathematical formula}x′=Mx and {a mathematical formula}y′⪰My.2. {a mathematical formula}Sky(L,M)⊆Ind(L,M,Sky(Disθ(L,M′),M)) such that {a mathematical formula}y′=M′y and {a mathematical formula}y′⪰My. As y is a skypattern, one has {a mathematical formula}y⪰Mx′ and thus, {a mathematical formula}y′=My. Furthermore, no pattern of {a mathematical formula}Disθ(L,M′) dominates y nor {a mathematical formula}y′: {a mathematical formula}y′∈Sky(Disθ(L,M′),M). Finally, as {a mathematical formula}y′=My, y belongs to {a mathematical formula}Ind(L,M,Sky(Disθ(L,M′),M)). □
     </paragraph>
     <paragraph>
      The skypatterns of {a mathematical formula}Sky(Disθ(L,M′),M) form a condensed representation of {a mathematical formula}Sky(L,M). It is well-known that the size of adequate condensed representations (i.e. {a mathematical formula}Dis⊂(L,M′) or {a mathematical formula}Dis⊃(L,M′)) is smaller than the whole collection of patterns [23]. Thus, we have achieved our objective as mentioned in Section 3.2.
     </paragraph>
     <paragraph>
      The technique is even more efficient if the set of measures is strictly{a mathematical formula}M′-skylineable. In this case, the {a mathematical formula}Ind operator can be skipped and Theorem 1 is reduced to the following relation: {a mathematical formula}Sky(L,M)=Sky(Disθ(L,M′),M) (with {a mathematical formula}θ∈{⊂,⊃}).
     </paragraph>
     <paragraph>
      Fig. 4 illustrates the computation of the skypatterns with our method Aetheris. Suppose that {a mathematical formula}M={freq,area}, the first step applies the maximal skylineable converter on M. Then, the distinct operator preserves the closed itemsets (Step 2). The skyline operator selects the dominant patterns at Step 3 by removing D and E which are dominated by AB (i.e. {a mathematical formula}area(D)=area(E)=3&lt;area(AB)=6). Finally, the last step computes the indistinct patterns of skypatterns. Note that this step in this example is unnecessary because the area is strictly {a mathematical formula}{freq}-skylineable.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Mining skypatterns using dynamic CSP
     </section-title>
     <paragraph>
      This section describes how the skypattern mining problem can be modeled and solved by using DynCSP [52], [53]. A major advantage of this method is that it improves the mining step during the process thanks to constraints dynamically arising from the current set of candidate skypatterns. These constraints avoid producing new solutions dominated by the current skypatterns and thus reduce the search space. More precisely, each time a solution is found, a new constraint is dynamically posted. The process stops when we cannot enlarge the dominated area further (cf. Fig. 1). The set of obtained representative patterns is a subset of the set of representative patterns extracted with Aetheris (cf. Section 3.3). The completeness of our {a mathematical formula}CP+Sky method is insured by the completeness of the CSP solver. The implementation has been carried out in Gecode.{sup:3}
     </paragraph>
     <paragraph>
      The rest of this section is organized as follows. Section 6.1 recalls some general background on CSP and DynCSP. Section 6.2 describes how skypattern mining can be modeled using DynCSP. Section 6.3 presents the pattern encoding as well as the filtering that is achieved. Sections 6.4 and 6.5 are devoted to closedness constraints and freeness constraints. Finally, Section 6.6 provides an example.
     </paragraph>
     <section label="6.1">
      <section-title>
       CSP and DynCSP
      </section-title>
      <section>
       <section>
        <section-title>
         Constraint Satisfaction Problem
        </section-title>
        <paragraph>
         A CSP [54], [55]{a mathematical formula}P=(X,D,C) is defined by a finite set of variables {a mathematical formula}X={x1,x2,…,xk}, a set of domains {a mathematical formula}D which maps every variable {a mathematical formula}xi∈X to a finite set of values {a mathematical formula}D(xi) and a finite set of constraints {a mathematical formula}C.
        </paragraph>
        <paragraph>
         Algorithm 1 provides a general overview of a CSP solver. Dom and Store denote respectively the current domains and the current set of constraints. Essentially, a CSP solver consists of a depth-first search algorithm. At each node of the search tree, procedure Constraint-Search selects an unassigned variable (line 5) according to user-defined heuristics{sup:4} and assigns it a value (line 6). After that assignment, procedure Constraint-Search is called recursively (line 7). It backtracks when a constraint cannot be satisfied, i.e. when at least one domain is empty (line 2). A solution is obtained (line 9) when each domain {a mathematical formula}Dom(xi) is reduced to a singleton and all constraints are satisfied.
        </paragraph>
        <paragraph>
         The main concept used to speed-up the search is the constraint propagation by Filtering method. This method reduces the domains of variables such that they remain locally consistent. Constraint propagation operates on an individual constraint. To maintain local consistency for individual constraints, propagation rules are used. Given a constraint and the current domains of the variables in its scope, a propagator removes domain values that do not satisfy the constraint. Since variables usually participate in several constraints, the updated domains are propagated to the other constraints, whose propagators are in turn activated. This process of constraint propagation is repeated for all constraints until no more domain values can be removed or a domain becomes empty.
        </paragraph>
       </section>
      </section>
      <section>
       <section>
        <section-title>
         Dynamic CSP
        </section-title>
        <paragraph>
         A DynCSP [52], [53] is a sequence {a mathematical formula}P1,P2,…,Pn of CSPs, each one resulting from some changes in the definition of the previous one. These changes may affect every component in the problem definition: variables (additions or removals), domains (value additions or removals), constraints (additions or removals).
        </paragraph>
       </section>
      </section>
     </section>
     <section label="6.2">
      <section-title>
       DynCSP-based method for mining skypatterns
      </section-title>
      <paragraph>
       This section provides our CSP-based method {a mathematical formula}CP+Sky for mining skypatterns. As before, the representative patterns are searched according to {a mathematical formula}M′ using the skylineability principle. The key idea is to use constraints on the dominance relation, which are dynamically added during the mining process. These constraints avoid producing solutions dominated by the solutions already extracted and thus reduce the search space. We start by highlighting the way we handle DynCSP and then we provide our encoding.
      </paragraph>
      <paragraph>
       For our approach, changes between CSP {a mathematical formula}Pi and CSP {a mathematical formula}Pi+1 are only performed by adding new constraints without any removal of constraints. Additions are handled in a straightforward way with the help of filtering. Solving such a DynCSP involves solving a single CSP with additional constraints posted during search. These constraints will survive backtracking and state that next solutions should verify both the current set of constraints as well as the added ones. Each time a new solution is found, new constraints {a mathematical formula}ϕ(X) are imposed. Such constraints state that next solutions should verify both the current set of constraints Store and {a mathematical formula}ϕ(X) (cf. line 10 of Algorithm 1).
      </paragraph>
      <paragraph>
       Variable x will denote the (unknown) skypattern we are looking for. We consider the sequence {a mathematical formula}P1,P2,…,Pn of CSP where each {a mathematical formula}Pi=({x},L,qi(x)) and:{a mathematical formula}{a mathematical formula}
      </paragraph>
      <paragraph>
       First, the constraint {a mathematical formula}disθ(x) states that x must be either a closed pattern w.r.t. {a mathematical formula}M′ (i.e. {a mathematical formula}disθ(x)=closedM′(x)) or a free pattern w.r.t. {a mathematical formula}M′ (i.e. {a mathematical formula}disθ(x)=freeM′(x)). Then, the constraint {a mathematical formula}ϕi(x)≡(si⊁Mx) states that the next solution (which is searched for) will not be dominated by {a mathematical formula}si. Using a short induction proof, we can easily argue that query {a mathematical formula}qi+1(x) looks for a pattern x that will not be dominated by any of the patterns {a mathematical formula}s1, {a mathematical formula}s2, …, {a mathematical formula}si.
      </paragraph>
      <paragraph>
       Each time the first solution {a mathematical formula}si to query {a mathematical formula}qi(x) is output by Algorithm 1, we dynamically post a new constraint {a mathematical formula}ϕi(x) (see line 10) leading to a reduction of the search space. For skypatterns, {a mathematical formula}ϕi(x) states that {a mathematical formula}(si⊁Mx):{a mathematical formula}
      </paragraph>
      <paragraph>
       This process stops when we cannot enlarge the dominated area further, i.e. there exists n s.t. query {a mathematical formula}qn+1(x) has no solution. The dominated area cannot be extended and is fully established.
      </paragraph>
      <paragraph>
       But, the n extracted patterns {a mathematical formula}s1, {a mathematical formula}s2, …, {a mathematical formula}sn are not necessarily all skypatterns. Some of them could only be “intermediate” patterns simply used to enlarge the dominated area. A post processing step must be performed to filter all candidate patterns {a mathematical formula}si that are not skypatterns, i.e. for which there exists {a mathematical formula}sj ({a mathematical formula}1≤i&lt;j≤n) s.t. {a mathematical formula}sj dominates {a mathematical formula}si. So mining skypatterns is achieved in a two-step approach:
      </paragraph>
      <list>
       <list-item label="1.">
        Compute the set {a mathematical formula}S={s1,s2,…,sn} of candidates using DynCSP.
       </list-item>
       <list-item label="2.">
        Filter all patterns {a mathematical formula}si∈S that are not skypatterns.
       </list-item>
      </list>
      <paragraph>
       While the number of candidates (n) could be very large, it remains reasonably-sized in practice for the experiments we conducted (see Section 7).
      </paragraph>
      <paragraph>
       However, the order in which candidates are produced in the first step influences the way the dominated area is enlarged, and therefore the effectiveness of {a mathematical formula}CP+Sky. One way to enhance the efficiency would be to select the most beneficial order in which candidates are generated. In the case of a single measure m, we can always derive an optimal order that guarantees that any solution produced in step 1 is a skypattern, thus avoiding the need for post-processing. It suffices to generate the patterns from the largest values of m to the lowest values of m (cf. Definition 1). But in the general case where several measures are involved, finding such an optimal order is often impossible and post-processing is required.
      </paragraph>
     </section>
     <section label="6.3">
      <section-title>
       Pattern encoding and filtering
      </section-title>
      <paragraph>
       We now introduce the modeling of a pattern that can be provided to the constraint programming system. Let d—be the 0/1 matrix where, for each transaction t and each item i, {a mathematical formula}(dt,i=1) iff {a mathematical formula}(i∈t). Pattern variables are set variables represented by their characteristic function with Boolean variables. [35] and [36] model an unknown pattern x and its associated dataset {a mathematical formula}T by introducing two sets of Boolean variables:
      </paragraph>
      <list>
       <list-item label="•">
        item variables {a mathematical formula}{Xi|i∈I} where {a mathematical formula}(Xi=1) iff {a mathematical formula}(i∈x),
       </list-item>
       <list-item label="•">
        transaction variables {a mathematical formula}{Tt|t∈T} where ({a mathematical formula}Tt=1) iff {a mathematical formula}(x⊆t).
       </list-item>
      </list>
      <paragraph>
       Each set of Boolean variables aims to represent the characteristic function of the unknown pattern.
      </paragraph>
      <paragraph>
       The relationship between x and {a mathematical formula}T is modeled by posting reified constraints stating that, for each transaction {a mathematical formula}t,(Tt=1) iff x is a subset of t:{a mathematical formula}
      </paragraph>
      <paragraph>
       A reified constraint associates a 0/1 variable to a constraint reflecting whether the constraint is satisfied (value 1) or not (value 0). Such constraints are useful for expressing propositional formulas over constraints and for expressing that a certain number of constraints hold. Reified constraints do not enjoy the same level of propagation as simple constraints, but if the solver deduces {a mathematical formula}Tt=1 (resp. {a mathematical formula}Tt=0), then the sum must be equal to 0 (resp. must be different from 0).
      </paragraph>
      <paragraph>
       The propagation is also performed in the same way from the sum constraint towards the equality constraint. For example, when an item variable {a mathematical formula}Xi is set, the following propagation is applied to the reified constraints described by Eq. (1) (see [35] for more details):
      </paragraph>
      <list>
       <list-item label="•">
        if for some t, {a mathematical formula}∑i∈I(min⁡D(Xi))×(1−dt,i)&gt;0 then remove 1 from {a mathematical formula}D(Tt),
       </list-item>
       <list-item label="•">
        if for some t, {a mathematical formula}∑i∈I(min⁡D(Xi))×(1−dt,i)=0 then remove 0 from {a mathematical formula}D(Tt).
       </list-item>
      </list>
      <paragraph>
       Finally, using the Boolean encoding, it is worth noting that some measures are easy to encode: {a mathematical formula}freq(x)=∑t∈TTt and {a mathematical formula}length(x)=∑i∈IXi. So, the minimal frequency constraint {a mathematical formula}freq(x)≥θ (where θ is a threshold) is encoded by the constraint {a mathematical formula}∑t∈TTt≥θ. In the same way, the maximal size constraint {a mathematical formula}length(x)≤α (where α is a threshold) is encoded by the constraint {a mathematical formula}∑i∈IXi≤α.
      </paragraph>
     </section>
     <section label="6.4">
      <section-title>
       Closedness constraints
      </section-title>
      <paragraph>
       This section describes how to encode {a mathematical formula}closedM′(x). As an illustration, we provide the examples of {a mathematical formula}M′={min} and {a mathematical formula}M′={freq}. Recalling that thanks to skylineability, these measures also allow to handle measures such as mean, area, {a mathematical formula}growth-rate, etc. In practice, these two examples are enough for running the experiments given in Section 7.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}M′={min} and {a mathematical formula}val(j) a function that associates an attribute value to each item j. If item i belongs to x, then its value must be greater than or equal to the min. Conversely, if this value is greater than or equal to the min, then i must belong to x (if not, x would not be maximal for inclusion). Item i belongs to x is encoded as {a mathematical formula}(Xi=1). So, x is a closed pattern for the measure min iff:{a mathematical formula}
      </paragraph>
      <paragraph>
       Let {a mathematical formula}M′={freq}, the closedness constraint ensures that a pattern has no superset with the same frequency. If item i belongs to x, it is obvious that {a mathematical formula}freq(x∪{i})=freq(x). Conversely, if {a mathematical formula}freq(x∪{i})=freq(x), then i must belong to x (if not, x would not be maximal for inclusion). {a mathematical formula}freq(x) is encoded as {a mathematical formula}∑t∈TTt and {a mathematical formula}freq(x∪{i}) is encoded as {a mathematical formula}∑t∈TTt×dt,i. Finally, the constraint {a mathematical formula}closedM′(x) is encoded using Eqs. (1) and (3).{a mathematical formula}
      </paragraph>
     </section>
     <section label="6.5">
      <section-title>
       Freeness constraints
      </section-title>
      <paragraph>
       Similar to the closedness constraint, we now give two examples of encoding of the freeness constraint. Following our principle of dealing with measures used in the experiments, we give the examples of {a mathematical formula}M′={freq} and {a mathematical formula}M′={max} because applying the minimal converter {a mathematical formula}c_ on mean gives max (cf. Table 4).
      </paragraph>
      <paragraph>
       Let {a mathematical formula}M′={max} and {a mathematical formula}val(j) a function that associates an attribute value to each item j. If item i does not belong to x, then its value must be greater than or equal to the min. Conversely, if this value is greater than or equal to the min, then i cannot belong to x (if i belongs to x, x would not be minimal for inclusion). Item i does not belong to x is encoded as {a mathematical formula}(Xi=0). So, x is a free pattern for the measure max iff:{a mathematical formula}
      </paragraph>
      <paragraph>
       Let {a mathematical formula}M′={freq}, the freeness constraint ensures that a pattern has no subset with the same frequency. If item i does not belong to x, it is obvious that {a mathematical formula}freq(x∖{i})=freq(x). Conversely, if {a mathematical formula}freq(x∖{i})=freq(x), then i must not belong to x (if i belongs to x, x would not be minimal for inclusion).
      </paragraph>
      <paragraph>
       In order to encode {a mathematical formula}freq(x∖{i}), we introduce Boolean variables {a mathematical formula}Tt,i′ such that the relationship between {a mathematical formula}x∖{i} and {a mathematical formula}T is modeled by posting reified constraints stating that, for each transaction {a mathematical formula}t,(Tt,i′=1) iff {a mathematical formula}x∖{i} is a subset of t:{a mathematical formula}
      </paragraph>
      <paragraph>
       {a mathematical formula}freq(x) is encoded as {a mathematical formula}∑t∈TTt and {a mathematical formula}freq(x∖{i}) is encoded as {a mathematical formula}∑t∈TTt,i′. So {a mathematical formula}freeM′(x) is modeled using Eqs. (1) and (6).{a mathematical formula}
      </paragraph>
     </section>
     <section label="6.6">
      <section-title>
       Solving the running example using DynCSP
      </section-title>
      <paragraph>
       We now illustrate {a mathematical formula}CP+Sky on the running example in Table 1a with {a mathematical formula}M={freq,area}. We use the maximal converter {a mathematical formula}c‾ and thus the closedness constraint. As {a mathematical formula}c‾(area)=freq, we get {a mathematical formula}M′={freq}. Fig. 5 depicts the various steps of the resolution.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}P1 be the associated DynCSP (see Section 6.2). {a mathematical formula}P1=({x},L,q1(x)) where query {a mathematical formula}q1(x)=closedM′(x). Its first solution is pattern {a mathematical formula}s1=ABCDEF (with {a mathematical formula}freq(s1)=2 and {a mathematical formula}area(s1)=12), cf. Fig. 5a. So, we consider query {a mathematical formula}q2(x)=closedM′(x)∧(s1⊁Mx) stating that we are looking for a closed pattern x not dominated by {a mathematical formula}s1=ABCDEF. Its first solution is pattern {a mathematical formula}s2=AB (with {a mathematical formula}freq(s2)=3 and {a mathematical formula}area(s2)=6), cf. Fig. 5b. Then, the next query is {a mathematical formula}q3(x)=closedM′(x)∧(s1⊁Mx)∧(s2⊁Mx) stating that we are looking for a closed pattern x neither dominated by {a mathematical formula}s1 nor {a mathematical formula}s2. Its first solution is pattern {a mathematical formula}s3=AC (with {a mathematical formula}freq(s3)=3 and {a mathematical formula}area(s3)=6), cf. Fig. 5c. The next query is {a mathematical formula}q4(x)=q3(x)∧(s3⊁Mx) whose first solution is {a mathematical formula}s4=A (cf. Fig. 5d) and then query {a mathematical formula}q5(x)=q4(x)∧(s4⊁Mx). {a mathematical formula}q5(x) has no solution since the dominated area cannot be enlarged further and the process ends at {a mathematical formula}n=5.
      </paragraph>
      <paragraph>
       In this example, note that all extracted patterns are skypatterns (i.e. there are no intermediate patterns). The CSP system did not generate solutions that do not satisfy the dominance relation. Experiments in the next section provide examples with intermediate patterns.
      </paragraph>
     </section>
    </section>
    <section label="7">
     <section-title>
      Experiments
     </section-title>
     <paragraph>
      We first report an experimental study on several UCI benchmarks (see Section 7.1). We then discuss the practical use of skypatterns in a chemoinformatics case study (see Section 7.2). All experiments were conducted on a personal computer running a Linux operating system with an i3 core processor with a clock speed of 2.13 GHz and 4 GB of RAM. The implementation of Aetheris refers to [1]. The implementation of {a mathematical formula}CP+Sky was carried out in Gecode. All source codes and data sets are publicly available at https://forge.greyc.fr/projects/skymining/files.
     </paragraph>
     <paragraph>
      Note that it was shown in [1] that Aetheris always outperforms a baseline approach by at least a factor of 10. In addition, the collection of skypatterns is always much smaller than the collection of patterns returned by an optimal constraint-based approach (i.e. assuming that an ideal end-user is able to perfectly set the thresholds and then run a usual constraint-based mining method). Therefore, this empirical study focuses on the comparison between Aetheris and {a mathematical formula}CP+Sky.
     </paragraph>
     <section label="7.1">
      <section-title>
       Experiments on UCI benchmarks
      </section-title>
      <section label="7.1.1">
       <section-title>
        Experimental protocol
       </section-title>
       <paragraph>
        We focused on 23 different (in terms of dimensions and density{sup:5}) datasets (see the left column in Table 5) from the UCI{sup:6} repository. We considered the set of measures {a mathematical formula}M={freq,max,area,mean,growth-rate} and selected 6 subsets: {a mathematical formula}M1={freq,area,mean,growth-rate}, {a mathematical formula}M2={freq,max,area,growth-rate}, {a mathematical formula}M3={freq,max,area,mean}, {a mathematical formula}M4={freq,max,mean,growth-rate}, {a mathematical formula}M5={max,area,mean,growth-rate} and {a mathematical formula}M6=M. Measures using numeric values, like mean or max, were applied to randomly generated attribute values (within the range {a mathematical formula}[0,1]).
       </paragraph>
       <paragraph>
        For each method, we report the CPU-time and the number of skypatterns for every query on the selected set of measures. Note that Aetheris first computes the set of closed patterns{sup:7} w.r.t. {a mathematical formula}M′ and then applies the {a mathematical formula}Sky operator on the extracted collection. On the other hand, {a mathematical formula}CP+Sky does not mine closed patterns as a first step but instead computes a small set of candidates using DynCSP and then applies the {a mathematical formula}Sky operator. For each method, the reported CPU-times include the different processing steps. We also report for each dataset the size of the condensed representation w.r.t. {a mathematical formula}M′ and the number of candidates to respectively analyze the behaviors of Aetheris and {a mathematical formula}CP+Sky.
       </paragraph>
      </section>
      <section label="7.1.2">
       <section-title>
        Performance analysis
       </section-title>
       <section>
        <section-title>
         A general overview
        </section-title>
        <paragraph>
         Table 5 provides the results of CPU-times for {a mathematical formula}CP+Sky and Aetheris for 138 skypattern queries ({a mathematical formula}23×6). We report for each dataset and for every collection of measures{sup:8}:
        </paragraph>
        <list>
         <list-item label="•">
          the number of skypatterns (the largest output is 478),
         </list-item>
         <list-item label="•">
          with {a mathematical formula}CP+Sky: the number of candidates and the associated CPU-time,
         </list-item>
         <list-item label="•">
          with Aetheris: the number of closed patterns and the associated CPU-time.
         </list-item>
        </list>
        <paragraph>
         Table 5 indicates that {a mathematical formula}CP+Sky and Aetheris run within the same order of magnitude. On 16 datasets out of 23, CPU times for both {a mathematical formula}CP+Sky and Aetheris are very small (less than 30 seconds). The results of the 7 remaining data sets are analyzed in more detail to highlight the differences and limitations of our proposed methods.
        </paragraph>
       </section>
       <section>
        <section-title>
         A more detailed analysis
        </section-title>
        <paragraph>
         Fig. 6 depicts a scatter plot of CPU-times for {a mathematical formula}CP+Sky and Aetheris. Each point represents a skypattern query for one of the 7 selected datasets: its x-value (log-scale) is the CPU-time obtained with {a mathematical formula}CP+Sky, its y-value (log scale) the CPU-time with Aetheris. A specific color is associated to each dataset. The line {a mathematical formula}y=x draws the case where Aetheris and {a mathematical formula}CP+Sky have the same CPU-times. Most of the points are above this line, which means a longer runtime for Aetheris. With all the measures (i.e. {a mathematical formula}M6), the speed-up is 1.9 (resp. 1.53) on hypo (resp. german). The only exception is the mushroom dataset.
        </paragraph>
        <paragraph>
         Another interesting result provided by Table 5 is the number of closed patterns extracted by Aetheris in comparison with the number of candidates generated by {a mathematical formula}CP+Sky. The number of candidates remains small (in the thousands) compared to the number of closed patterns (in millions). Fig. 7 illustrates this particular result for the selected datasets. It reports for each set of measures {a mathematical formula}Mi ({a mathematical formula}i∈[1,6]) and the 7 datasets investigated in Fig. 6, the number of closed patterns, the number of candidate patterns and the number of skypatterns (both methods). This figure highlights the discrepancy between the methods with the distinct lower number of representative patterns required by {a mathematical formula}CP+Sky in comparison to the Aetheris method.
        </paragraph>
        <paragraph>
         Table 6 shows an in-depth comparison of the CPU-times for the two steps performed by {a mathematical formula}CP+Sky and Aetheris for the set of measures {a mathematical formula}M6. The second (i.e. the post-processing) step is the same for both methods and is performed using the same classical algorithm: the BNL approach [21]. The time complexity of this approach is {a mathematical formula}O(n2) where n is the number of representative patterns generated in the first step. These results clearly show that {a mathematical formula}CP+Sky takes less time than Aetheris to generate the representative patterns. This is in part explained by the huge number of closed patterns that Aetheris needs to post-process. This drawback does not exist for {a mathematical formula}CP+Sky because the number of candidates remains small and thus, the post-processing step is negligible. The only exception is for the mushroom dataset, where Aetheris is very efficient.
        </paragraph>
       </section>
      </section>
      <section label="7.1.3">
       <section-title>
        Summary
       </section-title>
       <paragraph>
        No method is constantly better on all datasets. {a mathematical formula}CP+Sky usually generates a low number of candidates compared to Aetheris. The numbers of candidates and closed patterns seem to provide an appropriate explanation of the performances of the two methods. However, they only constitute simple indicators and do not take into account other evidence. For instance the results on the mushroom dataset may seem surprising and counter-intuitive. Even if the number of candidates (14,599) is low compared to the number of closed patterns extracted from this dataset (1,153,229), Aetheris is more efficient than {a mathematical formula}CP+Sky.
       </paragraph>
       <paragraph>
        The mushroom dataset (which is the largest UCI dataset both in terms of transactions and items) has the lowest density (around 18%), which implies that its number of closed patterns is small w.r.t. its size. The same reasoning also applies for the number of candidates. In this case, the size of the set of constraints is important, as there are as many reified constraints as transactions (cf. Section 6.3). So, filtering takes much more time to generate the candidates. For this dataset, it is more efficient to compute the closed patterns and filter them, even if they are more numerous.
       </paragraph>
       <paragraph>
        Following the mushroom dataset analysis, we investigated the notion of density and its impact on the performances of our two methods by generating several datasets and varying their density from 0.15 to 0.65 (we kept the numbers of items and transactions similar to the mushroom dataset). Fig. 8 shows the evolution of CPU-times according to the density for both methods. As the items in the data are randomly generated to provide the density value, the number of closed patterns increases according to the density. Thus, the running time of Aetheris also increases according to this parameter. The behavior of {a mathematical formula}CP+Sky is more complex due to the dynamic pruning. Having more candidate skypatterns is a benefit if these patterns are able to prune significantly the search space. The experimental study shows a good trade-off with a density close to 0.5 (note that in practice there are very few real-world datasets with a density higher than 0.5).
       </paragraph>
       <paragraph>
        We also performed experiments on other data sets from the UCI repository, such as the chess (75 items, 3196 transactions, density 0.49) and the connect data sets (129 items, {a mathematical formula}67,557 transactions, density 0.33). However, we were not able to complete the skypattern mining process. Aetheris was not able to complete the closed pattern mining step on either data set. For {a mathematical formula}CP+Sky, the first step of candidates generation took approximatively 20 hours and generated more than 40 million candidates for the chess dataset. The application of the sky operator failed because of the quadratic complexity (i.e. {a mathematical formula}O(n2)) of the BNL method. The experiments on the connect dataset with {a mathematical formula}CP+Sky were aborted after more than 24 hours of computation.
       </paragraph>
      </section>
     </section>
     <section label="7.2">
      <section-title>
       Case study: discovering toxicophores
      </section-title>
      <paragraph>
       A major issue in chemoinformatics is to establish relationships between chemicals and their activity in (eco)toxicity. Chemical fragments{sup:9} which cause toxicity are called toxicophores and their discovery is at the core of prediction models in (eco)toxicity [56]. The aim of this study, which is part of a larger research collaboration with the CERMN Lab, is to investigate the use of skypatterns for discovering toxicophores.
      </paragraph>
      <section label="7.2.1">
       <section-title>
        Experimental protocol
       </section-title>
       <paragraph>
        The dataset was collected from the ECB web site.{sup:10} For each chemical, the chemists have associated it with hazard statement codes (HSC) in 3 categories: H400 (very toxic, CL50 ≤ 1 mg/L), H401 (toxic, 1 mg/L &lt; CL50 ≤ 10 mg/L), and H402 (harmful, 10 mg/L &lt; CL50 ≤ 100 mg/L). We focus on the H400 and H402 classes. The dataset {a mathematical formula}T consists of 567 chemicals (transactions), 372 from the H400 class and 195 from the H402 class. The chemicals are encoded using 1450 frequent closed subgraphs (items) previously extracted{sup:11} with a 1% relative frequency threshold. Therefore, the extracted skypatterns correspond to sets of chemical fragments, which are represented by frequent closed subgraphs [57].
       </paragraph>
       <paragraph>
        Discovering candidate toxicophores is similar to supervised descriptive rule discovery [11], and or learning classification rules, and we therefore use growth rate as a contrast measure. Indeed, when a pattern's frequency strongly increases from class H402 to class H400, it can be considered a potential structural alert related to toxicity. If a compound includes several such fragments in its graph structure, it is more likely to be toxic. Emerging patterns model this idea using the growth rate measure. On the other hand, real-world datasets are often noisy and patterns with low frequency may be artefacts. We also use the frequency measure to ensure the representativeness of the patterns (i.e. the higher the frequency, the better).
       </paragraph>
       <paragraph>
        The skypattern framework makes it possible to integrate measures coming from the background domain. In ecotoxicity, chemists know that the aromaticity measure is a chemical property that favors toxicity since their metabolites can lead to very reactive species which can interact with biomacromolecules in a harmful way (the higher the aromaticity, the higher the toxicity hypothesis). The chemical knowledge provides the aromaticity of the chemical fragments and we compute the aromaticity of pattern as the mean of the aromaticity of its chemical fragments.
       </paragraph>
       <paragraph>
        We tested several combinations of measures: {a mathematical formula}M1={growth-rate,freq}, {a mathematical formula}M2={growth-rate,aromaticity}, {a mathematical formula}M3={freq,aromaticity} and {a mathematical formula}M4={growth-rate,freq,aromaticity}.
       </paragraph>
      </section>
      <section label="7.2.2">
       <section-title>
        Performance analysis
       </section-title>
       <paragraph>
        Table 7 reports, for each set of measures {a mathematical formula}Mi∈[1..4]: (i) the number of skypatterns, (ii) for {a mathematical formula}CP+Sky, the number of candidates and the associated CPU-time and (iii) for Aetheris, the number of closed patterns and the associated CPU-time. {a mathematical formula}CP+Sky outperforms Aetheris in term of CPU-times. Moreover, the number of candidates for {a mathematical formula}CP+Sky is drastically smaller than the number of closed patterns computed by Aetheris. It clearly shows the usefulness of filtering via the dynamically posted constraints.
       </paragraph>
      </section>
      <section label="7.2.3">
       <section-title>
        Qualitative analysis
       </section-title>
       <paragraph>
        We now analyze the skypatterns qualitatively by comparing them with well-known environmental toxicophores [58]. With the growth rate and frequency measures (i.e. {a mathematical formula}M1), only 8 skypatterns are found, among those we have emphasized 3 well-known toxicophores. Fig. 9a depicts these skypatterns denoted {a mathematical formula}Pi, one of them is on the y-axis. Two of them are components of widespread pesticides, namely the chloro-substituted aromatic ring ({a mathematical formula}P1: {Clc}) and organo-phosphorus moiety ({a mathematical formula}P3: {OP, OP=S}). The third one, the phenol ring ({a mathematical formula}P2: {c1(ccccc1)O}) is related to hydrophobocity and formation of free radicals [59].
       </paragraph>
       <paragraph>
        The most interesting results follow from the addition of the background knowledge. Indeed, adding the aromaticity measure leads to skypatterns with novel chemical characteristics. We discuss the results obtained with the growth rate, frequency and aromaticity measures (i.e. {a mathematical formula}M4). Once again, the whole set of skypatterns remains small and can lends itself to straight-forward analysis. 21 skypatterns are mined (see Fig. 9b). To simplify the picture, the {a mathematical formula}Si denote sets of skypatterns sharing a common chemical feature. The figure emphasizes several environmentally hazardous chemical fragments: the phenol ring ({a mathematical formula}S4), the chloro-substituted aromatic ring ({a mathematical formula}S3), the alkyl-substituted benzene ({a mathematical formula}S2), and the organophosphorus moiety ({a mathematical formula}P1). Besides, information dealing with nitrogen aromatic compounds is also extracted ({a mathematical formula}S1). The comparison of this list of patterns with jumping emerging fragments (JEF) extracted from previous experiments [60] highlights the generalization potency of the skypatterns. As an example, the organophosphorus moiety skypattern is a generalization of around 90 JEFs and can be seen as a kind of maximum common structure (i.e. consensus structure) of these fragments.
       </paragraph>
       <paragraph>
        The main result of the study concerns the chemical interpretation of the outputs. Indeed, the generalization capability of the skypatterns leads to a reduced list of potential toxicophores easily interpretable by the chemists (cf. Fig. 10). Even if the skypattern process is complete with respect to the user preferences and the dataset, the proposed list of toxicophores depends on the composition of the used dataset and the measures. We cannot hope to discover all the ecotoxicological structural alerts in one pass, because we cannot expect that all the structural alerts are present in a single dataset. But any progress in the discovery of potential toxicophores is a valuable step. The method can suggest new compounds as toxicophores, i.e. toxicophores which were previously unknown. Further in vitro experiments are required to validate such candidate toxicophores.
       </paragraph>
       <paragraph>
        Note that adding the p-value as a measure in order to provide a statistical significance in the skypatterns does not change the results in this experiment. Indeed, p-value is maximized by the closed patterns adequate to frequency and with the set of measures {a mathematical formula}M5={growth-rate,freq,aromaticity,p-value} only the aromaticity leads to another closed patterns. Out of curiosity, we ran the experiment with {a mathematical formula}M5 and we get 28 skypatterns instead of 21 with {a mathematical formula}M4 (the 21 skypatterns extracted with {a mathematical formula}M4 are still skypatterns with {a mathematical formula}M5). There are no significant new insights from a chemical point of view.
       </paragraph>
      </section>
     </section>
    </section>
    <section label="8">
     <section-title>
      Conclusion and perspectives
     </section-title>
     <paragraph>
      In this paper, we investigate in detail the skyline pattern mining problem by studying the theoretical relationships between condensed representations of patterns and skypatterns. Based on the concept of skylineability, we have devised the static method Aetheris and the dynamic method {a mathematical formula}CP+Sky. Aetheris exploits the condensed representations of patterns to provide a proper superset of skypatterns on which to apply the {a mathematical formula}Sky operator. {a mathematical formula}CP+Sky iteratively refines the skyline constraints using the extracted patterns. This leads to better pruning of the search space. Our approach generates the complete set of skypatterns in a generic manner (i.e. with a large set of measures that includes statistical assessments such as the p-value). The practical goal is to make the result of pattern mining useful from a user-preference point of view. One strength of the approach lies in the fact that no threshold has to be set, the end-user only needs to specify as input the dataset and the set of measures she is interested in.
     </paragraph>
     <paragraph>
      An extensive empirical study as well as a case study from chemoinformatics show the efficiency and effectiveness of our two algorithms according to both quantitative and qualitative aspects. Despite the gain in generality brought by the CSP framework and the fact that Aetheris benefits from the pruning strategies based on the anti-monotonicity to extract patterns, {a mathematical formula}CP+Sky competes with Aetheris and even outperforms it in some cases. However, with {a mathematical formula}CP+Sky, the search order of the patterns may significantly impact the efficiency of the CSP solver. Investigating the most beneficial order in which patterns are enumerated is a promising research direction to maximize the effectiveness of the strategy of dynamically posting constraints.
     </paragraph>
     <paragraph>
      Skypattern mining can generally be applied to a wide range of problems by adapting either the language or the dominance relation. For instance, the language of sequences or graphs can also produce skypatterns. The dominance relation can be changed or extended to take into account different other criteria for user-preferences. We sketch now these two issues.
     </paragraph>
     <section>
      <section>
       <section>
        <section-title>
         Language
        </section-title>
        <paragraph>
         Our formalization, and especially the skylineability notion, is general enough to be applied to a large set of languages (sequences, trees and graph for instance). However, a change in the language can impact the efficiency of the extraction methods. Regarding Aetheris, the efficiency of the approach is based on Theorem 1 involving the distinct and indistinct operators. As aforementioned, with itemset patterns and the frequency measure, the distinct operator corresponds to the well-known closed or free condensed representations of frequent patterns. Consequently, the efficient extraction of skypatterns for more complex languages (i.e. skyline sequential patterns or skyline graph patterns) is strongly tied to the advances and progress on complex condensed representations of patterns.
        </paragraph>
        <paragraph>
         Evaluating the distinct operator on more complex patterns efficiently such as sequences, trees and graphs implies additional challenges. To cite one, in the case of sequences, convenient properties such as the free patterns apriori property[61], which implies effective search space pruning, cannot be used. However, there are already many methods of extraction dedicated to closed sequential patterns, closed graphs and so on. Extending {a mathematical formula}CP+Sky to other languages is a challenging task due to the difficulty of modeling complex patterns. To the best of our knowledge, only certain types of pattern in sequence mining have been successfully studied [62], [63].
        </paragraph>
       </section>
       <section>
        <section-title>
         Dominance relation
        </section-title>
        <paragraph>
         The dominance relation contains two components: the measures for which basic preferences are expressed (e.g., frequency, area) and the combination of these basic preferences (here, the Pareto composition). Primitive-based measures are flexible enough to allow the user to express a wide variety of criteria. Indeed, classical interestingness measures for pattern mining (such as frequency, growth rate), utility functions and measures of statistical significance (like the p-value) fall within this framework. Of course, Aetheris, as mentioned above, depends again on condensed representations that are well-adapted for the desired measures. Conversely, all interestingness measures are easily expressible with {a mathematical formula}CP+Sky. Through its declarative nature, {a mathematical formula}CP+Sky offers via CSP a very flexible way to change the dominance relationship. For instance the strict dominance (i.e. a pattern is dominated by another pattern when the latter has a better value for all measures in M), is easily configurable with CSP and this relaxation of the dominance relation leads to the mining of soft-skypatterns [2].
        </paragraph>
       </section>
       <section>
        <section-title>
         Exploratory skypattern mining
        </section-title>
        <paragraph>
         We think that the skypattern mining is particularly well suited to exploratory research. Indeed, a strength of our approach is to propose a reduced collection of patterns to the data expert who can quickly analyze it. It would be interesting to integrate the user feedbacks to make skypattern mining more iterative and more exploratory. An interesting avenue is to offer an interactive way to refine the preference criteria by computing the skypattern cube according to all possible subsets of measures [64] and then assist the user with an intuitive navigation. We claim that the skypattern cube exploration will provide a better understanding of the impact of the measures on the problem at hand. Other kinds of interactions are also possible, such as discarding a skypattern to reveal patterns that were previously dominated and could become interesting.
        </paragraph>
       </section>
      </section>
     </section>
    </section>
   </content>
  </root>
 </body>
</html>