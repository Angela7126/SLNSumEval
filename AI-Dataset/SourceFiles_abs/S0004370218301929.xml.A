<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    LARS: A Logic-based framework for Analytic Reasoning over Streams.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      During the last decade, stream reasoning[40], [81] emerged as research topic from stream processing[98], [12] to address the semantic level of querying continuously changing data. The increasing amount and availability of data from sensors, networks, mobile devices, etc., has contributed to a shift in information processing from pulling static data on request to continuous pushing as soon as it is available. Many applications that deal with such potentially infinite streams of data make use of window operators to select recent snapshots of the unbounded input. Typical windows are obtained based on time or by counting tuples; they may progress instantly, or in larger steps. Window mechanisms have shown to be a useful ingredient in stream processing and reasoning for multiple reasons. First, some form of data limitation is often needed for pragmatic purposes, i.e., to cope with the amount of information. Second, employing windows permits to view streams as sequence of relations, i.e., as database. This allows for reusing available tools for processing static data. Third, many real-time use cases are inherently only concerned about the recent past, as the next example illustrates.
     </paragraph>
     <paragraph label="Example 1">
      To monitor a city's public transportation, the city traffic center has a static background data set for the assignment of trams and buses to lines of the form {a mathematical formula}line(ID,L), where ID is the identifier of a tram or bus and L the line identifier. The planned traveling time (duration D) between stops X and Y with line L is stored by rows {a mathematical formula}plan(L,X,Y,D). Facts of the form {a mathematical formula}old(ID) classify old trams which are inconvenient for traveling with baby strollers. Moreover, sensor data {a mathematical formula}tram(ID,X), {a mathematical formula}bus(ID,X) and {a mathematical formula}jam(X) report the appearance of trams, buses (with identifier ID) and traffic jams at stop X, respectively. Based on this, reports on the traffic status and suggested updates for travel routes shall be provided in real time. Consider Bob traveling with his baby on line {a mathematical formula}ℓ3 (Fig. 1(a)). He is currently at Haydn Street (h) and wants to go to Strauß Avenue (s), so he has different options to change trams at Mozart Circus (m). He wants to know (i) tram that (ii) is convenient for the stroller. Fig. 1(b) depicts arrival times, e.g., {a mathematical formula}tram(a1,b) at {a mathematical formula}t=36 represents that tram {a mathematical formula}a1 arrived at stop Beethoven Square at minute 36. Furthermore, consider the following background data tables, which specify the planned travel time between stops (plan), the association between lines and their trams (line), and which trams are old and thus ill-suited for strollers (old):{a mathematical formula} Based on this input stream and the static background data, we expect the following reports:
     </paragraph>
     <list>
      <list-item label="(1)">
       Tram {a mathematical formula}a1 is expected to arrive at m at time 44, and {a mathematical formula}a3 should arrive at m one minute earlier, i.e., at minute 43.
      </list-item>
      <list-item label="(2)">
       Switching from line {a mathematical formula}ℓ3 to {a mathematical formula}ℓ1 at m satisfies the short waiting time requirement. However, since tram {a mathematical formula}a1 is old, it is not a good connection with the stroller.  □
      </list-item>
     </list>
     <paragraph>
      Different research communities have contributed to aspects of reasoning over data streams, with different focus (see also [41]):
     </paragraph>
     <paragraph>
      – In the area of Data Stream Management Systems (DSMS), the focus is typically on “low-level” stream processing, i.e., queries on data that arrives at high input rate. Such queries are centered around cross-joins of data, elementary pattern matching, etc. Performance and scalability are important criteria, which have led to windows as a key means to deal with large data volumes, taking also physical implementation design (buffers, etc.) into account. Particularly influential work in this area has been the Stanford Data Stream Management System (STREAM) [9] and its continuous query language (CQL) [10], [11]. It extends SQL with window operators and essentially reduces the semantics of stream processing to SQL-based queries over obtained snapshots.
     </paragraph>
     <paragraph>
      – In Knowledge Representation and Reasoning (KR&amp;R), the approaches aim at stream reasoning, where implicit information is elicited from data in the input stream and a background knowledge base, represented for instance in a Description Logic or as a logic program. The focus is naturally put on higher-level (abstracted) information and lower-rate input streams. Often, stream reasoning is viewed as temporal reasoning over a sequence of knowledge bases extended with data. Windows or snapshots have not yet played a prominent role, or are limited to very restrictive forms, cf. [44], [65], [102], [94], [86].
     </paragraph>
     <paragraph>
      – In the Semantic Web area, the Linked Data movement has been striving to lift stream data to a semantic level. To this end, linked stream data aims at coupling tuples with timestamps, in order to facilitate temporal data processing. Similarly as CQL extends SQL, several proposals have been made to add window mechanisms to SPARQL, the standard query language for RDF data. These works include, e.g., C-SPARQL [14], CQELS [88], and {a mathematical formula}SPARQLStream[30]. The semantics of according queries is typically given only informally or on an operational basis, hiding potentially significant differences in results behind similar syntax. In fact, comparisons of these languages have been geared towards high data frequency and mere output volume of queries (i.e., number of tuples) than concrete tuples (i.e., contents), not their semantics.
     </paragraph>
     <paragraph>
      Motivation for a formal framework. The developments sketched above yield a landscape of different approaches for stream reasoning. While they often share conceptual ideas, their exact commonalities and differences remain unclear without a common theoretical underpinning, in which its declarative semantics may be expressed, analyzed, and compared. This impression was reinforced in a large workshop on stream reasoning held in Vienna, November 2015,{sup:1} where opinions even diverged on how to discriminate stream reasoning from stream processing; whether stream reasoning is more general than stream processing or vice versa, or whether declarative (model-based) vs. operational (code-based) definitions of semantics should play a role. The lack of theoretical underpinnings for stream reasoning has been observed already in [40]. In particular, the authors propose that a theoretical framework for stream reasoning must combine two aspects: first, it has to serve as basis for explicit formal semantics, and, second, it must account for high-throughput, i.e., frequency and volume of data.
     </paragraph>
     <paragraph>
      From a theoretical perspective, the trade-off between expressiveness and scalability is evident. In particular, some portions of the data might have a higher frequency and volume than others, and the potential difficulty of reasoning does not imply that all operations are highly complex. A theoretical foundation for stream reasoning should thus aim at covering the entire spectrum, i.e., provide means to express both semantically trivial real-time computations as well as complex reasoning tasks that are necessarily slower; possibly within the same query or program. This can only be achieved by a modular system, where the mechanisms to handle streams (like window operators for deliberate information loss) can be used in a generic and compositional way.
     </paragraph>
     <paragraph>
      Regarding the expressiveness, a rich framework should encompass advanced reasoning features as available in KR&amp;R. In particular, this includes intensional data definitions, i.e., the ability to abstract from (extensional) input data. Moreover, nonmonotonicity is of special relevance in stream reasoning, since conclusions may have to be retracted due to later arrival of previously missing information (e.g., in case of defaults) or contrary evidence (in case of contradictions). Next, model generation as in SAT solving and Answer Set Programming (ASP) are useful when tackling domains which permit multiple solutions. Such features and according techniques have been studied almost exclusively on static data, where in particular extensions of Datalog [33] play a prominent role. Zaniolo [102] already noted a lack of logical foundation for DSMS. We aim here at providing one for stream reasoning with generic windows.
     </paragraph>
     <paragraph>
      Contributions. Based on the above considerations, we have conceived LARS, a Logic-based Framework for Analytic Reasoning over Streams. Our contributions can be briefly summarized as follows.
     </paragraph>
     <paragraph>
      – Modeling streams and windows. As a basis for a declarative semantics, we provide a formal model of streams and a generic notion of window function that can be applied to streams; our notion can be instantiated to a plethora of window functions that are used in practice, including time-based windows (where data is selected based on temporal constraints), tuple-based windows (selection on order constraints), and partition-based windows (selection by a mix of order and semantic information), and filter windows (semantics information). Notably, the result of applying a window to a stream yields a substream, such that window functions can be composed (i.e., nested). This allows one to express complex data snapshots, based on a repertoire of selections that are available. In turn, composed data selections can be abstractly viewed as a single selection by a respective window function.
     </paragraph>
     <paragraph>
      – LARS language. The LARS framework provides two languages for reasoning over streams, referred to as LARS formulas and LARS programs respectively. The former language is the monotone core of LARS, i.e., a first-order formalism to reason over extensional data only. Inspired by the way how data in stream processing is handled, the central entailment definition extends propositional logic by novel operators (i) to limit data by generic window operators, and (ii) to specify a temporal modality of formulas within obtained snapshots. That is to say, LARS formulas express validity at some, all, or specific time points in a window. The propositional core is then considered also in a schematic way to allow for variables that serve as placeholders for domain values. In Example 1, the formula {a mathematical formula}⊞+5◇exp(a3,m) could informally state that tram {a mathematical formula}a3 is expected to arrive at station m within the next five minutes; {a mathematical formula}⊞+5◇exp(X,Y) is a schematic version with variables X and Y.
     </paragraph>
     <paragraph>
      LARS programs are an (in essence second-order) language for more involved applications that require reasoning over auxiliary (i.e., intensional) predicates. Programs are sets of rules similar as in Datalog but built upon LARS formulas instead of atoms as elementary expressions. In order to deal with incomplete information and negation, programs are equipped with a multiple model semantics as in Answer Set Programming [68], [13], [24], [25] to obtain preferable properties such as nonmonotonicity, model minimality and supportedness of inferences (Section 3.3). In fact, LARS programs can be seen as an extension of Answer Set Programming for stream reasoning. In Example 1, the rule {a mathematical formula}poss(X,m)←⊞+5◇exp(X,m),¬old(X). could informally state that when a tram X is expected to arrive at station m (Mozart Circus) within the next five minutes and is not an old make, then it is a possible target for further consideration.
     </paragraph>
     <paragraph>
      – Computational complexity and expressiveness. We investigate the computational complexity of model checking and satisfiability for both LARS formulas and programs, over an input data stream, assuming that window evaluation is tractable. Our analysis pays particular attention to nesting of windows and the use of different windows types that are common in practice. Our analysis reveals that both problems are {a mathematical formula}PSpace-complete for propositional (ground) LARS formulas and programs in general, but have lower complexity if either the nesting depth of window operators is bounded by a constant, or only common window operators as those mentioned above are used, under some mild constraints. In particular, reasoning in LARS is then not harder than in ASP; notably, this includes the most practical programs which employ no window nesting. For non-ground LARS formulas and programs (i.e., the Datalog case), the combined complexity of satisfiability testing increases (up to {a mathematical formula}NExpTimeNP) in the considered setting, while for model checking it does not drastically increase; for formulas, it remains unchanged. The data complexity is, as one might expect, in line with the complexity of the (bounded) ground case. Regarding expressiveness, LARS formulas can express only (and in general all) polynomial time recognizable languages. We show that in case of sliding time-based windows, propositional LARS formulas can be translated into linear-time temporal logic (LTL), and thus a fortiori can express only a strict fragment of the regular languages. While sliding time-based windows are easily described in LTL, expressing others (e.g., tuple-based windows) is more involved, and even impossible for polynomial-time windows in general. Propositional LARS programs instead are shown to capture the class of regular languages, i.e., every regular language and only regular languages can be expressed by propositional LARS programs. As non-ground LARS programs subsume disjunctive Datalog and are not harder to evaluate, these programs capture the class of {a mathematical formula}Σ2p recognizable languages, and are thus a rather expressive formalism.
     </paragraph>
     <paragraph>
      – LARS use cases. The use of LARS as framework allows for formally defining and comparing existing languages, in particular when they are defined only operationally or informally. By means of LARS one also may equip existing formalisms with a declarative semantics. We explore the modeling capabilities of LARS by drawing formal relations with different prominent languages: we capture the semantics of the (core of the) continuous query language (CQL) that extends SQL for streams, and we discuss C-SPARQL and CQELS that similarly extend SPARQL for RDF streams. Finally, we consider ETALIS [8], which is also rule-based, but differently from LARS aims at complex event processing and builds on time intervals rather than time points.
     </paragraph>
     <paragraph>
      Furthermore, LARS can be used as a genuine language for stream reasoning itself. In particular, a fragment called plain LARS has been utilized in multiple works mentioned in Sections 6.1–6.3. It extends normal logic programs essentially by so-called extended atoms for controlling the streaming aspects. Plain LARS programs have been used to model the decision unit in a simulation framework for Content-Centric Networking Management [17], [18].
     </paragraph>
     <paragraph>
      In summary, we have established with LARS a novel formalism to express and analyze stream reasoning, from both the theoretical and the practical perspective. Due to its linkage to ASP, it provides a uniform basis for developing AI applications in a streaming context, such as diagnosis, configuration, planning and many others, cf. [57]. Further works complement the seminal results presented here and address equivalence issues for optimization [20], incremental answer update to queries [19], and prototype implementation [17], [22], [15].
     </paragraph>
     <paragraph>
      Organization. The remainder of this article is organized as follows. The next section introduces the basic constituents of the model-theoretic semantics of our framework, viz. streams and window functions. Section 3 then presents the LARS language, where syntax and semantics of both LARS formulas and programs are defined. This is followed by a computational complexity analysis in Section 4 , where we investigate model checking and satisfiability. We show that some practical restrictions on window operators lead to significantly lower complexity. Section 5 investigates the relationship of LARS to selected other formalisms: LTL, CQL, C-SPARQL, CQELS and ETALIS. Section 6 provides a discussion of further work on LARS regarding theoretical foundations, prototype implementations and applications. We then put LARS into the broader context of stream processing and reasoning and discuss some of its distinguishing semantic features from a practical perspective. In the final Section 7 we draw conclusions and outline directions for future research. In order not to disrupt the flow of reading, proofs of technical results have been moved to the Appendix.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Streams and windows
     </section-title>
     <paragraph>
      This section introduces two central notions: streams and windows. From a conceptual perspective, we can view streams in contrast to relational databases, which are by and large time-agnostic, compound entities; they are typically large and change only due to explicit updates. Streams, on the other hand, can be seen as unbounded sequences of small, individual entities with an inherent notion of temporal appearance. Records in usual databases can be deleted, whereas streaming data can only be ignored or forgotten. Recent portions of a stream's entire history that are retained in memory are called windows, which can be selected in different ways due to window functions. Notably, the result of applying a window function to a stream is another (sub)stream; this allows for nesting of windows and thus to express complex data selections.
     </paragraph>
     <paragraph>
      In Section 2.1 we give the intuitive idea of streams and our formalization, followed by the general notions of windows and window functions in Section 2.2. We then introduce in Sections 2.3–2.7 specific instances as used in practice, respectively throughout this paper.
     </paragraph>
     <section label="2.1">
      <section-title>
       Streaming data
      </section-title>
      <paragraph>
       Streaming data can be viewed from different perspectives. Practically, streams can be seen as data objects that incrementally become available to be read and processed. We are interested here in a domain independent approach, i.e., we do not differentiate whether data signals are chunks of video streams, social media posts, server log entries, values from sensors, etc. A common conceptual abstraction is provided by the notion of an event, which is typically formalized as tuple with a timestamp. In line with the setting of many practical systems for stream processing, we adopt a discrete, linear time ontology. Streaming signals are reflected as atoms which are associated with time points.
      </paragraph>
      <paragraph label="Example 2">
       Fig. 2 shows the further development of the stream of Fig. 1(b). We now see that also {a mathematical formula}bus(a1,s) is associated with time point 40, and {a mathematical formula}tram(a3,m) with 43. Then, a later record of the same stream (Fig. 2(b)) places {a mathematical formula}tram(a1,m) and {a mathematical formula}bus(b2,m) at time points 44 and 45, respectively.  □ Due to our focus on the declarative semantics of stream reasoning, we will not elaborate on system aspects, such as update frequency of the stream, memory bottlenecks, system outages or out-of-order events [11], [43]. Instead, the aim here is to provide a starting point for formalizing an ideal semantics, from which a running system may have to diverge in practice, e.g., under heavy data load. We thus focus on the model-based aspect of stream reasoning, not architectures of potential systems.
      </paragraph>
      <paragraph>
       Formalizing streams. We use mutually disjoint finite sets of predicates{a mathematical formula}P, constants{a mathematical formula}C, variables{a mathematical formula}V and time variables{a mathematical formula}U. The set {a mathematical formula}T of terms is given by {a mathematical formula}C∪V and the set {a mathematical formula}A of atoms is defined as {a mathematical formula}{p(t1,…,tn)|p∈P, {a mathematical formula}t1,…,tn∈T}. The set {a mathematical formula}G of ground atoms contains all atoms {a mathematical formula}p(t1,…,tn)∈A such that {a mathematical formula}{t1,…,tn}⊆C. We also say a term is ground if it is a constant.
      </paragraph>
      <paragraph>
       We divide {a mathematical formula}P into two disjoint subsets, namely the extensional predicates{a mathematical formula}PE and the intensional predicates{a mathematical formula}PI. Accordingly, we distinguish extensional atoms{a mathematical formula}AE and intensional atoms{a mathematical formula}AI. Intensional predicates/atoms are used to express inferred information. On the other hand, extensional predicates (respectively atoms) are further partitioned into {a mathematical formula}PBE (respectively {a mathematical formula}ABE) for background data and {a mathematical formula}PSE (respectively {a mathematical formula}ASE) for data streams. The mentioned partitions are analogously defined for ground atoms {a mathematical formula}GI, {a mathematical formula}GBE and {a mathematical formula}GSE. Unless stated otherwise, we use (with slight abuse of notation) the symbol {a mathematical formula}G to refer to {a mathematical formula}GI∪GSE, i.e., ground atoms that are not reserved for background data.
      </paragraph>
      <paragraph>
       Additionally, we assume basic arithmetic operations (+, −, ×, ÷) and comparisons (=, ≠, &lt;, &gt;, ≤, ≥) are predefined by designated atoms {a mathematical formula}B⊆ABE, and used also in infix notation. For instance, “+” can be realized by a set of atoms of form {a mathematical formula}p+(X,Y,Z), where {a mathematical formula}p+ is a designated predicate symbol for “+” and X, Y and Z are integers such that {a mathematical formula}X+Y=Z; the latter expression is then used in rules but viewed as syntactic sugar for {a mathematical formula}p+(X,Y,Z). Whether an arithmetic expression holds is then determined by the existence of the according atom in the background data. Such auxiliary atoms are also used by practical ASP solvers such as dlv [77], [6].
      </paragraph>
      <paragraph label="Definition 1">
       We now present our formalization of streams, which we base on the linear time ontology {a mathematical formula}〈N,≤〉; informally, the increase by 1 is the passing of time in terms of a tick by a global system clock. StreamLet T be a closed nonempty interval in {a mathematical formula}N and {a mathematical formula}υ:N→2G an evaluation function such that {a mathematical formula}υ(t)=∅ for all {a mathematical formula}t∈N∖T. Then, the pair {a mathematical formula}S=(T,υ) is called a stream, T is the timeline of S, and the elements of  T are time points. We write evaluation functions also as sets of nonempty mappings. For instance, {a mathematical formula}{17↦{a,b}} assigns {a mathematical formula}{a,b} to time point 17, and ∅ else.
      </paragraph>
      <paragraph>
       Note that our stream definition remains agnostic about the specific meaning of time points. For instance, [97] and [43] distinguish the inherent time of a signal (that might be provided by the data source), called the application time, from the instant where a signal becomes available for processing, called the system time. The recent Apache Flink framework [32] distinguishes three notions of time: the event time refers to the creation of the signal at its producer, the ingestion time is the timestamp that Flink creates when it receives the signal, and the processing time is the local time at an internal operator when the signal is actually processed.
      </paragraph>
      <paragraph>
       These distinctions are useful for the study and improvement of execution models in stream processing, which are the concern of those works. Our focus, however, shifts to the pure declarative semantics of stream reasoning, which we view in full separation from different possibilities of their computation. In that regard, issues about wrong output due to lags between event time and processing time, delays during computation, etc., are out of our scope. We regard the result of undesired semantic effects that originate in the specifics of particular systems (under specific conditions) as deviations from an ideal semantics which we aim to formalize.
      </paragraph>
      <paragraph label="Example 3">
       In formal analysis, time points might refer to all conceptual notions of time mentioned above. In an implemented system, time points will naturally reflect system time, respectively ingestion time (in the granularity of the system). Nevertheless, an explicit distinction between application time and system time can be obtained by means of explicit timestamps as usual. Consider again the scenario of Example 1. We can model the input as the data stream {a mathematical formula}D=(T,υ) with timeline {a mathematical formula}T=[0,50] and evaluation {a mathematical formula}υ(36)={tram(a1,b),bus(b1,b)}, {a mathematical formula}υ(40)={tram(a3,h)}, and {a mathematical formula}υ(t)=∅ for all {a mathematical formula}t∈T∖{36,40}. With the mapping notation, we simply write {a mathematical formula}{36↦{tram(a1,b),bus(b1,b)}, {a mathematical formula}40↦{tram(a3,h)}}. In our use case, {a mathematical formula}40↦{tram(a3,h)} can mean that the tram with identifier {a mathematical formula}a3 actually appeared at station h at time point 40, or that the processing system received the information about this appearance at time point 40. Assuming the latter, we can still distinguish the two, if the application time is sent explicitly. For instance, the case that the tram appeared one minute (time point) earlier than recognized in the system would be reflected by the mapping {a mathematical formula}40↦tram(a3,h,39).  □
      </paragraph>
      <paragraph>
       Keeping the entire history of a stream is rarely practical, and often not useful: hardware restrictions and storage capabilities aside, many use cases on streaming data are intrinsically only concerned about recent snapshots of data. This leads to the notion of windows.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Windows
      </section-title>
      <paragraph>
       Central to the view on stream reasoning adopted in this work is the notion of a window, which typically is a recent, small selection of continuously streaming data. Restricting access to streams in form of windows may be a practical necessity due to limitations in computational resources, i.e., storage capacity or evaluation times of posed queries. Windows define which data has to be retained, respectively what can be deleted or forgotten. In that regard, a window separates data into a relevant part used as input for reasoning, and an irrelevant part that is ignored. Many stream processing use cases need this distinction already at the semantic level, in particular when only recent information is of interest. For instance, for the purpose of route planning only current (and predictable) traffic jams are of relevance, not those in the past.
      </paragraph>
      <paragraph label="Definition 2">
       Since our formalization of streams uses finite timelines, we can view windows simply as substreams, i.e., a window is a stream that is contained in another one. WindowLet {a mathematical formula}S=(T,υ) and {a mathematical formula}S′=(T′,υ′) be two streams such that {a mathematical formula}T′⊆T and {a mathematical formula}υ′(t′)⊆υ(t′) for all {a mathematical formula}t′∈T′. We then say that {a mathematical formula}S′ is a substream or window of S, denoted by {a mathematical formula}S′⊆S. Furthermore, the count{a mathematical formula}|S| of stream {a mathematical formula}S=(T,υ) is defined by {a mathematical formula}#{(a,t)|t∈T,a∈υ(t)} (where # stands for set cardinality), i.e., the total number of atom occurrences. In addition, we define the size of S by {a mathematical formula}|S|+#{t∈T|υ(t)=∅}, which also accounts for empty time points. The restriction{a mathematical formula}S|T′of S to{a mathematical formula}T′⊆T is the stream {a mathematical formula}(T′,υ|T′), where {a mathematical formula}υ|T′ restricts the domain of υ to {a mathematical formula}T′, i.e., {a mathematical formula}υ|T′(t)=υ(t) for all {a mathematical formula}t∈T′, else {a mathematical formula}υ|T′(t)=∅. A data stream contains only extensional atoms, which we refer to as signals, i.e., the set {a mathematical formula}GSE.
      </paragraph>
      <paragraph label="Example 4">
       cont'dFig. 3 shows a window of stream D which selects at time {a mathematical formula}t=43 (indicated by the bullet) the timeline {a mathematical formula}T′=[36,42] (rectangle) and only the bus appearances in this interval. Consequently, the window is given by {a mathematical formula}D′=(T′,υ′), where {a mathematical formula}υ′={36↦{bus(b1,b)},40↦{bus(b1,s)}}. Note further that the stream in Fig. 1(b) is a window of that in Fig. 2(a), which in turn is a window of Fig. 2(b), assuming a shared timeline (e.g. {a mathematical formula}[0,50]).  □
      </paragraph>
      <paragraph>
       Towards a generic framework we need an abstract mechanism for the selection of windows, given a stream and a time point.
      </paragraph>
      <paragraph label="Definition 3">
       Window functionAny (computable) function w that returns, given a stream {a mathematical formula}S=(T,υ), and a time point {a mathematical formula}t∈N, a window {a mathematical formula}S′ of S, is called a window function.
      </paragraph>
      <paragraph>
       We call the time point t at which a window function is applied the reference time point. The most common types of windows in practice include time-, tuple-, and partition-based windows, cf. [97], [11], [43] ; they will be presented in Sections 2.3–2.5. We associate them with three window functions symbols τ, #, and p, respectively. Traditionally [11], these window functions take a fixed size ranging back in time from a reference time point t; we will consider in Section 2.7 generalized variants which allow for looking back and forth from t. Moreover, we introduce in Section 2.6 a filter window function f which only drops data but retains the current timeline.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Time-based window
      </section-title>
      <paragraph>
       Window functions which select recent data based on a fixed amount of time are presumably the most widely used in practice. We formalize such time-based windows as follows.
      </paragraph>
      <paragraph label="Definition 4">
       Time-based windowLet {a mathematical formula}S=(T,υ) be a stream, {a mathematical formula}T=[tmin,tmax] and {a mathematical formula}t∈N. Furthermore, let {a mathematical formula}n∈N∪{∞} and {a mathematical formula}d∈N such that {a mathematical formula}1≤d≤n. If {a mathematical formula}t∈T, the time-based window function of sizen and hop size d of S at time t is defined by{a mathematical formula} where {a mathematical formula}T′=[tℓ,tu], {a mathematical formula}tℓ=max⁡{tmin,tu−n} and {a mathematical formula}tu=⌊td⌋⋅d. If {a mathematical formula}t∉T, we define {a mathematical formula}τn(d)(S,t)=S.
      </paragraph>
      <paragraph>
       Intuitively, a time-based window function selects, at time point t, a pivot point{a mathematical formula}tu≤t that is the closest time point to t such that the distance to the left end of the timeline is a multiple of d. From this time point {a mathematical formula}tu, the window reaches back (at most) n time points and selects all atoms in that interval. Note that the case for {a mathematical formula}t∉T is given only for formal reasons, i.e., compliance with Definition 3. Conceptually, the time-based window is only applicable if {a mathematical formula}t∈T. The general approach is useful for a compositional approach as discussed later.
      </paragraph>
      <paragraph>
       We call a time-based window function {a mathematical formula}τn(d)sliding, if {a mathematical formula}d=1, and tumbling if {a mathematical formula}d&gt;1 and {a mathematical formula}d=n, else hopping. The sliding window function {a mathematical formula}τn(1) is abbreviated by {a mathematical formula}τn. Fig. 4, Fig. 5, Fig. 6 illustrate these different modes of window movement. First, Fig. 4 depicts a sliding window of size {a mathematical formula}n=3, where from the reference time t (indicated by a bullet), always window {a mathematical formula}[t−n,t] is selected, unless the left end {a mathematical formula}tℓ has to be cut when it reaches the global limit {a mathematical formula}tℓ=0. For other progressions, the right end of the window does not necessarily equal the reference time. If the window shifts in bigger intervals ({a mathematical formula}1&lt;d&lt;n), we get a hopping window as shown in Fig. 5. Here, the hop size is 2, i.e., the window shifts to the right every 2 time points. If the hop size equals the window size, we get a tumbling window as shown in Fig. 6. Sliding windows can be seen as a means for a fully continuous evaluation of recent events. Hopping windows additionally allow one to specify a certain interval after which a re-evaluation is needed. This is of interest when we want to control the time when a result shall be refreshed, e.g., a condition over the last 60 seconds which shall be recomputed only every 15 seconds. Finally, the tumbling window is suitable when we want to partition the timeline, e.g., to evaluate something in fixed intervals of 60 seconds.
      </paragraph>
      <paragraph label="Example 5">
       cont'dOn the data stream D of Example 3, consider a monitoring use case where we want to know only bus and tram appearances reported within the last 4 minutes, at every minute. To this end, we can use a sliding time-based window function {a mathematical formula}τ4. Applying it on D at {a mathematical formula}t=42 gives {a mathematical formula}τ4(D,42)=([38,42],υ′), where {a mathematical formula}υ′={40↦{tram(a3,h),bus(b1,s)}}, as shown in Fig. 7. Using a hop size of {a mathematical formula}d=2 or {a mathematical formula}d=3 would result in the same window (at {a mathematical formula}t=42); the tumbling window function ({a mathematical formula}n=d=4) would select timeline {a mathematical formula}[36,40]. Note that the time-based window does not drop any data in the selected interval.  □
      </paragraph>
      <paragraph>
       Arguably, time-based windows are the most important ones in practice. The second most important class is dual: as one can limit resources typically by time or space, counting tuples (atoms) is the second natural approach for selecting recent chunks of data. We shall look at this tuple-based window next.
      </paragraph>
     </section>
     <section label="2.4">
      <section-title>
       Tuple-based window
      </section-title>
      <paragraph>
       Complementary to time-based windows, tuple-based windows define recency of data not in terms of time, but in terms of tuple count. Accordingly, they are also called count windows[69], [32]. A tuple-based window of size n simply returns the most recent n atoms, regardless of their temporal appearance. Practically, one can view it as a buffer that always contains the n most recent atoms.
      </paragraph>
      <paragraph>
       There are different reasons for using tuple-based windows. First, when reasoning about as much of historic data as possible, tuple-based windows may serve to define a threshold to address memory limits. Secondly, many use cases are intrinsically counting-based, where tuple-based windows can then select the relevant number of atoms. Typical examples in stream processing would be aggregations of recent signals that are received aperiodically from some sensor; for instance to decide the likelihood of a traffic jam by computing the average velocity of the last 50 cars. Another frequent use of tuple-based windows concerns selecting only the most recent atom of a stream, e.g., the current value of a car's temperature sensor to control the air conditioning. We now formally define tuple-based windows.
      </paragraph>
      <paragraph label="Definition 5">
       Tuple-based windowLet {a mathematical formula}S=(T,υ) be a stream, {a mathematical formula}T=[tmin,tmax], {a mathematical formula}n∈N∪{∞} and {a mathematical formula}t∈N. Furthermore, let {a mathematical formula}T′=[tℓ,t], where {a mathematical formula}tℓ=max⁡({tmin}∪{t′|tmin≤t′≤t∧|S|[t′,t]|≥n}) is called the left point.If {a mathematical formula}t∈T, the multi-valued tuple-based window of sizen of S at time t is defined by{a mathematical formula} where{a mathematical formula} and {a mathematical formula}X⊆υ(tℓ) such that {a mathematical formula}|(T′,υ′|T′)|=n. If {a mathematical formula}t∉T, we define {a mathematical formula}#n(S,t)=S.
      </paragraph>
      <paragraph>
       Intuitively, a tuple-based window of size n is obtained by searching back from current time point t until a time point {a mathematical formula}tℓ is reached such that the total number of atoms counted in the interval {a mathematical formula}[tℓ,t] is at least n. Then, in general, only a portion {a mathematical formula}X⊆υ(tℓ) of the atoms at the left point {a mathematical formula}tℓ can be retained to achieve the exact tuple count n. Note that, in case the selection {a mathematical formula}X=υ(tℓ) can be guaranteed (as e.g. for streams with at most one atom per time point), the window definition simplifies to {a mathematical formula}(T′,υ|T′) as for time-based windows; then only the left point {a mathematical formula}tℓ needs to be computed to determine {a mathematical formula}T′=[tℓ,t]. In general, however, multiple options exist for set X, making the tuple-based window function multi-valued. Practically, tuple-based windows can be assumed to be deterministic due to the specific implementation. In the sequel, when using a tuple-based window function, we always assume some single-valued refinement.
      </paragraph>
      <paragraph label="Example 6">
       To illustrate tuple-based windows, we use the stream from Fig. 2(b), formalized by {a mathematical formula}D=(T,υ) where {a mathematical formula}T=[0,50] and{a mathematical formula} To get the last three vehicle appearances w.r.t. reference time point {a mathematical formula}t=44, we can use the tuple-based window function {a mathematical formula}#3, which formally gives two possible windows at t: {a mathematical formula}S1=(T1,υ1) and {a mathematical formula}S2=(T2,υ2), where for both {a mathematical formula}j∈{1,2}, {a mathematical formula}Tj=[40,44],{a mathematical formula}{a mathematical formula}υ1(40)={bus(b1,s)} and {a mathematical formula}υ2(40)={tram(a3,h)}.That is to say, the two windows differ in the evaluation at time point 40, where a nondeterministic choice is made to pick exactly three atoms from the input stream from time point 44 back to 40. Window {a mathematical formula}S1 is shown in Fig. 8.  □
      </paragraph>
      <paragraph>
       There are two natural possibilities to enforce the uniqueness of a tuple-based window in practice. First, if there is a total order over all atoms, one can give a deterministic definition of the set X in Definition 5. Second, one may omit the requirement that exactlyn atoms are contained in the window, but instead demand the substream obtained by the smallest interval {a mathematical formula}[tℓ,t] containing at leastn atoms.
      </paragraph>
      <paragraph>
       Note that our definition of tuple-based windows leads to a sliding progression in the sense that the right end of the resulting window's timeline always is the reference time point. An extension with a hop size (analogous to that of the time-based window) is possible, yet less used in practice. Another refinement is more important: it concerns more fine-grained control of the counting mechanism, as we will introduce next.
      </paragraph>
     </section>
     <section label="2.5">
      <section-title>
       Partition-based window
      </section-title>
      <paragraph>
       The previous section presented tuple-based windows which select a given number of the most recent atoms. We now introduce a refinement which allows one to select different numbers of different atoms at the same time. The partition-based window function first separates virtual substreams and then obtains tuple-based windows (with different sizes) on them. Finally, their union is the resulting window. The prototypical application uses only two partitions: relevant atoms to be counted, and irrelevant atoms that shall be ignored.
      </paragraph>
      <paragraph label="Example 7">
       cont'dExample 6 used a tuple-based window for the last three vehicle signals. Assume now that we are only interested in trams. This would amount to partitioning the data stream D into a virtual substream {a mathematical formula}D1 that contains only tram appearances (i.e., all atoms with predicate tram) and another one, {a mathematical formula}D2, for bus appearances. Assuming access to these substreams, we can apply a tuple-based window of size 3 on {a mathematical formula}D1, another one of size 0 on {a mathematical formula}D2,{sup:2} and then merge the result. At {a mathematical formula}t=44 this would result in the window as depicted in Fig. 9, i.e., the alternate tuple-based window {a mathematical formula}S2 from before.  □
      </paragraph>
      <paragraph>
       Partition-based windows also provide a useful link between physical data streams and our formalization in Definition 1. In contrast to the latter, streaming applications usually combine multiple input sources. For instance, it is likely that tram and bus signals stem from different streams, or even that each vehicle sends its position in its own stream. Our focus, however, is not on processing the interplay of different streams but logic-oriented reasoning on top of their cumulative information. We therefore employ a single stream S which abstracts away different physical origins of data. Nevertheless, we can study different input streams in the formalism by selecting virtual substreams of S; partition-based windows are one possibility to obtain them.
      </paragraph>
      <paragraph label="Example 8">
       To define partition-based windows, we make use of a finite index set{a mathematical formula}I⊂N to tag atoms: we use an index function{a mathematical formula}idx:G→Ifor I which associates each ground atom {a mathematical formula}a∈G with an index{a mathematical formula}idx(a). Thus, given a stream {a mathematical formula}S=(T,υ), each index {a mathematical formula}i∈Iinduces a substream {a mathematical formula}Si=(T,υi), where {a mathematical formula}υi(t)={a∈υ(t)|idx(a)=i}. Moreover, we utilize a tuple size function{a mathematical formula}n:I→Nfor I that defines the size {a mathematical formula}n(i) for the tuple-based window on substream {a mathematical formula}Si. Naturally, we define the union{a mathematical formula}υ=υ1∪υ2 of two evaluation functions {a mathematical formula}υ1 and {a mathematical formula}υ2 by {a mathematical formula}a∈υ(t) iff {a mathematical formula}a∈υ1(t)∪υ2(t) for all {a mathematical formula}a∈G and {a mathematical formula}t∈N; the union of two streams {a mathematical formula}S1=([ℓ1,u1],υ1) and {a mathematical formula}S2=([ℓ2,u2],υ2) is then defined by {a mathematical formula}S1∪S2=([min⁡{ℓ1,ℓ2},max⁡{u1,u2}],υ1∪υ2). Partition-based windowLet {a mathematical formula}S=(T,υ) be a stream and {a mathematical formula}t∈N. Moreover, let idx be an index function and n be a tuple size function for an index set I. If {a mathematical formula}t∈T, the partition-based window of S at time t (relative to {a mathematical formula}idx,n) is defined by{a mathematical formula} If {a mathematical formula}t∉T, we define {a mathematical formula}pidx,n(S,t)=S. With this definition in place, we continue with the details for the previous example. cont'dTo define a window that selects the last three trams, we use an index set {a mathematical formula}I={1,2}, where index 1 is used for trams and 2 for buses. Accordingly, we let {a mathematical formula}X={tram(c1,c2)|c1,c2∈C} be the set of possible ground atoms with predicate tram, and define for all atoms {a mathematical formula}a∈G{a mathematical formula} This induces the substreams {a mathematical formula}D1=(T,υ1) and {a mathematical formula}D2=(T,υ2), where{a mathematical formula}We employ a tuple size function n such that {a mathematical formula}n(1)=3 and {a mathematical formula}n(2)=0, i.e., we will select three atoms from {a mathematical formula}D1 and none from {a mathematical formula}D2. At {a mathematical formula}t=44, this yields the windows {a mathematical formula}D′:=#n(1)(D,t)=([40,44],υ1′), where{a mathematical formula} and {a mathematical formula}#n(2)(D,t)=([43,43],∅), respectively. Their union equals {a mathematical formula}D′, i.e., {a mathematical formula}pidx,n(D,t)=D′.  □ We present another example, which concerns the tracking of each individual vehicle.
      </paragraph>
      <paragraph label="Example 9">
       cont'dWe are now interested in selecting the last appearance for each individual tram and bus. Consequently, we need a substream for each vehicle, then we can select the last atom on each of these substreams. We assume that all potential tram instances can have identifiers {a mathematical formula}a1 to {a mathematical formula}a10, likewise buses {a mathematical formula}b1 to {a mathematical formula}b50, and there might be signals with predicates other than tram and bus. For the latter, we reserve index 0 by defining simply{a mathematical formula} Next we assign {a mathematical formula}i=1,…,10 to tram identifiers and {a mathematical formula}i=101,…,150 to buses:{a mathematical formula}This gives us four non-empty induced substreams for D at 45:{a mathematical formula} We use the tuple size function n such that {a mathematical formula}n(0)=0 and {a mathematical formula}n(i)=1 for all {a mathematical formula}i∈I∖{0} and thus obtain the following respective tuple-based windows (of size 1):{a mathematical formula} The union of these windows gives us the result of the partition-based window:{a mathematical formula} where{a mathematical formula} The previous example indicates the power of partition-based windows that arises from its flexible selection mechanism. Applications may define more narrow variants which can then be uniformly represented by index functions. For formal analysis, however, a more compositional approach is desirable that does not hide multiple computation steps in a single function. For the use case illustrated in Example 7, Example 8 we suggest an alternative approach, where the tuple-based window follows an initial projection step. To this end, we now introduce filter windows.
      </paragraph>
     </section>
     <section label="2.6">
      <section-title>
       Filter window
      </section-title>
      <paragraph label="Definition 7">
       Time-based windows and tuple-based windows shrink the timeline and thus drop data outside their defined scope. Dually, filter windows leave the timeline as it is and drop all but a specified set of atoms. Accordingly, given a stream {a mathematical formula}S=(T,υ), we define for a set {a mathematical formula}A⊆G of ground atoms, the projection of υ to A by {a mathematical formula}υ|A(t)=υ(t)∩A for all {a mathematical formula}t∈N, and the projection of S to A by {a mathematical formula}S|A=(T,υ|A). This already yields the filter window. Filter windowLet {a mathematical formula}S=(T,υ) be a stream, {a mathematical formula}t∈N, and {a mathematical formula}A⊆G be a set of atoms. The filter window function for A (at time t) is defined by{a mathematical formula} Note that the filter window function works in a time-independent manner, i.e., it always retains the timeline and returns the same result for all {a mathematical formula}t∈N, in particular, for {a mathematical formula}t∉T. This is dual to the time-based window, where all atoms in the selected timeline can remain, and this timeline is selected independently from atoms.
      </paragraph>
      <paragraph>
       Filter windows are particularly useful as preprocessing step before applying tuple-based windows which then only count a defined subset of atoms.
      </paragraph>
      <paragraph label="Example 10">
       cont'dIn Example 7, Example 8 we selected the last three trams by means of a partition-based window. Alternatively, we can use the set A of atoms with predicate tram, where we obtain the stream {a mathematical formula}D1 above, shown in Fig. 10, by {a mathematical formula}fA(D,t) (for any {a mathematical formula}t∈N). Consequently, this specific partition-based window is equally obtained by consecutive applications of {a mathematical formula}fA and {a mathematical formula}#3; i.e., using {a mathematical formula}idx,n from Example 8 we get {a mathematical formula}pidx,n(D,t)=#3(fA(D,t′),t) (for all {a mathematical formula}t,t′∈N).Finally, we revisit Fig. 2. Using a set B of atoms with predicate bus, we obtain the depicted window by {a mathematical formula}τ6(2)(fB(D,t),43), or equivalently, by {a mathematical formula}fB(τ6(2)(D,43),t) (for any {a mathematical formula}t∈N); the hopping time-based window selects, at {a mathematical formula}t=43, the timeline {a mathematical formula}[36,42], and the filter window retains only bus signals. Due to the logical independence these functions, we can apply them in arbitrary order.  □ In contrast to the windows studied above filtering also affects atoms appearing after the time point t where function {a mathematical formula}fA is applied. We will now introduce generalizations of the other window functions that may also access future time points.
      </paragraph>
     </section>
     <section label="2.7">
      <section-title>
       Windows with access to the future
      </section-title>
      <paragraph label="Example 11">
       Standard window functions select substreams that contain recent data from the past. Time-based windows select an interval {a mathematical formula}[t1,t2], where {a mathematical formula}t2 is close or equal to reference time t, tuple-based windows and partition-based windows determine an interval {a mathematical formula}[t1,t] by counting atoms. We will now consider generalizations where the timeline can also extend to time points after t. One motivation for such future windows concerns predictions, i.e., inferred information about future events. Windows accessing later time points can then restrict access to intensional atoms assigned to them. cont'dWhen Bob is approaching Mozart Circus (station m) on line {a mathematical formula}ℓ3 at time {a mathematical formula}t=42, he wants to know whether there will be a connecting tram. For this, he is only interested in expected arrival times of trams within the next 5 minutes. These predictions could be reflected by intensional atoms of form {a mathematical formula}exp(ID,St), where ID is the tram identifier and St is the station where the tram is expected. We thus would like to have a time-based window that drops all such atoms relating to time points after{a mathematical formula}t+5.  □
      </paragraph>
      <paragraph>
       Having access to time points after the reference time point is also useful when we navigate within a timeline. Our forthcoming framework will introduce temporal modalities, which open up the possibility to apply windows at multiple time points within the same evaluation. This shifts the conceptual perspective from “past” and “future” to “before” and “after” relative to a reference time point that can be controlled. In that regard, it is natural to lift the time-based window accordingly.
      </paragraph>
      <paragraph label="Definition 8">
       Generalized time-based windowLet {a mathematical formula}S=(T,υ) be a stream, {a mathematical formula}T=[tmin,tmax] and let {a mathematical formula}t∈N. Furthermore, let {a mathematical formula}ℓ,u∈N∪{∞} and {a mathematical formula}d∈N such that {a mathematical formula}d≤ℓ+u. If {a mathematical formula}t∈T, the generalized time-based window function with range{a mathematical formula}(ℓ,u) and hop size d of S at time t is defined by{a mathematical formula} where {a mathematical formula}T′=[tℓ,tu], {a mathematical formula}tℓ=max⁡{tmin,t′−ℓ} with pivot point{a mathematical formula}t′=⌊td⌋⋅d, and {a mathematical formula}tu=min⁡{t′+u,tmax}. If {a mathematical formula}t∉T, we define {a mathematical formula}τℓ,u(d)(S,t)=S. The generalized time-based window replaces in Definition 4 the size n by a range {a mathematical formula}(ℓ,u): in addition to selecting the ℓ time points left of the pivot point, it also selects u time points right of it. Accordingly, the size of the generalized time-based window (function) {a mathematical formula}τℓ,u(d) is given by {a mathematical formula}ℓ+u. When we use time-based windows with future time points (after t) in the sequel, we will implicitly refer to the one of Definition 8.
      </paragraph>
      <paragraph>
       As before, a time-based window function {a mathematical formula}τℓ,u(d) is called sliding, if {a mathematical formula}d=1, and tumbling if {a mathematical formula}d&gt;1 and {a mathematical formula}d=ℓ+u, else hopping. We abbreviate {a mathematical formula}τℓ,u(1) by {a mathematical formula}τℓ,u, {a mathematical formula}τℓ,0(1) by {a mathematical formula}τℓ and {a mathematical formula}τ0,u(1) by {a mathematical formula}τ+u.
      </paragraph>
      <paragraph label="Example 12">
       Fig. 11 shows the selection mechanism of a hopping (generalized) time-based window with range {a mathematical formula}(3,1) and hop size 3. Consider for instance reference time point {a mathematical formula}t=7. Function {a mathematical formula}τ3,1(3) selects pivot time {a mathematical formula}t′=⌊73⌋⋅3=6, from which it reaches by {a mathematical formula}t′−ℓ time point 3 for the lower end, and by {a mathematical formula}t′+u time point 7 for the upper end. Consequently, the resulting window has the timeline {a mathematical formula}[3,7].  □
      </paragraph>
      <paragraph>
       The case for tuple-based windows is analogous: we want to be able to select a certain number of tuples before and after a reference time point, where the window is applied. Accordingly, we generalize the tuple-based window as follows.
      </paragraph>
      <paragraph label="Definition 9">
       Generalized tuple-based windowLet {a mathematical formula}S=(T,υ) be a stream, {a mathematical formula}T=[tmin,tmax] and {a mathematical formula}t,ℓ,u∈N. We define the left point{a mathematical formula}tℓ and right point{a mathematical formula}tu by{a mathematical formula} respectively. Let {a mathematical formula}Tℓ=[tℓ,t] and {a mathematical formula}Tu=[t+1,tu]. If {a mathematical formula}t∈T, the multi-valued generalized tuple-based window with range{a mathematical formula}(ℓ,u) of S at time t is defined by{a mathematical formula} where {a mathematical formula}T′=[tℓ,tu],{a mathematical formula} and {a mathematical formula}Xq⊆υ(tq), {a mathematical formula}q∈{ℓ,u}, such that {a mathematical formula}|(Tq,υ′|Tq)|=q. If {a mathematical formula}t∉T, we define {a mathematical formula}#ℓ,u(S,t)=S. This generalization of Definition 5 is straightforward: it adds to the selection of ℓ (n in Definition 5) atoms left of reference time t the selection of further u atoms right of t. We thus define the size of the generalized tuple-based window (function) {a mathematical formula}#ℓ,u by {a mathematical formula}ℓ+u. As before, we abbreviate {a mathematical formula}#0,u by {a mathematical formula}#+u.
      </paragraph>
      <paragraph label="Example 13">
       We immediately get the definition of generalized partition-based windows, by allowing extended tuple-based windows in Definition 6 (using tuple size functions that range over {a mathematical formula}N×N). cont'dWe now can determine the best connection at Mozart Circus. To this end, we use an index function idx that assigns index 1 to expected arrivals of trams at station m, i.e., the set A of atoms of form {a mathematical formula}exp(ID,m), and index 0 for all other atoms. Next, we define the tuple size function n such that {a mathematical formula}n(1)=(0,1) (i.e., the parameters {a mathematical formula}ℓ=0 and {a mathematical formula}u=1 for the generalized tuple-based window on substream {a mathematical formula}S1) and {a mathematical formula}n(0)=(0,0). This results in a window that contains only the next tram at m. Alternatively, we get the same result by employing {a mathematical formula}fA followed by {a mathematical formula}#+1.  □
      </paragraph>
      <paragraph>
       After having introduced streams, windows and different window functions, we are now prepared to propose a logic-based framework for stream reasoning.
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      The LARS framework
     </section-title>
     <paragraph>
      We now present an improved version of LARS [21], a Logic for Analytic Reasoning over Streams. LARS extends propositional logic for streaming data by employing any window function w (Definition 3) in a window operator {a mathematical formula}⊞w. Within the resulting substream, one can then control the temporal modality of formulas, respectively access temporal information. Based on such formulas, LARS then provides a rule-based language with a model-based, nonmonotonic semantics, which can be seen an extension of Answer Set Programming for streaming data.
     </paragraph>
     <paragraph>
      Before defining syntax and semantics of LARS below, we first present the central concepts informally.
     </paragraph>
     <paragraph>
      Window operators &amp; stream reset. If w is a window function, we call {a mathematical formula}⊞w a window operator. Given a formula α, the expression {a mathematical formula}⊞wα has the effect that α will be evaluated on the window obtained by applying w in the current stream S at the current time t. Dually, the reset operator ▹ serves to re-access the original stream. For specific window operators we use syntactic shortcuts as listed in Fig. 12.
     </paragraph>
     <paragraph>
      Temporal modalities. Regardless if formula evaluation is on the entire input stream or a window thereof, we provide explicit means to deal with the temporal information. Let {a mathematical formula}S=(T,υ) be a stream, i.e., the input stream or a window, and {a mathematical formula}t∈T be a time point. There are different ways to evaluate a formula α in S at t. First, we express by {a mathematical formula}@t′α, where {a mathematical formula}t′∈N∪U, that α has to hold when changing the evaluation time to {a mathematical formula}t′. We call {a mathematical formula}t′ in {a mathematical formula}@t′α a time pin; which is ground if {a mathematical formula}t′∈N, else non-ground. Next, time might be abstracted away. That is to require that α holds at some time point {a mathematical formula}t′∈T, denoted by ◇α. Dually, □α shall hold iff α holds at all time points in T. Based on these modalities, we define our language.
     </paragraph>
     <section label="3.1">
      <section-title>
       LARS formulas
      </section-title>
      <paragraph label="Definition 10">
       FormulasLet {a mathematical formula}a∈A be an atom, {a mathematical formula}t∈N∪U and w be a window function. The set {a mathematical formula}F of formulas is defined by the following grammar:{a mathematical formula} The set {a mathematical formula}FG of ground formulas contains all formulas where each term and each time pin is ground. In addition to streams, we consider background knowledge in form of static data, i.e., a set {a mathematical formula}B⊆GBE of ground atoms which does not change over time. From a semantic perspective, the difference to streams is that static data is always available, regardless of window applications.
      </paragraph>
      <paragraph label="Definition 12">
       The following definitions concern the semantics of ground formulas. StructureLet {a mathematical formula}S=(T,υ) be a stream, W be a set of window functions and {a mathematical formula}B⊆GEB a set of facts. Then, we call {a mathematical formula}M=〈S,W,B〉 a structure, S the interpretation stream and B the background data of M. We now define when a ground formula holds in a structure. EntailmentLet {a mathematical formula}M=〈S⋆,W,B〉 be a structure, {a mathematical formula}S⋆=(T⋆,υ⋆) and let {a mathematical formula}S=(T,υ) be a substream of {a mathematical formula}S⋆. Moreover, let {a mathematical formula}t∈T⋆. The entailment relation ⊩ between {a mathematical formula}(M,S,t) and formulas is defined as follows. Let {a mathematical formula}a∈G be an atom, let {a mathematical formula}α,β∈FG be ground formulas and {a mathematical formula}w∈W. Then,{a mathematical formula} If {a mathematical formula}M,S,t⊩α holds, we say that {a mathematical formula}(M,S,t)entailsα. Moreover, we say that Msatisfies α at time t, if {a mathematical formula}(M,S⋆,t) entails α. In this case we write {a mathematical formula}M,t⊨α and call M a model of αat time t. Satisfaction and the notion of a model are extended to sets of formulas as usual.
      </paragraph>
      <paragraph label="Example 14">
       cont'dLet {a mathematical formula}D=(T,υ) be the data stream of Example 5 and {a mathematical formula}S⋆=(T⋆,υ⋆)⊇D be a stream such that {a mathematical formula}T⋆=T and{a mathematical formula} Let {a mathematical formula}M=〈S⋆,W,B〉, where {a mathematical formula}W={τ+5}, and B is the set of facts from the data tables in Example 1. Then {a mathematical formula}M,S⋆,42⊩⊞+5◇exp(a3,m) holds: the window operator {a mathematical formula}⊞+5 selects {a mathematical formula}S′=(T′,υ′), with timeline {a mathematical formula}T′=[42,47] and {a mathematical formula}υ′={43↦{exp(a3,m)},44↦{exp(a1,m)}}, i.e., there is some {a mathematical formula}t′∈T′ ({a mathematical formula}t′=43) such that {a mathematical formula}M,S′,t′⊩exp(a3,m).  □
      </paragraph>
      <paragraph label="Example 16">
       We note that the original presentation of LARS [21] employed a so-called stream choice in window operators that allowed to direct the window function to be applied on the original stream {a mathematical formula}S⋆ (stream choice 1) and the current stream S (stream choice 2). Definition 12 presents a cleaner approach, where a window operator is always applied on the current stream. In case the original stream needs to be re-accessed in nested windows, this can be done by an explicit reset step ▹, followed by a window operator {a mathematical formula}⊞w. We define this combination as input window operator{a mathematical formula}⊠w:=▹⊞w. Consider a monitoring use case where a signal s must always appear within 5 minutes. Testing whether this condition holds for the last hour amounts to the formula {a mathematical formula}⊞60□⊠5◇s: we first select by a sliding time-based window the last 60 minutes. At every time point in this window, it must hold that if we consider the last 5 minutes there, signal s holds at some time point. Notably, by using {a mathematical formula}⊠5 instead of {a mathematical formula}⊞5 we ensure that this inner window reaches beyond the limits of the first. For instance, consider a stream {a mathematical formula}S=([0,500],υ). First, at {a mathematical formula}t=500, {a mathematical formula}⊞60 selects {a mathematical formula}S′=(T′,υ|T′), where {a mathematical formula}T′=[440,500]. During evaluation of □ at {a mathematical formula}t′=440, {a mathematical formula}⊠5 now selects {a mathematical formula}S|[435,440], while {a mathematical formula}⊞5 would select {a mathematical formula}S′|[440,440], since the timeline in {a mathematical formula}S′ only starts at 440.  □ Another subtle improvement over the previous version [21] concerns the fact that a window operator {a mathematical formula}⊞w may return a substream that does not contain the evaluation time point, i.e., {a mathematical formula}w(S,t)=(T′,υ′) does not imply {a mathematical formula}t∈T′. However, given a (sub)formula {a mathematical formula}⊞wφ, one typically wants to evaluate φ in the obtained window regardless of the specific evaluation time and its position relative to the window. While this could be technically handled for relevant cases, we now consider time points {a mathematical formula}t∈T⋆, and not {a mathematical formula}t∈T. That is to say, the evaluation time point t needs to be contained only in the global timeline {a mathematical formula}T⋆, not in the timeline T of the current substream S. Consider again Fig. 6, which illustrates the progress of a tumbling time-based window of size 3, i.e., the function {a mathematical formula}τ3(3). Assume further we are interested whether an atom x occurs in this window when evaluated at time 8. Accordingly, we evaluate {a mathematical formula}M,S,8⊩⊞3(3)◇x and the substream returned by {a mathematical formula}τ3(3) has timeline {a mathematical formula}[3,6]. We still expect that the entailment holds iff x appears within {a mathematical formula}[3,6], regardless of the fact that {a mathematical formula}8∉[3,6].  □ Notably, allowing any {a mathematical formula}t∈T⋆ in formula evaluation not only serves the applicability of windows such as hopping or tumbling windows. It also allows one to inspect whether the evaluation time is contained in the current timeline T. This possibility stems from the requirement that {a mathematical formula}t′ is contained in T for {a mathematical formula}@t′α to hold: the standard tautology {a mathematical formula}⊤:=a∨¬a holds (in all structures) at every time point {a mathematical formula}t∈T⋆, where entailment is defined; however, {a mathematical formula}@′t⊤ holds if and only if {a mathematical formula}t′∈T. Since also time points {a mathematical formula}t∈T⋆∖T can be evaluated, formulas can express conditions based on T. For instance, {a mathematical formula}M,S,t⊩⊞w(@t⊤∧φ) holds only if t is contained in the timeline of {a mathematical formula}w(S,t).
      </paragraph>
      <paragraph label="Definition 13">
       Queries &amp; non-ground formulas. We now consider the use of variables, leading to open formulas and queries. QueryLet {a mathematical formula}M=〈S,W,B〉 be a structure, {a mathematical formula}α∈F be a formula and let {a mathematical formula}u∈N∪U. Then, the tuple {a mathematical formula}Q=〈M,u,α〉 is called a query. We say Q is ground if α and u are ground, else non-ground. Given a ground query {a mathematical formula}Q=〈M,t,α〉, where {a mathematical formula}M=〈S,W,B〉, we define the answer ?Q to Q as yes, if {a mathematical formula}M,S,t⊩α holds, else no.
      </paragraph>
      <paragraph>
       To define the semantics of non-ground queries, we need the notions of a substitutionσ, defined as mapping {a mathematical formula}V∪U→C∪N that assigns (i) each variable {a mathematical formula}V∈V a constant {a mathematical formula}σ(V)∈C, and (ii) each time variable {a mathematical formula}U∈U a natural number {a mathematical formula}σ(U)∈N. The grounding{a mathematical formula}σ(α) (respectively {a mathematical formula}σ(u)) of formula α (respectively time pin u) due to σ is obtained by applying the substitutions on variables/time variables as usual. Given a timeline T, we say a substitution σ is over{a mathematical formula}(C,T), if the image of σ is contained in {a mathematical formula}C∪T; we denote by {a mathematical formula}σ(C,T) the set of all such substitutions. With this, we define the answer ?Q to a non-ground query {a mathematical formula}Q=〈M,u,α〉 by{a mathematical formula} This definition gives a general semantics to two important subclasses of non-ground queries {a mathematical formula}Q=〈M,u,α〉. First, if α is ground and {a mathematical formula}u∈U is a time variable, then the answer to Q amounts to the time points when α holds. Dually, if {a mathematical formula}u∈N and α is non-ground, we obtain a semantics for non-ground formula evaluation at a fixed time point.
      </paragraph>
      <paragraph label="Example 17">
       For queries, the set of window functions W in a stated structure {a mathematical formula}M=〈S,W,B〉 is implicitly given by the window operators used in α. In case we make use of background knowledge (beyond implicit auxiliary atoms for arithmetic) the set B is defined explicitly. Consider again the stream from Fig. 2(b), which we now formalize by {a mathematical formula}S=(T,υ), where {a mathematical formula}T=[30,50]. We ask:
      </paragraph>
      <list>
       <list-item>
        At {a mathematical formula}t=45, which trams arrived at which stations in the last 5 minutes?
       </list-item>
       <list-item>
        At {a mathematical formula}t=45, at which times and which stations did tram {a mathematical formula}a3 arrive in the last 5 minutes?
       </list-item>
       <list-item>
        At which times did we record a tram arrival at a station, where a bus arrived within the next 3 minutes?
       </list-item>
      </list>
      <paragraph label="Example 18">
       We observe that the operator @ allows for replaying a historic query. At any time {a mathematical formula}t′&gt;t, we can ask {a mathematical formula}〈M,t′,@tα〉 to simulate a previous query {a mathematical formula}〈M,t,α〉. In fact, this applies for any {a mathematical formula}t′∈N. cont'dConsider again {a mathematical formula}Q1 from Example 17, where {a mathematical formula}α1 is evaluated at {a mathematical formula}t=45, and an answer {a mathematical formula}σ∈?Q1. Then, for any time point {a mathematical formula}t′∈N, σ is also an answer of {a mathematical formula}〈M,t′,@45α1〉, since by definition, {a mathematical formula}M,S,45⊩σ(α1) iff {a mathematical formula}M,S,t′⊩@45σ(α1) and {a mathematical formula}45∈T.  □
      </paragraph>
      <paragraph label="Example 20">
       Nested windows Typically, window functions are used exclusively to restrict the processing of streams to a recent subset of the input. In our view, window functions provide a flexible means to discard data. cont'dRecall that we can select the last appearance of tram {a mathematical formula}a1 by first using a filter window function {a mathematical formula}fA for tram atoms {a mathematical formula}A={tram(a1,c)|c∈C} followed by a tuple-based window. We now also ask at which time U the tram was last recorded. The according LARS query {a mathematical formula}Q=〈M,45,α〉 is given by {a mathematical formula}M=〈D,{fA,#1},∅〉 and {a mathematical formula}α=⊞A⊞#1@Utram(a1,St), which has the single answer {a mathematical formula}σ={St↦m,U↦44}. That is, tram {a mathematical formula}a1 last appeared at station m at time 44.  □ LARS formulas provide a powerful, flexible language to query streaming data. However, the formalism presented so far has no means of expressing auxiliary information, i.e., intensional atoms, and thus comes with limitations. Dual to query {a mathematical formula}Q3 in Example 17, we now want to ask for which tram appearances no bus arrived within 3 minutes at the same station. The intended answer to this query should only contain tram {a mathematical formula}a3 at station h at time 40. A naive translation simply adds negation to {a mathematical formula}α3, i.e., {a mathematical formula}α3′=tram(A,St)∧¬⊞+3◇bus(B,St). However, the resulting query {a mathematical formula}Q3′=〈M,U,α3′〉 expresses the following: at which time points U did some tram appear at station St, where within the next 3 minutes there was no bus recording at St for any B, i.e., for any constant that can be substituted for B. Thus, whenever a tram {a mathematical formula}ai is at station st at time t, we hypothetically consider any atom {a mathematical formula}bus(x,St), where {a mathematical formula}x∈C, at time points {a mathematical formula}n=t, {a mathematical formula}t+1, {a mathematical formula}t+2, {a mathematical formula}t+3, and get an answer of form {a mathematical formula}{A↦ai,St↦st,B↦x,U↦t}, whenever {a mathematical formula}bus(x,st) is not in the evaluations from {a mathematical formula}υ(t) to {a mathematical formula}υ(t+3) in D. That results in answers like the following:{a mathematical formula} Clearly, we can limit scope of B by considering only constants that have been observed as bus identifiers so far, using {a mathematical formula}α3″=tram(A,St)∧¬⊞+3◇bus(B,St)∧◇bus(B,St′). The additional subformula {a mathematical formula}◇bus(B,St′) now matches all bus appearances throughout the stream and will thus be joined with every tram appearance {a mathematical formula}tram(A,St) (at time U). Semantically, this cross product yields potential answers of form {a mathematical formula}{A↦ai,St↦st,B↦x,St′=st′,U↦t}, which are reduced by those entries for which {a mathematical formula}bus(x,st) appeared between t and {a mathematical formula}t+3. For instance, {a mathematical formula}{A↦a1,St↦b,B↦b1,St↦y,U↦36}, where {a mathematical formula}y∈{b,s,m}, is not returned since {a mathematical formula}bus(b1,b) appeared at 36. We get, among others, the following answers:{a mathematical formula} The first question is how the result shall be interpreted. The non-essential {a mathematical formula}St′ does not capture anything of the conceptual query, which does not talk about stations of arbitrary bus stations. To remedy this, a simple post-processing may filter out such bindings and reduce resulting duplicates accordingly. However, this still leaves wrong results. For instance, the first three answers would reduce to {a mathematical formula}{A↦a1,St↦b,B↦b2,U↦36}. What this answer says is that bus {a mathematical formula}b2 did not arrive at station b within 3 minutes, but we intended to query for tram appearances after which no bus arrived.  □ The fundamental problem in Example 20 is that we query for substitutions of a bus identifier B when we are interested in cases where none exists. That is, we have to abstract away from specific bus existences which can only be expressed by auxiliary atoms, i.e., intensional atoms. Thus, towards more expressive reasoning over data streams, we now introduce LARS programs.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       LARS programs
      </section-title>
      <paragraph label="Definition 14">
       Now we define a rule language for stream reasoning with semantics similar to Answer Set Programming. Rule, ProgramA programP is a set of rules, i.e., expressions of the form{a mathematical formula} where {a mathematical formula}α,β1,…,βn∈F are formulas.
      </paragraph>
      <paragraph>
       Given a rule r of form (9), {a mathematical formula}H(r) denotes the headα, and {a mathematical formula}β(r)=β1∧…∧βn the body of r; the commas in (9) are a syntactic variant of ∧ as usual.
      </paragraph>
      <paragraph>
       Suppose we want to evaluate a program P on a data stream D. Let {a mathematical formula}I=(T,υ) be a stream such that {a mathematical formula}D⊆I. If at every time point in T, all atoms that occur in I but not in D have intensional predicates, then we call I an interpretation stream for D. Any rule r amounts to the material implication{a mathematical formula} Consider a structure {a mathematical formula}M=〈I,W,B〉, called an interpretation (for D). We then say
      </paragraph>
      <list>
       <list-item label="–">
        M is a model of rule{a mathematical formula}r∈Pfor D at time t, denoted {a mathematical formula}M,t⊨r, if {a mathematical formula}M,t⊨β(r)→H(r);
       </list-item>
       <list-item label="–">
        M is a model of P for D at time t, denoted {a mathematical formula}M,t⊨P, if {a mathematical formula}M,t⊨r for all rules {a mathematical formula}r∈P;
       </list-item>
       <list-item label="–">
        M a minimal model, if no model {a mathematical formula}M′=〈S′,W,B〉 of P for D at time t exists such that {a mathematical formula}S′=(T,υ′) and {a mathematical formula}S′⊂S.
       </list-item>
      </list>
      <paragraph label="Definition 15">
       Note that minimality is defined w.r.t. to the same timeline T. We often omit “for D” and/or “at t” if this is clear from the context. The reduct of a program P with respect to M at time t is defined by {a mathematical formula}PM,t={r∈P|M,t⊨β(r)}, i.e., the subset of rules whose bodies are satisfied. Answer streamLet {a mathematical formula}M=〈I,W,B〉 be a structure, where {a mathematical formula}I=(T,υ) is an interpretation stream for a data stream D, let P be a program and {a mathematical formula}t∈T. Then, I is called an answer stream of P for D at time t (relative to W and B), if M is a ⊆-minimal model of the reduct {a mathematical formula}PM,t for D at time t. Intuitively, the reduct {a mathematical formula}PM,t serves to disregard irrelevant rules with respect to an interpretation, i.e., those that do not fire. The remaining ones need to be satisfied in order for M to be a model. By demanding in addition that M is minimal, we ensure that all conclusions are supported, i.e., each intensional atom in an answer stream can be justified by derivations from (chains of) firing rules based on extensional atoms, i.e., atoms from the stream or background data. Anything not derivable this way is assumed to be false, i.e., we adopt default negation.
      </paragraph>
      <paragraph>
       For ASP fragments of LARS, answer streams correspond to answer sets as defined by the FLP-reduct [59], which we formulated for LARS programs above. More precisely, consider an interpretation stream {a mathematical formula}I=({t},υ′) for a data stream {a mathematical formula}D=({t},υ) and let {a mathematical formula}PASP be a program where in each rule of form (9) all body formulas {a mathematical formula}βi are literals, i.e., atoms or negated atoms, and the head α is a disjunction of atoms. Then, we have:
      </paragraph>
      <paragraph label="Proposition 1">
       For I and{a mathematical formula}PASPas described, I is an answer stream of P for D at t relative to arbitrary W and B iff{a mathematical formula}υ′(t)is an answer set of{a mathematical formula}PASP∪υ(t)∪B. That is, ordinary answer set programs are subsumed by LARS programs. In other words, the rich semantic properties of ASP carry over to LARS. We thus obtain a nonmonotonic semantics that comes with possibly multiple, supported minimal models. Section 3.3 below further explores the semantic properties of LARS.
      </paragraph>
      <paragraph label="Example 22">
       Non-ground programs. As for formulas, we consider non-ground programs as schematic versions of ground programs with variables of two sorts, namely constant variables {a mathematical formula}V and time variables {a mathematical formula}U. The semantics of these non-ground programs is given by the answer streams of according groundings, obtained by replacing variables with constants from {a mathematical formula}C, respectively time points from T, in all possible ways. cont'dWe now solve the problem of Example 20 as follows: the intention of formula {a mathematical formula}α3′ is formalized as rule {a mathematical formula}r1 which uses the intensional atom aBus, derived by rule {a mathematical formula}r2:{a mathematical formula} Here, q is the output relation which may be used for post processing and aBus is the intended abstraction for the appearance of any bus at the given station St. Rule {a mathematical formula}r2 assigns to any time point U an (intensional) atom {a mathematical formula}aBus(St) whenever there is an atom {a mathematical formula}bus(B,St) at U.Apart from the expressiveness issue, intensional atoms may also be used to enhance readability. For instance, the complex formula {a mathematical formula}@U¬⊞+3◇aBus(St) in {a mathematical formula}r1 may be simplified, giving the subformula {a mathematical formula}⊞+3◇aBus(St) a name on its own. This leads to the following approach:{a mathematical formula} Note further that rule {a mathematical formula}r2′ may be written without the use of a window as{a mathematical formula} Using the program {a mathematical formula}P={r1′,r2′}, we now get the intended result in the single answer stream {a mathematical formula}I=(T,υI) at {a mathematical formula}t=45: the evaluation function {a mathematical formula}υI assigns intensional atoms as follows (grouping shared time points):{a mathematical formula} That is, {a mathematical formula}busSoon(b) is assigned to time points 33, 34, 35, and 36, {a mathematical formula}busSoon(s) holds throughout the interval from 37 to 40, {a mathematical formula}busSoon(m) from 42 until 45; and the evaluation of time point 45 additionally contains {a mathematical formula}q(40,a3,h). The latter derivation correctly reflects that only at station h no bus appeared within 5 minutes after a tram appearance (tram {a mathematical formula}a3 at minute 40).  □ Particular semantic assets for LARS programs are inherited from Answer Set Programming, i.e., a multiple-model semantics permitting nonmonotonic reasoning. cont'dThe requests (i) and (ii) from Example 1 can be formulated by rules (11) and (12), respectively.{a mathematical formula}{a mathematical formula} Rule (11) encodes when a tram is expected at later stops. Similarly as in Example 9, we use for the partition-based window operator {a mathematical formula}⊞idx,n the index function idx such that {a mathematical formula}idx(g)=i for an atom {a mathematical formula}g∈G of form {a mathematical formula}tram(ai,X) and {a mathematical formula}idx(g)=0 else. By the tuple-based windows of sizes {a mathematical formula}n(i)=1 for {a mathematical formula}i&gt;0 and {a mathematical formula}n(0)=0 we get for each tram {a mathematical formula}ai only its most recent appearance at some stop X. Usually, the expected arrival time on the next stop can be computed by the traveling duration according to the table plan. For the case of traffic jams within the last 20 minutes, we block such conclusions by means of default negation.Next, rule (12) builds on the expected arrival times of rule (11) to identify good connections where the targeted tram is not an old make and the expected waiting time is at most 5 minutes. It uses a time-based window that looks 5 minutes ahead from the time when {a mathematical formula}exp(ID1,X) is concluded and checks the existence (operator ◇) of an expected (different) tram {a mathematical formula}ID2.We observe that the interpretation stream of the structure M of Example 14 is an answer stream of P for D at time t. Note that {a mathematical formula}gc(a3,a1,m) is not derived. Tram {a mathematical formula}a1 appears one minute after {a mathematical formula}a3 at Mozart Circus, but it is old.  □
      </paragraph>
      <paragraph label="Example 23">
       The next example demonstrates another advantage of our rule-based approach, namely the possibility to obtain different models for nondeterministic choices. cont'dConsider an extended scenario where a tram with identifier {a mathematical formula}a2 of line {a mathematical formula}ℓ2 is reported at Gulda Lane (g) at time point 38. This updates the data stream {a mathematical formula}D=(T,υ) in Example 3 (Fig. 1(b)) to {a mathematical formula}D′=(T,υ′), where {a mathematical formula}υ′=υ∪{38↦{tram(a2,g)}}. By the entries {a mathematical formula}line(a2,ℓ2) and {a mathematical formula}plan(ℓ2,g,m,7) in B, rule (11) derives that tram {a mathematical formula}a2 is expected to arrive at Mozart Circus at {a mathematical formula}t=45. Furthermore, we now assume that tram {a mathematical formula}a1 is not old, i.e., {a mathematical formula}old(a1)∉B. This gives Bob three good connections at stop m, when leaving tram {a mathematical formula}a3 at time 43:{a mathematical formula} Bob is not interested in the connection from {a mathematical formula}a1 to {a mathematical formula}a2, since he is currently traveling with {a mathematical formula}a3. His smart phone streams an according tuple {a mathematical formula}on(a3) at query time. This leaves him two options: he can either change to line {a mathematical formula}ℓ1 (and take tram {a mathematical formula}a1 after 1 minute at time point 44), or to line {a mathematical formula}ℓ2 (and take tram {a mathematical formula}a2 after 2 minutes at 45). The following two rules formalize the possibility to either change trams or skip a good connection:{a mathematical formula}{a mathematical formula} Consider the program P consisting of rules (11)–(14). Moreover, let {a mathematical formula}D″=(T,υ″) be the data stream obtained from {a mathematical formula}D′ by adding {a mathematical formula}{42↦{on(a3)}} to the evaluation and let {a mathematical formula}I0=(T,υ0), {a mathematical formula}I1=(T,υ1) and {a mathematical formula}I2=(T,υ2) be the following interpretation streams for {a mathematical formula}D″: we take{a mathematical formula} and for {a mathematical formula}i∈{1,2}, let {a mathematical formula}υi=υ0∪{42↦choicei}, where{a mathematical formula} Then, {a mathematical formula}I1 and {a mathematical formula}I2 are (the only) two answer streams for P at time 42 relative to {a mathematical formula}W={τ,p} and B, i.e., we get the user choices as separate models.  □
      </paragraph>
      <paragraph>
       Note that in this example we did not constrain good connections by the actual destination Bob wants to reach. By means of the presented formalism, such reachability relations can be expressed elegantly through recursion as in Datalog.
      </paragraph>
      <paragraph label="Example 24">
       Another benefit of our approach for advanced stream reasoning is the possibility to retract previous conclusions due to new input data. Combined with (minimal) model generation, i.e., alternatives that may be enumerated, compared under preference etc., such nonmonotonic reasoning allows for sophisticated AI applications in data stream settings. cont'dIf the lines {a mathematical formula}ℓ1 and {a mathematical formula}ℓ2 have the same traveling time from Mozart Circus to Strauß Avenue, Bob will pick {a mathematical formula}choice1 (answer stream {a mathematical formula}I1), since at {a mathematical formula}t=42 tram {a mathematical formula}a1 is expected to arrive one minute earlier than tram {a mathematical formula}a2.Suppose a few seconds later (still at {a mathematical formula}t=42) a traffic jam is reported for Beethoven Square. Thus, we now consider the data stream {a mathematical formula}Dj=(T,υj), where {a mathematical formula}υj=υ∪{42↦{on(a3),jam(b)}}. Thus, we have no expectation anymore when tram {a mathematical formula}a1 will arrive at Mozart Circus. Now {a mathematical formula}exp(a1,m) cannot be concluded for {a mathematical formula}t=44, and as a consequence, {a mathematical formula}gc(a3,a1,m) will not hold anymore. Thus, the previous two answer streams are discarded and only {a mathematical formula}change(a3,a2,m) remains recommended in the resulting unique answer stream.  □
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       Semantic properties of LARS programs
      </section-title>
      <paragraph>
       In this subsection, we show that some basic properties of the answer semantics of logic programs carry over to the notion of answer stream defined above. These are minimality of answer streams, supportedness by rules and consistency, i.e., existence of an answer stream in the absence of negation provided that the windows functions involved are monotonic, i.e., return growing substreams if the stream data increases.
      </paragraph>
      <paragraph label="Theorem 1">
       Let P be a program, D be a data stream and {a mathematical formula}t∈N. By {a mathematical formula}AS(P,D,t) we denote the set of answer streams of P for D at time t. The letter M always stands for the structure {a mathematical formula}M=〈I,W,B〉, where I is the considered answer stream, and W and B are implicit and fixed. By Definition 15, the structure M (due to answer stream I) is a minimal model of the reduct {a mathematical formula}PM,t for D at time t. Importantly, this implies that M is a model of the original program P, and in fact a minimal model. Minimality of answer streamsLet P be a LARS program, D be a data stream, t be a time point and{a mathematical formula}I∈AS(P,D,t). Then,{a mathematical formula}M=〈I,W,B〉is a minimal model of P for D at time t.
      </paragraph>
      <paragraph label="Theorem 2">
       Thus, answer streams warrant the property of minimality that answer sets enjoy, in the spirit of logic programming semantics. A simple consequence of minimality of models is the following. IncomparabilityAnswer streams are incomparable w.r.t. ⊆. That is, if{a mathematical formula}I,I′∈AS(P,D,t), then{a mathematical formula}I≠I′implies{a mathematical formula}I⊈I′and{a mathematical formula}I′⊈I. Our definition of answer streams follows the approach in [59], which requires a supporting rule for every derived atom. In other words, dropping any atom from an answer set would invalidate some rule. In our case, dropping an intensional atom a from an answer stream would lead to an unsatisfied rule that supports its derivation for some time point {a mathematical formula}t′. To simplify notation, we consider {a mathematical formula}I=(T,υ) also as set {a mathematical formula}{t′↦a|a∈υ(t′),t′∈T}. Accordingly, {a mathematical formula}I∖{t′↦a} amounts to removing in I atom a from {a mathematical formula}υ(t′), etc. SupportednessLet{a mathematical formula}I∈AS(P,D,t). Then, for every{a mathematical formula}t′↦a∈I∖Dthere exists a rule{a mathematical formula}r∈Psuch that (i){a mathematical formula}M,t⊨β(r)and (ii){a mathematical formula}M′,t⊭r, where{a mathematical formula}M′=〈I∖{t′↦a},W,B〉. Note that the conditions (i) and {a mathematical formula}(ii) in Theorem 2 amount for ordinary logic programs to the usual notion of supportedness of answer sets: if the rule head {a mathematical formula}α=a1∨⋯∨ak in (ii) is a disjunction of atoms, then M must satisfy a single atom {a mathematical formula}ai in α, and {a mathematical formula}ai=a.
      </paragraph>
      <paragraph>
       Finally, let us consider LARS programs in which α and each formula {a mathematical formula}βi are positive, i.e., each atom occurs in the formula tree only under an even number of negations; we call such programs positive. As for windows, we naturally call a window function wmonotonic, if for any streams S and {a mathematical formula}S′ such that {a mathematical formula}S⊆S′ and for any time {a mathematical formula}t′ it holds that {a mathematical formula}w(S,t′)⊆w(S′,t′). Then we obtain
      </paragraph>
      <paragraph label="Theorem 3">
       ConsistencyLet P be a positive LARS program such that all heads α of rules in P are satisfiable and all window operator{a mathematical formula}⊞woccurring in P have monotonic window functions w. Then for any D and t, (i){a mathematical formula}AS(P,D,t)≠∅and (ii) any{a mathematical formula}M=〈I,W,B〉is a minimal model of{a mathematical formula}PM,tat t iff{a mathematical formula}I∈AS(P,D,t).
      </paragraph>
      <paragraph>
       For example, sliding time-based windows are monotonic and likewise the other time-based windows considered above; furthermore, also filter windows are monotonic. Tuple-based windows (thus also partition-based windows) are not monotonic, and the statement in the theorem does not hold, even for very restricted rule syntax.
      </paragraph>
      <paragraph label="Example 25">
       Consider the program P consisting of the rules{a mathematical formula} and assume that the tie-break in the tuple selection is by lexicographic ordering, i.e., a before b before c before d. Informally, {a mathematical formula}⊞#1◇x expresses that the single selected tuple is x. Then {a mathematical formula}M=〈I,W,B〉 where (in abuse of notation) {a mathematical formula}I={a,b,c} is a model of P for the data stream {a mathematical formula}D=([0,0],∅) at {a mathematical formula}t=0. Moreover, it is the single minimal model for D at t: for any other model {a mathematical formula}M′=〈I′,W,B〉, we have that {a mathematical formula}d∈I′ implies {a mathematical formula}I′={a,b,c,d} (by {a mathematical formula}r0 and {a mathematical formula}r2), which is not minimal. Furthermore, {a mathematical formula}{a,b}∩I′=∅ would lead by {a mathematical formula}r1 and {a mathematical formula}r2 to {a mathematical formula}{a,b}⊆I′, which is contradictory; similarly {a mathematical formula}I′={c,a} (respectively {a mathematical formula}I′={c,b}) would lead by {a mathematical formula}r3 to {a mathematical formula}b∈I′ (respectively by {a mathematical formula}r4 to {a mathematical formula}a∈I′), which is again a contradiction. Thus, M is the only answer stream candidate. However, the reduct {a mathematical formula}PM,t={r0;r3} has a model {a mathematical formula}M′=〈I′,W,B〉 for D at t where {a mathematical formula}I′={c,b}. Thus, M is not an answer stream of P for D at {a mathematical formula}t=0 and {a mathematical formula}AS(P,D,t)=∅ follows. (The same holds if we replace {a mathematical formula}r2 with rules {a mathematical formula}a←d and {a mathematical formula}b←d; the resulting program is in the plain LARS fragment; cf. Section 6.1.)  □
      </paragraph>
      <paragraph>
       However, refined versions of tuple-based windows, which e.g. count only extensional data (as occurs often in practice), are monotonic and thus admissible in Theorem 3; furthermore, monotone windows can be nested as monotonicity is preserved. We remark that the consistency result (part (i) of the theorem) can be extended to classes of programs with layered (stratified) negation and recursion through non-monotonic windows.
      </paragraph>
      <paragraph>
       We note that Definition 14 is liberal in the sense that it permits extensional atoms also in rule heads. This is convenient in some scenarios with complex rule heads. Notably, any answer stream for a data stream D may only add intensional atoms to D. Thus, satisfaction of extensional atoms in rule heads anyway hinges on the input D; it is not possible to infer input data. If desired, one may rewrite a program in order to exclude extensional atoms from rule heads. To this end, one replaces every extensional predicate p (that is mentioned in a rule head) by a fresh intensional predicate {a mathematical formula}p′ and adds the rules {a mathematical formula}@Tp′←@Tp, {a mathematical formula}@T¬p′←@T¬p (or for the latter rule, alternatively the constraint {a mathematical formula}⊥←◇(p′∧¬p)). In case a ground program is required that works for all inputs, one may alternatively use the following set of rules, where {a mathematical formula}p″ is another fresh predicate:{a mathematical formula} Clearly, using these encodings, the answer streams of the original program P and of the rewritten program {a mathematical formula}P′ are in one-to-one correspondence. Moreover, we note that for programs that do not use extensional predicates in rule heads, data streams can be reduced to programs without extensional data, by replacing any input atom {a mathematical formula}p∈υ(t) in a data stream {a mathematical formula}D=(T,υ) by the fact {a mathematical formula}@tp←.
      </paragraph>
      <paragraph>
       In conclusion, we find that LARS programs have basic semantic properties comparable to those of ordinary answer set programs under the FLP-reduct. They can thus be seen as an extension of ASP for use cases in streaming with flexible window functions.
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Computational complexity of reasoning in LARS
     </section-title>
     <paragraph>
      In this section, we analyze the computational complexity of LARS, where we consider model checking and the satisfiability problem, for both LARS formulas and programs. In our analysis, we concentrate on the general case but pay attention to the effect of nested windows and particular classes of windows; a comprehensive study of the computational complexity for a rich taxonomy of classes of LARS formulas and LARS programs remains however for further study.
     </paragraph>
     <section label="4.1">
      <section-title>
       Problem statements and overview of results
      </section-title>
      <paragraph>
       We say that a stream {a mathematical formula}S=(T,υ)is over a subset {a mathematical formula}A′⊆A of atoms {a mathematical formula}A, if {a mathematical formula}v(t)∖A′=∅ for all {a mathematical formula}t∈T. We study the complexity of the following reasoning tasks, where in the sequel W is a set of window functions that are evaluable in polynomial time, {a mathematical formula}B⊆A is a set of background atoms, and where α is a ground LARS formula and P a ground LARS program.
      </paragraph>
      <list>
       <list-item label="(1)">
        Model Checking (MC). Given {a mathematical formula}M=〈S⋆,W,B〉, {a mathematical formula}S⋆=(T,υ), and {a mathematical formula}t∈T, check whether
       </list-item>
       <list-item label="(2)">
        Satisfiability (SAT). For decidability, we assume that relevant atoms are confined to a subset {a mathematical formula}A′⊆A of polynomial size in the input. The reasoning tasks are:
       </list-item>
      </list>
      <paragraph>
       Table 1 shows the computational complexity of reasoning in ground LARS, where {a mathematical formula}α− and {a mathematical formula}P− denotes the class of formulas respectively programs where the nesting depth of window operators in formulas and rules is bounded by a constant.
      </paragraph>
      <paragraph>
       As we can see from Table 1, in the general case model checking and satisfiability checking are both {a mathematical formula}PSpace-complete, and thus beyond the Polynomial Hierarchy. Informally, the recursive evaluation of a formula creates an exponential size tree, but at each point in time, only a polynomial size portion of this tree needs to be in memory. The {a mathematical formula}PSpace-hardness arises from the temporal operators □ and ◇ in combination with window operators. This allows for encoding quantified Boolean formulas (QBFs), whose evaluation is a canonical {a mathematical formula}PSpace-complete problem.
      </paragraph>
      <paragraph>
       The picture changes if we bound the window nesting depth in formulas and programs. Under a constant bound, the evaluation tree that is built has only polynomially many nodes (i.e., substreams). This allows us to solve the model checking problem for ground {a mathematical formula}α− formulas in polynomial time by using labeling techniques. The remaining results for satisfiability testing and for ground LARS programs are obtained from guess and check algorithms. The lower bounds (the hardness results) are in essence inherited from the complexity of answer set programs, except for model checking of LARS formulas. The {a mathematical formula}P-hardness of the latter problem is due to the generic form of windows whose associated functions can be {a mathematical formula}P-hard.
      </paragraph>
      <paragraph>
       Note that from the results on Model Checking in Table 1, we immediately obtain complexity results for answering ground queries {a mathematical formula}Q=〈M,t,α〉: the problem is {a mathematical formula}PSpace-complete in general, but polynomial for bounded window-nesting; and as the discussion in Section 4.3 shows, this generalizes to a richer class of queries.
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Derivation of the complexity results
      </section-title>
      <paragraph>
       LARS formulas. The complexity results for LARS formulas in the general case are based on the following result for model checking.
      </paragraph>
      <paragraph label="Theorem 4">
       Given a structure{a mathematical formula}M=〈S⋆,W,B〉, a stream{a mathematical formula}S=(T,υ)such that{a mathematical formula}S⊆S⋆, a time point t, and an arbitrary ground formula α, deciding{a mathematical formula}M,S,t⊩αis{a mathematical formula}PSpace-complete, where the{a mathematical formula}PSpace-hardness holds for{a mathematical formula}S=S⋆. Intuitively, {a mathematical formula}PSpace-membership is shown by a depth-first-search evaluation of the input formula α along its tree representation. An example for the formula tree is shown in Fig. 13.
      </paragraph>
      <paragraph>
       At each node of the tree, we need to store the content according to the window operators that are applied as in the path from the root. This requires only polynomial space for that node and all nodes on the path to it as well.
      </paragraph>
      <paragraph>
       The {a mathematical formula}PSpace-hardness is shown by a reduction from evaluating QBFs {a mathematical formula}∃x1∀x2⋯Qnxnϕ(x) to model checking. A LARS formula {a mathematical formula}α=◇⊞set:x1□⊞set:x2⋯ϕ(x) on the timeline {a mathematical formula}T=[0,1] is constructed where the window operator {a mathematical formula}⊞set:xi effects the possible truth assignments to {a mathematical formula}xi at the time points 0 or 1. To this end, the initial stream {a mathematical formula}S⋆ has all atoms {a mathematical formula}x1,…,xn at both 0 and 1. When {a mathematical formula}⊞set:xi is evaluated at time point 0 (respectively 1), it removes {a mathematical formula}xi from (respectively keeps {a mathematical formula}xi in) the stream. By branching to 0 or 1, all truth assignments to {a mathematical formula}x1,…,xn are generated in an evaluation tree. On top, ◇, □ naturally encode the quantifiers ∃ and ∀. Fig. 14 shows an example evaluation tree: the bold lines mark subtrees for which, given the assignment to {a mathematical formula}x1,…,xi by the path, the subformula {a mathematical formula}Qi+1xi+1…Qnxnϕ(x) evaluates to true. (More details are given in the Appendix.)
      </paragraph>
      <paragraph>
       For the satisfiability problem of LARS formulas, we obtain a similar result.
      </paragraph>
      <paragraph label="Theorem 5">
       Problem SAT for LARS formulas, i.e., given W, B, T, and t, is there a stream{a mathematical formula}S=(T,υ)is over{a mathematical formula}A′such that{a mathematical formula}M,S,t⊩α, where{a mathematical formula}M=〈S,W,B〉, is{a mathematical formula}PSpace-complete. Informally, a suitable evaluation function can be guessed and checked in polynomial space, and from {a mathematical formula}NPSpace = {a mathematical formula}PSpace we obtain membership in {a mathematical formula}PSpace. On the other hand, LARS model checking can be easily reduced to satisfiability testing (see Appendix).
      </paragraph>
      <paragraph>
       LARS programs. Based on Theorem 4, we show that model checking for ground LARS programs has the same complexity as for LARS formulas in general.
      </paragraph>
      <paragraph label="Theorem 6">
       Problem MC for LARS programs, i.e., given a structure{a mathematical formula}M=〈I,W,B〉, a data stream D, a program P, and a time point t, deciding whether{a mathematical formula}I=(T,υ)is an answer stream of P for D at time t, is{a mathematical formula}PSpace-complete.
      </paragraph>
      <paragraph>
       Informally, this holds because it suffices to check that {a mathematical formula}M,t⊨P and that no model {a mathematical formula}M′ smaller than M exists that satisfies the reduct {a mathematical formula}PM,t (at time t); building the latter and testing all candidate {a mathematical formula}M′ is feasible in polynomial space. The {a mathematical formula}PSpace-hardness is inherited from model checking for LARS formulas (see Appendix).
      </paragraph>
      <paragraph>
       For checking satisfiability of LARS programs, we obtain based on the previous theorem also {a mathematical formula}PSpace-completeness.
      </paragraph>
      <paragraph label="Theorem 7">
       Deciding SAT for LARS programs, i.e., given{a mathematical formula}W,B,Dand some LARS program P, does P have some answer stream I over{a mathematical formula}A′for D at t, is{a mathematical formula}PSpace-complete. As for the membership part, a guess for an answer stream of P w.r.t. data stream D and a time point t has polynomial size and can be verified in polynomial space; the {a mathematical formula}PSpace-hardness is again inherited from model checking for LARS formulas (see Appendix).
      </paragraph>
      <paragraph>
       Bounded window nesting. Revisiting Fig. 14, we see that an exponential size evaluation tree results from the evaluation of nested window operators {a mathematical formula}⊞set:xi, where each of them is evaluated at both time points 0 and 1. In this way, exponentially many different substreams are produced in the evaluation. Such an exponential explosion is avoided, if we bound the nesting of window operators in LARS formulas.
      </paragraph>
      <paragraph label="Definition 16">
       Window nesting depth {a mathematical formula}wnd(α)The window nesting depth of a LARS formula α, denoted {a mathematical formula}wnd(α), is the maximal number of window operators encountered on any path from the root to a leaf in the formula tree of α.{sup:3} Formally, {a mathematical formula}wnd(a)=0 for every atom a and inductively {a mathematical formula}wnd(¬α)=wnd(□α)=wnd(◇α)=wnd(▹α)=wnd(α); {a mathematical formula}wnd(α∧β)=wnd(α∨β)=wnd(α→β)=max⁡(wnd(α),wnd(β)); and {a mathematical formula}wnd(⊞α)=1+wnd(α). Note in particular that {a mathematical formula}wnd(α)=0 means no window operators occur in α, and that {a mathematical formula}wnd(α)=1 means that window operators occur but unnested.
      </paragraph>
      <paragraph>
       If {a mathematical formula}#w(α) is the number of window operators occurring in a LARS formula α, then at most {a mathematical formula}(#w(α)⋅|T|)wnd(α) many substreams of a stream {a mathematical formula}S=(T,υ) (respectively {a mathematical formula}S⋆=(T⋆,υ⋆)) are created in a recursive evaluation of {a mathematical formula}M,S,t⊩α. If {a mathematical formula}wnd(α) is bounded by a constant, then this number is polynomial in the size of S and α. We can thus use a labeling technique to evaluate formulas bottom up (from subformulas) over the possible substreams in polynomial time.
      </paragraph>
      <paragraph label="Theorem 8">
       Problem MC for LARS formulas α is in{a mathematical formula}P, if{a mathematical formula}wnd(α)is bounded by some constant{a mathematical formula}k≥0, and is{a mathematical formula}P-complete for arbitrary window operators. The {a mathematical formula}P membership part follows from a more general result in the next subsection (Theorem 10). We also have matching {a mathematical formula}P-hardness (and thus {a mathematical formula}P-completeness) in general due to the fact that evaluating window functions can be {a mathematical formula}P-complete in general.
      </paragraph>
      <paragraph>
       As a consequence of Theorem 8, also satisfiability of LARS formulas becomes easier to decide when the nesting depth is bounded.
      </paragraph>
      <paragraph label="Corollary 2">
       Problem SAT for LARS formulas α is{a mathematical formula}NP-complete, if{a mathematical formula}wnd(α)is bounded by some constant{a mathematical formula}k≥0. The membership is via a simple guess and check argument. Since LARS subsumes propositional logic, the problem is clearly also {a mathematical formula}NP-hard.
      </paragraph>
      <paragraph>
       Turning to LARS programs, let us define the window nesting depth for a program P naturally as follows.
      </paragraph>
      <paragraph label="Definition 17">
       Window nesting depth {a mathematical formula}wnd(P)Given a LARS program P, its window nesting depth is defined as {a mathematical formula}wnd(P)=max⁡{wnd(β(r)→α)|α←β(r)∈P}. Our focus is here on finite LARS programs P, for which the nesting depth is always well-defined and finite. For model checking such programs, we obtain the following result.
      </paragraph>
      <paragraph label="Theorem 9">
       Problem MC for LARS programs P is{a mathematical formula}co-NP-complete, if{a mathematical formula}wnd(P)is bounded by some constant{a mathematical formula}k≥0.
      </paragraph>
      <paragraph>
       Informally, an answer stream I of program P can be refuted by a guess and check algorithm in polynomial time, thanks to Theorem 8. The {a mathematical formula}co-NP-hardness is inherited from the problem for ordinary answer set programs. From Theorem 9, the following corollary is not difficult to obtain.
      </paragraph>
      <paragraph label="Corollary 3">
       Problem SAT for LARS programs P is{a mathematical formula}Σ2p-complete, if{a mathematical formula}wnd(P)is bounded by some constant{a mathematical formula}k≥0. The membership in {a mathematical formula}Σ2p follows from Theorem 9, as a candidate answer stream for P w.r.t. a data stream D and time point t can be guessed and checked in polynomial time with an {a mathematical formula}NP oracle. The {a mathematical formula}Σ2p-hardness is inherited from propositional disjunctive logic programs, for which deciding answer set existence is {a mathematical formula}Σ2p-complete [48].
      </paragraph>
     </section>
     <section label="4.3">
      <section-title>
       Semantic restriction: sparse window functions
      </section-title>
      <paragraph>
       Bounding the nesting depth of windows serves as a restriction that allows us to obtain tractability of model checking for LARS formulas. In addition to this syntactic criterion, we can obtain other important cases for which solving this problem is feasible in polynomial time due to semantic properties of the window operators that occur in a LARS formula.
      </paragraph>
      <paragraph>
       An important such property is that a window operator {a mathematical formula}⊞w and a nested window operator {a mathematical formula}⊞w1⊞w2, applied to a stream S from a small (polynomial size) set of streams, will always return a stream from that set. By sharing nodes in the substream evaluation tree, the resulting evaluation graph has polynomial size and the relevant subformula labeling for deciding satisfiability can be produced in polynomial time. Following the intuition that such window operators/functions can produce only few substreams in total, we call them sparse.{sup:4}
      </paragraph>
      <paragraph>
       A prototypical example of sparse window functions/operators (or sparse windows, for short) are (generalized) sliding time-based windows {a mathematical formula}⊞ℓ,u (short for {a mathematical formula}⊞ℓ,u(1), i.e., hop size {a mathematical formula}d=1) that cover the previous ℓ and the next u time points.{sup:5} Applied on a stream {a mathematical formula}S=(T,υ), the resulting window at time point t is the substream {a mathematical formula}S|T′, which restricts the timeline to {a mathematical formula}T′=T∩[t−ℓ,t+u]. Notably, the result of evaluating nested sliding time-based windows {a mathematical formula}⊞ℓ1,u1⋯⊞ℓk,uk also is a substream {a mathematical formula}S′ obtained by simply restricting the timeline; overall, there are {a mathematical formula}O(|T|2) many such {a mathematical formula}S′.
      </paragraph>
      <paragraph>
       We next describe evaluation graphs and results for sparse windows in more detail, and then discuss concrete classes of window operators that ensure the sparse window property. All time-based, tuple-based and filter windows considered in Section 2.3, 2.4, and 2.6, respectively, are among them, as well as a large class of partition-based windows in Section 2.5; furthermore, windows from these classes can be mixed arbitrarily.
      </paragraph>
      <paragraph>
       For uniformity, we regard in the sequel the reset operator ▹ in abuse of the notion as a window operator that yields, in the context of a structure {a mathematical formula}M=〈S⋆,W,B〉, the original stream; i.e., ▹ is viewed as {a mathematical formula}⊞w▹S⋆ where {a mathematical formula}wS▹⋆(S,t)=S⋆ (for all {a mathematical formula}t∈N).
      </paragraph>
      <paragraph>
       Window graph. For any formula φ, we refer to the sequences of window operators {a mathematical formula}⊞w1→⊞w2→⋯→⊞wk of φ along the branches of the formula tree of φ, where {a mathematical formula}k=1,2,…, as the window-paths of φ. Consider now a structure {a mathematical formula}M=〈S⋆,W,B〉 and a substream {a mathematical formula}S⊆S⋆. We call a set {a mathematical formula}S of streams an evaluation base of {a mathematical formula}(M,S,φ) and write {a mathematical formula}SB(M,S,φ) or simply {a mathematical formula}SB, if it contains S and each stream {a mathematical formula}Sk+1 that results if we apply the window operators {a mathematical formula}⊞wk, starting from {a mathematical formula}S0=S, at each time point of the current stream {a mathematical formula}Sk recursively along a window-path of φ. An evaluation base includes all streams that can be encountered in the recursive evaluation of {a mathematical formula}M,S,t⊩φ according to Definition 12, but it in general it includes further streams as well (we shall discuss this aspect later in this section). Given such a base {a mathematical formula}SB, the window graph for {a mathematical formula}(M,S,φ), denoted {a mathematical formula}WGSB(M,S,φ) or simply {a mathematical formula}WGSB is the graph {a mathematical formula}WGSB=(N,E) with nodes {a mathematical formula}N=SB and edges E that are obtained inductively along window-paths as follows: add from the node {a mathematical formula}Sk−1 for each time point t in {a mathematical formula}Sk−1 an edge labeled {a mathematical formula}(⊞wk,t) to {a mathematical formula}Sk=wk(Sk−1,t), where {a mathematical formula}S0=S. Informally, paths in {a mathematical formula}WGSB starting at S allow us to navigate between substreams of S as obtained by window operators as they occur in φ.
      </paragraph>
      <paragraph label="Example 26">
       Consider a structure {a mathematical formula}M=〈S⋆,W,B〉, where {a mathematical formula}S⋆=([0,8],υ) and {a mathematical formula}υ={5↦{a},7↦{b},8↦{c}}, and the formula {a mathematical formula}φ=⊞#2(⊞3◇b∧⊞#1◇c). We take {a mathematical formula}S=S⋆. The window-paths of maximal length are {a mathematical formula}p1=⊞#2→⊞3 and {a mathematical formula}p2=⊞#2→⊞#1, i.e., on the initial stream S we can apply {a mathematical formula}⊞#2 (at potentially every time point), and in the resulting streams one can apply {a mathematical formula}⊞3, respectively {a mathematical formula}⊞#1. We now establish an evaluation base {a mathematical formula}SB for {a mathematical formula}(M,S,φ). The initial window operator {a mathematical formula}⊞#2 yields potential windows {a mathematical formula}#2(S,0),…,#2(S,8), i.e., by abbreviating the restriction {a mathematical formula}S|T′ to timeline {a mathematical formula}T′=[a,b] by {a mathematical formula}Sab, the streams {a mathematical formula}S00, {a mathematical formula}S01, {a mathematical formula}S02, …, {a mathematical formula}S06, {a mathematical formula}S57, {a mathematical formula}S78. For path {a mathematical formula}p1, we may now apply on any of these streams at their respective time points the window function {a mathematical formula}τ3, similarly for {a mathematical formula}p2 function {a mathematical formula}#1. This results in an evaluation base {a mathematical formula}SB. Note that some of these additional applications return their input stream, e.g., {a mathematical formula}τ3(S78,8)=S78, since the timeline {a mathematical formula}[7,8] has size 1 and is not shrunk further by a time-based window of size 3.As for the edges of the window graph {a mathematical formula}WGSB, we add in the first step an edge {a mathematical formula}S→S00 with label {a mathematical formula}(⊞#2,0), an edge {a mathematical formula}S→S01 with label {a mathematical formula}(⊞#2,1), …, and an edge {a mathematical formula}S→S78 with label {a mathematical formula}(⊞#2,8). Then, in the second step for {a mathematical formula}p1, we add an edge {a mathematical formula}(S00→S00,0) with label {a mathematical formula}(⊞3,0), {a mathematical formula}S01→S00 with {a mathematical formula}(⊞3,0), {a mathematical formula}S01→S01 with {a mathematical formula}(⊞3,1), …, {a mathematical formula}S06→S52 with {a mathematical formula}(⊞3,5), {a mathematical formula}S06→S36 with {a mathematical formula}(⊞3,6), …, {a mathematical formula}S78→S77 with {a mathematical formula}(⊞3,7), and {a mathematical formula}S78→S78 with {a mathematical formula}(⊞3,8); and similarly with {a mathematical formula}⊞#1 for {a mathematical formula}p2.  □ For our purposes, the following lemma is useful.
      </paragraph>
      <paragraph label="Lemma 1">
       Given a structure{a mathematical formula}M=〈S⋆,W,B〉, a substream{a mathematical formula}S⊆S⋆, a formula φ and an evaluation base{a mathematical formula}SBfor{a mathematical formula}(M,S,φ), the window graph{a mathematical formula}WGSBfor{a mathematical formula}(M,S,φ)is computable in polynomial time.
      </paragraph>
      <paragraph>
       The proof is given in the Appendix.
      </paragraph>
      <paragraph>
       Stream labeling. Given a structure {a mathematical formula}M=〈S⋆,W,B〉, a substream {a mathematical formula}S⊆S⋆ and a window graph {a mathematical formula}WGSB=(N,E) for {a mathematical formula}(M,S,φ), we label each pair {a mathematical formula}(S,t) such that {a mathematical formula}S∈N and {a mathematical formula}t∈T⋆, where {a mathematical formula}S=(T,υ), with relevant formulas that hold in stream S at time t due to the evaluation base {a mathematical formula}SB. We define the label set {a mathematical formula}LSB(S,t) by the following steps:
      </paragraph>
      <list>
       <list-item label="1.">
        Take a subformula {a mathematical formula}⊞wkαk in φ such that {a mathematical formula}⊞w1→⊞w2→⋯→⊞wk is a maximal window-path in the formula tree of φ that has not yet been considered. We label each pair {a mathematical formula}(S,t), such that {a mathematical formula}S=Sk, with all subformulas of {a mathematical formula}αk that evaluate in the stream S at time t to true.More precisely, we add a subformula {a mathematical formula}α′ of {a mathematical formula}αk to {a mathematical formula}LSB(S,t), where {a mathematical formula}S=(T,υ), by a case distinction on the form of {a mathematical formula}α′ due to Definition 12 as follows. We add:
       </list-item>
       <list-item label="2.">
        We label {a mathematical formula}(S,t), where {a mathematical formula}S=Sk−1, with {a mathematical formula}⊞wkαk if {a mathematical formula}(Sk,t) was labeled with {a mathematical formula}αk in Step 1.
       </list-item>
       <list-item label="3.">
        Inductively, the window path {a mathematical formula}⊞w1→⊞w2→…→⊞wi is considered in Step 1 for {a mathematical formula}i&lt;k, i.e., one considers subformula {a mathematical formula}⊞wiαi, after all window operators that occur in {a mathematical formula}αi have been considered. Any subformula {a mathematical formula}⊞wjα of {a mathematical formula}αi starting with a window operator is like an atom, and presence of {a mathematical formula}⊞wjα in {a mathematical formula}LSB(Si,t) reflects the entailment result for this subformula in {a mathematical formula}Si at t.
       </list-item>
      </list>
      <paragraph label="Example 27">
       cont'dConsider the window graph {a mathematical formula}WGSB of Example 26. We are interested whether {a mathematical formula}M,S,8⊩φ holds ({a mathematical formula}S=S⋆) and start illustrating the bottom up evaluation by considering window-path {a mathematical formula}p2 at {a mathematical formula}t=8, i.e., edges {a mathematical formula}S→S78 and {a mathematical formula}S78→S88 with window graph labels {a mathematical formula}(⊞#2,8) and {a mathematical formula}(⊞#1,8), respectively. The (maximal) window-path {a mathematical formula}p2 ends before subformula ◇c which, in Step 1, is evaluated in {a mathematical formula}Sk=S88=([8,8],{8↦{c}}). Thus, we obtain formula labels {a mathematical formula}LSB(Sk,8)={c,◇c}. In Step 2, we thus get {a mathematical formula}LSB(Sk−1,8)={⊞#1◇c}, where {a mathematical formula}Sk−1=S78=([7,8],{7↦{b},8↦{c}}), i.e., the previous stream in the considered path.Likewise, we evaluate subformula ◇b for path {a mathematical formula}p1 at {a mathematical formula}t=8, i.e., the edges {a mathematical formula}S→S78 and {a mathematical formula}S78→S78 with window graph labels {a mathematical formula}(⊞#2,8) and {a mathematical formula}(⊞3,8), respectively. In Step 1, we add label ◇b to {a mathematical formula}LSB(S78,8). Note that b does not hold at time 8 in {a mathematical formula}S78 but {a mathematical formula}b∈LSB(S78,7) (and {a mathematical formula}7∈[7,8]) from similar evaluation, e.g., along path {a mathematical formula}S→S78→S77 with window graph labels {a mathematical formula}(⊞#2,8) and {a mathematical formula}(⊞3,7), respectively. Thus, we add in Step 2 to the formula {a mathematical formula}⊞3◇b to {a mathematical formula}LSB(S78,8) (note that in this path {a mathematical formula}Sk=Sk−1).Step 3 recognizes that all window operators of the conjunction {a mathematical formula}φ′=⊞3◇b∧⊞#1◇c have been considered. Hence, we go to Step 1 and find that for the formula {a mathematical formula}αk=φ′ both conjuncts {a mathematical formula}⊞3◇b and {a mathematical formula}⊞#1◇c are in {a mathematical formula}LSB(S78,8), i.e., {a mathematical formula}φ′ holds and is added. In the next Step 2, we consider {a mathematical formula}Sk−1=S, i.e., the original stream before evaluating {a mathematical formula}⊞#2. (That is, we navigate back the first edge {a mathematical formula}S→S78 with label {a mathematical formula}(⊞#2,8) for either path.) Since {a mathematical formula}φ′ has been added to {a mathematical formula}(S78,8) in Step 1, we now assign {a mathematical formula}LSB(S,8)={⊞#2φ′}. Finally, we recognize in Step 3 that no window operator remains to be considered along paths {a mathematical formula}p1 and {a mathematical formula}p2 at {a mathematical formula}t=8. We skip the stream labeling of further pairs {a mathematical formula}(S,t), as we already obtained that {a mathematical formula}φ∈LSB(S,8) which means that {a mathematical formula}M,S,8⊩φ holds.  □
      </paragraph>
      <paragraph label="Proposition 2">
       Let{a mathematical formula}SBbe an evaluation base for{a mathematical formula}(M,S,φ), where{a mathematical formula}M=〈S⋆,W,B〉and{a mathematical formula}S⊆S⋆, and let{a mathematical formula}t∈T⋆. Then, it holds that{a mathematical formula}M,S,t⊩φiff{a mathematical formula}φ∈LSB(S,t). Formally, this proposition can be proved by induction on the formula structure. We thus obtain an algorithm to decide {a mathematical formula}M,S,t⊩φ as follows:
      </paragraph>
      <list>
       <list-item label="1.">
        given an evaluation base {a mathematical formula}SB for {a mathematical formula}(M,S,φ), compute the window graph {a mathematical formula}WGSB;
       </list-item>
       <list-item label="2.">
        compute the labeling {a mathematical formula}LSB for φ;
       </list-item>
       <list-item label="3.">
        return “yes” iff {a mathematical formula}φ∈LSB(S,t).
       </list-item>
      </list>
      <paragraph>
       The correctness of this algorithm follows from Proposition 2. Regarding its time complexity, it is not hard to see that the algorithm runs in time polynomial in the size of {a mathematical formula}SB, M and φ (see Appendix). In particular, if the evaluation base {a mathematical formula}SB is small, we obtain tractability.
      </paragraph>
      <paragraph label="Theorem 10">
       Let{a mathematical formula}M=〈S⋆,W,B〉be a structure,{a mathematical formula}S⊆S⋆and let φ be a formula. Suppose that{a mathematical formula}(M,S,φ)has some evaluation base{a mathematical formula}SBof size polynomial in the size of M and φ. Then{a mathematical formula}M,S,t⊩φis decidable in polynomial time. The proof exploits that for an evaluation base {a mathematical formula}SB of polynomial size, the window graph {a mathematical formula}WGSB and the labeling {a mathematical formula}LSB(S,t) are constructed by the algorithm above in polynomial time. Notably, a suitable {a mathematical formula}SB need not be provided in the input. We can construct one on the fly along with the window graph {a mathematical formula}WGSB: we initialize {a mathematical formula}SB to S and add any stream {a mathematical formula}Sk not yet in {a mathematical formula}SB to it, as in the Example 26. This in fact yields a unique evaluation base for {a mathematical formula}(M,S,φ) that is contained in every evaluation base, and is thus guaranteed to have polynomial size.
      </paragraph>
      <paragraph>
       As already mentioned, the presented stream labeling {a mathematical formula}LSB for φ will in general contain more streams than necessary for the evaluation of {a mathematical formula}M,S,t⊩φ. We considered in Example 27 the entailment relation {a mathematical formula}M,S,8⊩φ, where S has the timeline {a mathematical formula}[0,8]. All pairs {a mathematical formula}(S′,t′) with a proper substream {a mathematical formula}S′ of S that has a timeline overlapping with {a mathematical formula}[0,6] are irrelevant, as the first window operator {a mathematical formula}⊞#2 already restricts the relevant timeline to {a mathematical formula}[7,8] and any further consideration affects only substreams of {a mathematical formula}S78. This would be different if a temporal modality {a mathematical formula}∘∈{◇,□,@t′} was in front of φ. More generally, if we consider a formula ∘ψ such that ψ does not start with a temporal modality at some time point t, we observe that ∘ changes which time points have to be considered (i.e., all or some {a mathematical formula}t′), while only a window operator in ψ will change the timeline. Moreover, given a sequence {a mathematical formula}∘1…∘n of modalities, we observe that the first {a mathematical formula}n−1 are irrelevant. Accordingly, we can restrict both the evaluation base {a mathematical formula}SB and the window graph {a mathematical formula}WGSB by considering the last modality ∘ for the current stream {a mathematical formula}Sk−1 to first determine the relevant time points {a mathematical formula}t′ based on which we step to {a mathematical formula}Sk=(Sk−1,t′). Following this intuition, we in fact skipped the discussion of most pairs {a mathematical formula}(S′,t′) in Example 27, by directly starting with the paths for {a mathematical formula}t=8 and focusing on the relevant streams in {a mathematical formula}SB and the relevant edges of the stream graph {a mathematical formula}WGSB. It is feasible to obtain these relevant subsets in polynomial time as well. While one can expect a significant speedup in a practical realization of this improvement, the worst case polynomial complexity of the stream labeling procedure does not change. In a more fine-grained view of the formula φ that looks besides window operators also at the occurrence of temporal operators, further tractable fragments of LARS formulas could be identified; we leave this for future work.
      </paragraph>
      <paragraph>
       On the other hand, from the theoretical perspective, we note that an even more abstract approach is possible: we may alternatively define an evaluation base independently of a formula, i.e., purely based on a structure {a mathematical formula}M=〈S⋆,W,B〉: any (potentially infinite) sequence of window operators {a mathematical formula}⊞w with {a mathematical formula}w∈W will eventually not produce new streams. A given formula φ that only uses window functions from W only represents a subset of these sequences. Sparse windows ensure that, even in this high-level approach, the size of the evaluation base remains polynomial in the size of the structure.
      </paragraph>
      <paragraph>
       Classes of sparse window functions. From Theorem 10 we immediately obtain the {a mathematical formula}P-membership of model checking for LARS formulas with bounded window nesting in Theorem 8. Furthermore, we can conclude that model checking for LARS formulas with unbounded nesting is tractable for a broad class of window operators.
      </paragraph>
      <paragraph>
       Concerning time-based window operators {a mathematical formula}⊞ℓ,u(d), as already observed above, evaluating the window function {a mathematical formula}τℓ,u(d)(S,t) on the stream S at time point t always yields a substream {a mathematical formula}S′=(T′,υ′)=(T′,υ|T′), i.e., {a mathematical formula}S′ restricts S to the timeline {a mathematical formula}T′. If we apply a further time-based window on {a mathematical formula}S′, we obtain another stream of this form. Overall, there are {a mathematical formula}O(|T|2) many such {a mathematical formula}S′; if we take possible occurrence of the reset operator ▹ into account, there are {a mathematical formula}O(|T⋆|2) many such streams. Thus, Theorem 10 holds for all LARS formulas that use only time-based window operators.
      </paragraph>
      <paragraph>
       A similar consideration establishes the same result for tuple-based windows {a mathematical formula}⊞#ℓ,u: evaluating a tuple-based window function {a mathematical formula}#ℓ,u(S,t) on the stream S at time point t yields a substream {a mathematical formula}S′=(T′,υ′) of {a mathematical formula}S=(T,υ) that diverges from {a mathematical formula}S=(T′,υ|T′) at most on the stream boundaries {a mathematical formula}tℓ and {a mathematical formula}tu, where {a mathematical formula}T′=[tℓ,tu]. In any case, {a mathematical formula}S′ is uniquely identified by the triple {a mathematical formula}(ℓ,u,t). If we apply a further tuple-based window on {a mathematical formula}S′, we again obtain a substream of S of this form; overall, there are {a mathematical formula}O(|T⋆|⋅A2) many such streams, where {a mathematical formula}A=∑t∈T⋆|υ⋆(t)| is the total number of atoms in the stream {a mathematical formula}S⋆, thus polynomially many.
      </paragraph>
      <paragraph>
       Each tuple-based window {a mathematical formula}⊞#ℓ,u trivially amounts to a partition-based window {a mathematical formula}⊞idxA,nA where all atoms are in one partition. The question is thus whether also partition-based windows are sparse. Unfortunately, the answer is negative.
      </paragraph>
      <paragraph label="Theorem 11">
       Problem MC for LARS formulas in which only partition-based windows occur is{a mathematical formula}PSpace-complete.
      </paragraph>
      <paragraph>
       The {a mathematical formula}PSpace-hardness can be shown by adapting the QBF reduction in the proof for arbitrary LARS formulas in Theorem 4. An analysis of the proof shows that the result even holds if each partition-based window creates only two partitions (which is the minimum in order not to collapse with a tuple-based window); it is recursive nesting and the use of either changing partitions, or of changing tuple counts (or both) which leads to intractability.
      </paragraph>
      <paragraph>
       The result for tuple-based windows generalizes to partition-based windows, provided that the index functions idx of the window operators {a mathematical formula}⊞idx,n that occur in the formula partition the ground atoms {a mathematical formula}G into groups that are formed from constantly many base groups {a mathematical formula}Bi. That is, each group {a mathematical formula}idx−1(i) is of the form {a mathematical formula}idx−1(i)=⋃B, where {a mathematical formula}B⊆{B1,…,Bk} and {a mathematical formula}G=⋃i=1kBi, where k is constant. Let us call such partitions meager. In this case, each (nested) result of evaluating a window function can be uniquely identified by a tuple {a mathematical formula}(ℓ1,u1,…,ℓk,uk,t), and there are polynomially many such tuples.
      </paragraph>
      <paragraph>
       Finally, let us consider filter windows as introduced in Section 2.6. Recall that the function {a mathematical formula}fA associated with {a mathematical formula}⊞A projects the input stream to the atoms in A. We can extend the description for partition-based windows results above by adding a concrete filter A that is applied prior to the partition-based selection. While in general, semantically an exponential number of filters A are possible, for the concrete evaluation of a LARS formula φ only filters A that syntactically result from the formula matter, and there are only linearly many of them. Thus, the number of relevant substream descriptions {a mathematical formula}(ℓ1,u1,…,ℓk,uk,t,A) is still polynomially bounded.
      </paragraph>
      <paragraph>
       Clearly, the meager-partition representations include all tuple-based representations, which in turn include all time-based representations. Thus, we obtain the following result.
      </paragraph>
      <paragraph label="Theorem 12">
       For LARS formulas α (respectively LARS programs P), problem MC is in{a mathematical formula}P(respectively{a mathematical formula}co-NP-complete), if only time-based, tuple-based, meager partition-based, and filter windows occur in α (respectively in P). This result can be further generalized by allowing in addition restricted occurrence of arbitrary windows in formulas. In particular, this holds if the nesting depth of such additional window operators in a formula is bounded by a constant. This is because if on a root-path in the formula tree the encountered such windows are {a mathematical formula}⊞w1,…,⊞wℓ, then the resulting substream S can be described by a sequence{a mathematical formula} where each {a mathematical formula}sdi=(ℓ1(i),u1(i),…,ℓk(i),uk(i),t(i),A(i)) is an extended partition-based window description. In total, only polynomially many such descriptions will matter.
      </paragraph>
      <paragraph>
       Thus in conclusion, for a wide range of formulas that occur in practice the Model Checking problem for LARS formulas is solvable in polynomial time. Furthermore, in frequent use cases with time-based and tuple-based windows it will have low complexity inside {a mathematical formula}P. Finally, based on the tractability of model checking, for satisfiability the same results as for {a mathematical formula}α− and {a mathematical formula}P− in Table 1 can be established using analog arguments.
      </paragraph>
     </section>
     <section label="4.4">
      <section-title>
       Non-ground LARS
      </section-title>
      <paragraph>
       For open LARS formulas and non-ground programs, infinite groundings and arithmetic are a source of undecidability. In analogy to database systems, and inspired by notions of safety in logic programming, we make here the following assumption.
      </paragraph>
      <paragraph>
       The set {a mathematical formula}C of constants includes, besides those mentioned in a formula α respectively the program P, at most polynomially many further constants, and the set {a mathematical formula}P of predicates plus {a mathematical formula}C are part of the input; the set of atoms {a mathematical formula}A′ to consider is {a mathematical formula}A′=A, i.e., the set of all possible atoms over {a mathematical formula}P and {a mathematical formula}C (but not part of the input). We disregard here arithmetic, respectively assume that it is provided over the range of interest (i.e., the timeline of the current stream) in the background data B.
      </paragraph>
      <paragraph>
       The results for LARS formulas and programs in this setting are shown in Table 2, where an open (schematic) LARS formula {a mathematical formula}α(x) is viewed as a representative of all its instances. Besides the combined complexity, where both the structure and the LARS formula respectively program are part of the input, we also consider the data complexity, where the formula respectively program is fixed.
      </paragraph>
      <paragraph>
       What we can observe is that in the general case model checking is not more expensive than in the ground case. This is because a naive instantiation of the formula respectively program to the ground case, which would cause an exponential blowup, can be avoided. On the other hand, a model respectively answer stream S witnessing satisfiability in the general case may have exponential size in the input. This blowup dominates the {a mathematical formula}PSpace-complexity of model checking. Under data complexity, instantiation does not cause a blowup and we obtain for both LARS formulas and programs the same results as in the ground case for bounded window nesting, as in Table 1; the {a mathematical formula}NP-, {a mathematical formula}co-NP- and {a mathematical formula}Σ2p-hardness parts are inherited from the complexity of deciding answer set existence respectively answer set checking for (disjunctive) Datalog programs that are subsumed by LARS formulas respectively programs.
      </paragraph>
      <paragraph>
       Bounding the window nesting depth clearly does not affect the data complexity, nor the combined complexity of satisfiability where the exponential stream size is dominating. For model checking, the {a mathematical formula}co-NP entry for LARS formulas {a mathematical formula}α− is explained by the tractability of the problem in the ground case: a model candidate can be refuted by guessing and checking an instance of the formula that violates the candidate. Finally, the {a mathematical formula}Π2p-entry for LARS programs {a mathematical formula}P− is explained by an additional minimality check; the {a mathematical formula}NP- respectively {a mathematical formula}Π2p-hardness is inherited from conjunctive query evaluation in databases respectively from answer set checking for disjunctive Datalog programs, cf. [47].
      </paragraph>
      <paragraph>
       In order to avoid an inflation of formal statements, we confine here to a summarizing result.
      </paragraph>
      <paragraph label="Corollary 4">
       The complexity of Model Checking (MC) and Satisfiability (SAT) of an open LARS formula α, respectively non-ground LARS program P, in the general case and for bounded window nesting, is as listed inTable 2. More proof details are given in the appendix. From the results in Table 2, we easily obtain the following results for answering non-ground LARS formula queries. Given a structure{a mathematical formula}M=〈S,W,B〉and a query{a mathematical formula}Q=〈M,u,α〉, deciding whether Q has some answer over M is (i){a mathematical formula}PSpace-complete for arbitrary α in combined complexity, (ii){a mathematical formula}NP-complete for α with bounded window nesting under combined complexity, and (iii) decidable in polynomial time (and{a mathematical formula}P-complete in general) under data complexity. These results derive from the fact that Q has no answer, if for every grounding {a mathematical formula}σ∈σ(C,T), we have that {a mathematical formula}M,t,σ(u)⊮σ(α), which is equivalent to {a mathematical formula}M,t,σ(u)⊩σ(¬α). From Theorem 13, we can thus infer the membership parts, where in (iii) α (as the formula is fixed) amounts to the {a mathematical formula}α− case and the number groundings σ is polynomial. The {a mathematical formula}PSpace-hardness for (i) is inherited from the ground case, and the {a mathematical formula}NP-hardness for (ii) from the classic {a mathematical formula}NP-completeness of conjunctive query answering [34]; finally, the {a mathematical formula}P-hardness for (iii) is due the unrestricted windows.
      </paragraph>
      <paragraph>
       Note that based on Theorem 12 and the discussion after it, the {a mathematical formula}NP-completeness of case (ii) generalizes to queries with bounded window nesting if all time-based, tuple-based, meager partition-based and filter-windows occurring in them are disregarded. Thus for practical settings, answering LARS formula queries is {a mathematical formula}NP-complete, and thus not harder than answering conjunctive queries.
      </paragraph>
     </section>
    </section>
    <section label="5">
     <section-title>
      Relation to other languages and formalisms
     </section-title>
     <paragraph>
      In this section we discuss the relationship of LARS with other formal languages for reasoning on data streams, starting with the prominent linear temporal logic (LTL). Then, we investigate the continuous query language (CQL), followed by a note on extensions of the SPARQL query language for streaming, i.e., C-SPARQL and CQELS. Finally, we consider ETALIS as an example of a complex event processing language that focuses on expressing of temporal intervals by rules. Further related work is discussed separately in Section 6.4.
     </paragraph>
     <section label="5.1">
      <section-title>
       Temporal logic
      </section-title>
      <paragraph>
       In this section, we compare LARS to temporal logic, where we naturally focus on linear time logic (LTL) [91] extended with past time operators (PLTL) [79]. Syntactically, these logics extend propositional logic with temporal operators, according to the following syntax{a mathematical formula} where {a mathematical formula}a∈G. The informal meaning of {a mathematical formula}Xα is that α is true at the next point in time, and {a mathematical formula}αUβ means that α is from now on true until β is true at some point; {a mathematical formula}Xα−1 and {a mathematical formula}αUβ−1 are the counterparts for the past (not available in LTL),{sup:6} i.e., that α is true at the previous point of time respectively that α has always been true after some time point at which β was true. Important derived operators are {a mathematical formula}Fα and {a mathematical formula}Gα which are shorthand for {a mathematical formula}⊤Uα, where {a mathematical formula}⊤=¬⊥, and {a mathematical formula}¬(⊤U¬α) and state that α is true now or at some respectively now and at every time point in the future; {a mathematical formula}Fα−1=⊤Uα−1 and {a mathematical formula}Gα−1=¬(⊤U¬−1α) express the counterparts for the past.
      </paragraph>
      <paragraph>
       Semantically, PLTL-formulas are evaluated over paths, which are infinite sequences {a mathematical formula}π=π(0), {a mathematical formula}π(1), {a mathematical formula}π(2), … of positions with an associated interpretation {a mathematical formula}ν(π(i)) of propositional atoms {a mathematical formula}A, for each {a mathematical formula}i≥0; the latter is often tacitly omitted. The satisfaction relation {a mathematical formula}π,i⊨α is inductively defined as follows:{a mathematical formula} Note in particular that {a mathematical formula}¬X⊤−1 allows us to recognize that we are at the beginning of the path, as {a mathematical formula}π,i⊨¬X⊤−1 holds iff {a mathematical formula}i=0. Two PLTL formulas α and β are equivalent, if for every path π and integer {a mathematical formula}i≥0, it holds that {a mathematical formula}π,i⊨α iff {a mathematical formula}π,i⊨β, and initially equivalent, if for every path π it holds that {a mathematical formula}π,0⊨α iff {a mathematical formula}π,0⊨β.
      </paragraph>
      <paragraph>
       It is well-known that PLTL is not more expressive than LTL in the sense that every PLTL formula is initially equivalent to some LTL-formula [60], but the smallest such formula can be exponentially larger [79].
      </paragraph>
      <paragraph>
       Comparison to LARS. Comparing LARS to linear temporal logic, we see that the temporal operators are clearly different, The temporal operators □ and ◇ in LARS have as counterparts the pairs {a mathematical formula}G,G−1 and {a mathematical formula}F,F−1 respectively, which allow one to address all positions in a path; the past time operators are indispensable for evaluation inside the path. The window operators in LARS have no counterpart in LTL and PLTL, and similarly the {a mathematical formula}@t′ operator which is known as nominal in hybrid logic and can be traced back to Prior's work [93]. On the other hand, LARS has no next-time {a mathematical formula}X nor until {a mathematical formula}U or any of their past time counterparts.
      </paragraph>
      <paragraph>
       The presence of temporal operators in linear time logic formulas affects the computational complexity of model checking and satisfiability testing in general (cf. [42]). In the general case, for both LTL and PLTL these problems are {a mathematical formula}PSpace-complete, cf. [96], where satisfiability of a formula α means existence of a path π such that {a mathematical formula}π,0⊨α, and model checking that {a mathematical formula}π,0⊨α for every path π in a given Kripke structure. Thus, at the surface LARS and LTL have the same computational complexity.
      </paragraph>
      <paragraph>
       However, in LARS we consider only single path Kripke structures of a given length, for both satisfiability and model checking at some given time point t. For both LTL and PLTL, model checking single paths is feasible in polynomial time,{sup:7} and satisfiability is thus easily seen to be {a mathematical formula}NP-complete in this setting. Thus, there is a considerable complexity gap between LARS and linear time logic.
      </paragraph>
      <paragraph>
       Nonetheless, it is possible to express (propositional) LARS in linear temporal logic, if we confine to particular window operators. We show in the next section that this is possible for sliding time-based windows; that is, we can view this instance of LARS as a fragment of linear time logic. As LTL expresses all and only the star-free regular languages, i.e., definable by regular expressions without Kleene star, we obtain that such LARS formulas can a fortiori express only a strict fragment of the regular languages, where a language consists of all input streams (representing a finite string) on which the formula evaluates to true. For example, the language defined by {a mathematical formula}(aa)⁎ (strings of a of even length) cannot be expressed. LARS formulas with arbitrary (polynomial-time evaluable) window operators trivially express by Corollary 4 all and only the polynomial time recognizable languages.{sup:8}
      </paragraph>
      <paragraph>
       Translation of LARS to Linear Temporal Logic. Formally, we represent any LARS structure {a mathematical formula}M=〈S,W,∅〉, where {a mathematical formula}S=(T,υ), as a PLTL interpretation {a mathematical formula}π(M)=π(0),π(1),… where for each integer {a mathematical formula}i≥0, {a mathematical formula}ν(π(i))={u} if {a mathematical formula}i∉T, and {a mathematical formula}ν(π(i))=υ(i) otherwise, where u is a special atom which expresses that the position i is not in the stream.
      </paragraph>
      <paragraph>
       Our translation of LARS formulas to PLTL-formulas for evaluation at a time point t in a stream {a mathematical formula}S=(T,υ), where {a mathematical formula}T=[ℓ′,u′], is shown in Algorithm 1. The parameters {a mathematical formula}ℓ,u mark the interval {a mathematical formula}[ℓ,u] of the substream that is currently considered, while {a mathematical formula}ℓ′,u′ marks the original interval. The translation proceeds recursively, where the temporal modalities □, ◇ and {a mathematical formula}@t′ are effected using the {a mathematical formula}X operator, where we use here {a mathematical formula}Xαk as a shorthand for the k-fold iteration of {a mathematical formula}X on α; that is, {a mathematical formula}Xα0=α, for {a mathematical formula}k&gt;0 we have {a mathematical formula}Xαk=XXαk−1, and for {a mathematical formula}k&lt;0 we have {a mathematical formula}Xαk=X−1Xαk+1. For window operators {a mathematical formula}⊞i,j the current interval has to be adjusted to at most i steps before respectively j steps after t, while for the reset operator ▹ the original interval is selected.
      </paragraph>
      <paragraph label="Example 28">
       Consider the formula {a mathematical formula}φ=@1q∨p∧⊞1,3◇r, and let {a mathematical formula}[ℓ′,u′]=[ℓ,u]=[2,4] and {a mathematical formula}t=3. Then we have{a mathematical formula} The ⊥ disjunct is due to the fact that position 1 is not in the timeline {a mathematical formula}T=[2,4]. The conjunction {a mathematical formula}Xr−1∧r∧Xr stems from the translation of the window {a mathematical formula}⊞1,3. Note that {a mathematical formula}Xr2 and {a mathematical formula}Xr3 are missing since {a mathematical formula}t=3 is in distance 1 to the end of the bound {a mathematical formula}u=4.  □
      </paragraph>
      <paragraph>
       We then can show that the transformation in Algorithm 1 works properly.
      </paragraph>
      <paragraph label="Proposition 3">
       Let{a mathematical formula}M=〈S,W,∅〉, where{a mathematical formula}S=(T,υ)and{a mathematical formula}T=[tℓ,tu], and let{a mathematical formula}t∈Tand φ be a LARS formula. Then{a mathematical formula}
      </paragraph>
      <paragraph>
       By this proposition, we can reduce model checking of a LARS formula φ on an input stream {a mathematical formula}S=(T,υ), to model checking an ad-hoc PLTL formula constructed from φ, M and the specific time point {a mathematical formula}t∈T, on a single path {a mathematical formula}π(M). In particular, we can do this for {a mathematical formula}T=[0,t], i.e., at the end of the input stream. Furthermore, we can transform the PLTL formula easily to an LTL formula that is initially equivalent.
      </paragraph>
      <paragraph>
       Unfortunately the transformation {an inline-figure} is not practical, as it is exponential in the formula size. However, it can be exploited by a nondeterministic algorithm for model checking {a mathematical formula}M,S,t⊩φ in {a mathematical formula}ALogSpace (i.e., alternating logspace): in the recursive evaluation, conjunction and disjunction evaluated by universal and existential computation states, respectively, and no further storage than the interval bounds and few (constantly many) auxiliary variables is needed. Since {a mathematical formula}ALogSpace=P, this yields an alternative proof that for LARS formulas with sliding time-based window operators, model checking is feasible in polynomial time.
      </paragraph>
      <paragraph>
       Regarding the expressivity of LARS, we are interested in a transformation {an inline-figure} (respectively {an inline-figure}) that depends only on {a mathematical formula}t′ and φ (respectively φ), but not the input stream S. It turns out that such a transformation exists, but is much more involved.
      </paragraph>
      <paragraph label="Theorem 14">
       For every LARS formula φ with sliding time-based windows over atoms{a mathematical formula}A, LTL formulas{an inline-figure}and{an inline-figure}over{a mathematical formula}A∪{u}are constructible such that for every structure{a mathematical formula}M=〈S,W,∅〉, where{a mathematical formula}S=(T,υ)and{a mathematical formula}T=[0,t], it holds that
      </paragraph>
      <list>
       <list-item label="(i)">
        {a mathematical formula}M,S,t′⊩φiff{an inline-figure}iff{an inline-figure}, respectively;
       </list-item>
       <list-item label="(ii)">
        {a mathematical formula}M,S,t⊩φiff{an inline-figure}.
       </list-item>
      </list>
      <paragraph>
       Thus in other words, LARS with sliding time-based windows is a fragment of PLTL (and in fact a strict fragment, as the until-operator can not be expressed). Furthermore, as PLTL and LTL have the same expressiveness and can express only regular languages, the considered LARS fragment is thus a strict fragment of the regular languages.
      </paragraph>
      <paragraph>
       The proof of Theorem 14 is given in the Appendix. Informally, this result can be established as follows. If we let {a mathematical formula}dist(n)=X¬nu∧Xun+1 express that the distance to the end of the input stream S is {a mathematical formula}n≥0, then the formula{a mathematical formula} would express model checking of φ at {a mathematical formula}t′; however, this is not an admissible PLTL-formula.
      </paragraph>
      <paragraph>
       If each occurrence of a temporal operator □, ◇, and {a mathematical formula}@t′ in φ is windowed, i.e., within the scope of some window {a mathematical formula}⊞i,j not followed by any ▹, the transformation {an inline-figure} yields for fixed φ and {a mathematical formula}t′ only finitely many different formulas for all {a mathematical formula}n≥0; this is because only a bounded number of distances {a mathematical formula}u−ℓ occur, and for some large enough {a mathematical formula}n0, the result of the transformation is identical for all {a mathematical formula}n≥n0. That is, we can obtain {an inline-figure} as{a mathematical formula} where {a mathematical formula}dist≥(n)=X¬nu expresses that the distance to the end of the input stream is at least n. Non-windowed occurrences of □, ◇, or {a mathematical formula}@t in φ can be naively expressed using infinite formulas similarly as in (15), which again can be replaced by finite formulas (as only finitely many different constituents are necessary). Finally, the formula {an inline-figure} can be obtained from {an inline-figure} likewise using a formula {a mathematical formula}end(t′)=X¬t′u∧Xut′+1 to recognize the end of the input stream.
      </paragraph>
      <paragraph>
       LARS programs. If we allow intensional atoms and consider LARS programs, then the expressivity increases and all regular languages can be expressed. Formally, let {a mathematical formula}PN,N denote the class of propositional LARS programs in which all windows are sliding time-based windows {a mathematical formula}⊞i,j. Furthermore, denote for each program {a mathematical formula}P∈PN,N with extensional atoms {a mathematical formula}GE(P) by {a mathematical formula}LE(P) the set of all input (data) streams {a mathematical formula}S=(T,υ) over {a mathematical formula}GE, where {a mathematical formula}T=[0,t], such that P has some answer stream for S at t. Naturally, any stream S over {a mathematical formula}GE encodes a string {a mathematical formula}υ(0)υ(1)⋯υ(t) over the alphabet {a mathematical formula}2GE. We then establish:
      </paragraph>
      <paragraph label="Theorem 15">
       {a mathematical formula}PN,Ncaptures the class of regular languages modulo the empty string ϵ, that is
      </paragraph>
      <list>
       <list-item label="(i)">
        for each{a mathematical formula}P∈PN,Nand extensional atoms{a mathematical formula}GE(P), the set{a mathematical formula}LE(P), viewed as set of strings over{a mathematical formula}Σ=2GE(P), is a regular language{sup:9}; and
       </list-item>
       <list-item label="(ii)">
        for each regular language{a mathematical formula}Lover alphabet Σ such that{a mathematical formula}ϵ∉L, there exists some program{a mathematical formula}P∈PN,Nwith extensional atoms{a mathematical formula}GE(P)such that{a mathematical formula}L=LE(P).{sup:10}Furthermore, this holds even if only the window{a mathematical formula}⊞1,0is used and the @-operator and ▹ do not occur in{a mathematical formula}PL.
       </list-item>
      </list>
      <paragraph>
       Informally, (i) holds as we can express answer stream existence for a program in {a mathematical formula}PN,N over finite input streams S by a formula in monadic second-order logic (MSO); as the MSO definable languages coincide with the regular languages by the famous Büchi–Elgot–Trakhtenbrot Theorem [28], [27], [55], [100], propositional LARS programs can express only regular languages. Conversely, (ii) holds as we can encode finite automata A in propositional LARS programs {a mathematical formula}PA such that answer stream existence for an input stream S amounts to acceptance of S by A. Informally, the answer streams encode accepting runs; for that, it is crucial that intensional (auxiliary) atoms are available, to store the states of the automaton during a run. Particularly worth noting is that {a mathematical formula}PA can not use an ordering on the input elements, as binary predicates are not available.
      </paragraph>
      <paragraph>
       The availability of intensional atoms for capturing the regular languages is essential, as without such atoms the expressiveness of the LARS programs {a mathematical formula}PN,N coincides with the one of respective LARS formulas (i.e., with sliding time-based windows {a mathematical formula}⊞i,j). By the result of Theorem 14, such formulas are subsumed by the fragment of PLTL in which only the operators {a mathematical formula}X,G and their past time versions {a mathematical formula}X−1,G−1 are available. That fragment amounts to the 2-variable fragment of FO-logic on strings [58] and is less expressive than full FO-logic on strings, which in turn is as expressive as full LTL and PLTL and captures the star-free regular languages.
      </paragraph>
      <paragraph>
       If we abandon extensional atoms and consider definability in terms of models, i.e., answer streams of a LARS program represent strings over an alphabet {a mathematical formula}Σ=2A (similarly as in part (i) of Theorem 15) where {a mathematical formula}A=GI(P)=G(P), then {a mathematical formula}PN,N and the LARS {a mathematical formula}⊞i,j-formulas have incomparable expressiveness. However, if as in part (ii) of Theorem 15, the letters σ of Σ are singleton interpretations {a mathematical formula}{σ}⊆A, then {a mathematical formula}PN,N is strictly more expressive than the class of LARS {a mathematical formula}⊞i,j-formulas. In both alphabet settings, LARS programs can define languages that are not expressible in LTL. More details are given in the Appendix.
      </paragraph>
      <paragraph>
       We remark that the translation {an inline-figure} from above can be exploited to capture answer streams for restricted classes of LARS programs, in the sense that the existence of an answer stream for an input (data) stream S at its end t amounts to the existence of an equilibrium model of a formula {an inline-figure}, which extends {an inline-figure} with the stream data. Equilibrium models of an LTL formula φ are particular models that satisfy a stability condition [29], [2]; they lift the respective notion for classical formulas, which captures the answer sets of ordinary logic programs [87], to LTL. The restricted class of LARS programs can be singled out via the class LARSHT of programs in [20], whose answer streams correspond as shown there to its equilibrium models, where the notion is naturally lifted from single interpretations to streams; we leave this for future work.
      </paragraph>
      <paragraph>
       We close this section with noting that the expressiveness of LARS programs with sliding time-based windows increases if we move beyond propositional programs; by the results in Section 4 and well-known results for disjunctive Datalog [52], it can be seen that they capture the class of languages with complexity in {a mathematical formula}Σ2p; however, we omit here further consideration.
      </paragraph>
     </section>
     <section label="5.2">
      <section-title>
       Continuous Query Language (CQL)
      </section-title>
      <paragraph label="Example 29">
       A particularly influential work in stream processing has been the Stanford Stream Data Manager (STREAM) [9] and its Continuous Query Language (CQL) [10], [11]. The central idea is to reuse existing features from SQL and extend it with streams as additional data sources. To this end, different window operators are used to obtain recent snapshots of data, which are then essentially viewed as database relations. Following up on request (i) from Example 1, we state a CQL query for expected arrival times of trams where no traffic jam has been reported at their last station within the last 20 minutes. Recall that the relation {a mathematical formula}plan(L,X,Y,D) records for line L the scheduled travel time D between station X and Y.{a mathematical formula}Note that streams TRAM and JAM have designated timestamp fields “T”, i.e., explicit attributes that state the time when the tuple occurred in the stream.  □ In CQL, a stream is viewed as bag of elements of form {a mathematical formula}〈c,t〉, where c is a tuple (which we can view as vector of constants) and t a timestamp; a relation maps timestamps to bags of tuples. To translate between these concepts, the operational semantics of CQL builds on three operators:
      </paragraph>
      <list>
       <list-item label="–">
        Stream-to-relation (S2R) operators apply window functions to the input stream to create a relation for recent tuples, i.e., those in the selected window.
       </list-item>
       <list-item label="–">
        Relation-to-relation (R2R) operators can manipulate relations similarly as in relational algebra, respectively SQL.
       </list-item>
       <list-item label="–">
        Relation-to-stream (R2S) translates back a relation into a stream for the output of continuous queries.
       </list-item>
      </list>
      <paragraph>
       Our focus here is on the first two operators, the R2S operator only concerns how output is generated but does not influence the query semantics as such. The S2R operator allows us to consider streaming tuples as sets of atoms. The semantics of CQL thus essentially reduces to the R2R operator, once recent snapshots of streaming data have been selected by S2R. Due to this, we show that LARS programs capture CQL by exploiting two well-known translations: from SQL to relational algebra [35] and from relational algebra to Datalog [61]. Let us call the former translation RelAlg and the latter Dat.
      </paragraph>
      <paragraph>
       The idea is to have a 3-step process to obtain a Datalog program for a CQL query q:
      </paragraph>
      <list>
       <list-item label="(1)">
        replace in FROM clauses the input sources (i.e., streams with window expressions) by virtual table names due to the renaming function rel as defined in Table 3. By replacing in CQL query q each occurrence of an input stream s by a relation {a mathematical formula}rel(s), we obtain a SQL query {a mathematical formula}rel(q).
       </list-item>
       <list-item label="(2)">
        Apply RelAlg on this query to obtain a relational algebra expression.
       </list-item>
       <list-item label="(3)">
        Apply Dat on the expression to obtain a Datalog program with a designated predicate {a mathematical formula}qˆ that reflects the resulting tuples.
       </list-item>
      </list>
      <paragraph>
       More formally, we get for a CQL query q a Datalog program {a mathematical formula}ΔD(q)=Dat(RelAlg(rel(q))). Any static relation (table) B can be naturally encoded as{a mathematical formula} where the lower case b version of relation name B serves as predicate name for atoms; tuples c can be seen as vectors of constants.
      </paragraph>
      <paragraph>
       We observe that LARS allows us to model the S2R operator. A snapshot of a stream S amounts to (i) applying an according window operator and then (ii) abstracting away time. The second step amounts to existential quantification over time, i.e., formulas of form {a mathematical formula}⊞w◇φ. Table 3 lists the LARS window functions corresponding to those in CQL. We thus can derive each snapshot relation {a mathematical formula}rel(s) for a CQL input source s (as listed in the table) using a snapshot rule of form{a mathematical formula} where the lower case s version of stream name S serves as predicate name, and V is the list of variables corresponding to the attributes of tuples in S. We refer to static relations and input streams (with window expressions) uniformly as input sources. We thus obtain a LARS program{a mathematical formula} For a set Q of queries, we simply take respective unions, i.e., {a mathematical formula}Δx(Q)=⋃q∈QΔx(q), {a mathematical formula}x∈{L,D}.{sup:11}
      </paragraph>
      <paragraph label="Theorem 16">
       We give a Datalog translation {a mathematical formula}ΔD(q) of the CQL query q in Example 29. (Note that due to the exact translation from SQL and potential optimizations the intermediate relational algebra representation might vary and thus the specific set of derived Datalog rules. The employed translation is detailed in the Appendix.) Let {a mathematical formula}T=ID1,ST1,T1; {a mathematical formula}L=ID2,L2; {a mathematical formula}P=L3,X3,Y3,D3; {a mathematical formula}J=ST4,T4 (subscripts for variables serve to reflect their origin in the same schema in a readable way).{a mathematical formula} Informally, {a mathematical formula}q0 captures the cross product of relations LINE and PLAN as given in the FROM-clause, and the relation corresponding to the window on stream TRAM. The selection based on the statement TRAM.ID=LINE.ID AND LINE.L=PLAN.L in the WHERE-clause is captured in predicate {a mathematical formula}q1. The cross product of recent tram appearances at stations and traffic jams is then reflected in {a mathematical formula}q2 and the join with {a mathematical formula}q1 yields {a mathematical formula}q12, which thus captures tram appearances that shall not be considered. In order to remove these, jam information is projected away to obtain predicate {a mathematical formula}q12′. Finally, those variable groundings for {a mathematical formula}q1 are reported that are not groundings for {a mathematical formula}q12′, and in addition the calculated arrival time TY which adds the planned travel time {a mathematical formula}D3 to occurrence time {a mathematical formula}T1 of the last station. (Note that we explicitly model arrival times in tuples. Thus, they remain accessible after S2R, respectively in the Datalog and LARS encodings.)Using snapshot rules of form (18), we obtain a LARS program {a mathematical formula}ΔL(q) by adding the following rules ({a mathematical formula}idx,n are from Example 22):{a mathematical formula} To establish the correspondence between the result of a set Q of CQL queries and its LARS translation {a mathematical formula}ΔL(Q), we first build a conversion of the input streams in Q to a LARS data stream. (Recall that LARS considers only a single stream which can be virtually split, e.g., by partition-based windows.) Without loss of generality, we assume that Q is evaluated on static relations {a mathematical formula}B1,…,Bm and input streams {a mathematical formula}S1,…,Sn, and that any stream is only used in one place in the FROM clause in a single query (we can always duplicate streams and rename them). We consider the union of these input streams, given by{a mathematical formula} where the element {a mathematical formula}〈cij,tij〉 represents the tuple {a mathematical formula}cij that occurs at the {a mathematical formula}jth position at time {a mathematical formula}tij in stream {a mathematical formula}Si (with {a mathematical formula}mi elements). We use the (lower case) name {a mathematical formula}si of CQL stream {a mathematical formula}Si as predicate symbol of according atoms and thus obtain the LARS data stream by{a mathematical formula} where {a mathematical formula}1≤i≤n and {a mathematical formula}1≤j≤mi. Similarly, we define for {a mathematical formula}B=B1,…,Bm the atom set {a mathematical formula}Δ(B)=⋃i=1m{bi(c)|c∈Bi}. Let {a mathematical formula}cqlRes(q,t) denote the set of resulting tuples of CQL query q at time t and let {a mathematical formula}cqlRes(Q,t)=⋃q∈QcqlRes(q,t). The following theorem shows that the translation {a mathematical formula}ΔL faithfully captures CQL. For a set A of atoms and a set Q of CQL queries let {a mathematical formula}A|Q denote the set of all tuples c such that {a mathematical formula}qˆ(c)∈A for some query {a mathematical formula}q∈Q (recall that {a mathematical formula}qˆ is the “output” predicate of the Datalog transformation of q). Let Q be a set of CQL queries to be evaluated on input streams{an inline-figure}and background relations{an inline-figure},{a mathematical formula}P=ΔL(Q), and t a time point. Moreover, let{an inline-figure}such that W is implicit byTable 3and windows mentioned in Q. Then,
      </paragraph>
      <list>
       <list-item label="(i)">
        If{a mathematical formula}I=(T,υ)is an answer stream of P for{an inline-figure}at t, then{a mathematical formula}υ(t)|Q=cqlRes(Q,t).
       </list-item>
       <list-item label="(ii)">
        There exists an answer stream{a mathematical formula}I=(T,υ)of P for{an inline-figure}at t such that{a mathematical formula}υ(t)|Q=cqlRes(Q,t).
       </list-item>
      </list>
      <paragraph label="Proof (sketch)">
       Intuitively, (i) establishes the soundness and (ii) the completeness of the translation {a mathematical formula}ΔL. Consider a set Q of CQL queries and its translations {a mathematical formula}ΔD(Q) to Datalog and {a mathematical formula}ΔL(Q) to LARS, and moreover the data stream {a mathematical formula}Δ(S) corresponding to CQL input stream S. First, we observe that the Datalog program {a mathematical formula}ΔD(Q) is an acyclic program and thus has as well-known a single answer set. Using the snapshot of the streaming data (i.e., the result of the S2R operator) as input, we thus get by the correctness from RelAlg and Dat that the result of Q is captured by the answer set of {a mathematical formula}ΔD(Q). As noted above, the result of the S2R operator on an input source s amounts to abstracting away the temporal information. This step is carried out in LARS by existential temporal quantification with ◇ in the according window as listed in Table 3. We observe that snapshot rules, i.e. {a mathematical formula}ΔL(Q)∖ΔD(Q), add a stratified layer to {a mathematical formula}ΔD(Q) and faithfully derive the relations {a mathematical formula}rel(s) as follows. Provided encoding {a mathematical formula}Δ(S) (and background data {a mathematical formula}Δ(B) for static relations B), {a mathematical formula}rel(s)(c) will be derived iff c is a tuple in the snapshot of input source s in Q: any ground snapshot rule of form {a mathematical formula}rel(s)(c)←⊞w(s)◇s(c) must be satisfied when the formula {a mathematical formula}⊞w(s)◇s(c) is satisfied, thus the rule head {a mathematical formula}rel(s)(c) is concluded if the tuple c is contained in the snapshot; the only-if part is ensured by minimality of answer streams and the fact that relation names do not occur elsewhere as rule heads in the translation. From this also follows that the interpretation of these predicates must coincide in {a mathematical formula}ΔD(Q) and {a mathematical formula}ΔL(Q); the latter contains no further rules not contained in {a mathematical formula}ΔD(Q). It thus follows that the answer set of {a mathematical formula}ΔD(Q) corresponds to the answer stream of {a mathematical formula}ΔL(Q). That is to say, given the answer stream {a mathematical formula}I=(T,υ) of {a mathematical formula}ΔL(Q) for {a mathematical formula}Δ(S) at time t, {a mathematical formula}qˆ(c)∈υ(t) iff {a mathematical formula}c∈cqlRes(Q,t).  □ More details can be found in the Appendix. We conclude this section by contrasting CQL and LARS.
      </paragraph>
      <paragraph>
       Differences between CQL and LARS. CQL extends SQL in a similar way as LARS extends ASP. As a consequence, the semantic differences between SQL and ASP naturally carry over to CQL and LARS. The first difference in that regard is a conceptual one in their respective definitions: CQL has an operational semantics, while the LARS semantics is model-based; CQL specifies how streaming tuples are evaluated in stepwise processing of a query, while LARS merely formalizes what a program entails, given a stream and a time point. CQL works on multisets (bags) of tuples per time point, while LARS uses sets. Expressivity features of ASP carry over to LARS, in particular those that SQL (respectively CQL) has not. LARS is a paradigm for expressive reasoning, while CQL targets query processing. One way to think about this distinction is that SQL-like querying usually centers around filtering, joining and aggregating data in a deterministic way (in the sense that the set of returned tuples is unique) while reasoning typically involves abstractions, constraints, complex negation (potentially in a cyclic way) and non-determinism.
      </paragraph>
      <paragraph>
       More specifically, core reasoning features of ASP (respectively LARS) that are not directly available in SQL (respectively CQL) include supported minimal models by means of the stable model semantics, the possibility to enumerate multiple solutions for use cases with choices, nonmonotonic negation with defaults, loops through negation, and constraints. The answer set semantics (respectively answer stream semantics) is fully declarative in the sense that the order of rules does not influence the output, and the possibility to express combinatorial problems makes it applicable to constraint satisfaction problems. For further discussion on the semantic features of ASP we refer the interested reader to [53], [24], [25].
      </paragraph>
      <paragraph>
       On top of the properties that LARS inherits from ASP, generic window functions are the central mechanism for handling streams. The stream-to-relation mechanism of CQL serves as elegant abstraction over specific window functions. However, as explained above, viewing streams as relations implicitly comes with existential quantification with respect to time. By dropping temporal information, any window function w in CQL is captured in LARS by a window operator {a mathematical formula}⊞w, followed by ◇.
      </paragraph>
      <paragraph>
       Further differences between CQL and LARS concern the additional temporal modalities (□ and @), and, in particular, their combination with generic windows. We will explore this further in Section 6.5, when we highlight LARS-specific features from an application oriented perspective.
      </paragraph>
     </section>
     <section label="5.3">
      <section-title>
       Semantic web: C-SPARQL and CQELS
      </section-title>
      <paragraph>
       Among research initiatives for the Semantic Web, RDF Stream Processing (RSP) emerged to address the question of querying heterogeneous streams. The RSP community is interested in extending SPARQL for streams in a similar way as CQL builds on SQL. In particular, C-SPARQL [14] and CQELS [88] employ an operational semantics that is based on the CQL approach of reducing stream reasoning to relational processing between a pre-processing of input streams and a post-processing towards output streams.
      </paragraph>
      <paragraph>
       In [36], [37] we investigated these two query languages for RDF data. We studied their difference which arises mainly due to the different execution modes. While C-SPARQL is pull-based, i.e., repeatedly returning a query result after a fixed temporal interval, CQELS is push-based, i.e., reporting results after every new input. We presented the comparative analysis by first formalizing these execution modes semantically for LARS programs. Then, we gave translations for the two RSP languages to LARS in a similar way as for CQL.
      </paragraph>
      <paragraph>
       One difference between CQL and the SPARQL extensions are due to the fact that RDF graphs (i.e., sets of triples) do not come with a schema. While for CQL the integration of multiple input sources (tables and streams) is clear, there are different ways to integrate different input streams that arrive in RDF format. While C-SPARQL merges the relational snapshots into one graph (by stating them in the FROM-part of the query), CQELS provides explicit access to each input stream (in the WHERE clause of the query).
      </paragraph>
      <paragraph>
       The central idea of capturing the push- and pull-based execution modes in LARS is to introduce an auxiliary atom c to rule bodies to control potential rule firing. The push-based mode will infer c whenever any atom holds in window {a mathematical formula}⊞0 that contains only the current time point. On the other hand, the encoding of pull-based execution amounts to testing for {a mathematical formula}⊞0@T⊤ whether current time T is a multiple of the query interval; only in this case, c shall hold.
      </paragraph>
      <paragraph>
       Furthermore, window expressions of C-SPARQL and CQELS can easily be encoded as window operators in LARS. Note that LARS allows for using any kind of computable window function that does not need further information than the input stream and the query time point. In fact, the time-based and tuple-based window functions as presented in Sections 2.3 and 2.4 correspond to those used in considered RSP languages.
      </paragraph>
      <paragraph>
       Finally, the translation from RSP queries to LARS is based on an existing reduction from SPARQL to Datalog rules [92]. For C-SPARQL, it suffices to use a uniform representation of triples {a mathematical formula}t(s,p,o) that are available as input {a mathematical formula}i(s,p,o,x) in stream source x at some time point in the considered snapshot. Thus, the encoding essentially takes the form {a mathematical formula}t(s,p,o)←⊞w◇i(s,p,o,x), where {a mathematical formula}⊞w is the according window translation. For CQELS, we additionally have to disambiguate the stream source due to the so-called stream graph pattern as stated in the original WHERE clause.
      </paragraph>
      <paragraph>
       Based on these translations, questions on the semantics of C-SPARQL and CQELS can then be made precise; in particular, when syntactically similar queries indeed produce the same results. In [36] we formalized a notion of agreement and gave sufficient conditions for agreement for sliding time-based windows (under some restrictions). Our results formally reflect the drastic effect of execution modes on the query results from a semantic perspective.
      </paragraph>
     </section>
     <section label="5.4">
      <section-title>
       Complex event processing: ETALIS
      </section-title>
      <paragraph>
       Related to stream processing is complex event processing (CEP), where one deals with the derivation of complex events (that typically span over temporal intervals) based on atomic events (that occur at time points). We briefly study the relation between LARS and the CEP language ETALIS [8]. This allows us to draw a line between stream reasoning and CEP by means of LARS.
      </paragraph>
      <paragraph>
       In ETALIS, an event streamϵ associates atomic events (represented as ground atoms) with time points, i.e., non-negative rational numbers. For comparability with LARS, we consider here only natural numbers. confine here to natural numbers. Complex events can be described by rules due to so-called event patterns, which resemble [3] interval relations. An interpretation {a mathematical formula}I is a function that maps atoms to sets of pairs {a mathematical formula}〈t1,t2〉∈N×N representing intervals {a mathematical formula}[t1,t2]. Let {a mathematical formula}r=a←pt be a rule, where a is an atom and pt an event pattern. Then, interpretation {a mathematical formula}Isatisfiesr if all intervals assigned to pt are also assigned to a. Given an event stream ϵ and rule base {a mathematical formula}R, an interpretation {a mathematical formula}I is model for {a mathematical formula}ϵ,R, if {a mathematical formula}I (i) maps each atomic event a to the interval {a mathematical formula}〈t,t〉 if a occurs in ϵ at time point t, and (ii) satisfies each rule {a mathematical formula}r∈R. The semantics of ETALIS is then defined in terms of minimal models,{sup:12} which are always unique due to the definition of event patterns. More precisely, ETALIS employs a monotonic semantics computable by a straightforward fixed-point iteration.
      </paragraph>
      <paragraph>
       Intervals in LARS. In contrast to ETALIS, the semantics of LARS is based on time points. Nevertheless, we can represent intervals in LARS and thus capture the ETALIS event patterns under some restrictions. Consider a window function {a mathematical formula}w[ℓ,u] that selects the (maximal) substream of the interval {a mathematical formula}[ℓ,u]. Given a formula α, we define the abbreviations{a mathematical formula} That is to say, formula {a mathematical formula}〚ℓ,u〛α holds iff α holds at every time point in the interval {a mathematical formula}[ℓ,u], regardless of the query time. Similarly, {a mathematical formula}〈〈ℓ,u〉〉α holds iff {a mathematical formula}[ℓ,u] is a maximal interval in which α always holds.
      </paragraph>
      <paragraph label="Example 31">
       Consider two events, x and y, which hold in the intervals {a mathematical formula}〈t1,t2〉 and {a mathematical formula}〈t3,t4〉, respectively, and assume {a mathematical formula}t2&lt;t3. An ETALIS rule r{a mathematical formula}z←xSEQy thus assigns the interval {a mathematical formula}〈t1,t4〉 to z. With the above syntactic abbreviations, we may express r in LARS as{a mathematical formula}That is, if {a mathematical formula}[t1,t2] is a maximal interval in which x holds, and {a mathematical formula}[t3,t4], where {a mathematical formula}t2&lt;t3, is a maximal interval in which y holds, then z must hold at every time point in {a mathematical formula}[t1,t4].  □
      </paragraph>
      <paragraph>
       However, this straightforward encoding does not suffice to express ETALIS in LARS. The essential problem arises from overlapping intervals (for the same event/formula). LARS assigns atoms to a single timeline by an evaluation function {a mathematical formula}υ:T→2A. Unless an encoding makes use of time points in atoms, we can encode intervals only by assigning atoms to consecutive time points. Adjacent or overlapping intervals for the same atom cannot be distinguished, they all amount to a merged view of them. For instance, consider an event e that is assigned to {a mathematical formula}〈1,4〉 and {a mathematical formula}〈3,5〉 in ETALIS. By naively constructing a LARS interpretation υ, we would assign {a mathematical formula}υ(t)={e}, for {a mathematical formula}t=1,…,4 and {a mathematical formula}t=3,…,5, and then only be able to read off a merged interval from 1 to 5. There is no way to distinguish the intervals {a mathematical formula}[t1,t4] and {a mathematical formula}[t3,t5] without explicitly encoding the boundaries of these atoms as terms in atoms such that they remain distinguishable.
      </paragraph>
      <paragraph>
       For the sake of illustrating the capabilities of LARS regarding intervals, we now consider separable ETALIS interpretations, i.e., where such overlaps do not occur. If the minimal model of an event stream ϵ and a rule base {a mathematical formula}R is separable, we also call the pair {a mathematical formula}(ϵ,R)separable. In this case, the approach of Example 31 allows us to faithfully translate positive ETALIS rule bases. The notion of minimality in LARS is based on set inclusion, whereas ETALIS defines minimality in terms of minimal length and the supportedness of inferred intervals (see Footnote 12). Notably, ETALIS defines a special form of negation (i.e., the NOT pattern) which ensures that a fixpoint iteration can be done. Using a natural translation for negation would give multiple LARS models in general. However, when confining to positive ETALIS programs with separable minimal models, a straightforward translation as indicated in Example 31 captures the ETALIS semantics.
      </paragraph>
      <paragraph>
       The suggested intuitive approach is thus less expressive than ETALIS, where an atom can be assigned to overlapping intervals. On the other hand, the canonical minimal model of the ETALIS semantics can be computed by fixpoint-iteration for intervals of increasing size. Consequently, by explicitly encoding intervals {a mathematical formula}〈t1,t2〉 into atoms that contain {a mathematical formula}t1 and {a mathematical formula}t2 as terms, the bottom-up evaluation of such models can be emulated with LARS (as in Answer Set Programming). It remains as an interesting topic to find a suitable extension of LARS for nonmonotonic complex event processing (with multiple models) that has an interval-based evaluation function {a mathematical formula}υ:T×T→2A.
      </paragraph>
     </section>
    </section>
    <section label="6">
     <section-title>
      Discussion
     </section-title>
     <paragraph>
      After having discussed relationships of LARS with selected formalisms, we now mention in Sections 6.1–6.3 further research that is based directly on LARS. In Section 6.4 we embed our framework in the broader context of related work. Finally, we discuss in Section 6.5 specific properties that LARS provides for potential applications.
     </paragraph>
     <section label="6.1">
      <section-title>
       Theoretical foundations
      </section-title>
      <paragraph>
       We first review theoretical work on LARS regarding program equivalence and techniques for incremental model update.
      </paragraph>
      <paragraph>
       Equivalence notions. Towards optimizations of LARS programs, [20] studied several notions of equivalence. They extended the notions of strong equivalence (SE) [78], uniform equivalence (UE) [49] and relativized uniform equivalence (RUE) [101] from ASP to LARS and introduced data equivalence for streams. Based on a logic called Bi-LARS they captured the semantics of a large fragment of LARS, including plain LARS, by lifting the model-theoretic characterizations of SE/UE/RUE for ASP. Moreover, Beck et al. studied a special form of monotone windows, a class which includes time-based windows. Restricting to these allows for a variant of Bi-LARS that extends the logic of Here-and-There [73], thus establishing a link to equilibrium logic [87], [78] for the considered class of LARS programs. A final complexity analysis revealed that checking the considered equivalence relations is typically not worse than for ordinary ASP.
      </paragraph>
      <paragraph>
       Incremental reasoning: answer update. Of special interest in stream reasoning is model update and incremental evaluation, in particular, when dealing with expressive languages such as LARS. To this end, we first extended in [19][46] seminal justification-based truth maintenance system (JTMS) for a LARS fragment that was later called plain LARS. It extends normal logic rules of form{a mathematical formula} as follows: the rule head α can be an atom {a mathematical formula}a∈A or a so-called @-atom of form {a mathematical formula}@ta ({a mathematical formula}t∈N); and body elements {a mathematical formula}βi ({a mathematical formula}1≤i≤m) are extended atoms, given by the grammar{a mathematical formula} Doyle's JTMS deals with non-monotonic reasoning by updating a model in the light of new evidence. Technically, this change amounts to the addition of a new rule. Based on (partial) correspondence with stable model semantics [56], we extended this maintenance technique for plain LARS. First, we extended the update mechanism for the time dimension which is included in the label of atoms. Secondly, according central JTMS data structures such as support and consequences have been adjusted accordingly.
      </paragraph>
      <paragraph>
       In particular, the focus is on the concept of stream-stratified programs. In analogy to stratified negation, stream-stratified programs allows one to split up a program into layers based on occurrences of window operators. This assumption aids efficient evaluation and is practical, since one can assume an acyclic flow of information in many applications. There, the output of any stream stratum serves as input for the next higher stratum. Notably, our approach accounts for a generic class of window operators as proposed by LARS as formal language.
      </paragraph>
     </section>
     <section label="6.2">
      <section-title>
       Prototype implementations
      </section-title>
      <paragraph>
       Fragments of LARS have been implemented in several experimental prototypes [17], [22], [15] which are based on different realization principles.
      </paragraph>
      <paragraph>
       LARS via ASP with external atoms. For a pilot application of LARS in multi-media data management discussed in Section 6.3, a specific fragment of LARS that amounts to plain LARS was implemented in dlvhex [51], [50], which is a solver for an extension of ASP with external atoms. The latter allow for an API style access to external information, which can be utilized to perform computations outside an ASP program. Specifically, sliding time-based windows have been realized as external atoms that access the data stream viewed as an external object. While conceptually simple, this implementation is not geared towards performance and specifically lacks incremental reasoning techniques.
      </paragraph>
      <paragraph>
       Ticker: incremental reasoning by program adjustment. More recently, [22] developed another approach for practical, fully incremental reasoning, i.e., for sliding time- and tuple-based windows. While this work also exploits JTMS as specific update technique, it explores more generally the idea of updating a model by incrementally adjusting an encoding of a plain LARS program. Due to the correspondence with ASP, JTMS is a suitable mechanism for the show case. (In the absence of constraints and so-called odd loops JTMS computes and updates answer sets.)
      </paragraph>
      <paragraph>
       Beck et al. considered two encodings: the first one is static and replaces window atoms by auxiliary atoms that are derived based on additional rules. For instance, the LARS rule{a mathematical formula} can be naturally translated into the following ASP rules, provided an additional predicate {a mathematical formula}now(t) is given to model the query time t.{a mathematical formula} The idea similarly carries over for other operators, some of which are more subtle. Assuming that we remove the auxiliary predicate now and directly deal with partial groundings, we get, e.g., at time {a mathematical formula}t=7:{a mathematical formula} We observe that the rules {a mathematical formula}r1′,r2′,r3′ cover the timeline {a mathematical formula}[5,7]. If we now move to time 8, i.e. the timeline {a mathematical formula}[6,8], we can keep any groundings for time points 6 and 7; only groundings for rule {a mathematical formula}r3′ need to be removed, and suitable rules for time 8 have to be added. Thus, based on the window information and the development of the stream (in terms of time, respectively new atoms), new rules are added and some rules expire. For the latter, we can efficiently determine when a rule expires.
      </paragraph>
      <paragraph>
       Based on this principle, we have built a reasoning engine called Ticker,{sup:13} that can be run in two evaluation modes. The first one exploits the static encoding and calls Clingo [62] for ASP-based evaluation. From a semantic perspective, this mode is sufficient for use cases that always have a unique solution, i.e., a single model. The second mode uses the incremental technique and carries out the program update (and thus the model update) by our own implementation and extension of JTMS that also allows for removing rules. In case of multiple potential solutions (answer streams), the system will compute one model at random and then maintain it due to the operational semantics of JTMS. Our experimental evaluations indicate a clear performance benefit of incremental evaluation. For a detailed, formal review of the employed JTMS techniques we refer to [16].
      </paragraph>
      <paragraph>
       Laser: high performance incremental reasoning. In [15] non-ground plain LARS with sliding windows was then considered with the aim of providing highly efficient model update. For applications that do not need multiple model reasoning, one can exploit additional structural information that arises from stratification. Hence, this work focused on positive and stratified programs, i.e., both stream-stratification and stratified negation. Existing semi-naive evaluation techniques as in Datalog [1] have been extended to deal with the temporal dimension of LARS. In particular, for time-based windows, substitutions for non-ground formulas are annotated with two time markers that express the interval during which the according ground formula is guaranteed to hold. As long as the evaluation time is included in such an interval, the substitution can be retained. Thus, when time progresses, parts of the model may be carried over instead of being recomputed. Moreover, further annotations (i.e. guarantees) might be added incrementally for existing substitutions. In this way, the update process may partially reduce to updating annotations of existing derivations. On the other hand, substitutions may expire and are then removed efficiently due to the lookup of the respective time marker. The approach works similarly for tuple-based windows, under analogous annotations that refer to the global tuple count.
      </paragraph>
      <paragraph>
       This research resulted in a prototype engine called Laser{sup:14} that was evaluated empirically and compared against C-SPARQL [14], CQELS [88] and Ticker (using Clingo mode), all of which have been outperformed significantly. We note that Ticker and Laser have been developed in parallel and Ticker's incremental evaluation mode was not available for evaluation during the empirical study of Laser. However, the established results indicate that Laser will also be significantly faster than the incremental approach of Ticker. We further note that C-SPARQL can be seen as an implementation of CQL for the Semantic Web.
      </paragraph>
      <paragraph>
       We thus have two incremental reasoning engines for plain LARS using sliding (time-based and tuple-based) windows: Ticker may be used for problems with multiple models and Laser exploits the restriction to stratified negation to obtain high performance.
      </paragraph>
     </section>
     <section label="6.3">
      <section-title>
       Applications of LARS
      </section-title>
      <paragraph>
       We now give examples how LARS may be used practically as modeling language, respectively as formal tool or framework.
      </paragraph>
      <paragraph>
       Cache management in Content-Centric Networking.[17], [18] presented a show case application of stream reasoning with LARS. Research in the area of Content-Centric Networking (CCN) deals with future internet architectures for more efficient multimedia distribution. Clients issue interest packets, and routers return or need to retrieve data packets based on the content name. A router's caching strategy then decides which data item to store locally, and when to delete it. In our work, we investigated the use of a LARS-based decision component in a complex simulation environment for such an architecture. This implementation uses a specific fragment of LARS (which amounts to plain LARS) and was implemented in dlvhex [51], [50]. This work tries to convey two key messages. First, switching caching strategies dynamically based on patterns of user demand leads to better cache hit ratios and a smaller average number of intermediate router forwards (hops) for content retrieval; and second, that the fully declarative control unit based on LARS is easier to maintain than imperative alternatives.
      </paragraph>
      <paragraph>
       Streaming multi-context systems. Nonmonotonic Multi-Context Systems (MCS) [26] is a formal framework for interlinking knowledge bases, called contexts, via so called bridge rules for information exchange. In [38], the latter have been generalized to streaming bridge rules, which utilize a fragment of LARS for processing of data streams that are dynamically generated by contexts. A semantics of streaming MCS was presented that lifts the key notion of (static) MCS equilibrium to an asynchronous execution model; it is the first semantics of this kind.
      </paragraph>
      <paragraph>
       Dynamic knowledge-based (re)configuration of cyber-physical systems (DynaCon). The development of LARS has also led to an industrial research project that addresses the continuous reconfiguration of components in cyber-physical systems (CPS), DynaCon, which was launched in late 2017 and is funded by the Austrian Research Promotion Agency. Streaming information indicates environment changes such as system faults, attacks, or altered objectives, which are monitored by a networked CPS that can adapt for optimal results. The proposed domain independent architecture has two central modules: one for describing changes and triggering reconfiguration, and another for computing the latter. Conceptually, LARS can be used for both modules. In practice, they will be realized in separation: the computationally expensive configuration tasks can be carried out by a mature ASP solver such as Clingo, which can be repeatedly invoked due to the result of another reasoning system that continuously processes the streaming data. Here, engines based on LARS such as Ticker or Laser can be a suitable choice for expressing complex domain knowledge by means of logical rules.
      </paragraph>
     </section>
     <section label="6.4">
      <section-title>
       Related work
      </section-title>
      <paragraph>
       In the Semantic Web area, the SPARQL language was extended to queries on streams of RDF triples. Respective engines such as CQELS [88] and C-SPARQL [14], as mentioned in Section 5.3, or {a mathematical formula}SPARQLStream[30] follow up on the snapshot semantics of CQL [10], [11] (cf. Section 5.2). Moreover, EP-SPARQL [7], transfers event processing methods of ETALIS [8] (cf. Section 5.4) to semantic web reasoning. It adds to the SPARQL syntax binary operators seq, equals, optionalseq and equalsoptional to combine query expressions (i.e., so-called graph patterns) similarly as union and optional in SPARQL. These constructs introduce joins that depend on temporal information. For instance, given patterns {a mathematical formula}P1 and {a mathematical formula}P2, {an inline-figure} results in a join of {a mathematical formula}P1 and {a mathematical formula}P2 if they occur in a seq relation as in ETALIS, i.e., the instantiation of {a mathematical formula}P1 must occur strictly before that of {a mathematical formula}P2. Moreover, functions are provided for expressing conditions on the timestamps of the start time and the end time, and the duration of triples in the FILTER clause. The execution model exploits event-driven backward chaining rules as in ETALIS, couched in a Prolog implementation.
      </paragraph>
      <paragraph>
       While the above SPARQL extensions provide a variety of ideas to lift static querying techniques to streams, they face difficulties with incorporating more expressive reasoning features as typically studied in Knowledge Representation and Reasoning (KR&amp;R) like nonmonotonicity, default reasoning, or multiple possible solutions. Such features are important to deal with missing or incomplete data, respectively to enumerate alternative solutions and choices. Moreover, as observed by Dindar et al. [43], conceptually identical queries may produce different results on different engines. This may be due to differences that either arise from potential flaws in implementations, but also due to (correctly implemented) different semantics. Comparisons between different approaches are confined to experimental analysis [89] or informal examination on specific examples. For the user it is important to know the exact capabilities and semantic behaviors of given methods for systematic analysis and comparison.
      </paragraph>
      <paragraph>
       In KR&amp;R, first attempts towards expressive stream reasoning have been recently carried out and reveal many open problems. The plain approach of Do et al. [44] periodically calls the dlvhex solver [54] without incremental reasoning and thus cannot handle heavy data load. Another logic-based approach is Streamlog [102] which extends Datalog for stream reasoning, motivated by a perceived lack of logical foundations of Data Stream Management Systems. By introducing so-called sequential programs that have syntactic restrictions on special temporal rules, Streamlog defines a non-blocking negation that can be used in recursive rules in a stream setting. Sequential programs are locally stratified and thus have unique models that can be computed efficiently by a fixpoint computation. The temporal predicates of Streamlog use the time point as first argument, i.e., an atom {a mathematical formula}p(t,x1,…,xn) corresponds to {a mathematical formula}@tp(x1,…,xn) in LARS, where time is explicit; respectively orthogonal to logical truth.
      </paragraph>
      <paragraph>
       Reasoning over streams has also been considered in ontology-based data access (OBDA). Ontology Stream Management Systems (OSMS), as introduced in [94], consider the use of Truth Maintenance Systems to deal with large volumes of data in EL++ reasoning. Streams of ontologies are also considered in the query language STARQL [86] for query answering over streams. Neither Streamlog nor OSMS employ window mechanisms; STARQL on the other hand provides time-based windows.
      </paragraph>
      <paragraph>
       Multiple works on the ASP solver Clingo have addressed the issue of data or program change. Incremental ASP [65] introduced new techniques for incremental grounding and solving based on the module theory in [85] which allows for composing programs with explicit (distinct) input and output atoms. An incremental program is a triple {a mathematical formula}(B,P,Q) consisting of three program parts: B describes static knowledge; P and Q are slices that depend on a parameter t. At each step t, the program grows by a new set {a mathematical formula}P[t], while {a mathematical formula}Q[t] is considered only temporarily at t. Relying on according composition of modules, model computation can then be carried out incrementally. The work resulted in the solver iClingo, which uses declarations #base, #cumulative t, and #volatile t to delineate program parts B, P, and Q from above, respectively. In a step k, the parameter (variable) t in a rule of program part P or Q is then instantiated with k. All other variables can be grounded only once, i.e., these instantiations must be derivable from static knowledge. While incremental ASP focuses on stepwise computation of models, reactive ASP [64] targets real-time systems by providing additional means to add new data online. On top of incremental programs and its update mechanism, reactive programs support an asynchronous control via so-called online progressions of external events and inquiries which themselves are programs. In essence, at each step, external information can be incorporated to ground new rules dynamically. The resulting solver oClingo uses the additional declaration #external to introduce atoms that can be fed into the system in a streaming fashion. However, while reactive ASP provides incremental solving features for streaming data, it lacks a window mechanism. More precisely, the dynamic program parts P (which is cumulative) and Q (which concerns only the current step) do not fit the conceptual approach of windows which express the relevance of information relative to an interval of steps. With the aim of providing such a window mechanism for stream reasoning, time-decaying logic programs[63] were defined as triples {a mathematical formula}(B,P,{Q1,…,Qm}), where the instantiation of each program part {a mathematical formula}Qi expires after a specified life span of {a mathematical formula}ni steps ({a mathematical formula}ni∈N∪{∞}). Thus, each program part {a mathematical formula}Qi resembles functionality of a sliding window of length {a mathematical formula}ni. To incorporate this facility, oClingo's additional declaration of form #volatile t : n states that subsequent rules that are parameterized with variable t are discarded after n steps.
      </paragraph>
      <paragraph>
       Ideas from incremental ASP, reactive ASP and time-decaying logic programs have been improved continuously and are now subsumed in the current version 5 of Clingo [66]. Its multi-shot solving capabilities to evaluate changing programs were presented earlier in [67] which gave an introduction to multi-shot solving by modeling the board game Ricochet Robots. These works all provide additional control for grounding and solving via additional parameters that can be accessed by an external script. Such mechanisms can be used, e.g., to simulate the progress of time and to encode certain window operators. While Clingo's multi-shot features target the incremental and reactive control of the ASP solving process, LARS programs explicitly lift the ASP semantics for streams and provide novel language constructs that can be flexibly composed.
      </paragraph>
      <paragraph>
       Another proposal for nonmonotonic stream reasoning is StreamRule [80], which emphasizes the potential of ASP-based reasoning for the Semantic Web. The proposed architecture combines the Linked Sensor Middleware (LSM) [90], CQELS for query processing and pattern matching, and oClingo for subsequent rule-based reasoning. In a similar way, the PrASP system [84] for probabilistic answer set programming is used as component of a probabilistic stream reasoning system architecture in [83]. As LARS is not geared towards quantitative uncertainty, we can not directly model the semantics PrASP in our framework. Extending the framework in this direction is an interesting issue for future work.
      </paragraph>
      <paragraph>
       A central challenge in incremental reasoning, in particular for materialization of Datalog programs, arises from fact deletion which requires to identify and retract inferred facts that are not derivable anymore. The Delete/Rederive (DRed) algorithm [70] works by first overestimating deletions and then rederives them in case they still hold. This potential source of inefficiency was addressed by the Backward/Forward algorithm [82], which avoids the overdeletion phase. Instead, it determines by a combination of backward and forward chaining which of the facts that may have to be removed have alternate proofs from remaining facts. The algorithm was shown to be significantly faster than DRed in some ontology query answering benchmarks. However, it is not applicable to programs with negation.
      </paragraph>
      <paragraph>
       In Section 5.1, we already investigated the relation of LARS and Linear Temporal Logic (LTL). Metric Temporal Logic (MTL) [75] is a notational variant of a fragment of Alur and Henzinger's [5] timed propositional temporal logic, which has been conceived to model real-time systems. Informally, it generalizes LTL (and in presence of past time operators, PLTL), where operators {a mathematical formula}OpIφ allow for evaluating a formula φ on a set I of time points that can be any convex set (i.e., interval) or is defined by the congruence relation {a mathematical formula}≡dc. For example,{a mathematical formula} expresses that each request is granted within one time step. Specifically, LTL respectively PLTL result for a uniform interval {a mathematical formula}I=[0,∞) and the discrete time ontology {a mathematical formula}〈N,≤〉. Compared to LARS, MTL does not have general window operators (merely interval-bounded versions of the LTL operators {a mathematical formula}G, {a mathematical formula}F respectively {a mathematical formula}G−1, {a mathematical formula}F1 are available) but features all operators of LTL respectively PLTL; notably, sliding time-based windows of LARS with universal respectively existential formula evaluation correspond to MTL window operators; i.e.,{a mathematical formula} Informally, {a mathematical formula}⊟[0,a]φ (respectively {an inline-figure}) checks whether φ holds always (respectively at least once) within a steps back from the current time point respectively state; {a mathematical formula}⊞[0,b]φ (respectively {an inline-figure}) is analogous for b steps forward. MTL has a timed state-sequence semantics with arbitrary time increase between successive states; this gives it an event-driven flavor, and comparability with LARS, where time increases by a single tick, is more difficult, in particular for LARS programs that resort to minimal models. Even for state-sequences with uniform time increase, nested windows may yield different results, as windows in LARS narrow down the input stream to a (finite) substream, while in MTL streams are at any evaluation stage infinite objects.{sup:15} Furthermore, MTL is very expressive, as satisfiability and model checking are both {a mathematical formula}ExpSpace-complete problems.{sup:16}
      </paragraph>
      <paragraph>
       While the use of MTL in stream processing has been advocated early on [72], the interest in it for stream reasoning has recently increased [31], [99], [23]. Most recently, [23] have considered a Horn fragment of Metric Temporal Logic called Metric Time Datalog (datalogMTL). More precisely, it is a fragment of Alur et al.'s [4] Metric Interval Temporal Logic (MITL), which uses a dense time ontology (the real numbers {a mathematical formula}R respectively the rational numbers {a mathematical formula}Q) and allows to express truth of statements over a time interval rather than a single time point; as in MTL with dense time ontology, in MITL satisfiability and model checking are undecidable in general, but {a mathematical formula}ExpSpace-complete if point intervals excluded. Brandt et al.'s datalogMTL programs contain rules of the form {a mathematical formula}A+←A1∧⋯∧Ak where each {a mathematical formula}Ai is either (i) an inequality or (ii) a formula {a mathematical formula}Op1I1⋯OpnInBi, {a mathematical formula}n≥0, where each {a mathematical formula}Opi is from {⊞, ⊟, {an inline-figure}, {an inline-figure}, {a mathematical formula}Ii is an interval over {a mathematical formula}Q, and {a mathematical formula}Bi is an atom, and where {a mathematical formula}A+ is a formula in (ii) without {an inline-figure} and {an inline-figure}. They worked out a canonical model property for query answering, which is akin to the least model property of Horn logic programs, but technically more involved. Based on it, they showed that query answering is {a mathematical formula}ExpSpace-complete already in the propositional case; notably, allowing {an inline-figure} and {an inline-figure} in rule head leads to undecidability. The canonical model property is then exploited to develop a first-order rewriting for non-recursive (acyclic) Horn rules, referred to as {a mathematical formula}datalognrMTL; for this fragment, query answering is {a mathematical formula}PSpace-complete. Modulo the divergence in window operators and different time ontologies, datalogMTL appears to be naturally related to LARS Horn rules respectively (negation-free) programs. It remains an issue for future work to study the relationship between datalogMTL and LARS in depth, and in particular to see whether notions and techniques for LARS (which is model-centric) can be exploited for datalogMTL (which is query-centric) and vice versa.
      </paragraph>
      <paragraph>
       Finally, stream reasoning has also been considered from the perspective of spatio-temporal reasoning, e.g., in [45], [39], [74].
      </paragraph>
     </section>
     <section label="6.5">
      <section-title>
       Distinguishing LARS features from an application perspective
      </section-title>
      <paragraph>
       Sections 5.1–5.4 explored the formal relationship between LARS and related formalisms, and we discussed further related work in the previous section. We now elaborate on practical implications of such differences, in particular, which kind of features in applications can be targeted with LARS but not with other approaches, or where LARS is easier to apply. In doing so, we leave aside the theoretical framework side of LARS to formalize the semantics of other languages and concentrate on its potential use as genuine reasoning language.
      </paragraph>
      <paragraph>
       Regarding temporal reasoning in the spirit of LTL or MTL, the biggest difference regarding applications is that LARS formulas and programs are centered around the idea of dropping data, whereas temporal reasoning is usually concerned with specifications of guarantees over infinite timelines. That is to say, languages for temporal reasoning are more geared towards monitoring and verification rather than computations that involve abstractions or auxiliary information (as in ASP/LARS rule heads). Disregarding discussed encoding potentials (cf. Section 5.1), we imagine that from an application perspective the choice between temporal reasoning and stream reasoning with windows is determined by these aspects. On the other hand, combinations of their respective features point at intriguing future research issues, i.e., augmenting temporal reasoning languages like LTL or MTL with generic window functions, respectively considering infinite timelines in variants of LARS.
      </paragraph>
      <paragraph>
       Example 22 (page 33) illustrated some of the benefits that come with LARS-based reasoning. We compute expected arrival times of trams in rule (11) and then reason in rule (12) which pairs of expected arrivals yield good connections. First to mention here is the abstraction which takes place: by introducing rule (11) the condition of the body gets a name that can be reused in other rules. Clearly, standard stream query languages such as those building on CQL can similarly introduce abstraction by means of nested queries. However, this way, according translations of more involved programs (i.e., with many rules) quickly become unreadable. On the technical side, it is possible to chain such query nesting but it is not possible to impose mutual conditions on their respective evaluations, i.e., cycles. This is related to a commitment to single models in most stream processing approaches, as we shall further discuss below.
      </paragraph>
      <paragraph>
       The ability to compute transitive closures is among the semantic assets inherited from ASP. We may assume that the background facts plan for traveling times are specified only for consecutive stations. Nevertheless, we can then compute expected arrival times at further stations by adding the following rule:{a mathematical formula} The rule expresses the following: We expect a tram ID at station Y at time {a mathematical formula}TY if it is already expected D minutes before at the previous station X at time {a mathematical formula}TX, where D is the planned time it takes the tram to get from X to Y. Importantly, the same rule then applies to station Y and its subsequent station Z, and so forth. In other words, we can compute expected arrival times for all remaining stations of that line. Given in addition similar rules for connecting lines, all potential future trajectories can be reasoned about in principle. Such recursive reasoning is typical for ASP but rarely available in stream query languages; LARS makes it available in flexible combination with streaming data. Note in particular that predicate exp depends (in rule (11)) on the current inexistence of traffic jams. Thus, any path of pairwise reachable stations that depends on station X (in terms of the predicate exp) will be dismissed as soon as a traffic jam is reported at X. This nonmonotonic effect of negation that additional information may lead to the retraction of conclusion is an important feature if one wants to reason with defaults such as the normal flow of traffic.
      </paragraph>
      <paragraph>
       The possibility to express loops through predicates also in the presence of negation makes LARS applicable to combinatorial problems and dynamic constraint satisfaction problems. We illustrated this in Example 23, where we used the information on pre-selected good connections (due to rules (11) and (12)) to specify a choice between changing trams or skipping a good connection. This was established by the predicate change which is in a cyclic dependency with predicate skip. Using query languages in the spirit of CQL, we could specify some conditions for changing trams in one query and for skipping connections in another, but it would not be feasible to write a query that outputs both options as a result of the same query due to the mutual dependence and the inherent determinism. Apart from the limitations regarding cyclic dependencies, the only way to express multiple options in such deterministic languages would be to encode their enumeration as such in the query result. This however may lead to large output, if an exponential number of options exists. In contrast, a nondeterministic language allows one to produce the options declaratively one by one, in an enumerative fashion, where one may stop at any time; this would in a deterministic language require operational elements, as e.g., in Prolog.
      </paragraph>
      <paragraph>
       Limitation to single solutions is also a shortcoming of ETALIS. It can express combinations of intervals that go beyond the temporal capabilities of LARS but it has a rudimentary form of negation and no other means that could serve to express multiple solutions. When using time points as additional arguments in atoms, LARS can emulate ETALIS. On the other hand, it is not possible to encode the rich semantic properties of LARS in ETALIS.
      </paragraph>
      <paragraph>
       Languages like CQL that adopt the snapshot semantics (which drop the temporal information of obtained windows) cannot express temporal reasoning (beyond what can be encoded with explicit timestamps in tuples). By contrast, LARS provides fine-grained control. This not only allows one to reason about the contents of windows as such (as in CQL) but also about temporal occurrence. In other words, LARS can not only express whether something holds but also that something always holds or when something is true. Consider, for instance, the modality {a mathematical formula}@T in the head of rule (11). This places the inference explicitly to a time point that is defined in the rule body. In that regard the @-operator not only serves to match or select time points from streaming data, but to reason also about the temporal information of inferred data. An example of such reasoning is realized by the formula{a mathematical formula} in rule (12): based on the specific time T of the expected arrival of the other tram {a mathematical formula}ID1 in that rule, the formula is satisfied if there is an expected tram at a station within the next 5 minutes relative toT. That is to say, we control at which time T the window {a mathematical formula}⊞+5 is selected, where T itself is inferred information. Note further that this window is non-standard in that it selects future time points. LARS itself is agnostic about which window functions to employ; everything that computes substreams is applicable. We emphasize that such windows may include also inferred data, as do for instance our time-based windows. As a consequence, the full power of LARS operator combinations extends to inferred information. Beyond semantic properties inherited from ASP, it is exactly this compositionality of generic windows and temporal modalities (◇, □ and @) that sets apart LARS from existing streaming languages.
      </paragraph>
      <paragraph>
       In the works on Content-Centric Networking mentioned above (cf. Section 6.3) we made use of the compositional nature of LARS operators, staying even within the plain LARS fragment. Consider the following two rules from there (slightly adapted):{a mathematical formula}{a mathematical formula} The task is to infer x when the predicate value has continuously held an integer greater or equal to 18 during the last 30 time points. To this end, we make an abstraction in the first rule: every time point (during the last 30) where there is a value {a mathematical formula}V≥18 is associated with atom high; the second rule then fires if we can infer a high value for all time points during the considered interval.
      </paragraph>
      <paragraph>
       In combination with nested window operators (and reset), the possibility to navigate along the timeline with temporal modalities leads to highly expressive reasoning capabilities, as examined in the complexity analysis. Example 15 (page 29) illustrated the use of window nesting in combination with temporal modalities, where we formalized{a mathematical formula} to check whether a signal s appeared always within 5 minutes during the last 60 minutes.
      </paragraph>
      <paragraph>
       While nested queries are often available in other approaches, specifications of temporal conditions on their evaluation are not. Note that φ can be seen as reasoning over a sequence of nested reasoning steps, thus yielding a formal counterpart to evaluating re-runs ({a mathematical formula}⊞60□ψ) of the same query ({a mathematical formula}ψ=⊞5◇s, after stepping out with reset ▹). This way LARS can express evaluations of evaluations (in arbitrary depth) and in this way serve for hierarchical reasoning.
      </paragraph>
     </section>
    </section>
    <section label="7">
     <section-title>
      Conclusion
     </section-title>
     <paragraph>
      We have presented LARS, a logic-based formalism to model and analyze stream processing respectively reasoning over data streams, where the data volume is reduced by using data snapshots called windows. LARS is equipped with a model-based semantics and offers besides “classical” semantics also an expressive rule-based language that adopts the answer set semantics for dealing with incomplete information.
     </paragraph>
     <paragraph>
      Drawing from the observation about what operations are typically performed on windows in stream processing, we have considered the temporal modalities □, ◇ and the nominal operator {a mathematical formula}@t; that is, LARS allows for distinguishing truth of a formula at (i) specific time points, but also (ii) at some respectively every time point in a window; furthermore, it offers general window operators that may be nested, which enables reasoning over streams within the language. After discussing some elementary properties of LARS programs, we have investigated the computational complexity of major reasoning tasks in LARS, viz. model checking and satisfiability testing, for both LARS formulas and programs, where we have put emphasis on specific classes of windows that are widely used in practice (time-based, tuple-based, and partition-based windows). In that, we have characterized the complexity of instance classes of the problems ranging from {a mathematical formula}P-completeness in the propositional (ground) case to {a mathematical formula}NExpTimeNP-completeness in the Datalog setting. Notably, the use of common windows in practice does not add to the worst-case complexity of the underlying fragment of temporal logic, nor does bounded nesting depth in general.
     </paragraph>
     <paragraph>
      We have then related LARS to selected other languages and formalisms for reasoning over streams. We have shown that propositional LARS formulas with sliding time windows can be expressed in linear temporal logic, and thus amount to a (strict) fragment of the regular languages, while LARS program with such windows capture the regular languages. Furthermore, we have shown that queries in the well-known Continuous Query Language (CQL) [11] can be captured by LARS, and we have briefly discussed that the operational semantics of the RDF Stream Processing engines CQELS [88] and C-SPARQL [14] can modeled in LARS, while the prominent ETALIS language [8], which is geared towards complex event processing, is beyond a natural representation.
     </paragraph>
     <paragraph>
      The modeling of CQL, CQELS and C-SPARQL illustrates the usage of LARS as a formal representation and analysis framework, which was one of the motivations behind the formalism. As it turned out, the formalism and its affinity to Answer Set Programming make it attractive as a genuine reasoning language, which has been pursued in a pilot application in the context of content-centric network management [17], [18]; follow up research in cyber-physical systems is on the agenda. For these endeavors, recent experimental implementation prototypes of LARS fragments, which cater for incremental reasoning, will be instrumental.
     </paragraph>
     <section label="7.1">
      <section-title>
       Outlook and future work
      </section-title>
      <paragraph>
       There are several directions for future work. One is to enrich the LARS framework. Besides aggregates, towards event processing further temporal operators such as next time {a mathematical formula}(X) and until {a mathematical formula}(U), as well as their past time versions {a mathematical formula}(X−1,U−1) can be considered. The entailment relation over streams can be naturally extended adhering to the usual semantics of these operators (where at the end of a stream, {a mathematical formula}Xα evaluates to false). Accordingly, the evaluation algorithms discussed in Section 4 can be extended, without an increase of worst case complexity in the general case. However, the complexity of fragments of the language, as well their expressiveness, might be affected.
      </paragraph>
      <paragraph>
       Another direction is a refined picture of the complexity and expressivity of LARS fragments. Restrictions to the general framework can be defined in form of syntactic and semantic criteria. The fragments introduced in [19], [20] may serve here as a starting point. Based on the results, efficient implementations and optimization may be developed, where in particular incremental methods (as discussed in Sections 6.1–6.3), data reduction via small window size (to be determined from the data) and approximation are of interest.
      </paragraph>
      <paragraph>
       Related to the previous direction is to extend and deepen the investigation of the relationship to other formalisms and languages for stream reasoning, in particular to metric temporal logic and datalogMTL as the Horn fragment thereof. In connection with this, further reasoning tasks, such as prediction based on future evolutions of the stream might be considered; some initial results have been obtained in [20], [38].
      </paragraph>
      <paragraph>
       Finally, further use of LARS to model stream reasoning languages, e.g., {a mathematical formula}SPARQLStream[30], and to develop reasoning modules for applications remain to be continued.
      </paragraph>
     </section>
    </section>
   </content>
   <appendices>
    <section label="Appendix A">
     <section-title>
      The LARS framework
     </section-title>
     <paragraph label="Proof of Theorem 1">
      Consider the structure {a mathematical formula}M=〈I,W,B〉, where {a mathematical formula}I∈AS(P,D,t). We first show that M is a model of P at time t, i.e., that {a mathematical formula}M,t⊨r for all rules {a mathematical formula}r∈P. There are two cases. If {a mathematical formula}r∈PM,t, satisfaction at t holds by definition. Else, let {a mathematical formula}r=α←β1,…,βn. We have {a mathematical formula}M,t⊭β(r) and thus {a mathematical formula}M,t⊨β(r)→α.As for minimality, suppose that {a mathematical formula}M′=〈I,W,B〉 where {a mathematical formula}M′⊂M is a model of P for D at time t. Then, {a mathematical formula}M′,t⊨r for each rule {a mathematical formula}r∈P, and hence {a mathematical formula}M′,t⊨r for each rule {a mathematical formula}r∈PM,t⊆P. This means {a mathematical formula}M′ is a model of {a mathematical formula}PM,t at time t; hence M is not a minimal model of {a mathematical formula}PM,t at time t, which contradicts {a mathematical formula}I∈AS(P,D,t).  □
     </paragraph>
     <paragraph label="Proof of Theorem 2">
      Let {a mathematical formula}I∈AS(P,D,t) and {a mathematical formula}t′↦a∈I∖D. By Definition 15, {a mathematical formula}M=〈I,W,B〉 is a minimal model of {a mathematical formula}PM,t for D at t. Towards a contradiction, assume that for all {a mathematical formula}r∈P it holds that (i) {a mathematical formula}M,t⊭β(r) or (ii) {a mathematical formula}M′,t⊨r, where {a mathematical formula}M′=〈I∖{t′↦a},W,B〉. We first observe that item (i) cannot hold for all rules, as this would imply that {a mathematical formula}PM,t=∅, which has the single minimal model {a mathematical formula}〈D,W,B〉 at t; this would imply {a mathematical formula}I=D and thus {a mathematical formula}t′↦a∈I would be impossible, contradiction.We now only consider those rules {a mathematical formula}r∈P where {a mathematical formula}M,t⊨β(r), i.e., the reduct {a mathematical formula}PM,t≠∅. Since for all {a mathematical formula}r∈PM,t we have that {a mathematical formula}M′,t⊨r, where {a mathematical formula}M′=〈I∖{t′↦a},W,B〉, we conclude that M is not a minimal model of {a mathematical formula}PM,t. This yields the contradiction.  □
     </paragraph>
     <paragraph label="Proof of Theorem 3">
      Under the asserted properties, clearly some model {a mathematical formula}M=〈I,W,B〉 of P exists for D at t: simply let in I all intensional atoms be true. Furthermore, any model {a mathematical formula}M′⊂M of {a mathematical formula}PM,t for D at t satisfies {a mathematical formula}M′,t⊨P, as under the monotonicity assertions {a mathematical formula}M′,t⊭β(r) for each (grounded) rule r in {a mathematical formula}P∖PM,t. By repeating this argument for {a mathematical formula}M′ etc., we can build a maximal, strictly decreasing chain of models {a mathematical formula}M0=M,M1,M2,… of P for D at t. The intersection N of all these models is another model of P for D at t, and hence no model {a mathematical formula}N′⊂N of P for D at t can exist. Consequently, N is also a minimal model of {a mathematical formula}PN,t for D at t; in other words, N is an answer stream of P for D at t. This proves part (i). As for part (ii), by Theorem 1 each {a mathematical formula}I∈AS(P,D,t) is such that {a mathematical formula}M=〈I,W,B〉 is a minimal model of {a mathematical formula}PM,t at t; conversely, the chain construction in part (i) starting with any minimal model {a mathematical formula}M=〈I,W,B〉 of P for D at t yields {a mathematical formula}N=M, and thus {a mathematical formula}I∈AS(P,D,t) holds.  □
     </paragraph>
    </section>
    <section label="Appendix B">
     <section-title>
      Computational complexity
     </section-title>
     <paragraph>
      In this section, we provide proofs of the complexity results and further details on computation.
     </paragraph>
     <section label="B.1">
      LARS formulas α
      <paragraph label="Proof of Theorem 4">
       Let {a mathematical formula}M=〈S⋆,W,B〉, {a mathematical formula}S=(T⋆,υ⋆), be a structure, let {a mathematical formula}S⊆S⋆ be a substream of {a mathematical formula}S⋆ and let α be a ground formula. Let N denote the size of M plus S.{a mathematical formula}PSpacemembership. We show that the space used to determine {a mathematical formula}M,S,t⊩α is bounded by {a mathematical formula}O(|α|⁎N+Nk), where {a mathematical formula}|α| is the size (length) of formula α and {a mathematical formula}k≥1 is some constant.Indeed, a ground formula α can be represented as a tree whose leaf nodes are atoms from {a mathematical formula}A and whose intermediate nodes are operators from {a mathematical formula}{¬,∧,∨,→,◇,□,@t,⊞w,▹}, where {a mathematical formula}t∈T. For example, the formula {a mathematical formula}⊞10□(⊞#3◇a∧(⊞4◇b→⊞5□(¬c∧d))) can be represented by the tree in Fig. 13.The following strategy guarantees that evaluating a ground formula α remains in {a mathematical formula}O(|α|⁎N+Nk) space. We travel the tree in a depth-first-search manner.
       <list>
        When encountering a logical connective: evaluate the truth value of its sub-tree(s) and then combine the result using the semantics of the corresponding connective.When encountering a window operator {a mathematical formula}⊞w: extract a substream {a mathematical formula}S′=w(S,t) of the current stream S and store {a mathematical formula}S′ in a new place for evaluating the sub-tree of this operator.When encountering a □ or ◇ operator: iterate over the timeline T of the current window to determine the truth value of the sub-tree for each {a mathematical formula}t∈T.When encountering an {a mathematical formula}@t operator where t is a time point (and {a mathematical formula}t∈T where {a mathematical formula}S=(T,υ)): evaluate the sub-tree with reference to this time point.When encountering a leaf node: check the occurrence of the atom in the evaluation function at the current reference time point.Furthermore, when visiting a node in the tree, we only need to consider the windows constructed by the window operators appearing on the path from the root to the current node. For other already visited branches, the space allocated for storing windows can be released. In case (3), we loop over all time points
       </list>
       <paragraph>
        {a mathematical formula}t∈T and need only an iteration counter.Therefore, at any time, the space used is bounded by the depth of the tree times N, plus the space for window evaluation; this yields {a mathematical formula}O(|α|⁎N+Nk).{a mathematical formula}PSpacehardness. Given a QBF of the form{a mathematical formula} where {a mathematical formula}Qi∈{∃,∀}, we translate it into a LARS formula{a mathematical formula} where for {a mathematical formula}1≤i≤n, {a mathematical formula}Wi=◇ if {a mathematical formula}Qi=∃, {a mathematical formula}Wi=□ if {a mathematical formula}Qi=∀, and {a mathematical formula}⊞set:xi is a window operator with an associated window function {a mathematical formula}setxi defined as follows. Given a stream {a mathematical formula}S=(T,υ) and a time point {a mathematical formula}t∈{0,1}:{a mathematical formula} where {a mathematical formula}T′=T and for all {a mathematical formula}j∈T:{a mathematical formula} That is, {a mathematical formula}setxi removes {a mathematical formula}xi from the input stream S, if it is called at time {a mathematical formula}t=0, and it leaves S unchanged if it is called at {a mathematical formula}t=1; informally, this amounts to setting {a mathematical formula}xi to false (=0) and to true (=1), respectively.Let now {a mathematical formula}S⋆=(T⋆,υ⋆), where {a mathematical formula}T⋆=[0,1] and {a mathematical formula}υ⋆(0)=υ⋆(1)={x1,x2,…,xn} and let {a mathematical formula}M=〈S⋆,W,∅〉, where {a mathematical formula}W={⊞set:x1,…,⊞set:xn}.Informally, {a mathematical formula}◇⊞set:x1α′ is entailed at {a mathematical formula}t=0 (likewise, at {a mathematical formula}t=1), if either at {a mathematical formula}t=0 or {a mathematical formula}t=1, after applying the window function {a mathematical formula}setxi(S,t), the formula {a mathematical formula}α′ evaluates to true (=1) at t; that is, after either setting {a mathematical formula}x1 false (0) or to true (1), respectively. Dually, {a mathematical formula}□⊞set:x1α′ is entailed at {a mathematical formula}t=0 (likewise, at {a mathematical formula}t=1) iff {a mathematical formula}α′ evaluates to true for both setting {a mathematical formula}x1 to false and to true. The nesting of the formula (25) thus mimics the QBF Φ in (24), as follows:
       </paragraph>
       <list>
        <list-item label="(i)">
         the two time points 0 and 1 encode the truth values false and true, respectively.
        </list-item>
        <list-item label="(ii)">
         By starting with the function {a mathematical formula}υ⋆ as the set {a mathematical formula}{x1,x2,…,xn} and by removing in {a mathematical formula}⊞set:xi the atom {a mathematical formula}xi on the 0 branch and keeping {a mathematical formula}xi on the 1-branch, the evaluation of α can be seen as traversing a binary evaluation tree where the substream at each leaf node represents a complete truth assignment to {a mathematical formula}x1,…,xn. Fig. 14 shows the tree with three variables.
        </list-item>
        <list-item label="(iii)">
         The operator ◇ (respectively □) in front of {a mathematical formula}⊞set:xi simulates the quantifier ∃ (respectively ∀): some (respectively every) of the subtrees, rooted at the 0 or 1 child, must evaluate to true.
        </list-item>
       </list>
       <paragraph>
        A subtree of the tree starting at the root that fulfills the condition (iii) each satisfies the formula {a mathematical formula}ϕ(x1,…,xn) at each leaf witnesses then that Φ evaluates to true.More formally, we show by induction on {a mathematical formula}i=0,…,n that if {a mathematical formula}Sn−i=(T⋆,υn−i) is a substream of {a mathematical formula}S⋆ such that {a mathematical formula}υn−i(0)=υn−i(1)⊇{xn−i+1,…,xn}, then for the truth assignment σ to {a mathematical formula}x1,…,xn−i such that {a mathematical formula}σ(xj)⇔xj∈υn−i(0), it holds that{a mathematical formula} for any {a mathematical formula}t∈{0,1} iff{a mathematical formula} evaluates to true; here {a mathematical formula}S0=S⋆.For {a mathematical formula}i=0, the stream {a mathematical formula}Sn is a complete truth assignment to {a mathematical formula}x1,…,xn and by construction the claim holds. For the inductive step, suppose the statement holds for i and consider {a mathematical formula}i+1. By applying {a mathematical formula}setxn−i on {a mathematical formula}Sn−(i+1)+1=Sn−i at {a mathematical formula}t=0, a stream of form {a mathematical formula}Sn−i+1 results, where {a mathematical formula}xn−i is set to false; thus by the induction hypothesis{a mathematical formula} where {a mathematical formula}σ(xn−i)=0; for {a mathematical formula}t=1 the argument is analogous, where “0” is replaced by “1”. Hence by definition of ◇ respectively □, we obtain that (26) holds iff (27) holds. This proves the claim.For {a mathematical formula}n=0, as {a mathematical formula}S0=S⋆ we then obtain that {a mathematical formula}M,S⋆,t⊩α for α in (25) and {a mathematical formula}t∈{0,1} iff Φ in (24) evaluates to true. As {a mathematical formula}M,S⋆, α and t are computable in polynomial time from Φ, it follows that deciding {a mathematical formula}M,S,t⊩α, i.e., model checking for LARS formulas, is {a mathematical formula}PSpace-hard.  □
       </paragraph>
      </paragraph>
      <paragraph label="Proof of Theorem 5">
       {a mathematical formula}PSpace membership follows from the fact that we can guess an evaluation function v on T and then perform a model check {a mathematical formula}M,S,t⊩α where {a mathematical formula}S=(T,υ); relative to the set {a mathematical formula}A′ of atoms, the guess for υ has polynomial size, and thus the combined guess and check algorithm can run in {a mathematical formula}NPSpace; as {a mathematical formula}NPSpace=PSpace by Savitch's result [95], it is thus in {a mathematical formula}PSpace.The {a mathematical formula}PSpace-hardness follows from a simple reduction of model checking {a mathematical formula}M,S,t⊩α, where from the proof of Theorem 4 w.l.o.g. {a mathematical formula}S=S⋆=(T⋆,υ⋆): we construct{a mathematical formula} i.e., fix the possible valuation to υ, and ask for an evaluation function {a mathematical formula}υ′ on {a mathematical formula}T⋆ s.t. {a mathematical formula}M,(T⋆,υ′),t⊩αS.  □
      </paragraph>
      <paragraph label="Proof of Theorem 6">
       To decide the problem, we can (a) check that I is an interpretation stream for D, (b) compute {a mathematical formula}PM,t, and (c) check that M is a minimal model of {a mathematical formula}PM,t, i.e., that (c.1) {a mathematical formula}M,t⊨PM,t and (c.2) no {a mathematical formula}M′=〈I′,W,B〉, with {a mathematical formula}I′=(T,υ′)⊂(T,υ) exists such that {a mathematical formula}M′,t⊨PM,t. Now,
       <list>
        step (a) is trivially polynomial;steps (b) and (c.1) are feasible in polynomial time using a {a mathematical formula}PSpace oracle; andstep (c.2) is feasible in nondeterministic polynomial time using a {a mathematical formula}PSpace oracle (guess {a mathematical formula}(T′,v′) and check {a mathematical formula}M′,t⊨PM,t).The
       </list>
       <paragraph>
        {a mathematical formula}PSpace-hardness of the problem is easily obtained from Theorem 4: for given ground formula α and {a mathematical formula}M=〈S,W,B〉, let {a mathematical formula}P={α←⊤}, where ⊤ is an arbitrary tautology. Note that no intensional data occur in α, and thus no interpretation {a mathematical formula}M′ that is smaller than M is possible, and thus {a mathematical formula}M=〈S,W,B〉 is an answer stream for P for D at t iff {a mathematical formula}M,S,t⊩P holds.  □
       </paragraph>
      </paragraph>
      <paragraph label="Proof of Theorem 7">
       To show satisfiability of a ground LARS program P, we can guess a stream {a mathematical formula}I=(T,v) and check that I is an answer stream of P for D at t; the guess is polynomial in the size of {a mathematical formula}A′ and the check feasible in {a mathematical formula}PSpace by Theorem 6; overall, the computation is feasible in {a mathematical formula}NPSpace, thus in {a mathematical formula}PSpace.The {a mathematical formula}PSpace-hardness of SAT for LARS programs P follows from the reduction of MC for LARS formulas to MC for LARS programs in the proof of Theorem 6.  □
      </paragraph>
     </section>
     <section label="B.2">
      <section-title>
       Bounded window nesting
      </section-title>
      <paragraph label="Proof of Theorem 8">
       In the discussion preceding the results, a bound {a mathematical formula}N=(#w(α)⁎|T|)wnd(α) on the number of substreams that emerge in the recursive evaluation of α has been derived. Clearly the set of all these substreams forms an evaluation base {a mathematical formula}SB for {a mathematical formula}M,S,α. If {a mathematical formula}wnd(α) is bounded by a constant k, then N is polynomially bounded in the size of M and α. The result then follows immediately from Theorem 10.  □
      </paragraph>
      <paragraph label="Proof of Theorem 9">
       Membership in {a mathematical formula}co-NP can be seen as follows: the {a mathematical formula}PSpace oracle in the algorithm considered in the proof of Theorem 6 can by Theorem 8 be replaced by a polynomial-time computation. It follows that we can refute nondeterministically in polynomial time that I is an answer stream of P for D at t. Consequently, problem MC is for LARS programs {a mathematical formula}P− in {a mathematical formula}co-NP. On the other hand, {a mathematical formula}co-NP-hardness is inherited from the {a mathematical formula}co-NP-completeness of answer set checking for (disjunctive) propositional logic programs, cf. [48], which is subsumed by model checking for LARS programs.  □
      </paragraph>
     </section>
     <section label="B.3">
      <section-title>
       Semantic restriction: sparse window functions
      </section-title>
      <paragraph label="Proof of Lemma 1">
       Indeed, by traversing the recursive Definition 12, we can add the edges of {a mathematical formula}WGSB=(N,E) as described, by calculating each {a mathematical formula}wk(Sk−1,t), which takes polynomial time; there are {a mathematical formula}|T⋆| many such calculations to make, and in total thus at most {a mathematical formula}#w(φ)⁎|T⋆| many, where {a mathematical formula}#w(φ) is the total number of window occurrences in φ. In order to find {a mathematical formula}wk(Sk−1,t) in {a mathematical formula}SB, i.e., the stream {a mathematical formula}S′∈SB such that {a mathematical formula}S′=wk(Sk−1,t) one can use hashing or, if the stream is to large, use a trie structure which makes this feasible in {a mathematical formula}O(‖S′‖) time, where {a mathematical formula}‖S′‖ is the size of {a mathematical formula}S′ (which is {a mathematical formula}O(|A|⁎|T|)).Thus in total the time to compute {a mathematical formula}WGSB for {a mathematical formula}(M,S,φ) is{a mathematical formula} where {a mathematical formula}Cw=O(‖S⋆‖k)=O(|T⋆|k⁎|A|k) is a polynomial in {a mathematical formula}‖S⋆‖ that bounds the evaluation time of any window. Indeed, there are at most {a mathematical formula}#w(φ)⁎|SB|⁎|T⋆| many edges to consider, and computing plus matching a window {a mathematical formula}S′ against {a mathematical formula}SB takes {a mathematical formula}O(Cw+‖S⋆‖) time. Overall, this is polynomial in the size of M, {a mathematical formula}SB, and φ.  □
      </paragraph>
      <paragraph label="Proof of Proposition 2">
       The statement is proved by induction on the structure of the formula φ. In the base case, φ is a single atom a, and by construction the windows graph {a mathematical formula}WGSB has no edges. The node {a mathematical formula}(S,t), {a mathematical formula}t∈T⋆ is labeled with a iff {a mathematical formula}a∈υ(t), where {a mathematical formula}S=(T,υ), and thus {a mathematical formula}M,S,t⊩φ iff {a mathematical formula}φ∈LSB(S,t) holds. In the induction step, assume that the statement holds for all subformulas of φ, and consider the different cases of the root connective op of φ. From the induction hypothesis that or each {a mathematical formula}M,S,t and subformula α of φ, the entailment {a mathematical formula}M,S,t⊩α is correctly reflected by {a mathematical formula}α∈LSB(S,t), it is not hard to verify that in each case, φ is added to the label of {a mathematical formula}(S,t) if and only if {a mathematical formula}M,S,t⊩φ holds. Note in this context that for {a mathematical formula}op=⊞w and {a mathematical formula}op=▹, the window graph {a mathematical formula}WGSB for φ contains the one for {a mathematical formula}M,S′,t⊩α respectively {a mathematical formula}M,S,t′⊩α or {a mathematical formula}M,S⋆,t⊩α in the recursive Definition 12 as a subgraph.  □
      </paragraph>
      <paragraph label="Proof of Theorem 10">
       From a window graph {a mathematical formula}WGSB=(N,E) for {a mathematical formula}(M,S,φ), where {a mathematical formula}M=〈S⋆,W,B〉, we can drop each node {a mathematical formula}S′≠S from {a mathematical formula}SB that does not occur in E; the remaining graph {a mathematical formula}WGSB⋆=(N′,E) is the smallest window graph possible, i.e., {a mathematical formula}N′⊆N holds for each window graph {a mathematical formula}WGSB′=(N,E) for {a mathematical formula}(M,S,φ). Notably we can build {a mathematical formula}SB⋆ on the fly by initially setting {a mathematical formula}SB⋆={S} and by then adding any {a mathematical formula}S′=wk(Sk−1,t) along the window path that is not yet member of {a mathematical formula}SB⋆. Following the analysis in Lemma 1, as inserting a stream S into {a mathematical formula}SB is like searching feasible in {a mathematical formula}O(‖S‖) time, building {a mathematical formula}WGSB⋆ take also time bounded by (28), i.e., by {a mathematical formula}O(#w(φ)⁎|SB|⁎|T⋆|⁎(Cw+‖S⋆‖)+|φ|) = {a mathematical formula}O(|φ|⁎|SB|⁎|T⋆|k+1⁎|A|k).The time to construct the bottom labeling is bounded by {a mathematical formula}O(|T⋆|⁎|SB⋆|⁎|φ|): for each subformula {a mathematical formula}φ′ of φ and pair {a mathematical formula}(S′,t′), where {a mathematical formula}S∈SB⋆ and {a mathematical formula}t′∈T⁎ we have to decide whether {a mathematical formula}φ′ is put in {a mathematical formula}LSB(S′,t′). This can be decided by constantly many lookups of already constructed labels for subformulas of {a mathematical formula}φ′; for ◇α, we can use a flag that is set true if {a mathematical formula}(S′,t′) is labeled with α, where {a mathematical formula}t′∈T. For □α, we can proceed similarly.The total runtime of the algorithm is thus bounded by{a mathematical formula} Given that the size of {a mathematical formula}SB is polynomial in the size of M and φ, it follows that the runtime is polynomial in the size of M and φ.  □
      </paragraph>
      <paragraph label="Proof of Theorem 11">
       By Theorem 4, it remains to show {a mathematical formula}PSpace-hardness. For this, we reconsider the reduction from evaluating a QBF {a mathematical formula}Φ=Q1x1Q2x2…Qnxnϕ(x1,x2,…,xn) as in (24) to model checking for a LARS formula (25), and adapt the reduction as follows.For each atom {a mathematical formula}xi, we introduce a fresh atom {a mathematical formula}wi, and we change the content of stream {a mathematical formula}S⋆=([0,1],υ⋆) to {a mathematical formula}υ⋆(0)={x1,…,xn}, {a mathematical formula}υ⋆(1)={w1,x1,…,wn,xn}. Furthermore, we replace the window {a mathematical formula}⊞set:x1 with the partition-based window {a mathematical formula}⊞idx(i),n(i), where {a mathematical formula}idx(i) creates two partitions {a mathematical formula}idx−1(1)={wi,xi} and {a mathematical formula}idx−1(2)=A∖{wi,xi}, with the counts {a mathematical formula}n(i)(1)=(1,2) and {a mathematical formula}n(i)(2)=(∞,∞), where ∞ can be replaced by any number {a mathematical formula}≥2⁎(n−1). For making the selection deterministic, we assume any total order ≤ (e.g., lexicographic order) such that {a mathematical formula}wi≤xi for all {a mathematical formula}i=1,…n.Informally, these changes have the following effects:
       <list>
        evaluated at time point 0, the partition based window function {a mathematical formula}pidx(i),n(i) will for the partition {a mathematical formula}{wi,xi} remove at time0 one atom ({a mathematical formula}ℓ(i)=1); as {a mathematical formula}wi is not in {a mathematical formula}υ⋆(0), it will remove {a mathematical formula}x1; at 1, it will remove two atoms ({a mathematical formula}u(i)=2), and thus both {a mathematical formula}wi and {a mathematical formula}xi.evaluated at time point 1, {a mathematical formula}pidx(i),n(i) will for the partition {a mathematical formula}{wi,xi} remove at time 1 one atom (as {a mathematical formula}ℓ(i)=1), and as {a mathematical formula}wi&lt;xi, it will remove {a mathematical formula}wi; the count {a mathematical formula}u(i)=2 has no effect as 1 is the maximal time point in {a mathematical formula}T⋆=[0,1].Thus, the stream
       </list>
       <paragraph>
        {a mathematical formula}pidx(i),n(i)(S⋆,0) has neither {a mathematical formula}xi nor {a mathematical formula}wi at {a mathematical formula}t=0,1, and {a mathematical formula}pidx(i),n(i)(S⋆,0) has {a mathematical formula}xi at {a mathematical formula}t=0,1 and {a mathematical formula}wi not at {a mathematical formula}t=0,1. Thus, the evaluation of the formula{a mathematical formula} on the modified {a mathematical formula}S⋆ generates at the innermost evaluation level the same streams{a mathematical formula} where {a mathematical formula}t1,…,tn∈{0,1}, as the evaluation of the formula α in (25) on the original {a mathematical formula}S⋆ at the innermost level, which are given by {a mathematical formula}setxn(setxn−1(⋯setx1(S⋆,t1),⋯),tn−1),tn).Consequently, {a mathematical formula}α′ is entailed at an arbitrary {a mathematical formula}t∈{0,1} on the modified {a mathematical formula}S⋆ iff α is entailed at an arbitrary {a mathematical formula}t∈{0,1} on the original {a mathematical formula}S⋆. This proves {a mathematical formula}PSpace-hardness.We note that the reduction proves the result where each partition-based window creates only two (individual) partitions, but all such windows use the same tuple counts {a mathematical formula}n(i)=(1,2). The reduction above can be easily adjusted to partition-based windows that use all the same partitioning but different tuple counts: just let {a mathematical formula}idx(i′)=idx, where {a mathematical formula}idx(j)={wj,xj} and {a mathematical formula}n(i′)(j)=(ℓji,uji), for {a mathematical formula}i,j=1,…,n, such that {a mathematical formula}ℓji=uji=∞ if {a mathematical formula}j≠i, and {a mathematical formula}ℓji=1 and {a mathematical formula}uji=2 if {a mathematical formula}j=i; then each associated partition-based window function {a mathematical formula}pidx(i′),n(i′) clearly coincides with {a mathematical formula}pidx(i),n(i), which implies {a mathematical formula}PSpace-hardness for this setting.  □
       </paragraph>
      </paragraph>
      <paragraph label="Proof of Theorem 12">
       To begin with, each reset operator ▹ that occurs in the formula α returns the stream {a mathematical formula}S⋆, and thus we need to deal with substreams of S and {a mathematical formula}S⋆ in the evaluation of α. It is sufficient to consider just S (and substreams of it), as {a mathematical formula}S=S⋆ is covered and the result then clearly follows.As argued in the discussion, each result of a time-based window function {a mathematical formula}τℓ,u(d)(S,t) can be expressed as the result of a tuple-based window function {a mathematical formula}#ℓ′,u′(S,t′), where the counts {a mathematical formula}ℓ′ and {a mathematical formula}u′ are set such that exactly the atoms in {a mathematical formula}τℓ,u(d)(S,t′) will be selected. Furthermore, each result of a tuple-based window function {a mathematical formula}#ℓ,u(S,t) can be viewed as the result of a dummy partition-based window function {a mathematical formula}pidxA,nA(S,t) where {a mathematical formula}idxA:A→{1} and {a mathematical formula}nA(1)=(ℓ,u), i.e., only one partition exists that contains all tuples; clearly, this trivial partition is always the union {a mathematical formula}B1∪⋯∪Bk of all base groups {a mathematical formula}Bi for meager partitionings. Thus, it is sufficient to consider the latter case.Consider a stream {a mathematical formula}S=(T,υ), {a mathematical formula}T=[tℓ,tu], and some time point {a mathematical formula}t∈T. We can describe with a tuple {a mathematical formula}di=(ℓ1,u1,…,ℓk,uk,t) stream S, where {a mathematical formula}ℓi states how many atoms in S from {a mathematical formula}[tℓ,t] that are in partition {a mathematical formula}Bi should be included, and {a mathematical formula}ui similarly how many atoms in S from {a mathematical formula}[t+1,tu] are in {a mathematical formula}Bi. Now if {a mathematical formula}pidx,n(S,t′) is applied on S, we can single out, for each partition {a mathematical formula}idx−1(j)=⋃{Bi|Bi⊆idx−1(j)}, how many atoms back (respectively forward) from {a mathematical formula}t′ have to be included, depending on {a mathematical formula}n(j)=(ℓjidx,ujidx) and we can break this down to counts {a mathematical formula}ℓi′,ui′ for all base groups {a mathematical formula}Bi, {a mathematical formula}i=1,…,k. Thus we obtain a description {a mathematical formula}di′=(ℓ1′,u1′,…,ℓk′,uk′,t′) that describes {a mathematical formula}pidx,n(S,t′). Overall, there are polynomially many such descriptions in the size of the input.Finally, we extend the description {a mathematical formula}di for a substream with a filter A to {a mathematical formula}sd=(ℓ1,u1,…,ℓk,uk,t,A), where for describing the initial stream S we can use {a mathematical formula}A=A (i.e., no atom is filtered). Clearly, if we apply a meager partition-based window function on S at {a mathematical formula}t′, the description {a mathematical formula}sd′=(ℓ1,u1,…,ℓk,uk,t,A) of S can be adjusted to represent {a mathematical formula}pidx,n(S,t′) by a description {a mathematical formula}sd=(ℓ1′,u1′,…,ℓk′,uk′,t′,A){sup:17}; in case of a filter window application, we can represent {a mathematical formula}fA′(S,t′) by {a mathematical formula}sd′=(ℓ1′,u1′,…,ℓk′,uk′,t′,A∩A′). Consequently, the possible descriptions that result are of the form {a mathematical formula}sd=(ℓ1,u1,…,ℓk,uk,t,A1∩A1∩⋯∩Ai) where {a mathematical formula}⊞A1,⊞A2,…,⊞Ai are the filter windows encountered on some path from the root of the formula tree of φ; overall, the number of paths (and thus such sequences) is bounded by the size of φ. Hence, overall the number of extended descriptions is polynomially bounded in the size of the input.  □
      </paragraph>
     </section>
     <section label="B.4">
      <section-title>
       Non-ground case
      </section-title>
      <paragraph label="Proof of Theorem 13">
       Combined complexity. We first consider the combined complexity.(MC) Under the above assumptions, model checking for a LARS formula {a mathematical formula}α(x) on a structure {a mathematical formula}M=〈S⋆,W,B〉 w.r.t. S and time point t is {a mathematical formula}PSpace-complete; this is because an instance {a mathematical formula}α′ of {a mathematical formula}α(x) where this fails can be guessed and verified in {a mathematical formula}PSpace.Likewise, MC for non-ground LARS programs P is in {a mathematical formula}PSpace; to establish this, the algorithm in the proof of Theorem 6 has to be adapted, in that it is avoided that the reduct {a mathematical formula}PM,t is built explicitly; rather, all ground instances of all rules {a mathematical formula}r∈P are considered one by one to check satisfaction of {a mathematical formula}PM,t, which is feasible in polynomial space.The {a mathematical formula}PSpace hardness for both α and P is inherited from the ground case. We note, however, that already for formulas {a mathematical formula}α(x)=¬(p1(x1)∧⋯∧pk(xk)) i.e., negated conjunctive queries, the problem is co-{a mathematical formula}NP-hard; this follows from the classic result that satisfiability of a conjunctive query is {a mathematical formula}NP-complete [34].Bounded window nesting. For the LARS formulas in the class {a mathematical formula}α−, the problem MC is {a mathematical formula}co-NP-complete: a ground instance {a mathematical formula}α′ of α such that {a mathematical formula}M,S,t⊮α′ can be guessed and verified in polynomial time; the {a mathematical formula}co-NP-hardness is inherited from the {a mathematical formula}NP-completeness of conjunctive query evaluation.Similarly, for LARS programs {a mathematical formula}P− the complexity increases from co-{a mathematical formula}NP in the ground case to co-{a mathematical formula}Σ2p, as the evaluation of LARS formula {a mathematical formula}α− is co-{a mathematical formula}NP-complete: checking (c.1) that {a mathematical formula}M,t⊨PM,t is in co-{a mathematical formula}NP and (c.2) that no {a mathematical formula}I′⊂I for D exists such that {a mathematical formula}M,I′,t⊩PM,t is in co-{a mathematical formula}Σ2p=Π2p: a guess for such an {a mathematical formula}I′, which is of polynomial size, can be verified with an {a mathematical formula}NP oracle in polynomial time. Combining (a)-(c), this leads to membership in co-{a mathematical formula}Σ2p=Π2p. The matching {a mathematical formula}Π2p-hardness is inherited from answer set checking of non-ground Datalog programs, see [47].(SAT) As regards SAT, arbitrary predicate arity causes an exponential size grounding for the valuation υ on T, i.e., for {a mathematical formula}S=(T,υ), as the size of the set {a mathematical formula}A of all atoms becomes exponential. However, once υ is available, we can for a ground formula α decide {a mathematical formula}M,S,t⊩α, where {a mathematical formula}M=〈S⋆,W,B〉, in time exponential in the size of the problem input: modulo window evaluation, the recursive evaluation procedure from Theorem 4 runs in polynomial space (iterations respectively guesses are made over the timeline {a mathematical formula}T⋆); in total, it will encounter at most exponentially many points of substream creation (i.e., window evaluation) in the size of {a mathematical formula}T⋆ and α. Each substream creation is polynomial in the size of S; as the latter is exponential in the size of the problem input, it follows that the total time spent to create substreams will also be exponential in the size of the problem input. Thus, deciding {a mathematical formula}M,S,t⊩α is feasible in time exponential in the size of the problem input; if the size of {a mathematical formula}S⋆ is exponential in the number {a mathematical formula}|P|+|C| of predicates and constants, it is feasible in time polynomial in the size of {a mathematical formula}S⋆. Thus for open LARS formulas α, the complexity of SAT is in {a mathematical formula}NExpTime, while for non-ground LARS programs P, it is in {a mathematical formula}NExpTimeNP: an exponential size guess {a mathematical formula}I=(T,υ) for an answer stream for P of D can be verified with an {a mathematical formula}NP oracle in polynomial time. The matching hardness results follow from results for the complexity of disjunctive Datalog programs [52]: for LARS formulas, {a mathematical formula}NExpTime-hardness is inherited from the {a mathematical formula}NExpTime-completeness of deciding whether a disjunctive Datalog program P has some classical (Herbrand) model, and for LARS programs {a mathematical formula}NExpTimeNP-hardness follows from the {a mathematical formula}NExpTimeNP-completeness of deciding whether a disjunctive Datalog program P has some answer set. Both these results are easy corollaries to the proof of Theorem 8.5 in [52]. As P can be seen as an open LARS formula and no window operators occur in it, the hardness results hold already for {a mathematical formula}α− respectively {a mathematical formula}P−.Data complexity. The data complexity of LARS formulas and LARS programs (i.e., the formula α respectively the program P is fixed and just varying the data stream D and the time point t is varied) coincides with the one of ground LARS formulas {a mathematical formula}α− (respectively programs {a mathematical formula}P−), as shown in Table 1. Indeed, α (respectively P) can be reduced to an equivalent ground formula {a mathematical formula}α′ (respectively ground program {a mathematical formula}P′) by instantiation in polynomial time, as only polynomially many ground instances of α (respectively each rule in P) exist. The matching lower bounds, are obtained from: (a) arbitrary polynomial-time window functions, which implies {a mathematical formula}P-hardness of MC for fixed LARS formulas (b) the data complexity of disjunctive Datalog program; from the proofs in [52], it follows that under data complexity, model checking is co-{a mathematical formula}NP-complete; deciding classical model existence is {a mathematical formula}NP-complete; and deciding answer set existence is {a mathematical formula}Σ2p-complete. This proves the result.  □
      </paragraph>
     </section>
    </section>
    <section label="Appendix C">
     <section-title>
      Relation to other languages and formalisms
     </section-title>
     <section label="C.1">
      <section-title>
       Temporal logic
      </section-title>
      <paragraph label="Proof of Proposition 3">
       The first equivalence is shown by induction on the structure of the formula; the second follows trivially. The base case of an atom is trivial; the other cases follow easily from the induction hypothesis. Indeed, the cases where φ is a Boolean combination are immediate; likewise, for □α and ◇α simple quantifier elimination works, and for {a mathematical formula}@t′α moving to the respective position. For the case of {a mathematical formula}⊞i,jα, the window around t is properly calculated, where {a mathematical formula}T′=[ℓ′,u′] and {a mathematical formula}ℓ′=max⁡(ℓ,t−i) and {a mathematical formula}u′=min⁡(t+j,u); note that {a mathematical formula}t∈T′ holds. Finally, for ▹α, as time-based windows do not remove content, all what needs to be done is to reset the bounds of the interval considered.  □
      </paragraph>
      <paragraph label="Proof of Theorem 14">
       For a formula φ in which each occurrence of □, ◇ and {a mathematical formula}@t′ is windowed (call such φ windowed), by the argument given in the discussion after Theorem 14, if we set {an inline-figure} to the formula (16), then {a mathematical formula}M,S,t′⊩φ iff {an inline-figure} holds.Exploiting this, we can transform a formula {a mathematical formula}φ=@tα, where α is windowed, to{a mathematical formula} that is, move to the initial position 0 of the path and then check that at position t the formula {an inline-figure} holds.For a formula {a mathematical formula}φ=□α, where α is windowed, we can similarly as in (29) write naively{a mathematical formula} this is not an LTL-formula, but again we observe that only finitely many {an inline-figure} will be produced: for some {a mathematical formula}t≥t0 large enough, all formulas {an inline-figure} are identical. Thus we can set{a mathematical formula} For a formula ◇α where α is windowed, the transformation is analogous, viz.{a mathematical formula} This argument can be extended to show by induction on the structure of an arbitrary LARS formula φ that some LTL-formula {an inline-figure} exists such that {a mathematical formula}M,S,t′⊩φ iff {an inline-figure}; where the induction statement includes that some {a mathematical formula}t0≥0 exists such that for all {a mathematical formula}t′≥t0 we have {an inline-figure}. This proves the first (left) equivalence in (i); the second, viz., {an inline-figure} if and only if {an inline-figure}, is obvious.As for (ii), using the formula {a mathematical formula}end(t)=X¬tu∧Xut+1, we can naively transform φ to{a mathematical formula} which is not an LTL-formula. As all {an inline-figure} for {a mathematical formula}t≥t0 are identical, we obtain{a mathematical formula} where {a mathematical formula}end=¬u∧Xu. It then follows that {a mathematical formula}M,S,t⊩φ  iff {an inline-figure}; this proves the result.  □
      </paragraph>
      <paragraph label="Proof of Theorem 15">
       To show that LARS programs can express only regular languages, we first note that any propositional LARS formula φ in which only windows {a mathematical formula}⊞i,j occur is first-order expressible, i.e., that there is a monadic first-order formula {a mathematical formula}Φφ(x) such that for any structure {a mathematical formula}M=〈S,W,∅〉, {a mathematical formula}S=(T,υ) and {a mathematical formula}t∈T, we have {a mathematical formula}M,S,t⊩φ iff {a mathematical formula}S⊨Φ(t); this formula can be built inductively, using variables to access the window range, and by taking the distance of the time point t to the start and end of S, respectively, into account.Furthermore, it is well-known that answer set existence for a logic program P can be expressed by a sentence {a mathematical formula}Ψ(P) in second-order logic, see e.g. [52], [13]. Informally, that sentence says that there exists an interpretation I of the predicates in P such that (i) I is a model of P, and (ii) there is no interpretation {a mathematical formula}I′⊂I such that {a mathematical formula}I′ is a model of {a mathematical formula}PI, where {a mathematical formula}PI is the reduct of P w.r.t. I. Notably, {a mathematical formula}Ψ(P) is modular w.r.t. rules and extensional data, i.e., {a mathematical formula}Ψ(P)=⋃r∈P(Ψ({r})) and for facts D over external predicates not occurring in rule heads of P, {a mathematical formula}Ψ(P∪D) holds iff {a mathematical formula}M(D)⊨Ψ(P), where M is the rendering of D as a FO-structure. Moreover, if all predicates in P have arity at most one, then {a mathematical formula}Ψ(P) amounts to a monadic second-order (MSO) formula. One can easily extend the translation Ψ from ordinary logic programs P to programs where the rule constituents are arbitrary FO-formulas rather than atoms and literals, i.e., with rules of the form{a mathematical formula} where the {a mathematical formula}Φi(xi) are FO-formulas, while preserving the monadic arity bound. It follows that over streams {a mathematical formula}S=(T,υ), {a mathematical formula}T=[0,t], which represent strings {a mathematical formula}υ(0)υ(1)⋯υ(t) over the alphabet {a mathematical formula}Σ=2GE(P), answer stream existence of P for S at t can be expressed in MSO; hence by the Büchi–Elgot–Trakhtenbrot Theorem [28], [27], [55], [100] propositional LARS programs can express only regular languages.Conversely, suppose {a mathematical formula}A=(Σ,Q,δ,qo,F) is a deterministic finite state automaton (FSA),{sup:18} where Σ is the alphabet, Q is the set of states, {a mathematical formula}δ⊆Q×Σ×Q is the (w.l.o.g. total) transition function, {a mathematical formula}q0 is the initial state, and F is the set of final states, that accepts a regular language {a mathematical formula}LA⊆Σ⁎ such that {a mathematical formula}ϵ∉LA. We encode A in a propositional LARS program {a mathematical formula}PA with external atoms {a mathematical formula}GE(P) such that A accepts a string {a mathematical formula}σ0σ1⋯σt from {a mathematical formula}Σ⁎ iff {a mathematical formula}PA has an answer set for {a mathematical formula}M=〈S,W,∅〉 at position t, where {a mathematical formula}S=(T,υ), {a mathematical formula}T=[0,t], and {a mathematical formula}υ(t′)={σt′}, for {a mathematical formula}t′=0,…,t. Furthermore, by design {a mathematical formula}PA has some answer stream for S at t only if S is a valid string encoding (i.e., {a mathematical formula}|υ(t)|=1 for all time points t in S).To this end, we use as intensional atoms the states Q, a further atom p to distinguish, in combination with a window operator, neighbored positions in a string, and an atom s to mark the beginning of the stream. We then set up the following rules for program {a mathematical formula}PA:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} Intuitively, the first rule is a constraint which checks that at each position exactly one letter from {a mathematical formula}G occurs, i.e., that the input stream encodes a word over {a mathematical formula}G. We assign to the first position {a mathematical formula}q0, p, and s by (36). The rule (37) ensures that s can be only at the first position; it is effective if the input string has at least two letters (expressed by {a mathematical formula}@1⊤, i.e., position 1 is within the stream). In that case, s can not be at second position 1 (ensured by the left conjunct), and then it can not be at any other position (right conjunct). The rule (38) propagates in alternation p and ¬p from position 0 through the stream. The rule (39) checks the transitions of the automaton at the non-final positions, where p and ¬p are used to distinguish the current and the predecessor position. Finally, the rules (40) check the transition at the last position of the input: if it does not lead to acceptance, no model (and thus answer stream) is possible.For a non-void S, it can be shown that {a mathematical formula}PA has an answer stream for {a mathematical formula}M=〈I,W,∅〉 for S at t iff S correctly encodes a string {a mathematical formula}σ0σ1⋯σt and A accepts S. While (35) ensures the correct encoding, the capturing of acceptance can be argued as follows. By induction on the formula (36) for the base and (37), (38) for the induction step, we can see that in any model I of P for S at t, s occurs only at position 0 and p only at each even position 0, 2, etc. Furthermore, again by induction using (36) and (39) that up to position {a mathematical formula}t′, {a mathematical formula}0≤t′≤t, we have in I at position {a mathematical formula}t′ the state q in which the automaton A is after reading the prefix {a mathematical formula}σ1σ2…σt′−1, {a mathematical formula}0≤t′≤t of the string encoded by S; notice that supportedness and minimality of answer streams (Theorem 1, Theorem 2) imply that I has at each position {a mathematical formula}t′ a unique state {a mathematical formula}q′. Rule (40) checks then whether reading the last letter {a mathematical formula}σt leads to acceptance.Thus, all regular languages {a mathematical formula}L modulo the empty string ϵ can be expressed; the latter could be easily handled, if the empty steam would be allowed, using the formula {a mathematical formula}□(⊥) to recognize it (for {a mathematical formula}S=(T,υ), we have {a mathematical formula}M,S,0⊩□(⊥) iff {a mathematical formula}T=∅).On the other hand, the above encoding uses the @-operator. With a little more effort and exploiting answer set minimality, we can eliminate its use. Roughly speaking, the idea is to ensure the presence of s at position 0, which then by (37) can not occur elsewhere. We then can use s to recognize the first position, i.e., to emulate {a mathematical formula}@0, and replace (36) with{a mathematical formula} furthermore, we can then replace {a mathematical formula}@1⊤ everywhere by {a mathematical formula}◇¬s and remove {a mathematical formula}@1¬s from (37). Suppose we make these changes and set up the rule{a mathematical formula} Then in combination with the modified rule (37),{a mathematical formula} we obtain that in every model I for S at t, the occurrences of s form an initial segment of the stream. In order to make sure that this initial segment is minimal, i.e., consists only of position 0, we use a new atom {a mathematical formula}s′ and state that {a mathematical formula}s′ must also form an initial segment in every model I, and moreover one that is contained in the segment of s:{a mathematical formula}{a mathematical formula}{a mathematical formula} To ensure the minimality of the segment for s, we add a constraint which excludes that the segment for {a mathematical formula}s′ is a proper subsegment:{a mathematical formula} As {a mathematical formula}s′ occurs only in the rules (44)–(47), minimality and supportedness of answer streams (Theorem 1, Theorem 2) imply that in any answer stream I of the resulting program {a mathematical formula}PA′ for S at t, the atom {a mathematical formula}s′ (and thus also s) must be present at position 0 and only there.Formally, it can be shown that {a mathematical formula}PA′ has an answer stream for {a mathematical formula}S=(T,υ), {a mathematical formula}T=[0,t], at t iff S correctly encodes a string {a mathematical formula}σ0σ1⋯σt from {a mathematical formula}Σ⁎ and A accepts {a mathematical formula}σ0σ1⋯σt. This concludes the proof of the result.  □
      </paragraph>
      <paragraph>
       For an example of a regular language that is not expressible in LTL but definable by some LARS program in {a mathematical formula}PN,N that has only intensional atoms, consider {a mathematical formula}L=a(aa)⁎ over {a mathematical formula}Σ={a}, i.e., strings of a's with odd length. The following program P defines {a mathematical formula}L:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} Informally, for a timeline {a mathematical formula}T=[0,n], {a mathematical formula}n≥0, the string {a mathematical formula}({a})n+1 is an answer stream of P at {a mathematical formula}t=n, if and only if n is even. To see this, clearly the corresponding stream {a mathematical formula}S=(T,{i↦{a}|0≤i≤n}) induces a model {a mathematical formula}M=〈S,W,B〉 of P; the constraint (51) ensures that this M is the only answer stream candidate for this timeline. The reduct {a mathematical formula}PM,t contains all rules of P except (51). By the rule (50), a smaller model {a mathematical formula}M′ of {a mathematical formula}PM,t, requires {a mathematical formula}n&gt;0, and by the rule (49) starting from position {a mathematical formula}i=n, {a mathematical formula}n−1 down to 0 we must have at position i in alternation a, ¬a, a etc. and ¬a at position 0 (which means {a mathematical formula}|T| is even, i.e., n is odd); the rule (48) provides the necessary support for the alternating presence of a.
      </paragraph>
      <paragraph>
       Note that the program P fits both alphabet settings (a) {a mathematical formula}Σ=2A and (b) {a mathematical formula}Σ={{σ}|σ∈A}. To establish that in the setting (b), {a mathematical formula}PN,N is strictly more expressive than the class of LARS {a mathematical formula}⊞i,j formulas, it is then sufficient to observe that any language {a mathematical formula}L over Σ defined by a LARS {a mathematical formula}⊞i,j formula φ is also defined by the LARS program {a mathematical formula}Pφ={⋁{σ}∈Σσ←;⊥←¬φ}. To establish that in setting (a), {a mathematical formula}PN,N and the class of LARS {a mathematical formula}⊞i,j formulas are incomparable, just consider the language {a mathematical formula}L={{a},{}}: by the minimality condition, not both {a mathematical formula}S=([0,0],{0↦{}}) and {a mathematical formula}S=([0,0],{0↦{a}}) can be answer streams of a LARS program defining {a mathematical formula}L, but {a mathematical formula}L is definable by the LARS formula {a mathematical formula}¬@1(a∨¬a).
      </paragraph>
     </section>
     <section label="C.2">
      <section-title>
       Continuous Query Language (CQL)
      </section-title>
      <paragraph>
       In this section, we give additional details on the translation from CQL to Datalog, respectively LARS, and the presented CQL query q of Example 29. First, applying rel on q gives us the following SQL query:
      </paragraph>
      <paragraph>
       {a mathematical formula}
      </paragraph>
      <paragraph>
       Translating this CQL query to relational algebra according to [35], we get the following relational algebra expression {a mathematical formula}RelAlg(rel(q)), where tram and jam abbreviate relation names {a mathematical formula}tram_part_ID_rows_1 and {a mathematical formula}jam_range_20, respectively.{a mathematical formula} where{a mathematical formula}Fig. 15 shows the syntactic expression tree. Note that different such translations might be considered, e.g., by considering other orders in cross products, or joining earlier, etc. However, no semantic differences arise from such optimizations and thus no further discussion is needed for our purposes.
      </paragraph>
      <paragraph>
       The translated Datalog program {a mathematical formula}ΔD(q)=Dat(RelAlg(rel(q))), using the translation in [61], is the one in Example 30.
      </paragraph>
      <paragraph>
       Without loss of generality, i.e., due to possible renamings, we assume in the sequel that relation names {a mathematical formula}Bi and stream names {a mathematical formula}Si are pairwise distinct.
      </paragraph>
      <paragraph label="Proof of Theorem 16">
       Before going into the details, let us note that the relational algebra expression is tree-shaped and thus {a mathematical formula}ΔD(Q) is an acyclic program (i.e., there is not cyclic recursion through rules). Furthermore, Dat only creates atomic rule heads; therefore {a mathematical formula}ΔD(Q) is also definite (i.e., each rule head consists of an atom). The translation {a mathematical formula}ΔL(Q) only adds a stratified layer to {a mathematical formula}ΔD(Q), i.e., the snapshot rules. Thus, both translations {a mathematical formula}ΔD(Q) and {a mathematical formula}ΔL(Q) amount to stratified theories and have a unique answer set respectively answer stream relative to given input data.A correspondence between the CQL results {a mathematical formula}cqlRes(Q,t) and the answer set of {a mathematical formula}ΔL(Q) at time t obtained by the following steps.
      </paragraph>
      <list>
       <list-item label="(1)">
        First, we construct the input for the translated Datalog program, i.e., the atoms reflecting the static relations and those obtained from snapshots. Correctness and completeness of the (compound) translation – from SQL to Relational Algebra and from the latter to Datalog – establishes a correspondence between the unique answer set of the Datalog program and the results of the CQL queries (Lemma 2).
       </list-item>
       <list-item label="(2)">
        Lemma 3 shows that these atoms need not be provided as such, but can be derived by snapshot rules in LARS itself.
       </list-item>
       <list-item label="(3)">
        Lemma 4 guarantees that the unique answer set of the Datalog encoding {a mathematical formula}ΔD(Q), given snapshot relations as input, corresponds with the unique answer stream of the LARS encoding {a mathematical formula}ΔL(Q), given the stream as input.
       </list-item>
       <list-item label="(4)">
        By combining these lemmas, we obtain the desired correspondence between the results of CQL queries and the answer stream of respective LARS programs.
       </list-item>
      </list>
     </section>
    </section>
   </appendices>
  </root>
 </body>
</html>