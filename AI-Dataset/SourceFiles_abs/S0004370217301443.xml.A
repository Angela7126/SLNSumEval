<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Reactive multi-context systems: Heterogeneous reasoning in dynamic environments.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Fueled by initiatives such as the Semantic Web, Linked Open Data, and the Internet of Things, among others, the wide and increasing availability of machine-processable data and knowledge has prepared the ground and called for a new class of dynamic, rich, knowledge-intensive applications. Such new applications require automated reasoning based on the integration of several heterogeneous knowledge bases – possibly overlapping, independently developed, and written in distinct languages with different semantic assumptions – together with data/event streams produced by sensors and detectors, to be able to support automation and problem-solving, to enforce traceable and correct decisions, and to facilitate the internalization of relevant dynamic data and knowledge into such heterogeneous knowledge bases.
     </paragraph>
     <paragraph>
      Consider a scenario where Dave, an elderly person suffering from dementia, lives alone in an apartment equipped with various sensors, e.g., smoke detectors, cameras, and body sensors measuring relevant body functions (e.g., pulse, blood pressure, etc.). An assisted living application in such a scenario could leverage the information continuously received from the sensors, together with Dave 's medical records stored in a relational database, a biomedical health ontology with information about diseases, their symptoms and treatments, represented in some description logic, some action policy rules represented as a non-monotonic logic program, to name only a few, and use it to detect relevant events, suggest appropriate action, and even raise alarms, while keeping a history of relevant events and Dave 's medical records up to date, thus allowing him to live on his own despite his condition. After detecting that Dave left the room while preparing a meal, the system could alert him in case he does not return soon, or even turn the stove off in case it detects that Dave fell asleep, not wanting to wake him up because his current treatment/health status values rest over immediate nutrition. Naturally, if Dave is not gone long enough, and no sensor shows any potential problems (smoke, gas, fire, etc.), then the system should seamlessly take no action.
     </paragraph>
     <paragraph>
      Given the requirements posed by novel applications such as the one just described, the availability of a vast number of knowledge bases – written using many different formalisms – and the relevance of streams of data/events produced by sensors/detectors, modern research in knowledge representation and reasoning faces two fundamental problems: dealing with the integration of heterogeneous data and knowledge, and dealing with the dynamics of such novel knowledge-based systems.
     </paragraph>
     <paragraph label="Integration">
      Bridge rules are similar to logic programming rules (including default negation), with an important difference: they provide means to access other contexts in their bodies. Bridge rules not only allow for a fully declarative specification of the information flow, but they also allow information to be modified instead of being just passed along as is. Using bridge rules we may translate a piece of information into the language/format of another context, pass on an abstraction of the original information, leaving out unnecessary details, select or hide information, add conclusions to a context based on the absence of information in another one, and even use simple encodings of preferences among parent contexts.MCSs went through several development steps until they reached their present form. Advancing work in [26], [34] aiming to integrate different inference systems, monotonic heterogeneous multi-context systems were defined in [27], with reasoning within as well as across monotonic contexts. The first, still limited attempts to include non-monotonic reasoning were done in [39], [12], where default negation in the rules is used to allow for reasoning based on the absence of information from a context.The non-monotonic MCSs of [9] substantially generalize previous approaches, by accommodating heterogeneous and both monotonic and non-monotonic contexts. Hence, they are capable of integrating, among many others, “typical” monotonic logics like description logics or temporal logics, and non-monotonic formalisms like Reiter's default logic, logic programs under answer set semantics, circumscription, defeasible logic, or theories in autoepistemic logic. The semantics of nonmonotonic MCSs is defined in terms of equilibria: a belief set for each context that is acceptable for its knowledge base augmented by the heads of its applicable bridge rules.More recently, the so-called managed MCSs (mMCSs) [10] addressed a limitation of MCSs in the way they integrate knowledge between contexts. Instead of simply adding the head of an applicable bridge rule to the context's knowledge base, which could cause some inconsistency, mMCSs allow for operations other than addition, such as, for instance, revision and deletion, hence dealing with the problem of consistency management within contexts.
     </paragraph>
     <paragraph label="Our approach">
      In this paper, we aim to address both challenges in a single, uniform approach. We develop a system that allows us to integrate heterogeneous knowledge bases with streams of incoming information and to use them for continuous online reasoning, reacting, and evolving the knowledge bases by internalizing relevant knowledge. In a nutshell, our work follows the multi-context systems tradition, but adds what is needed to also deal with dynamics.To this end, we introduce reactive Multi-Context Systems (rMCSs). These systems build upon mMCSs and thus provide their functionality for integrating heterogeneous knowledge sources, admitting also operations for manipulating their knowledge bases. In addition, rMCSs can handle continuous streams of input data. Equilibria remain the fundamental underlying semantic notion, but the focus now lies on the dynamic evolution of the systems. Given an initial configuration of knowledge bases, that is, an initial knowledge base for each context, a specific input stream will lead to a corresponding stream of equilibria, generated by respective updates of the knowledge bases.Contrary to existing MCSs which possess only one type of bridge rules modeling the information flow to be taken into account when computing equilibria (or the operations that need to be applied in case of mMCSs), rMCSs have an additional, different type of bridge rules, distinguished by the occurrence of the operator next in the head. Whereas the head of a managing bridge rule in mMCS specifies how a specific knowledge base should temporarily be changed for the purpose of determining the current equilibrium, the head of a new kind of bridge rule in rMCS with the operator next in the head specifies how the knowledge base should permanently be changed as the system moves to the next state. These new bridge rules allow us to decouple the computation of equilibria from specifying the evolution of knowledge base configurations.It is often the case that the information currently available from some stream needs to be taken into account by some context when computing the semantics at that point. The way such information is taken into account is specified by a bridge rule with a management operation in its head, just as in mMCSs. For example, we may have some default value for some variable stored in a context, but, under some conditions (cond1), prefer to use the value that is read from some sensor (observed in some stream) whenever one is available. This could be specified by the bridge rule (where {a mathematical formula}set is a management operation with the obvious meaning):{a mathematical formula} Whenever {a mathematical formula}meter(X) is observed in the stream, and cond1 holds, the {a mathematical formula}value(X) would be matched, but only while {a mathematical formula}meter(X) is observed and cond1 holds, i.e., the management operation's effects are not permanent. In subsequent states, if there was no observation for {a mathematical formula}meter(X), or cond1 no longer holds, then {a mathematical formula}value(X) would return to its original value. However, sometimes we may wish to specify some permanent change to the knowledge base of some context that persists beyond the state at which the pre-conditions were true, which is why a new form of bridge rule is needed. In the previous example, if under certain conditions (cond2) we want to internalize the current observation in a permanent way, i.e., permanently update the default value, then the following new kind of bridge rule would be specified:{a mathematical formula} The intuitive reading of this bridge rule is that whenever at some state both {a mathematical formula}meter(X) is true in the stream st and condition cond2 holds, then the bridge rule's context should be changed according to the operation {a mathematical formula}set(value(X)) when moving to the next state. These two different behaviors could not be achieved with a single kind of bridge rule since one of them aims at temporarily affecting the system at current state while the other one aims at permanently affecting the system from the subsequent state. Interestingly, the two kinds could be combined to specify that some current effect should be made permanent.This new kind of bridge rule further allows the specification of the evolution of some context based on current conditions, which was not possible in mMCS. Suppose, for example, a single context that maintains a counter {a mathematical formula}ctr(.) keeping track of how often the context was updated. With the new kind of bridge rule, we could simply write:{a mathematical formula} Assuming that the management operation {a mathematical formula}set has the intuitively expected meaning, using the bridge rule{a mathematical formula} would not work, as it would lead to the non-existence of equilibria. In mMCSs, one might think of a workaround that would overload the management function, but that would also require that the language of the context be extended, which might not be possible and is clearly at odds with the very idea of declarative knowledge representation. Additional examples showing the benefits of the next operator will be discussed in Sect. 3.2.The main contributions of this paper can be summarized as follows:
      <list>
       We extend multi-context systems with the concepts relevant to deal with dynamics, ultimately leading to the notion of equilibria streams.We introduce a new, second type of bridge rules using the operator next. This allows us to separate the computation of equilibria from the specification of the context evolution which provides a lot more modeling flexibility and leads to much more natural problem representations.We study various forms of inconsistency, generalize existing inconsistency handling techniques to rMCSs and introduce several new ones.For a subclass of rMCSs we define well-founded semantics as a skeptical, deterministic alternative to the equilibria-based semantics. The new semantics gives rise to so-called grounded equilibria streams.We investigate the complexity of various problems related to rMCSs and provide a number of complexity results.The paper is organized as follows. In Section
      </list>
      <paragraph>
       2, we introduce reactive MCSs, our framework for reactive reasoning in the presence of heterogeneous knowledge sources. In particular, we show how to integrate data streams into mMCSs and how to model the dynamics of our systems, based on two types of bridge rules. Section 3 illustrates how several typical problems arising in the context of stream reasoning can be handled using our framework. Reasoning based on multiple knowledge sources that need to be integrated faces the problem of potential inconsistencies. Section 4 discusses various methods for handling inconsistencies, with a special focus on non-existence of equilibria. In particular, we show how methods developed for mMCSs can be generalized to rMCSs. Nondeterminism in rMCSs is discussed in Section 5. One way of avoiding nondeterminism is by applying an alternative, skeptical semantics. We show how such a semantics, called well-founded semantics, can be defined for rMCSs, and what the effect of using this semantics instead of the original one is. The complexity of various problems related to rMCSs is investigated in Section 6. Section 7 discusses related work, with a special focus on two of the most relevant approaches w.r.t. stream reasoning, namely LARS (Logic-based framework for Analyzing Reasoning over Streams) [7] and STARQL [37]. Section 8 concludes and points out directions for future work.This paper combines and unifies the results of [11] and [29], two papers by different subsets of the authors describing independent adaptations of multi-context systems for dynamic environments. The approach developed here generalizes these earlier approaches and substantially improves on the presentation of the underlying concepts.
      </paragraph>
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Reactive multi-context systems
     </section-title>
     <paragraph>
      Reactive multi-context systems (rMCSs) make use of basic ideas from managed multi-context systems (mMCSs) [10] which extend multi-context systems (MCSs) as defined by Brewka and Eiter [9] by management capabilities. In particular, similar to mMCSs, we will make use of a management function and bridge rules that allow for conflict resolution between contexts as well as a fine-grained declarative specification of the information flow between contexts. To not unnecessarily burden the reader with repetitive material on these common components, we abstain from recalling the details of mMCSs first. It will be clear from the presentation when new concepts/ideas specific to rMCSs will be presented.
     </paragraph>
     <section label="2.1">
      <section-title>
       Specifying the components of an rMCS
      </section-title>
      <paragraph>
       Similar as for previous notions of MCSs, we build on an abstract notion of a logic, which is a triple {a mathematical formula}L=〈KB,BS,acc〉, where KB is the set of admissible knowledge bases of L, BS is the set of possible belief sets, whose elements are called beliefs; and {a mathematical formula}acc:KB→2BS is a function describing the semantics of L by assigning to each knowledge base a set of acceptable belief sets.{sup:1}
      </paragraph>
      <paragraph label="Example 1">
       We illustrate how different formalisms we use in examples throughout the paper can be represented by the notion of a logic.First, consider the case of description logics (DLs) as (commonly decidable) fragments of first-order logic [5]. Given a DL language {a mathematical formula}L, we consider the logic {a mathematical formula}Ld=〈KBd,BSd,accd〉 where {a mathematical formula}KBd is the set of all well-formed DL knowledge bases over {a mathematical formula}L, also called ontologies, {a mathematical formula}BSd is the set of deductively closed subsets of {a mathematical formula}L, and {a mathematical formula}accd maps every {a mathematical formula}kb∈KBd to {a mathematical formula}{E}, where E is the set of formulas in {a mathematical formula}L entailed by kb.As an example for a non-deterministic formalism, consider logic programs under the answer set semantics [25]. Given a set of ground, i.e., variable-free, atoms A, we use the logic {a mathematical formula}La=〈KBa,BSa,acca〉 such that {a mathematical formula}KBa is the set of all logic programs over A. The set of possible belief sets is given by the set {a mathematical formula}BSa=2A of possible answer sets and the function {a mathematical formula}acca maps every logic program to the set of its answer sets.Given a set E of entries, a simple logic for storing elements from E can be realized by the logic {a mathematical formula}Ls=〈KBs,BSs,accs〉, such that {a mathematical formula}KBs=BSs=2E, and {a mathematical formula}accs maps every set {a mathematical formula}E′⊆E to {a mathematical formula}{E′}. Such {a mathematical formula}Ls can, e.g., be used to represent a simple database logic. We will call a logic of this type a storage logic.
      </paragraph>
      <paragraph>
       In addition to a logic that captures language and semantics of a formalism to be integrated in an rMCS, a context also describes how a knowledge base belonging to the logic can be manipulated.
      </paragraph>
      <paragraph label="Definition 1">
       ContextA context is a triple {a mathematical formula}C=〈L,OP,mng〉 where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}L=〈KB,BS,acc〉 is a logic,
       </list-item>
       <list-item label="•">
        OP is a set of operations,
       </list-item>
       <list-item label="•">
        {a mathematical formula}mng:2OP×KB→KB is a management function.
       </list-item>
      </list>
      <paragraph>
       For an indexed context {a mathematical formula}Ci we will write {a mathematical formula}Li=〈KBi,BSi,acci〉, {a mathematical formula}OPi, and {a mathematical formula}mngi to denote its components. Note that we leave the exact nature of the operations in OP unspecified – they can be seen as mere labels whose semantics is determined by the management function – and that we use a deterministic management function instead of a non-deterministic one, unlike mMCS [10].{sup:2}
      </paragraph>
      <paragraph label="Example 2">
       Consider the assisted living scenario from the Introduction in which we want to recognize potential threats caused, e.g., by overheating of the stove. We use the context {a mathematical formula}Cst to monitor the stove. Its logic {a mathematical formula}Lst is a storage logic taking {a mathematical formula}E={pw,tm(cold),tm(hot)} as the set of entries, representing the stove's power status (on if pw is present, and off otherwise) and a qualitative value for its temperature (cold/hot). The current temperature and power state of the stove should be kept up to date in a knowledge base over {a mathematical formula}Lst using the following operations:{a mathematical formula} The semantics of the operations is given, for {a mathematical formula}OP′⊆OPst, by {a mathematical formula}mngst(OP′,kb)={a mathematical formula} We assume a single constantly operating temperature sensor which triggers exactly one of the {a mathematical formula}setTemp operations. Thus, the current value is simply inserted and we do not need to care about persistence of the temperature value or conflicting information. The power information, on the other hand, is based on someone toggling a switch, which requires persistence of the fluent pw. Note that {a mathematical formula}mngst ensures that the stove is considered on whenever it is switched on, and also when it is not being switched off and already considered on in the given knowledge base kb. The second alternative implements persistence. Also note that whenever both conflicting {a mathematical formula}setPower operations are in {a mathematical formula}OP′, {a mathematical formula}setPower(on) “wins”, that is, pw will be in the knowledge base. This is justified by the application: a potential overheating of the stove is considerably more harmful than unnecessarily turning off the electricity.Assume we have a knowledge base {a mathematical formula}kb={tm(cold)}. Then, an update with the set {a mathematical formula}OP={setPower(on),setTemp(hot)} of operations would result in the knowledge base {a mathematical formula}mngst(OP,kb)={pw,tm(hot)}.
      </paragraph>
      <paragraph label="Definition 2">
       Contexts exchange information using bridge rules that are rules similar in spirit to those in logic programming and that determine which operations from {a mathematical formula}OPi to apply to {a mathematical formula}kbi in a context {a mathematical formula}Ci depending on beliefs held in other contexts, and, in our approach also on input from the outside. To keep the approach as abstract as possible, we only require that inputs be elements of some formal input language IL. Moreover, we allow for situations where input comes from different sources with potentially different input languages and thus consider tuples {a mathematical formula}〈IL1,…,ILk〉 of input languages. Bridge ruleLet {a mathematical formula}C=〈C1,…,Cn〉 be a tuple of contexts and {a mathematical formula}IL=〈IL1,…,ILk〉 a tuple of input languages. A bridge rule for{a mathematical formula}Ciover{a mathematical formula}Cand{a mathematical formula}IL , {a mathematical formula}i∈{1,…,n}, is of the form{a mathematical formula} such that {a mathematical formula}op=op or {a mathematical formula}op=next(op) for {a mathematical formula}op∈OPi, {a mathematical formula}j∈{0,…,m}, and every atom{a mathematical formula}aℓ, {a mathematical formula}ℓ∈{1,…,m}, is one of the following:
      </paragraph>
      <list>
       <list-item label="•">
        a context atom{a mathematical formula}c:b with {a mathematical formula}c∈{1,…,n} and {a mathematical formula}b∈B for some {a mathematical formula}B∈BSc, or
       </list-item>
       <list-item label="•">
        an input atom{a mathematical formula}s::b with {a mathematical formula}s∈{1,…,k} and {a mathematical formula}b∈ILs.
       </list-item>
      </list>
      <paragraph>
       Roughly, a set of bridge rules for {a mathematical formula}Ci describes which operations to apply to its knowledge base {a mathematical formula}kbi, depending on whether currently available beliefs and external inputs match the literals in the body. Intuitively, rules with head op affect the computation of the semantics at the current time instant, while rules with head {a mathematical formula}next(op) affect the computation of the knowledge base(s) at the next time instant. We define their precise semantics later in Section 2.2 and proceed by defining reactive multi-context systems.
      </paragraph>
      <paragraph label="Definition 3">
       Reactive multi-context systemA reactive Multi-Context System (rMCS ) is a tuple {a mathematical formula}M=〈C,IL,BR〉, where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}C=〈C1,…,Cn〉 is a tuple of contexts;
       </list-item>
       <list-item label="•">
        {a mathematical formula}IL=〈IL1,…,ILk〉 is a tuple of input languages;
       </list-item>
       <list-item label="•">
        {a mathematical formula}BR=〈BR1,…,BRn〉 is a tuple such that each {a mathematical formula}BRi, {a mathematical formula}i∈{1,…,n}, is a set of bridge rules for {a mathematical formula}Ci over {a mathematical formula}C and {a mathematical formula}IL.
       </list-item>
      </list>
      <paragraph label="Example 3">
       Consider rMCS {a mathematical formula}Mex3=〈〈Cst〉,〈ILex3〉,〈BRex3〉〉 with {a mathematical formula}Cst as in Example 2.{sup:3} The input language {a mathematical formula}ILex3={switch} is used to report whether the power switch of the stove has been turned. The bridge rules in {a mathematical formula}BRex3 are given by{a mathematical formula} and react to switching the stove on or off: depending on the current power state of the stove that is stored in the knowledge base of {a mathematical formula}Cst, whenever the switch is activated, the bridge rules derive an update of the knowledge base where the power state is reversed.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Reacting to external inputs – semantics of rMCSs
      </section-title>
      <paragraph>
       To define the semantics of rMCSs, we first focus on the static case of a single time instant, and only subsequently introduce the corresponding dynamic notions for reacting to inputs changing over time.
      </paragraph>
      <paragraph label="Definition 5">
       We start with the evaluation of bridge rules, for which we need to know current beliefs and current external information. The former is captured by the notion of a belief state denoted by a tuple of belief sets – one for each context – similar as in previous work on multi-context systems. Belief stateLet {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉 be an rMCS. Then, a belief state for M is a tuple {a mathematical formula}B=〈B1,…,Bn〉 such that {a mathematical formula}Bi∈BSi, for each {a mathematical formula}i∈{1,…,n}. We use {a mathematical formula}BelM to denote the set of all belief states for M. To also capture the current external information, we introduce the notion of an input. InputLet {a mathematical formula}M=〈C,〈IL1,…,ILk〉,BR〉 be an rMCS. Then an input for M is a tuple {a mathematical formula}I=〈I1,…,Ik〉 such that {a mathematical formula}Ii⊆ILi, {a mathematical formula}i∈{1,…,k}. The set of all inputs for M is denoted by {a mathematical formula}InpM.
      </paragraph>
      <paragraph label="Definition 6">
       We are now ready to define when literals (in bridge rule bodies) are satisfied. Satisfaction of literalsLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS such that {a mathematical formula}C=〈C1,…,Cn〉 and {a mathematical formula}IL=〈IL1,…,ILk〉. Given an input {a mathematical formula}I=〈I1,…,Ik〉 for M and a belief state {a mathematical formula}B=〈B1,…,Bn〉 for M, we define the satisfaction of literals as:
       <list>
        {a mathematical formula}〈I,B〉⊨aℓ if {a mathematical formula}aℓ is of the form {a mathematical formula}c:b and {a mathematical formula}b∈Bc;{a mathematical formula}〈I,B〉⊨aℓ if {a mathematical formula}aℓ is of the form {a mathematical formula}s::b and {a mathematical formula}b∈Is;{a mathematical formula}〈I,B〉⊨notaℓ if {a mathematical formula}〈I,B〉⊭aℓ.Let
       </list>
       <paragraph>
        r be a bridge rule for {a mathematical formula}Ci over {a mathematical formula}C and {a mathematical formula}IL. Then
       </paragraph>
       <list>
        <list-item label="•">
         {a mathematical formula}〈I,B〉⊨bd(r) if {a mathematical formula}〈I,B〉⊨l for every {a mathematical formula}l∈bd(r).
        </list-item>
       </list>
       <paragraph label="Definition 7">
        If {a mathematical formula}〈I,B〉⊨bd(r), we say that r is applicable under{a mathematical formula}Iand{a mathematical formula}B. The operations encoded in the heads of applicable bridge rules in an rMCS determine which knowledge base updates should take place. We collect them in two disjoint sets. Applicable bridge rulesLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS such that {a mathematical formula}C=〈C1,…,Cn〉 and {a mathematical formula}BR=〈BR1,…,BRn〉. Given an input {a mathematical formula}I for M and a belief state {a mathematical formula}B for M, we define, for each {a mathematical formula}i∈{1,…,n}, the sets
       </paragraph>
       <list>
        <list-item label="•">
         {a mathematical formula}appinow(I,B)={hd(r)|r∈BRi,〈I,B〉⊨bd(r),hd(r)∈OPi};
        </list-item>
        <list-item label="•">
         {a mathematical formula}appinext(I,B)={op|r∈BRi,〈I,B〉⊨bd(r),hd(r)=next(op)}.
        </list-item>
       </list>
       <paragraph label="Definition 8">
        Intuitively, the operations in {a mathematical formula}appinow(I,B) are used for non-persistent updates of the knowledge base that influence the semantics of an rMCS for a single point in time. The operations in {a mathematical formula}appinext(I,B) on the other hand are used for changing knowledge bases over time. They are not used for computing the current semantics but are applied in the next point in time depending on the current semantics. This continuous change of knowledge bases over time is the reason why, unlike in previous work on MCSs, we do not consider knowledge bases as part of the contexts to which they are associated but store them in a separate configuration structure defined next. Configuration of knowledge basesLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS such that {a mathematical formula}C=〈C1,…,Cn〉. A configuration of knowledge bases for M is a tuple {a mathematical formula}KB=〈kb1,…,kbn〉 such that {a mathematical formula}kbi∈KBi, for each {a mathematical formula}i∈{1,…,n}. We use {a mathematical formula}ConM to denote the set of all configurations of knowledge bases for M.
       </paragraph>
      </paragraph>
      <paragraph>
       The semantics of an rMCS for a single time instant is given by its equilibria.
      </paragraph>
      <paragraph label="Definition 9">
       EquilibriumLet {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉 be an rMCS, {a mathematical formula}KB=〈kb1,…,kbn〉 a configuration of knowledge bases for M, and {a mathematical formula}I an input for M. Then, a belief state {a mathematical formula}B=〈B1,…,Bn〉 for M is an equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I if, for each {a mathematical formula}i∈{1,…,n}, we have that{a mathematical formula}
      </paragraph>
      <paragraph label="Example 4">
       Consider rMCS {a mathematical formula}Mex3 from Example 3 with the configuration of knowledge bases for {a mathematical formula}Mex3, {a mathematical formula}KB=〈kbst〉=〈∅〉, representing that the stove is turned off, input {a mathematical formula}I=〈{switch}〉 for {a mathematical formula}Mex3 and the belief state {a mathematical formula}B=〈∅〉 for {a mathematical formula}Mex3. As both bridge rules in {a mathematical formula}BRex3 use the next operator, we have {a mathematical formula}appstnow(I,B)=∅ and consequently, following the definition of {a mathematical formula}mngst in Example 2, {a mathematical formula}kbst remains unchanged, i.e., {a mathematical formula}mngst(appstnow(I,B),kbst)=kbst. Thus, {a mathematical formula}accst(mngst(appstnow(I,B),kbst))={∅}. Thus, {a mathematical formula}B is an equilibrium of {a mathematical formula}Mex3 given {a mathematical formula}KB and {a mathematical formula}I.
      </paragraph>
      <paragraph>
       Based on an equilibrium at the current time instant, we can compute an updated configuration of knowledge bases using the update function as introduced next.
      </paragraph>
      <paragraph label="Definition 10">
       Update functionLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS such that {a mathematical formula}C=〈C1,…,Cn〉, {a mathematical formula}KB=〈kb1,…,kbn〉 a configuration of knowledge bases for M, {a mathematical formula}I an input for M, and {a mathematical formula}B a belief state for M. Then, the update function for M is defined as {a mathematical formula}updM(KB,I,B)=〈kb1′,…,kbn′〉, such that, for each {a mathematical formula}i∈{1…,n}, {a mathematical formula}kbi′=mngi(appinext(I,B),kbi).
      </paragraph>
      <paragraph>
       We can finally show how an rMCS behaves in the presence of external information that changes over time. For this purpose, we assume that an rMCS receives data in a stream of inputs, i.e., an input for each time instant, and we represent individual time instants by natural numbers. These can be interpreted as logical time instants that do not necessarily represent specific physical time points, nor do we require that every pair of consecutive natural numbers represents equidistant physical time spans.
      </paragraph>
      <paragraph label="Definition 11">
       Input streamLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS such that {a mathematical formula}IL=〈IL1,…,ILk〉. An input stream for M (until τ) is a function {a mathematical formula}I:[1..τ]→InpM where {a mathematical formula}τ∈N∪{∞}. We will omit the term “until τ” whenever the limit of the stream is irrelevant. Clearly, an input stream for M until τ also fully determines an input stream for M until {a mathematical formula}τ′ for every {a mathematical formula}1≤τ′&lt;τ. For any input stream {a mathematical formula}I and {a mathematical formula}t∈[1..τ], we will use {a mathematical formula}It to denote {a mathematical formula}I(t), i.e., the input {a mathematical formula}〈I1,…,Ik〉 for M at time t. We also term stream the restriction of an input stream {a mathematical formula}I to a single input language {a mathematical formula}ILi, i.e., a function {a mathematical formula}Ii:[1..τ]→2ILi that is fully determined by {a mathematical formula}I.
      </paragraph>
      <paragraph>
       Note that {a mathematical formula}It encapsulates (input) data for every input language of M. Hence, we assume that, at every time instant, we receive input from every external source of the rMCS. This synchronicity is required since the evaluation of a bridge rule may depend on the availability of information from multiple streams. One possibility for modeling external sources that do not continuously provide information is setting {a mathematical formula}Ist to the empty set for representing a lack of input from the source with language {a mathematical formula}ILs at time t.
      </paragraph>
      <paragraph label="Definition 12">
       The semantics of an rMCS over time is given by its equilibria streams for a given initial configuration of knowledge bases and an input stream for the system. Equilibria streamLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS, {a mathematical formula}KB a configuration of knowledge bases for M, and {a mathematical formula}I an input stream for M until τ where {a mathematical formula}τ∈N∪{∞}. Then, an equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}I is a function {a mathematical formula}B:[1..τ]→BelM such that
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}Bt is an equilibrium of M given {a mathematical formula}KBt and {a mathematical formula}It, where {a mathematical formula}KBt is inductively defined as
       </list-item>
      </list>
      <paragraph>
       Note that the limit τ of an equilibria stream is aligned with that of the given input stream. Following the definition, it is easy to see that if we have an equilibria stream {a mathematical formula}B of M given {a mathematical formula}KB and {a mathematical formula}I, then the substream of {a mathematical formula}B of size {a mathematical formula}τ′, with {a mathematical formula}τ′≤τ, is an equilibria stream of M given {a mathematical formula}KB and {a mathematical formula}I′, where {a mathematical formula}I′ is the substream of {a mathematical formula}I of size {a mathematical formula}τ′. This implies that, conversely, each extension of the input stream can only lead to equilibria streams that extend those obtained given the original input stream.
      </paragraph>
      <paragraph label="Example 5">
       Recall {a mathematical formula}Mex3, {a mathematical formula}KB, and {a mathematical formula}B from Example 4, as well as an input stream {a mathematical formula}I until 3 with {a mathematical formula}I1=〈{switch}〉, {a mathematical formula}I2=〈∅〉, and {a mathematical formula}I3=〈{switch}〉. There is an equilibria stream {a mathematical formula}B of {a mathematical formula}Mex3 given {a mathematical formula}KB and {a mathematical formula}I. Note that the input {a mathematical formula}I1 coincides with input {a mathematical formula}I from Example 4. As {a mathematical formula}B is the only equilibrium of {a mathematical formula}Mex3 given {a mathematical formula}KB and {a mathematical formula}I, we have that {a mathematical formula}B1=B.As we have {a mathematical formula}appstnext(I,B)={setPower(on)}, the update function provides the following configuration of knowledge bases for time instant 2 (with {a mathematical formula}KB1=KB):{a mathematical formula} Thus, switching the power state at time 1 leads to an updated knowledge base indicating that the stove is on at time 2. The table in Fig. 1 summarizes the equilibria stream and the configurations stream given {a mathematical formula}KB and {a mathematical formula}I.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Rule schemata
      </section-title>
      <paragraph>
       For convenience, we will represent sets of bridge rules using rule schemata. Intuitively, a rule schema is a parametrized bridge rule and each instance is a bridge rule. It will be convenient to use not only parameters, but also conditions to additionally constrain the set of instances. We will use them, e.g., for allowing arithmetic operations and comparison relations in bridge rules.
      </paragraph>
      <paragraph>
       Given a tuple {a mathematical formula}C=〈C1,…,Cn〉 of contexts and a tuple {a mathematical formula}IL of input languages, let {a mathematical formula}A be the alphabet of symbols occurring in all possible bridge rules for all contexts {a mathematical formula}Ci∈{C1,…,Cn} over {a mathematical formula}C and {a mathematical formula}IL. We call a string over {a mathematical formula}A an instantiation term for {a mathematical formula}C and {a mathematical formula}IL. Then, an instantiation condition for {a mathematical formula}C and {a mathematical formula}IL is a predicate {a mathematical formula}id(T1,…,To), where {a mathematical formula}T1,…,To are strings over {a mathematical formula}P∪A and where {a mathematical formula}P={P1,…,Pk} is a set of symbols (called parameters) such that {a mathematical formula}P∩A=∅. A rule schema R for {a mathematical formula}C and {a mathematical formula}IL with parameters P is of the form{a mathematical formula} such that H, {a mathematical formula}A1, ..., {a mathematical formula}Am are strings over {a mathematical formula}P∪A and {a mathematical formula}Di is an instantiation condition for each {a mathematical formula}i∈{1,…s}.
      </paragraph>
      <paragraph>
       A bridge rule {a mathematical formula}r=op←a1,…,aj,notaj+1,…,notam for {a mathematical formula}Ci over {a mathematical formula}C and {a mathematical formula}IL is an instance of a rule schema R for {a mathematical formula}C and {a mathematical formula}IL with parameters P of the form (2) if r results from {a mathematical formula}H←A1,…,Aj,notAj+1,…,notAm by a uniform substitution σ of parameters with instantiation terms, and for each {a mathematical formula}Di=id(T1,…,To), {a mathematical formula}i∈{1,…s}, the predicate {a mathematical formula}id(T1σ,…,Toσ) holds.
      </paragraph>
      <paragraph>
       We adopt the convention from logic programming that parameters start with uppercase letters. Moreover, we will denote instantiation conditions representing comparison and arithmetic operations using standard infix notation. For example, the rule schema{a mathematical formula} expresses that temperature values received on stream S should be added to the knowledge base (tagged with the stream index) if they lie between 45 °C and 65 °C.
      </paragraph>
      <paragraph>
       Note that we assume that instantiation conditions only evaluate to true if their arguments are substituted by appropriate instantiation terms, for example when X is substituted by numeric values in the temperature example.
      </paragraph>
     </section>
     <section label="2.4">
      <section-title>
       Example scenario
      </section-title>
      <paragraph>
       So far, in our examples we have only shown rMCSs with a single context, to ease the presentation. We conclude this section with an extensive example of the assisted-living scenario thereby illustrating the usage of an rMCS with several contexts (and input languages) and the flow of information within these.
      </paragraph>
      <paragraph>
       The rMCS for our assisted living scenario, {a mathematical formula}Mal=〈C,IL,BR〉, as illustrated in Fig. 2, with {a mathematical formula}C=〈Cst,Cpos,Chm,Cho,Cec〉 has five contexts: {a mathematical formula}Cst is the stove context, {a mathematical formula}Cpos keeps track of the current position of Dave, {a mathematical formula}Chm monitors Dave 's health status, {a mathematical formula}Cho is a medical ontology that the system may consult, and {a mathematical formula}Cec is the emergency control context that is responsible for detecting potential threats and taking actions, such as raising an alarm. The five contexts are connected by their corresponding sets of bridge rules {a mathematical formula}BR=〈BRst,BRpos,BRhm,BRho,BRec〉, and four input languages {a mathematical formula}IL=〈ILst,ILpos,ILhs,ILdd〉 represent the sensors used in the assisted living scenario.
      </paragraph>
      <paragraph>
       The stove context {a mathematical formula}Cst has already been described in Example 2, Example 3. We adjust {a mathematical formula}ILst=ILex3∪{tmp(T)|T∈Z} to allow for temperature sensor input data in {a mathematical formula}ILst and by adding further bridge rules for context {a mathematical formula}Cst, i.e., {a mathematical formula}BRst extends {a mathematical formula}BRex3 (with st replacing {a mathematical formula}ex3 in input literals) by the instances of the following bridge rule schemata{a mathematical formula} that classify the current temperature value as cold or hot. These bridge rules do not use the next operator and hence influence the computation of equilibria rather than the update of knowledge bases for the next step, i.e., temperature information does not persist in the knowledge base, but continuously computed from the input stream.
      </paragraph>
      <paragraph>
       The input language {a mathematical formula}ILpos is given by{a mathematical formula} and non-empty sensor (stream) input for {a mathematical formula}Ipos signals when Dave changes rooms. This information is used in context {a mathematical formula}Cpos to keep track of Dave 's position. This context also uses a storage logic with {a mathematical formula}E={pos(P)|P∈{kitchen,bathroom,bedroom}}, and its corresponding set of bridge rules {a mathematical formula}BRpos is given by the schema{a mathematical formula} The management function writes Dave 's new position into the knowledge base whenever he changes rooms and keeps the previous position, otherwise, which is why we have a bridge rule with the operator next, to ensure that, as for {a mathematical formula}setPower(P) for {a mathematical formula}Cst, the current position is stored. In addition, here we also have an identical copy of the bridge rule without next with the rationale that the information is available immediately. Intuitively, this will allow us to avoid situations in which the conditions for an alarm would be met including the absence of Dave, although he is just entering the room in question.
      </paragraph>
      <paragraph>
       The input language {a mathematical formula}ILhs is used to provide stream data on the health sensor readings from Dave while {a mathematical formula}ILdd serves to provide data on the (usage of the) drug dispenser. The information from both sensors is used in context {a mathematical formula}Chm which serves as a health monitor and also builds on a storage logic with{a mathematical formula} Here, {a mathematical formula}ILhs contains {a mathematical formula}{asleep}∪{bpReading(R)|R a blood pressure value} while {a mathematical formula}ILdd contains {a mathematical formula}{dispensed(drugA)} and the bridge rules in {a mathematical formula}BRhm are given by:{a mathematical formula} While the sleep status can be monitored permanently and new data arrives at every time instant, blood pressure measurements and taking medications are only taken occasionally, so this data needs to be stored until new information arrives. Here, we abstract from the details on the duration of effects of medications. The management function {a mathematical formula}mnghm(OP,kb) can then be defined quite similarly to {a mathematical formula}mngst(OP,kb).
      </paragraph>
      <paragraph>
       The context {a mathematical formula}Cho=〈Lho,OPho,mngho〉 represents a biomedical health ontology, which uses the DL logic described in Example 1. It contains information on diseases, treatments, and so on, and, it can, e.g., be used to consult for possible effects of medications by context {a mathematical formula}Cec as explained below. In our case, {a mathematical formula}kbho is simplified to{a mathematical formula} which allows one to derive that {a mathematical formula}drugA causes high blood pressure. In our simple setting, the management function {a mathematical formula}mngho leaves the knowledge base {a mathematical formula}kbho unchanged.
      </paragraph>
      <paragraph>
       {a mathematical formula}Cec=〈Lec,OPec,mngec〉 is the context for detecting emergencies. It is implemented as an answer set program, hence the acceptable belief sets of {a mathematical formula}Lec are the answer sets of its knowledge bases as outlined in Example 1. The bridge rules in {a mathematical formula}BRec do not refer to stream input but query other contexts:{a mathematical formula} Note that in the first bridge rule, we only import information for the case that will possibly be problematic, namely if the oven is turned on and hot, whereas, e.g., in the second, we use a schema to keep track of the position in all cases. The answer set program {a mathematical formula}kbec is given by the rules:{a mathematical formula}
      </paragraph>
      <paragraph>
       The management function of {a mathematical formula}Cec, {a mathematical formula}mngec(OP,kb), that adds information from the bridge rules temporarily as input facts to the context's knowledge base can be defined similar to the previous contexts.
      </paragraph>
      <paragraph>
       An example run of this entire rMCS is given in Fig. 3. Note that we have omitted from {a mathematical formula}KBt and {a mathematical formula}Bt all information which is fixed to ease the reading, which is why, e.g., {a mathematical formula}KBho and {a mathematical formula}KBec in the figure are always empty. The presented situation begins with Dave in the kitchen, where he turns on the stove at {a mathematical formula}t=1. The effect of this is visible at {a mathematical formula}t=2, where he takes his medication (also in the kitchen). Note that blood pressure readings are not constantly done, and therefore at {a mathematical formula}t=2 no reading occurs. Subsequently, Dave leaves for the bedroom to rest (thus forgetting about the stove), and this change of position is available right away and stored. The next blood pressure reading at {a mathematical formula}t=4 is high, which is stored in the corresponding knowledge base from {a mathematical formula}t=5 onwards, at which time point a medical assistent would be called if the medication most likely causing this was not registered. Finally, at {a mathematical formula}t=6, the oven has become hot, but since Dave has fallen asleep, the context for detecting emergencies initiates turning off the stove to prevent possible problems. If Dave was not asleep yet, an alarm would have been sounded reminding him of the stove instead.
      </paragraph>
      <paragraph>
       Finally, note that in our example scenario, currently the effects of taken medications do not wear off. Such extension can be handled by e.g., incorporating explicit time, one of the modeling features of rMCSs described in the next section.
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Modeling with rMCSs
     </section-title>
     <paragraph>
      The running example demonstrates that rMCSs can jointly integrate different formalisms and deal with a dynamic environment. In this section, we want to focus on aspects relevant to the knowledge engineer, namely how to model a certain scenario using an rMCS. To this end, we elaborate on different generic modeling techniques for rMCSs that we consider helpful in typical target applications. For concrete implementations, these techniques can still be refined and tailored towards the specific needs of the problem domain at hand. First, in Section 3.1, we discuss bridge rules as a device for translating stream data to a knowledge base language. When to use the next operator in the head of bridge rules is addressed in Section 3.2. In Section 3.3, we discuss how we deal with time on the object level, including the use of timestamps as well as external and logical clocks. Then, in Section 3.4, another technique is presented that allows for managing conflicting data in input streams on the modeling level, e.g., contradictory sensor measurements. An important issue for systems that are continuously online is when to keep data and when to remove it. In Section 3.5, we discuss how to do this and provide techniques for dynamically adjusting what information is kept in the system. These techniques allow us, e.g., to modify the size of sliding windows for stream data depending on the current situation. While the computation of acceptable belief sets may be easy for some contexts, it might be expensive for others that have to perform complex reasoning. In practice, it will therefore be wise to only evaluate these contexts if necessary.
     </paragraph>
     <section label="3.1">
      <section-title>
       Incorporating stream data
      </section-title>
      <paragraph>
       Bridge rules are responsible for providing a context with information from streams and other contexts. As we deal with heterogeneous context languages and since input languages may differ from context languages, one important aspect of rMCSs (and earlier types of MCSs) is that bridge rules can be seen as a translation device between the different languages: bridge rule bodies use the languages of the source contexts or streams whereas a bridge rule head is an operation that produces a knowledge base in the target language (via the management function). But bridge rules do not necessarily pass information the way it is used in the body. Rather, we can model bridge rules such that we they focus on information relevant to the target context and, e.g., translate sensor data into a form that is convenient for reasoning. Consider the bridge rule schemas shown in Section 2.4 for {a mathematical formula}Cst:{a mathematical formula} In this case, the bridge rules only communicate whether the stove is hot or cold, abstracting away the exact temperature value coming from the sensor. This is in contrast to rule schema (3) discussed in the previous section where parameter X appears in the rule head whereby a concrete temperature value is added to the knowledge base.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       Operational and declarative bridge rules
      </section-title>
      <paragraph>
       For gaining a better understanding of when to use next in the head of a bridge rule, reconsider the example of turning a switch on and off as in Example 2, Example 3. Remember that the bridge rules{a mathematical formula} were used so that an occurrence of an input atom switch causes the knowledge base to contain an inverted power state at the next time point. In order to highlight the difference, assume we would instead use the bridge rules{a mathematical formula} without next. We refer to the version of {a mathematical formula}Mex3 from Example 3 with these modified bridge rules by {a mathematical formula}Mex3′. Consider the configuration {a mathematical formula}KB=〈kbst〉 of knowledge bases with {a mathematical formula}kbst=∅ and the input {a mathematical formula}I=〈{switch}〉 as in Example 4. Indeed, {a mathematical formula}Mex3′ has no equilibrium given {a mathematical formula}KB and {a mathematical formula}I: If we take belief state {a mathematical formula}B=〈∅〉 as in Example 4, we have {a mathematical formula}appstnow(I,B)={setPower(on)} (instead of ∅ as in Example 4). Consequently, following the definition of {a mathematical formula}mngst in Example 2, we get {a mathematical formula}mngst(appstnow(I,B),kbst)={pw(on)}. But then {a mathematical formula}B is not contained in {a mathematical formula}accst(mngst(appstnow(I,B),kbst))={{pw(on)}}, thus, {a mathematical formula}B is not an equilibrium of {a mathematical formula}Mex3′ given {a mathematical formula}KB and {a mathematical formula}I. This is in line with the intuition that without next, turning the switch should affect the current equilibrium. However, {a mathematical formula}B′=〈{pw(on)}〉 is also not an equilibrium of {a mathematical formula}Mex3′. Since {a mathematical formula}appstnow(I,B′)={setPower(off)}, we get {a mathematical formula}mngst(appstnow(I,B′),kbst)=∅. But then {a mathematical formula}accst(mngst(appstnow(I,B′),kbst))={∅} does not contain {a mathematical formula}B′, consequently also {a mathematical formula}B′ is not an equilibrium of {a mathematical formula}Mex3′ given {a mathematical formula}KB and {a mathematical formula}I. The two bridge rules without next prevent stability of a belief state required for an equilibrium: believing that the power is on (respectively off) causes an update of the knowledge base that the power is off (respectively on) which is in turn inconsistent to the belief.
      </paragraph>
      <paragraph>
       The reason why the change considered here does not work is that the two types of bridge rule are meant to be used for different purposes. The bridge rules using next are responsible for changing knowledge bases over time. An rMCS without such bridge rules cannot alter its initial configuration of knowledge bases. Thus, these rules come with an operational flavor. Bridge rules without next on the other hand have a pure declarative nature and their purpose is to semantically integrate the contexts of an rMCS.
      </paragraph>
      <paragraph>
       Still, as we have seen for {a mathematical formula}Mal in Section 2.4, it sometimes makes sense to use essentially the same bridge rules with and without next: the bridge rule{a mathematical formula} ensures that the information about the position of Dave persists in the knowledge base, whereas{a mathematical formula} provides this information for computing equilibria in the current time instant.
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       Integration of time
      </section-title>
      <paragraph>
       The structure of input streams and equilibria streams implicitly induces a discrete logical time for rMCSs. In order to operate in dynamic environments, in many cases it is necessary to deal with explicit physical time or logical time, and both can be achieved on the level of modeling. To this end, it is necessary to have access to explicit time points on this level, i.e., in the bridge rules and knowledge bases. A natural way to make such time points explicitly available is the use of an external clock that provides the current time via an input stream {a mathematical formula}Ic. Thus, every input for the rMCS contains information about the current time which can then be queried in bridge rules.
      </paragraph>
      <paragraph>
       Consider a context {a mathematical formula}C1 that requires information about the development of temperature values from an incoming sensor over time. The bridge rule schema{a mathematical formula} can be used to add atoms of form {a mathematical formula}tmpAtTime(Temp,T) to the context, where {a mathematical formula}Temp is the current temperature and T stands for the time of the sensor reading. This setting also allows for querying, e.g., whether a temperature of 45 °C was exceeded within the last 10 minutes, as expressed in the following bridge rule schema:{a mathematical formula}
      </paragraph>
      <paragraph>
       Another possibility is to use logical time synchronized with the length of the equilibria stream, e.g., whenever the use of an external clock is not an option. We can obtain timestamps from the computation of knowledge base updates by using one context {a mathematical formula}Cclock that keeps information about the current logical time that uses the following bridge rule schemas and whose initial knowledge base is assumed to be empty:{a mathematical formula} The first rule is used for initialization ensuring that if no time information is yet available, the logical time is set to the value 0. The third rule increments the current time by one and stores the updated value in the knowledge base of the next time instant. Finally, the second rule, ensures that once this value is greater than 0, the first rule can no longer be applied.
      </paragraph>
     </section>
     <section label="3.4">
      <section-title>
       Handling inconsistent stream data
      </section-title>
      <paragraph>
       In many situations, inconsistencies may occur when dealing with multiple external sources of data. Consider, e.g., an array of sensors that measure interdependent properties among which there may be a sensor that provides more fine-grained results, but which is also less reliable, so that it sometimes provides values that conflict with the data from the remaining sensors. In this case, we would like to use such a measure of reliability to consistently accommodate relevant sensor data. Next, we present a technique for integrating possibly inconsistent stream data into a context of an rMCS. Let {a mathematical formula}M=〈C,IL,BR〉 be an rMCS with {a mathematical formula}IL=〈IL1,…,ILk〉, and {a mathematical formula}Ci∈C a context whose aim is to receive and consistently accommodate (potentially conflicting) information from the streams. To deal with possible inconsistencies, {a mathematical formula}Ci has bridge rules of the form{a mathematical formula} for {a mathematical formula}j∈{1,…,k}, where the operation {a mathematical formula}addC is meant to consistently add the information of sensor j to the context. To address possible inconsistencies among sensors, we foresee a management function {a mathematical formula}mngi that operates based on a total preference relation ≺ over the available sensors. The second argument of the {a mathematical formula}addC operation provides information about the source of a piece of information and thus a way of imposing preferences on the information to be added. Without loss of generality assume {a mathematical formula}IL1&gt;…&gt;ILk, that is, input language {a mathematical formula}IL1 has highest priority. Moreover, a notion of consistency needs to be specific to the context and so we assume a property {a mathematical formula}cons(kb) that holds if the knowledge base kb is consistent (according to such domain specific notion of consistency).
      </paragraph>
      <paragraph>
       Given a set of operations OP, we define the sets of input data from each sensor {a mathematical formula}inpj′={d|addC(d,j)∈OP} for {a mathematical formula}j∈{1,…,k}.
      </paragraph>
      <paragraph>
       We then assume that {a mathematical formula}inp0c(OP)=∅ and let{a mathematical formula} Finally, we define {a mathematical formula}mngi(OP,kbi)=kbi∪inpkc(OP).
      </paragraph>
      <paragraph>
       The intuitive idea is that, starting with the input stream with highest priority, data from each sensor is only incorporated into the knowledge base if such data is consistent with the data already collected from the input streams with higher priority.
      </paragraph>
      <paragraph>
       Note that by considering {a mathematical formula}inp0c(OP)=∅, the solution only considers inconsistency of data on the streams. For considering inconsistency between the streams and also the knowledge base {a mathematical formula}kbi of the context, we can set {a mathematical formula}inp0c(OP)=kbi.
      </paragraph>
      <paragraph>
       We can also easily consider the incorporation of meta-information about sensors whose readings are considered inconsistent. This only requires a small change in the definition of {a mathematical formula}inpjc(OP) to {a mathematical formula}inpj−1c(OP)∪{incons(j)} in case a conflict occurs. Such meta information can then be further leveraged by, e.g., initiating a control of the sensor if such measurements fall outside of the expected parameters of such sensor.
      </paragraph>
      <paragraph>
       In all, this shows how the management function can solve conflicts due to inconsistent stream data based on preferences among the streams. Of course, many more strategies for integrating inconsistent stream data can be thought of. For example, in absence of a global ranking between streams, one way to ensure consistency is to select maximally consistent subsets of stream data. A corresponding management function could then be defined such that {a mathematical formula}mngi(OP,kbi)=kbi∪inpmx, where {a mathematical formula}inpmx is a maximal set where {a mathematical formula}inpmx⊆{d|addC(d,j)∈OP,j∈{1,…,m}} and {a mathematical formula}cons(inpmx) holds.
      </paragraph>
      <paragraph>
       The strategies above show how we can deal with contradictory information in the processed data by means of modeling. In Section 4, we address inconsistency on the level of the formalism caused by nonexistence of equilibria or inconsistent belief states.
      </paragraph>
     </section>
     <section label="3.5">
      <section-title>
       Selective forgetting and data retention
      </section-title>
      <paragraph>
       As argued in Section 3.3 for the example where we were constantly adding sensor information to some knowledge base, sometimes it is necessary to forget (part of this) knowledge again. In this section, we show how rMCSs can model scenarios where there is a need to dynamically adjust the size of the stored stream history. We do that by considering an extension of our running example. Recall from {a mathematical formula}Mal in Section 2.4 that context {a mathematical formula}Cec is a context for detecting emergencies. In a situation where the stove is hot and Dave is asleep, {a mathematical formula}turnOff(stove) is derived, signaling that the stove must be turned off. In case the stove is hot, but Dave is neither asleep nor in the kitchen, then an alarm is raised, signaling a potential emergency. In the latter case, we do not want to immediately turn the stove off, since it may well be the case that the absence of Dave from the kitchen is short. A situation is only considered a real emergency if Dave is absent from the kitchen for a (predefined) long period of time. To model such situation, we use a context {a mathematical formula}CstE, which collects timestamped alerts raised by context {a mathematical formula}Cec and uses these to check if a real stove-related emergency has occurred. Since we need to reason about time as in Section 3.3, we consider an input stream {a mathematical formula}Ic that provides the current time. The possible knowledge bases of {a mathematical formula}CstE contain elements of the form {a mathematical formula}alert(stove,t) where {a mathematical formula}t∈N, one element of the form {a mathematical formula}winE(t), which defines the limit size of the time window between two alerts above which an emergency should be raised, and possibly one element of the form {a mathematical formula}emergency(stove) that signals the existence of a stove-related emergency. The set of bridge rules of {a mathematical formula}CstE is determined by the following bridge rule schemas:{a mathematical formula}
      </paragraph>
      <paragraph>
       The first rule adds a timestamped stove alert whenever such alert is active on context {a mathematical formula}Cec. The second rule removes all currently stored stove alerts whenever no such alert is coming from context {a mathematical formula}Cec. This guarantees that the knowledge base of {a mathematical formula}CstE does not accumulate unnecessary information. The last bridge rule triggers a real emergency alert whenever, in the history of alerts kept in the knowledge base of {a mathematical formula}CstE, there is an alert whose timestamp differs from the current time more than the acceptable emergency window.
      </paragraph>
      <paragraph>
       Using context {a mathematical formula}CstE, we have shown how to model scenarios where tracking the stream history is triggered by alerts of possible emergencies. We now also consider the case where such alerts trigger the change of the window size of stream history to be kept. Consider a scenario with several potential emergencies, which can be just suspected or confirmed. Based on the status of the emergencies at each time point, we may need to adapt the size of the stream history that is kept. We generically model such scenario with an rMCS with a context {a mathematical formula}Cd, which is used for emergency detection in such a dynamic environment, and an input language {a mathematical formula}ILs, which represents the possible observations. Assume there are m potential emergencies {a mathematical formula}e1,…,em we want the context to handle. The role of {a mathematical formula}Cd is to check, based on the observations made, whether one or more of the emergencies {a mathematical formula}ei are suspected or confirmed. Based on information about potential emergencies, {a mathematical formula}Cd adjusts the time window of the observations that are kept. This is the basis for intelligent forgetting based on dynamic windows.
      </paragraph>
      <paragraph>
       The only assumptions we make about how {a mathematical formula}Cd works internally are:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}Cd may signal that emergency {a mathematical formula}ei is suspected ({a mathematical formula}susp(ei)) or confirmed ({a mathematical formula}conf(ei)).
       </list-item>
       <list-item label="•">
        {a mathematical formula}Cd has information for each different observation p about default, respectively actual window sizes, {a mathematical formula}defWin(p,w), {a mathematical formula}win(p,w), and
       </list-item>
       <list-item label="•">
        {a mathematical formula}Cd has information about the window size for each observation relevant for a particular emergency, {a mathematical formula}rel(p,e,w).
       </list-item>
      </list>
      <paragraph>
       The set of bridge rules for {a mathematical formula}Cd includes the following rules.{a mathematical formula}
      </paragraph>
      <paragraph>
       The operation {a mathematical formula}set sets the window size to a new value, deleting the old one, while {a mathematical formula}alarm is an operation that adds information to the context knowledge base signaling an alarm. Since an observation can be relevant for more than one emergency, it may be the case that the management function has to deal with operations {a mathematical formula}set(win(p,w)) with the same p but with different values of w. In that case, in order to avoid loosing observations relevant for some suspected emergency, the management function takes the largest value of w as the window size for p.
      </paragraph>
      <paragraph>
       Finally, the following bridge rule schemas define addition and deletion of observations from some stream s. The deletion of observations are performed in accordance with the determined window sizes:{a mathematical formula}
      </paragraph>
      <paragraph>
       The management function just performs additions and deletions on the context knowledge base. Since additions always include the (current) time of addition, deletions always refer to an earlier point in time, thus these two operators can never occur simultaneously.
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Inconsistency management
     </section-title>
     <paragraph>
      The occurrence of inconsistencies within frameworks that aim at integrating knowledge from different sources cannot be neglected, even more so in dynamic settings where knowledge changes over time. There are many reasons why rMCSs may fail to have an equilibria stream. These include the absence of an acceptable belief set for one of its contexts given its current knowledge base at some point in time, some occurring conflict between the operations in the heads of bridge rules, or simply because the input stream is such that the configuration of the flow of information within the rMCS, namely its bridge rules, prevent the existence of such an equilibria stream. In a real world situation, an rMCS without an equilibria stream is essentially useless. Not only can it not be used at the first time point equilibria ceased to exist, but it also cannot recover, even if what caused the problem was the particular input at that time point, which is bound to subsequently change into some other input that would no longer cause any trouble. This is so because an equilibria stream requires the existence of an equilibrium at every time point.
     </paragraph>
     <paragraph>
      In this section, we address the problem of inexistent equilibria streams, also known as global inconsistency. We begin by defining a notion of coherence associated with individual contexts which allows us to first establish sufficient conditions for the existence of equilibria streams, and then abstract away from problems due to specific incoherent contexts and focus on those problems essentially caused by the way the flow of information in rMCSs is organized through its bridge rules. We introduce the notion of a repair, which modifies an rMCS by changing its bridge rules at some particular point in time in order to obtain some equilibria stream, which we dub repaired equilibria stream. We establish sufficient conditions for the existence of repaired equilibria streams and briefly discuss different possible strategies to define such repairs. However, repaired equilibria streams may not always exist either, e.g., because some particular context is incoherent. To deal with such situations, we relax the concept of equilibria stream and introduce the notion of partial equilibria stream, which essentially allows the non-existences of equilibria at some time points. It turns out that partial equilibria streams always exist thus solving the problem of global inconsistency for rMCSs.
     </paragraph>
     <paragraph>
      In related work, the problem of global inconsistency has been addressed in the context of mMCSs [15] by establishing sufficient conditions for the existence of equilibria. We also follow that idea, but among the two notions established in [15], diagnosis and explanation, the former corresponding to rules that need to be altered to restore consistency, and the latter corresponding to combinations of rules that cause inconsistency, we focus on the former. This is justified by the fact that the two notions turn out to be dual of each other, and somehow correspond to our notion of repair. The main difference here is that we opt to not allow the (non-standard) strengthening of bridge-rule to restore consistency, and, of course, the fact that our repairs need to take into account the dynamic nature of rMCSs .
     </paragraph>
     <paragraph>
      We start by introducing two notions of global consistency differing only on whether we consider a particular input stream or all possible input streams.
     </paragraph>
     <paragraph label="Definition 13">
      Let M be an rMCS, {a mathematical formula}KB a configuration of knowledge bases for M, and {a mathematical formula}I an input stream for M. Then, M is consistent with respect to {a mathematical formula}KB and {a mathematical formula}I if there exists an equilibria stream of M given {a mathematical formula}KB and {a mathematical formula}I. M is strongly consistent with respect to {a mathematical formula}KB if, for every input stream {a mathematical formula}I for M, M is consistent with respect to {a mathematical formula}KB and {a mathematical formula}I.
     </paragraph>
     <paragraph>
      Obviously, for a fixed configuration of knowledge bases, strong consistency implies consistency w.r.t. any input stream, but not vice-versa.
     </paragraph>
     <paragraph>
      Unfortunately, verifying strong consistency is in general highly complex since it requires checking all possible equilibria streams. Nevertheless, we can establish conditions that ensure that an rMCS M is strongly consistent with respect to a given configuration of knowledge bases {a mathematical formula}KB, hence guaranteeing the existence of an equilibria stream independently of the input. It is based on two notions – totally coherent contexts and acyclic rMCSs – that together are sufficient to ensure (strong) consistency.
     </paragraph>
     <paragraph>
      Total coherence imposes that each knowledge base of a context always has at least one acceptable belief set.
     </paragraph>
     <paragraph label="Definition 14">
      A context {a mathematical formula}Ci is totally coherent if {a mathematical formula}acci(kb)≠∅, for every {a mathematical formula}kb∈KBi.
     </paragraph>
     <paragraph>
      The second notion describes cycles between contexts which may be a cause of inconsistency. Acyclic rMCSs are those whose bridge rules have no cycles.
     </paragraph>
     <paragraph label="Definition 15">
      Given an rMCS {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉, {a mathematical formula}◃M is the binary relation over contexts of M such that {a mathematical formula}(Ci,Cj)∈◃M if there is a bridge rule {a mathematical formula}r∈BRi and {a mathematical formula}j:b∈bd(r) for some b. If {a mathematical formula}(Ci,Cj)∈◃M, also denoted by {a mathematical formula}Ci◃MCj, we say that {a mathematical formula}Ci depends on {a mathematical formula}Cj in M, dropping the reference to M whenever unambiguous.
     </paragraph>
     <paragraph label="Definition 16">
      An rMCS M is acyclic if the transitive closure of {a mathematical formula}◃M is irreflexive.
     </paragraph>
     <paragraph>
      We can show that acyclicity and total coherence together are indeed sufficient to ensure strong consistency.
     </paragraph>
     <paragraph label="Proposition 1">
      Let{a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉be an acyclic rMCS such that every{a mathematical formula}Ci,{a mathematical formula}1≤i≤n, is totally coherent, and{a mathematical formula}KBa configuration of knowledge bases for M. Then, M is strongly consistent with respect to{a mathematical formula}KB.
     </paragraph>
     <paragraph>
      Nevertheless, these conditions are rather restrictive since there are many useful cyclic rMCSs which only under some particular configurations of knowledge bases and input streams may have no equilibria streams.
     </paragraph>
     <paragraph>
      To deal with these, and recover an equilibria stream, one possibility is to repair the rMCSs by locally, and selectively, eliminating some of its bridge rules. Towards introducing the notion of repair, given an rMCS {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉, we denote by {a mathematical formula}brM the set of all bridge rules of M, i.e., {a mathematical formula}brM=⋃1≤i≤nBRi. Moreover, given a set {a mathematical formula}R⊆brM, denote by {a mathematical formula}M[R] the rMCS obtained from M by restricting the bridge rules to those not in R.
     </paragraph>
     <paragraph label="Definition 17">
      RepairLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS, {a mathematical formula}KB a configuration of knowledge bases for M, and {a mathematical formula}I an input stream for M until τ where {a mathematical formula}τ∈N∪{∞}. Then, a repair for M given {a mathematical formula}KB and {a mathematical formula}I is a function {a mathematical formula}R:[1..τ]→2brM such that there exists a function {a mathematical formula}B:[1..τ]→BelM such that
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}Bt is an equilibrium of {a mathematical formula}M[Rt] given {a mathematical formula}KBt and {a mathematical formula}It, where {a mathematical formula}KBt is inductively defined as
      </list-item>
     </list>
     <paragraph>
      Note the generality of this notion, which considers to be a repair essentially any sequence of bridge rules (defined by the repair function {a mathematical formula}R) that, if removed from the rMCS at their corresponding time point, will allow for an equilibrium at that time point. This may include repairs that unnecessarily eliminate some bridge rules, and even the empty repair i.e. the repair {a mathematical formula}R∅ such that {a mathematical formula}R∅t=∅ for every t, whenever M already has an equilibria stream given {a mathematical formula}KB and {a mathematical formula}I. This ensures that the set of repaired equilibria streams properly extends the set of equilibria streams, since equilibria streams coincide with repaired equilibria streams given the empty repair.
     </paragraph>
     <paragraph label="Proposition 2">
      Every equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}Iis a repaired equilibria stream of M given{a mathematical formula}KB,{a mathematical formula}Iand the empty repair{a mathematical formula}R∅.
     </paragraph>
     <paragraph>
      It turns out that for rMCSs composed of totally coherent contexts, repaired equilibria streams always exist.
     </paragraph>
     <paragraph label="Proposition 3">
      Let{a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉be an rMCS such that each{a mathematical formula}Ci,{a mathematical formula}i∈{1,…,n}, is totally coherent,{a mathematical formula}KBa configuration of knowledge bases for M, and{a mathematical formula}Ian input stream for M until τ. Then, there exists{a mathematical formula}R:[1..τ]→2brMand{a mathematical formula}B:[1..τ]→BelMsuch that{a mathematical formula}Bis a repaired equilibria stream given{a mathematical formula}KB,{a mathematical formula}Iand{a mathematical formula}R.
     </paragraph>
     <paragraph>
      Whenever repair operations are considered in the literature, e.g., in the context of databases [4], there is a special emphasis on seeking repairs that are somehow minimal, the rational being that we want to change things as little as possible to regain consistency. In the case of repairs of rMCS, it is easy to establish an order relation between them, based on a comparison of the bridge rules to be deleted at each time point.
     </paragraph>
     <paragraph label="Definition 18">
      Let {a mathematical formula}Ra and {a mathematical formula}Rb be two repairs for some rMCS M given a configuration of knowledge bases for M, {a mathematical formula}KB and {a mathematical formula}I, an input stream for M until τ. We say that {a mathematical formula}Ra≤Rb if {a mathematical formula}Rai⊆Rbi for every {a mathematical formula}i≤τ, and that {a mathematical formula}Ra&lt;Rb if {a mathematical formula}Ra≤Rb and {a mathematical formula}Rai⊂Rbi for some {a mathematical formula}i≤τ.
     </paragraph>
     <paragraph>
      This relation can be straightforwardly used to check whether a repair is minimal, and we can restrict ourselves to adopting minimal repairs. However, there may be good reasons to adopt non-minimal repairs, e.g., so that they can be determined as we go, or so that deleted bridge rules are not reinstated, etc. Even though investigating specific types of repairs falls outside the scope of this paper, we nevertheless present and briefly discuss some possibilities.
     </paragraph>
     <paragraph label="Definition 19">
      Types of repairsLet {a mathematical formula}R be a repair for some rMCS M given {a mathematical formula}KB and {a mathematical formula}I. We say that {a mathematical formula}R is a: Minimal repairif there is no repair {a mathematical formula}Ra for M given {a mathematical formula}KB and {a mathematical formula}I such that {a mathematical formula}Ra&lt;R.Global repairif {a mathematical formula}Ri=Rj for every {a mathematical formula}i,j≤τ.Minimal global repairif {a mathematical formula}R is global and there is no global repair {a mathematical formula}Ra for M given {a mathematical formula}KB and {a mathematical formula}I such that {a mathematical formula}Ra&lt;R.Incremental repairif {a mathematical formula}Ri⊆Rj for every {a mathematical formula}i≤j≤τ.Minimally incremental repairif {a mathematical formula}R is incremental and there is no incremental repair {a mathematical formula}Ra and {a mathematical formula}j≤τ such that {a mathematical formula}Rai⊂Ri for every {a mathematical formula}i≤j.
     </paragraph>
     <paragraph>
      Minimal repairs perhaps correspond to the ideal situation in the sense that they never unnecessarily remove bridge rules. In some circumstances, it may be the case that if a bridge rule is somehow involved in some inconsistency, it should not be used at any time point, leading to the notion of global repair. Given the set of all repairs, checking which are global is also obviously less complex than checking which are minimal. A further refinement – minimal global repairs – would be to only consider repairs that are minimal among the global ones, which would be much simpler to check than checking whether it is simply minimal. Note that a minimal global repair is not necessarily a minimal repair. One of the problems with these types of repairs is that we can only check whether they are of that type globally, i.e., we can only check once we know the entire input stream {a mathematical formula}I. This was not the case with plain repairs, as defined in Definition 17, which could be checked as we go, i.e., we can determine what bridge rules to include in the repair at a particular time point by having access to the input stream {a mathematical formula}I up to that time point only. This is important so that rMCSs can be used to effectively react to their environment. The last two types of repairs defined above allow for just that. Incremental repairs essentially impose that removed bridge rules cannot be reused in the future, i.e., that the set of removed bridge rules monotonically grows with time, while minimally incremental repairs further impose that only minimal sets of bridge rules can be added at each time point. Other types of repairs could be defined, e.g., by defining some priority relation between bridge rules, some distance measure between subsets of bridge rules and minimize it when considering the repair at consecutive time points, among many other options, whose investigation we leave for future work. Repairs could also be extended to allow for the strengthening of bridge rules, besides their elimination, generalizing ideas from [15] and [10] where the extreme case of eliminating the entire body of bridge rules as part of a repair is considered.
     </paragraph>
     <paragraph>
      Despite the existence of repaired equilibria streams for large classes of systems, two problems remain: first, computing a repair may be excessively complex, and second, there remain situations where no repaired equilibria stream exists, namely when the rMCS contains contexts that are not totally coherent. The second issue could be dealt with by ensuring that for each non-totally coherent context there would be some bridge rule with a management operation in its head that would always restore consistency of the context, and that such rule could always be activated through a repair (for example, by adding a negated reserved atom to its body, and another bridge rule with that atom in its head and an empty body, so that removing this latter rule through a repair would activate the management function and restore consistency of the context). But this would require special care in the way the system is specified, and its analysis would require a very complex analysis of the entire system including the specific behavior of management functions. In practice, it would be quite hard – close to impossible in general – to ensure the existence of repaired equilibria streams, and we would still be faced with the first problem, that of the complexity of determining the repairs.
     </paragraph>
     <paragraph>
      A solution to this problem is to relax the notion of equilibria stream so that it does not require an equilibrium at every time point. This way, if no equilibrium exists at some time point, the equilibria stream would be undefined at that point, but possibly defined again in subsequent time points. This leads to the following notion of partial equilibria stream.{sup:4}
     </paragraph>
     <paragraph label="Definition 20">
      Partial equilibria streamLet {a mathematical formula}M=〈C,IL,BR〉 be an rMCS, {a mathematical formula}KB=〈kb1,…,kbn〉 a configuration of knowledge bases for M, and {a mathematical formula}I an input stream for M until τ where {a mathematical formula}τ∈N∪{∞}. Then, a partial equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}I is a partial function {a mathematical formula}B:[1..τ]↛BelM such that
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}Bt is an equilibrium of M given {a mathematical formula}KBt and {a mathematical formula}It, where {a mathematical formula}KBt is inductively defined as
      </list-item>
      <list-item label="•">
       or {a mathematical formula}Bt is undefined.
      </list-item>
     </list>
     <paragraph>
      As expected, this is a proper generalization of the notion of equilibria stream:
     </paragraph>
     <paragraph label="Proposition 4">
      Every equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}Iis a partial equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}I.
     </paragraph>
     <paragraph>
      And it turns out that partial equilibria streams always exist.
     </paragraph>
     <paragraph label="Proposition 5">
      Let M be an rMCS,{a mathematical formula}KBa configuration of knowledge bases for M, and{a mathematical formula}Ian input stream for M until τ. Then, there exists{a mathematical formula}B:[1..τ]↛BelMsuch that{a mathematical formula}Bis a partial equilibria stream given{a mathematical formula}KBand{a mathematical formula}I.
     </paragraph>
     <paragraph>
      One final word to note is that partial equilibria streams not only allow us to deal with situations where equilibria do not exist at some time instants, but they also open the ground to consider other kinds of situations where we do not wish to consider equilibria at some time point, for example because we were not able to compute them on time, or simply because we do not wish to process the input at every time point, e.g., whenever we just wish to sample the input with a lower frequency than it is generated. If we wish to restrict that partial equilibria streams only relax equilibria streams when necessary, i.e., when equilibria do not exist at some time point, we can further impose the following condition on Definition 20:{a mathematical formula}
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Non-determinism and well-founded semantics
     </section-title>
     <paragraph>
      Reactive MCSs as considered so far are non-deterministic for two reasons. On the one hand, we allow for contexts whose semantics may return multiple belief sets for the same knowledge base, and on the other hand, the flow of information between contexts established by bridge rules may be the source of non-determinism. As this leads to multiple equilibria and thus to exponentially many equilibria streams, in practice, this may be undesired, which is why it is important to study under which conditions non-determinism can be avoided.
     </paragraph>
     <paragraph>
      The first source of non-determinism solely depends on the choice of the contexts occurring in the rMCS, i.e., it can be avoided when determining/designing the rMCS in question. The second source, however, requires to consider the entire rMCS when eliminating the non-determinism. This can be achieved by introducing preferences on equilibria using, e.g., preference functions as proposed by Ellmauthaler [17]. One might also adopt language constructs for expressing preferences in ASP such as optimization statements [24] or weak constraints [13], which essentially assign a quality measure to equilibria, or, more recently, add a pre-order on the contexts [36]. Alternatively, and inspired by notions developed for MCSs [9], we may consider restrictions on rMCSs such that these non-determinisms do not occur in the first place. In the remainder of this section, we will focus on such restrictions leading to an alternative well-founded semantics for rMCSs.
     </paragraph>
     <paragraph>
      As a first step towards this objective, only equilibria that are subset-minimal will be considered, also with the aim of avoiding unnecessary self-justifications of information resulting from the interaction of various contexts. Then, grounded equilibria as a special case for so-called reducible MCSs will be presented for which the existence of minimal equilibria can be effectively checked. Subsequently, a well-founded semantics for such reducible MCSs will be defined under which an approximation of all grounded equilibria can be computed deterministically. In the following, we transfer these notions from static MCSs in [9] to dynamic rMCSs and discuss under which (non-trivial) conditions they actually can be applied.
     </paragraph>
     <paragraph>
      We start with the notion of minimal equilibria. Formally, given an rMCS {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉, a configuration of knowledge bases {a mathematical formula}KB for M and an input {a mathematical formula}I for M, an equilibrium {a mathematical formula}B=〈B1,…,Bn〉 of M given {a mathematical formula}KB and {a mathematical formula}I is minimal if there is no equilibrium {a mathematical formula}B′=〈B1′,…,Bn′〉 of M given {a mathematical formula}KB and {a mathematical formula}I such that {a mathematical formula}Bi′⊆Bi for all i with {a mathematical formula}1≤i≤n and {a mathematical formula}Bj′⊊Bj for some j with {a mathematical formula}j∈{1…n}.
     </paragraph>
     <paragraph label="Example 6">
      This notion of minimality avoids to some extent unnecessary self-justifications in equilibria (streams). A simple example of such self-justification is shown in Example 2 in [9], which can be transcribed to our setting using a simple rMCS without input languages, a single propositional context {a mathematical formula}C1 with empty kb and {a mathematical formula}BR1 only containing {a mathematical formula}add(a)←1:a. Then both {a mathematical formula}〈∅〉 and {a mathematical formula}〈{a}〉 are equilibria. The latter is considered dubious as a is justified by itself and minimality would avoid such self-justification. Note that this does not always work. A single storage context with empty kb and bridge rules {a mathematical formula}add(b)←not1:a. and {a mathematical formula}add(a)←1:a. has two minimal equilibria {a mathematical formula}〈{a}〉 and {a mathematical formula}〈{b}〉, the former being self-justified. Still, avoiding non-minimality whenever possible certainly is a decent guiding principle, and, as we will see later, it can be avoided altogether under certain conditions.
     </paragraph>
     <paragraph>
      The problem is that checking for minimality commonly raises the computational complexity of determining equilibria. To avoid that, we now formalize conditions under which minimal equilibria can be effectively checked.
     </paragraph>
     <paragraph>
      For that purpose, we start by introducing the notion of monotonic logics. Namely, a logic {a mathematical formula}L=〈KB,BS,acc〉 is monotonic if
     </paragraph>
     <list>
      <list-item label="1.">
       {a mathematical formula}acc(kb) is a singleton set for each {a mathematical formula}kb∈KB, and
      </list-item>
      <list-item label="2.">
       {a mathematical formula}B⊆B′ whenever {a mathematical formula}kb⊆kb′, {a mathematical formula}acc(kb)={B}, and {a mathematical formula}acc(kb′)={B′}.
      </list-item>
     </list>
     <paragraph>
      In other words, L is monotonic if acc is deterministic and monotonic.
     </paragraph>
     <paragraph>
      Maybe not surprisingly, the logics of non-monotonic formalisms such as {a mathematical formula}La for the answer set semantics in Example 1 do not satisfy this definition. We therefore proceed with introducing the notion of a reducible logic, which covers monotonic logics, but also includes logics that can be reduced to monotonic ones given a belief set of the logic.
     </paragraph>
     <paragraph>
      Logic {a mathematical formula}L=〈KB,BS,acc〉 is reducible iff, for some {a mathematical formula}KB⁎⊆KB and some reduction function {a mathematical formula}red:KB×BS→KB⁎,
     </paragraph>
     <list>
      <list-item label="1.">
       {a mathematical formula}〈KB⁎,BS,acc〉 is monotonic,
      </list-item>
      <list-item label="2.">
       for each {a mathematical formula}kb∈KB, and all {a mathematical formula}B,B′∈BS:
      </list-item>
     </list>
     <paragraph>
      Intuitively, L is reducible, if a) the restriction of L to {a mathematical formula}KB⁎ is monotonic, and b) there is a reduction function which should not reduce kb further if it already is in {a mathematical formula}KB⁎, which is antitonic, and by means of which acceptability of a belief set can be checked by the reduction (see also [9]).
     </paragraph>
     <paragraph label="Definition 21">
      In a reducible rMCS, the logics of all contexts have to be reducible. Additionally, we require red and mng to be applicable in arbitrary order for all contexts, and that sequences of increasing sets of operations are monotonic in the following sense. Given rMCS {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉 and, for some {a mathematical formula}i∈{1,…n}, {a mathematical formula}kb∈KBi, we say that {a mathematical formula}OP⊆OPi in context {a mathematical formula}Ci is monotonic w.r.t. kb, if {a mathematical formula}kb⊆mng(OP,kb). Intuitively, a set of monotonic operations will not remove content from the knowledge base to which it is applied. Let {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉 be an rMCS, {a mathematical formula}KB a configuration of knowledge bases for M and {a mathematical formula}Si={hd(r)∈OPi|r∈BRi} for all {a mathematical formula}i∈{1,…,n}. Then, M is reducible given{a mathematical formula}KB iff, for all {a mathematical formula}i∈{1,…,n},
     </paragraph>
     <list>
      <list-item label="1.">
       {a mathematical formula}Li is reducible;
      </list-item>
      <list-item label="2.">
       for all {a mathematical formula}OP⊆Si, all {a mathematical formula}kb∈KBi, and all {a mathematical formula}Bi∈BSi:{a mathematical formula}
      </list-item>
      <list-item label="3.">
       for all {a mathematical formula}OP1⊆…⊆OPm⊆Si and all {a mathematical formula}j∈{1,…,m}: {a mathematical formula}OPj is monotonic w.r.t. {a mathematical formula}kbij where
      </list-item>
     </list>
     <paragraph>
      The second condition essentially requires that no {a mathematical formula}mngi introduces formulas that are affected by {a mathematical formula}redi. The third condition in addition checks whether any sequence of increasing sets of (applicable) operations is monotonic, i.e., whether some {a mathematical formula}kbim can be obtained in a step-wise, monotonic iteration.
     </paragraph>
     <paragraph label="Example 7">
      Recall {a mathematical formula}Mal from Section 2.4, for which we want to check whether it is reducible. First, all contexts but {a mathematical formula}Cec build on a monotonic logic, so their logics are automatically reducible. This also means that the second condition is trivially satisfied for these contexts using the identity function for {a mathematical formula}redi. At the same time, {a mathematical formula}Lec is reducible using the well-known Gelfond–Lifschitz reduct [25], and clearly none of the bridge rules in {a mathematical formula}BRec can introduce any knowledge base formula (for any {a mathematical formula}kb∈KBec) which is affected by such {a mathematical formula}redec. More care needs to be taken regarding the third condition: in fact, e.g., applying {a mathematical formula}setTemp(hot) to {a mathematical formula}{tm(cold)} yields {a mathematical formula}{tm(hot)}, which is clearly not monotonic. This can however be avoided if it is ensured that {a mathematical formula}kbst does not contain information on the temperature. Then, any increasing sequence of operations is monotonic w.r.t. the corresponding {a mathematical formula}kbij (cf. Example 2). The same is not true for {a mathematical formula}BRpos which is why we have to omit the bridge rules {a mathematical formula}setPos(P)←pos::enters(P). in {a mathematical formula}BRpos, thus only preventing the information of Dave changing the room from being available right away. With this slight adjustment, the rMCS {a mathematical formula}Mal is in fact reducible.
     </paragraph>
     <paragraph label="Definition 22">
      Following notions from logic programming, we introduce definite rMCSs. Let {a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉 be a reducible rMCS given {a mathematical formula}KB. Then, M is definite given{a mathematical formula}KB iff, for all {a mathematical formula}i∈{1,…,n},
     </paragraph>
     <list>
      <list-item label="1.">
       no {a mathematical formula}r∈BRi contains not;
      </list-item>
      <list-item label="2.">
       for all {a mathematical formula}B∈BSi: {a mathematical formula}kbi=red(kbi,B).
      </list-item>
     </list>
     <paragraph>
      Thus, in a definite rMCS (given {a mathematical formula}KB), the bridge rules are monotonic and all knowledge bases are already reduced. This suggests the following iteration.
     </paragraph>
     <paragraph label="Definition 23">
      Let M be a definite rMCS given {a mathematical formula}KB, and {a mathematical formula}I an input for M. For all {a mathematical formula}i∈{1…n}, let {a mathematical formula}kbi0=kbi and define, for each successor ordinal {a mathematical formula}α+1,{a mathematical formula} where {a mathematical formula}Bα=〈B1α,…,Bnα〉 and {a mathematical formula}acci(kbiα)={Biα} for any ordinal α. Furthermore, for each limit ordinal α, define {a mathematical formula}kbiα=⋃β≤αkbiβ, and let {a mathematical formula}kbi∞=⋃α&gt;0kbiα. We next show two properties of the iteration defined in Definition 23 that will prove useful subsequently.
     </paragraph>
     <paragraph label="Lemma 1">
      Let M be a definite rMCS given{a mathematical formula}KB, and{a mathematical formula}Ian input for M. The following holds for the iteration inDefinition 23for all ordinals α:
     </paragraph>
     <list>
      <list-item label="1.">
       M is definite given{a mathematical formula}KBα;
      </list-item>
      <list-item label="2.">
       for any ordinal β with{a mathematical formula}β≤αwe have{a mathematical formula}kbiβ⊆kbiαfor{a mathematical formula}i∈{1,…,n}.
      </list-item>
     </list>
     <paragraph>
      Lemma 1 guarantees that the iteration is well-defined and monotonic and we can show that it yields an equilibrium. In fact, it is the unique minimal equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I.
     </paragraph>
     <paragraph label="Proposition 6">
      Let M be a definite rMCS given{a mathematical formula}KB, and{a mathematical formula}Ian input for M. Then{a mathematical formula}〈B1∞,…,Bn∞〉is the unique minimal equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I. We call it grounded equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I, denoted by{a mathematical formula}GE(M,KB,I).
     </paragraph>
     <paragraph>
      As pointed out in [9], for many logics, {a mathematical formula}kbi∞=kbiω holds and the iteration even stops after finitely many steps. This is also the case for the slightly revised scenario in Example 7. Moreover, as a consequence of Proposition 6, no self-justification can occur in the grounded equilibrium of definite rMCSs.
     </paragraph>
     <paragraph>
      This fixpoint iteration cannot be applied to arbitrary reducible rMCSs right away as, e.g., not in the bridge rule bodies and non-reduced knowledge bases may allow the removal of already derived information in the iteration. To counter that, we introduce the notion of a reduct for rMCSs where, for a bridge rule of the form (1), {a mathematical formula}bd(r)+={a1,…,aj}) and {a mathematical formula}bd(r)−={aj+1,…,am}.
     </paragraph>
     <paragraph label="Definition 24">
      Let {a mathematical formula}M=〈C,IL,〈BR1,…,BRn〉〉 be a reducible rMCS given {a mathematical formula}KB, {a mathematical formula}I an input for M, and {a mathematical formula}B=〈B1,…,Bn〉 a belief state of M. The {a mathematical formula}(I,B)-reduct of M and{a mathematical formula}KB is obtained as {a mathematical formula}M(I,B)=〈IL,C,〈BR1(I,B),…,BRn(I,B)〉〉 where {a mathematical formula}BRi(I,B)={hd(r)←bd(r)+|r∈BRi,hd(r)=op with {a mathematical formula}op∈OPi,〈I,B〉⊭aℓ for all {a mathematical formula}aℓ∈bd(r)−} and as {a mathematical formula}KB(I,B)=〈kb1B1,…,kbnBn〉 where {a mathematical formula}kbiBi=redi(kbi,Bi). Note that bridge rules with an operation under next in its head are ignored here, as these do not affect the computation of the equilibria anyway.
     </paragraph>
     <paragraph>
      For all reducible rMCSs M given {a mathematical formula}KB, all inputs {a mathematical formula}I for M, and all belief states {a mathematical formula}B for M, the {a mathematical formula}(I,B)-reduct of M and {a mathematical formula}KB is definite. In this case, we can check whether {a mathematical formula}B is a grounded equilibrium for M given {a mathematical formula}KB and {a mathematical formula}I in the usual manner.
     </paragraph>
     <paragraph label="Definition 25">
      Let {a mathematical formula}M=〈C,IL,BR〉 be a reducible rMCS given {a mathematical formula}KB, and {a mathematical formula}I an input for M. A belief state {a mathematical formula}B of M is a grounded equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I iff {a mathematical formula}B=GE(M(I,B),KB(I,B),I). Grounded equilibria of reducible rMCSs given some {a mathematical formula}KB are also minimal.
     </paragraph>
     <paragraph label="Proposition 7">
      Every grounded equilibrium of a reducible rMCS M given{a mathematical formula}KBand an input{a mathematical formula}Iis a minimal equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I.
     </paragraph>
     <paragraph>
      Grounded equilibria of reducible rMCSs are not unique equilibria in general. Consider, e.g., again Example 6. Then {a mathematical formula}〈{b}〉 is a grounded equilibrium, while {a mathematical formula}〈{a}〉 is not. Still, as checking for grounded equilibria relies on the unique grounded equilibrium of the reduct, we know that no self-justification can occur in grounded equilibria, which is also why {a mathematical formula}〈{a}〉 is filtered.
     </paragraph>
     <paragraph>
      We can now introduce grounded equilibria streams provided that rMCS M given {a mathematical formula}KB is reducible for each {a mathematical formula}KB occurring in {a mathematical formula}KB. Unfortunately, checking for reducibility cannot be done a priori as the {a mathematical formula}KB will only be known at runtime (due to 3. of Definition 21). To complete the picture, we also spell out under which conditions an initially reducible rMCS given {a mathematical formula}KB remains reducible.
     </paragraph>
     <paragraph label="Definition 26">
      Let {a mathematical formula}M=〈C,IL,BR〉 be a reducible rMCS given {a mathematical formula}KB. Then M is persistently reducible given{a mathematical formula}KB iff for all sequences {a mathematical formula}OP1,…OPm with {a mathematical formula}m&gt;0 and {a mathematical formula}OPj⊆{op|next(op)∈hd(r),r∈BRi}, M is reducible given {a mathematical formula}KBj where {a mathematical formula}KB1=KB and {a mathematical formula}KBj=〈kb1j,…,kbnj〉 for {a mathematical formula}j&gt;1 with {a mathematical formula}kbij=mng(OPj−1,kbij−1). Thus, any reducible rMCS (given some concrete {a mathematical formula}KB) is persistently reducible if applying any arbitrary sequence of the operations under next occurring in the bridge rules yields again a reducible rMCS.
     </paragraph>
     <paragraph>
      It should be noted that checking for reducible rMCSs is not trivial in general and even less so for persistently reducible rMCSs. Still, certain kinds of contexts clearly satisfy the restrictions including those occurring in the example scenario in Example 7. Namely, they either store certain pieces of information, but only do change them using next and not otherwise, or their kb is initially empty and this is never changed using next, so information is only stored temporarily for the computation of the current equilibrium. The scenario is thus persistently reducible for any knowledge base configuration which does not store pieces of information in the initial {a mathematical formula}kbi for contexts of the latter kind.
     </paragraph>
     <paragraph>
      This allows us to introduce grounded equilibria streams.
     </paragraph>
     <paragraph label="Definition 27">
      Let {a mathematical formula}M=〈C,IL,BR〉 be a persistently reducible rMCS given {a mathematical formula}KB, {a mathematical formula}I an input stream for M until s, {a mathematical formula}B=〈B1,…,Bs〉 an equilibria stream of M given {a mathematical formula}KB and {a mathematical formula}I, and {a mathematical formula}KB the configurations stream of M given {a mathematical formula}KB, {a mathematical formula}I, and {a mathematical formula}B. Then, {a mathematical formula}B is a grounded equilibria stream of M given {a mathematical formula}KB and {a mathematical formula}I iff, for each {a mathematical formula}t∈{1…s}, {a mathematical formula}Bt=GE(M(I,B),(KBt)(I,B),It). A grounded equilibria stream of some M given {a mathematical formula}KB and {a mathematical formula}I can thus be understood as a stream of grounded equilibria. It is thus straightforward to see that each equilibrium in a grounded equilibria stream is minimal w.r.t. the knowledge base configuration and input of its time point.
     </paragraph>
     <paragraph>
      We remark that the notion of persistently reducible rMCSs substantially differs from reducible MCSs on which the former are founded. On the one hand, permitting operations in mng beyond simple addition, as used already for mMCSs, requires the non-trivial tests for reducible rMCSs, and in addition, persistent reducibility needs to be verified for the dynamic aspect of rMCSs. Thus, these new notions also extend the work in [9] from MCSs to mMCSs.
     </paragraph>
     <paragraph>
      For reducible rMCSs in general, determining grounded equilibria is not deterministic yet, since we have to guess and check the grounded equilibrium in each step. This is why we now introduce the well-founded semantics for reducible rMCSs M following the ideas in [9]. Its definition is based on the operator {a mathematical formula}γM,KB,I(B)=GE(M(I,B),KB(I,B),I), provided {a mathematical formula}BSi for each logic {a mathematical formula}Li in all the contexts of M has a least element {a mathematical formula}Bi⁎ (w.r.t. subset inclusion). Such rMCSs are called normal.
     </paragraph>
     <paragraph>
      It can be shown that {a mathematical formula}γM,KB,I is antitonic which means that applying {a mathematical formula}γM,KB,I twice yields a monotonic operator. Hence, by the Knaster–Tarski theorem, {a mathematical formula}(γM,KB,I)2 has a least fixpoint which determines the well-founded semantics.
     </paragraph>
     <paragraph label="Definition 28">
      Let M be a normal, reducible rMCS given {a mathematical formula}KB, and {a mathematical formula}I an input for M. The well-founded model of M given{a mathematical formula}KBand{a mathematical formula}I, denoted {a mathematical formula}WF(M,KB,I), is the least fixpoint of {a mathematical formula}(γM,KB,I)2.
     </paragraph>
     <paragraph>
      Starting with the belief state {a mathematical formula}B⁎=〈B1⁎,…,Bn⁎〉, this fixpoint can be iterated, establishing the relation between {a mathematical formula}WF(M,KB,I) and grounded equilibria of M.
     </paragraph>
     <paragraph label="Proposition 8">
      Let{a mathematical formula}M=〈C,IL,BR〉be a normal, reducible rMCS given{a mathematical formula}KB,{a mathematical formula}Ian input for M,{a mathematical formula}WF(M,KB,I)=〈W1,…Wn〉, and{a mathematical formula}B=〈B1,…,Bn〉a grounded equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I. Then{a mathematical formula}Wi⊆Bifor{a mathematical formula}i∈{1…n}.
     </paragraph>
     <paragraph>
      The well-founded model of M can thus be viewed as the belief state representing what is accepted in all grounded equilibria, even though {a mathematical formula}WF(M,KB,I) may itself not necessarily be a grounded equilibrium. Yet, if the rMCS is acyclic (i.e., no cyclic dependencies over bridge rules exist between beliefs in the rMCS, see Sect. 4), then the grounded equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I is unique and identical to the well-founded model. This is indeed the case for the scenario in Example 7.
     </paragraph>
     <paragraph>
      The well-founded semantics can be generalized to streams as follows.
     </paragraph>
     <paragraph label="Definition 29">
      Let {a mathematical formula}M=〈C,IL,BR〉 be a normal, persistently reducible rMCS given {a mathematical formula}KB, and {a mathematical formula}I an input stream for M until τ. The well-founded stream of M given{a mathematical formula}KBand{a mathematical formula}I is a function {a mathematical formula}WF:[1..τ]→BelM such that
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}WFt is the well-founded model of M given {a mathematical formula}KBt and {a mathematical formula}It, where {a mathematical formula}KBt is defined as
      </list-item>
     </list>
     <paragraph>
      Clearly, Proposition 8 also generalizes to the well-founded stream (of M given {a mathematical formula}KB and {a mathematical formula}I) including all the made observations. That is, the well-founded stream may not coincide with any (grounded) equilibria stream, unless the rMCS in question is acyclic, in which case the grounded equilibria stream is unique and does coincide with the well-founded stream. Again, this can be verified for the scenario in Example 7.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Complexity
     </section-title>
     <paragraph>
      In this section, we want to analyze the complexity of answering queries over equilibria streams of rMCSs. As our framework has many degrees of freedom, we need to impose some restrictions in order to get meaningful complexity results. In particular, we are only interested in decision problems with input of finite size, since otherwise the decision problem would unfortunately be undecidable right away. Thus, in the following, we only consider finite rMCSs, i.e., we do not consider rule schemas (which stand potentially for an infinite amount of bridge rules), and assume that all knowledge bases in the given rMCS are finite. Also, we restrict our considerations to finite input streams.
     </paragraph>
     <paragraph label="Definition 30">
      We start by introducing the two reasoning problems we consider. The problem {a mathematical formula}Q∃, respectively {a mathematical formula}Q∀, is deciding whether for a given finite rMCS M, a belief b for the k-th context of M, a configuration of knowledge bases {a mathematical formula}KB for M, and an input stream {a mathematical formula}I until τ, it holds that {a mathematical formula}b∈Bk for some {a mathematical formula}Bt=〈B1,…,Bn〉, ({a mathematical formula}1≤t≤τ), for some, respectively all, equilibria stream(s) {a mathematical formula}B given {a mathematical formula}KB and {a mathematical formula}I. As the complexity of an rMCS depends on that of its individual contexts, we introduce the notion of context complexity (cf. [15]). To do so, we need to focus on relevant parts of belief sets by means of projection. Intuitively, among all beliefs, we only need to consider belief b that we want to query and the beliefs that contribute to the application of bridge rules for deciding {a mathematical formula}Q∃ or {a mathematical formula}Q∀. Given M, b, k, and {a mathematical formula}I as in Definition 30, the set of relevant beliefs for a context {a mathematical formula}Ci of M is given by{a mathematical formula} Then, a projected belief state for M and {a mathematical formula}k:b is a tuple{a mathematical formula} where {a mathematical formula}B=〈B1,…,Bn〉 is a belief state for M. If {a mathematical formula}B is an equilibrium, then we call this tuple projected equilibrium. The context complexity of {a mathematical formula}Ci in M with respect to {a mathematical formula}k:b for a fixed input {a mathematical formula}I is the complexity of deciding the context problem of {a mathematical formula}Ci, that is, whether for a given projected belief state {a mathematical formula}B=〈B1,…,Bn〉 for M and {a mathematical formula}k:b, there is some belief set {a mathematical formula}Bi′ for {a mathematical formula}Ci with {a mathematical formula}Bi=Bi′∩RBi(M,k:b) and {a mathematical formula}Bi′∈acci(mngi(appi(I,B),kbi)). The context complexity{a mathematical formula}CC(M,k:b) of an entire rMCS is a (smallest) upper bound for the context complexity classes of its contexts.
     </paragraph>
     <paragraph label="Theorem 1">
      Table 1summarizes the complexities of membership of problems{a mathematical formula}Q∃and{a mathematical formula}Q∀for finite input steams (until some{a mathematical formula}τ∈N) depending on the context complexity. Hardness also holds if it holds for the context complexity.
     </paragraph>
     <paragraph>
      These results can also be used to show the complexity results of a strongly related problem, namely ensuring that a certain belief does always hold over all time instants for some or all equilibria streams. This can be achieved by simply considering the co-problem of ensuring that the negated belief does not hold at any time instant for some or all equilibria streams. In case the considered belief set itself does not allow us expressing this negated belief, an appropriate additional auxiliary context with adequate bridge rules can be used to represent it and query for it.
     </paragraph>
     <paragraph label="Proposition 9">
      Note that allowing for input streams of infinite length leads to undecidability. Given a finite rMCS M, the problems{a mathematical formula}Q∃and{a mathematical formula}Q∀are undecidable for infinite input streams (when{a mathematical formula}τ=∞). The reason is that rMCSs are expressive enough (even with very simple context logics) to simulate a Turing machine such that deciding {a mathematical formula}Q∃ or {a mathematical formula}Q∀ for infinite runs solves the halting problem. We provide an rMCS that implements a Turing machine service in Appendix C: a fixed rMCS can read the configuration of a Turing machine TM as well as the corresponding input and then simulate a run of TM on that input.
     </paragraph>
     <paragraph>
      For persistently reducible rMCSs, it turns out that the complexity results for the analog problems {a mathematical formula}Q∃g and {a mathematical formula}Q∀g on grounded equilibria streams are identical to {a mathematical formula}Q∃ and {a mathematical formula}Q∀ on equilibria streams.
     </paragraph>
     <paragraph label="Theorem 2">
      Let{a mathematical formula}M=〈C,IL,BR〉be a finite, persistently reducible rMCS given{a mathematical formula}KB. Then membership and hardness results for{a mathematical formula}Q∃gand{a mathematical formula}Q∀gon grounded equilibria streams for finite input streams coincide with those for{a mathematical formula}Q∃and{a mathematical formula}Q∀inTheorem 1.
     </paragraph>
     <paragraph>
      Note that this only holds if checking whether M is persistently reducible is already known/can be neglected. While such assumption is a strong one in general, in Section 5 it is argued that this can be done easily for contexts of certain kinds, including the ones used in the example scenario in Section 2.4 (and in Example 7).
     </paragraph>
     <paragraph>
      Regarding the well-founded stream, we can restrict our attention to the problem {a mathematical formula}Q∃wf for the well-founded stream, since it coincides with {a mathematical formula}Q∀wf for the unique well-founded stream, and to polynomial contexts given the motivation for the well-founded stream.
     </paragraph>
     <paragraph label="Theorem 3">
      Let{a mathematical formula}M=〈C,IL,BR〉be a finite, normal, persistently reducible rMCS given{a mathematical formula}KBsuch that{a mathematical formula}CC(M,k:b)=Pfor{a mathematical formula}Q∃wf. Then,{a mathematical formula}Q∃wfis inP. In addition, hardness holds provided{a mathematical formula}CC(M,k:b)=Pis hard. This result, together with the observation that the well-founded stream coincides with the unique grounded equilibrium stream until s, allows us to verify that computing the results in our use case scenario in Section 2.4 can be done in polynomial time.
     </paragraph>
    </section>
    <section label="7">
     <section-title>
      Related work
     </section-title>
     <paragraph>
      Several systems and frameworks for modeling the dynamics of knowledge and the flow of information have been developed. These systems are obviously related to reactive multi-context systems. In this section, we present those approaches we consider most relevant, stressing differences as well as commonalities with rMCSs. Note that we focus entirely on dynamic approaches and do not include systems which handle heterogeneous information in a static setting. An interesting example of the latter type are Lierler and Truszczyński's abstract modular systems [33]. In a nutshell, modular systems realize the communication between different reasoning modules through joint vocabularies rather than bridge rules. These systems are best viewed as alternatives to classical MCSs. It is an open question how to adapt them to a dynamic setting.
     </paragraph>
     <paragraph>
      Since rMCSs have been designed for applications involving stream reasoning, we will first consider two recent approaches for stream reasoning, namely LARS [7] and STARQL [37]. Then, we consider EVOLP [2], a framework that focuses on dynamics in the form of updates in the restricted setting of generalized logic programs building on similar notions as the operator next used for rMCSs. Finally, we consider asynchronous multi-context systems [19], and also reactive ASP [23], [8].{sup:5}
     </paragraph>
     <section label="7.1">
      <section-title>
       Reactive multi-context systems and stream reasoning
      </section-title>
      <paragraph>
       Reasoning over streaming data is a topic of increasing interest. Key driver is the central role that streams play in current endeavors towards the Internet of Things, the Internet of Services, as well as the vision of a fourth industrial revolution. Stream reasoning has been a prominent issue in the Semantic Web community for several years,{sup:6} and has also received substantial attention by researchers from areas such as Knowledge Representation and Reasoning and Databases lately [18].
      </paragraph>
      <paragraph>
       We consider rMCSs to be a well-suited formalism for stream reasoning that addresses important challenges that naturally arise in this context. One important benefit of rMCSs is that their managing capabilities provide a dynamic way to decide which data to keep for future reasoning and which data to drop. In this respect, rMCSs offer greater flexibility than sliding-window approaches. Nevertheless, as also demonstrated in Section 3, rMCSs can be used to implement windowing techniques.
      </paragraph>
      <paragraph>
       In the following, we consider two recently proposed frameworks for stream reasoning, LARS [7] and STARQL [37].
      </paragraph>
      <paragraph>
       LARS
      </paragraph>
      <paragraph>
       The Logic-based framework for Analyzing Reasoning over Streams (LARS) [7] aims at providing a formal declarative logical language for reasoning with streams. LARS is a rule-based formalism, whose language features not only provide different means to refer to or abstract from time, but also a novel window operator, thus providing a flexible mechanism to represent and reason with views on streaming data. The semantics of LARS is based on the FLP semantics of logic programs [20].
      </paragraph>
      <paragraph>
       Since the semantics of a LARS program is defined for a fixed input data stream and for a particular time point, it is in fact mainly static.
      </paragraph>
      <paragraph>
       Given their generality, rMCSs can be used to add a dynamic layer to LARS. In D.1 we show how that can be done by defining an rMCS with a LARS context. The system continuously feeds this context with the relevant (recent) substream of the input stream such that the LARS semantics can be computed for each time point.
      </paragraph>
      <paragraph>
       STARQL
      </paragraph>
      <paragraph>
       STARQL (pronounced Star-Q-L) [37], a framework for ontology-based stream reasoning, is developed within the Optique Project [38] that comes with a stream query language inspired by the RDF query language SPARQL [30]. Streams in this framework come in the form of timestamped Description Logic assertions. Both input as well as answers of STARQL queries are streams of this kind. Unlike the related language continuous SPARQL (C-SPARQL) [6], STARQL goes beyond RDF semantics and allows for DL reasoning.
      </paragraph>
      <paragraph>
       Due to the abstract nature of rMCSs, there are many ways to realize STARQL queries as rMCSs. One such way would be to assume a correspondence of one equilibrium computation per STARQL query evaluation. In that case, STARQL input stream and time stamps can be represented using rMCSs input streams, and rMCSs contexts can be devised to handle the different components of a STARQL query. We illustrate the realization in detail in D.1.
      </paragraph>
     </section>
     <section label="7.2">
      <section-title>
       EVOLP
      </section-title>
      <paragraph>
       The framework of evolving logic programs EVOLP [2] is a powerful approach for modeling updates of (propositional) generalized logic programs. Evolving logic programs are defined as general logic programs built over a special language which allows them to express self-evolution. For that, the language includes a reserved unary predicate, assert, whose argument may itself be a full-blown rule, thus making arbitrary nesting possible. The idea of EVOLP is that programs can update their own rules thus describing their possible self-evolution. Moreover, besides self-evolution, evolving logic programs also consider evolution caused by the addition of external rules.
      </paragraph>
      <paragraph>
       The semantics of evolving logic programs is based on sequences of interpretations, called evolution stable models.
      </paragraph>
      <paragraph>
       Given their general nature, rMCSs can capture EVOLP in such a way that equilibria streams of an rMCS correspond to the evolution stable models of evolving logic programs as we demonstrate in D.2. At the heart of this correspondence between evolution stable models in EVOLP and equilibria streams for rMCSs is the fact that, conceptionally, the operators next and assert are rather similar.
      </paragraph>
     </section>
     <section label="7.3">
      <section-title>
       Reactive ASP
      </section-title>
      <paragraph>
       Closely related to EVOLP are the two frameworks of Reactive ASP, one implemented as a solver oclingo[23] and one described in [8]. The system oclingo extends an ASP solver for handling external modules provided at runtime by a controller. The output of these external modules can be seen as the observations of EVOLP. Unlike the observations in EVOLP, which can be rules, external modules in oclingo are restricted to produce atoms so the evolving capabilities are very restricted. On the other hand, oclingo permits committing to a specific answer set at each state for the sake of efficiency, a feature that is not part of EVOLP. Reactive ASP as described in [8] can be seen as a more straightforward generalization of EVOLP where operations other than assert for self-updating a program are permitted. Since EVOLP can be captured by rMCSs, and since rMCSs permit several (evolution) operations in the head of bridge rules, it should be clear that Reactive ASP as described in [8] can be captured by rMCSs.
      </paragraph>
     </section>
     <section label="7.4">
      <section-title>
       Asynchronous multi-context systems
      </section-title>
      <paragraph>
       Asynchronous multi-context systems (aMCSs ) are a framework for loosely coupling knowledge representation formalisms and services [19]. Like rMCSs, they consist of heterogeneous contexts and are aware of continuous streams of information. However, the semantics of aMCSs is not defined in terms of equilibria but every context delivers output whenever available. Intuitively, equilibria realize a tight integration approach in which the semantics of the individual contexts are interdependent at each time point, while aMCSs do not reach this high level of integration. Rather, contexts communicate with each other by means of input and output streams over time. Consequently, instead of bridge rules that depend on system-wide equilibria, aMCSs use output rules that define which information should be sent to another context or an output stream of the overall system based on a result of a single context.
      </paragraph>
      <paragraph>
       A further difference is the role of non-determinism in the semantics of aMCSs and rMCSs. While multiple equilibria give rise to non-determinism at each step in a run, for aMCSs, all accepted belief sets of a context are computed in a consecutive way. Nevertheless, there is also a source of non-determinism in the case of aMCSs. The durations of computations and communication are taken into consideration in aMCS but their lengths are left open. Thus, the order in which contexts finish their computation can influence the system and resulting knowledge bases.
      </paragraph>
      <paragraph>
       Finally, both aMCSs and rMCSs are very general frameworks that allow for simulating Turing machines (cf. Appendix C) and thus for performing multi-purpose computations. A setup to simulate an rMCS by an aMCS has been presented in [19].
      </paragraph>
     </section>
    </section>
    <section label="8">
     <section-title>
      Conclusions
     </section-title>
     <paragraph>
      In this paper, we have introduced reactive Multi-Context Systems (rMCSs), an adaptation of multi-context systems suitable for continuous reasoning in dynamic environments, with the objective to achieve two goals at the same time: integrating heterogeneous knowledge sources and opening knowledge-based systems for dynamic scenarios in the presence of incoming information. For addressing the first goal, we have built rMCSs upon managed multi-context systems, inheriting their functionality for integrating heterogeneous knowledge sources, admitting also relevant operations on knowledge bases. To accommodate the dynamic aspects, rMCSs are equipped with several extensions. For one, bridge rules in our framework allow for input atoms to incorporate the information of multiple external streams of data. Moreover, contrary to standard MCSs which possess only one type of bridge rules modeling the information flow which needs to be taken into account when equilibria are computed (or the operations that need to be applied in case of mMCSs), rMCS have an additional, different type of bridge rules, distinguished by the occurrence of the operator next in the head. These rules are used to specify how the configuration of knowledge bases evolves whenever an equilibrium was computed providing the definition of equilibria streams which define the semantics of rMCSs over time.
     </paragraph>
     <paragraph>
      The resulting formalism is indeed very expressive offering the capabilities to model the integration of heterogeneous knowledge in the presence of incoming information in different dynamic scenarios. Based on a running example dealing with assisted living, we have demonstrated how to model such different dynamic scenarios using rMCSs and addressed several temporal aspects of modeling such as incorporating time on the object level and forgetting.
     </paragraph>
     <paragraph>
      Other real world use cases of an even larger scale can be handled as well, such as the one described in [40] where the customs service needs to assess imported cargo for a variety of risk factors including terrorism, narcotics, food and consumer safety, pest infestation, tariff violations, and intellectual property rights. Assessing this risk, even at a preliminary level, involves extensive knowledge about commodities, business entities, trade patterns, government policies and trade agreements. Some of this knowledge may be external to a given customs agency: for instance the broad classification of commodities according to the international Harmonized Tariff System (HTS), or international trade agreements. Other knowledge may be internal to a customs agency, such as lists of suspected violators or of importers who have a history of good compliance with regulations. In [40], all this extensive knowledge is encoded in ontologies based on description logics and logic programming rules under the answer set semantics, and rMCSs naturally cover these formalisms as shown, e.g., in the running example. In addition, they easily allow for the direct modular integration of information given in databases or for example business rules without the need for any prior conversion (which may not be readily available for arbitrary formalisms). While some of the knowledge in this risk assessment scenario is relatively stable, much of it changes rapidly. Changes are made not only at a specific level, such as knowledge about the expected arrival date of a shipment; but at a more general level as well. For instance, while the broad HTS code for tomatoes (0702) does not change, the full classification and tariffs for cherry tomatoes for import into the US changes seasonally. Here again, rMCSs provide mechanisms to easily make changes no matter if they are of a mere temporary nature or more persistent by using sensor data and the incorporation of knowledge via next respectively. And, unlike [40], this flexibility is achieved without having to ensure or to test whether the integrated heterogeneous knowledge is organized in so-called layers.
     </paragraph>
     <paragraph>
      Naturally, dealing with inconsistency is an important issue in dynamic settings where knowledge changes over time. Indeed, we may face different kinds of inconsistencies when using rMCSs, e.g., in the form of inconsistent sensor input for which we discuss modeling-based solutions. Another type of inconsistency is the absence of equilibria at certain time points which could potentially render an entire system useless. We have addressed this problem first by showing sufficient conditions on the contexts and the bridge rules that ensure the existence of an equilibria stream. In the cases where these conditions are not met, we have presented two possible solutions, one following an approach based on repairs – essentially the selective removal of bridge rules to regain an equilibria stream – and a second by relaxing the notion of equilibria stream to ensure that intermediate inconsistent states can be recovered. Thus, rMCSs remain usable in the face of possible inconsistencies which may always occur in real use cases where knowledge and sensor data from different sources is integrated.
     </paragraph>
     <paragraph>
      We have also addressed the non-determinism of rMCSs and discussed possibilities for avoiding it in situations where it is not desired. To this end, we have also provided a well-founded stream semantics for rMCSs. The study of computational complexity we conducted confirms worst case complexities similar to managed multi-context systems. Hence, the additional integration of sensor data does not raise the worst case complexity of reasoning with heterogeneous knowledge integrated in multi-context systems. In addition, the results confirm that if very efficient reasoning with such rich knowledge is essential, we can restrict to the well-founded stream. This implies some restrictions on the permitted expressiveness, but we have argued that often these restrictions can be accommodated.
     </paragraph>
     <paragraph>
      Finally, we compared our approach to related work. Most importantly, we have shown that rMCSs can capture two relevant approaches in stream reasoning, namely LARS [7] and STARQL [37], thus showcasing that rMCSs are indeed “defined in the right way” for the intended integration of constant streams of data.
     </paragraph>
     <paragraph>
      Regarding future work, several interesting lines of research can be considered. First, we may want to extend rMCSs to enhance their applicability in an even wider set of scenarios. Namely, one might adopt language constructs for expressing preferences in ASP such as optimization statements [24] or weak constraints [13], which assign a quality measure to equilibria. This would allow us, e.g., to improve on the potentially high non-determinism when faced with several equilibria at one time point and thus avoid having to consider a possibly huge number of different equilibria. We would also like to explore giving bridge rules access to the entire belief set of another context or an input and not just to one element. A potential application would be counting, e.g., to ask if there was no sensor reading.
     </paragraph>
     <paragraph>
      An alternative to deal with inconsistent states is to follow a paraconsistent approach, as proposed for hybrid knowledge bases in [21], [31]. Also, following the idea of EVOLP [2] as explored in [28], we could allow the bridge rules to change with time, strengthening the evolving and adaptation capabilities of rMCSs. We would also like to establish bridges to asynchronous MCSs [19], a framework for loosely coupling knowledge representation formalisms whose semantics assumes that every context delivers output whenever available. Finally, we may build on existing implementations of distributed (static) MCSs [14] for providing an implementation of rMCSs that handles the integration and evolution of distributed, heterogeneous knowledge with incoming streams of data and reasoning over such integration.
     </paragraph>
     <paragraph>
      The framework introduced in this paper is highly abstract. Needless to say this was our intention. We wanted to capture a wide range of situations without imposing any restrictions on the KR formalisms used. It is a matter of the application to choose the best suited formalisms to solve a specific task. The downside of this generality, of course, is that the framework as such needs to be instantiated in various ways before it is ready-to-use. In particular, we need to select the context logics and define the ways in which contexts and dynamic information interact by specifying adequate bridge rules. We still believe our approach provides a valuable - and to the best of our knowledge unique – solution to the problems outlined in the introduction, that is, problems which originate in the heterogeneous and dynamic nature of the information available in many challenging applications.
     </paragraph>
    </section>
   </content>
   <appendices>
    <section label="Appendix A">
     <section-title>
      Proofs inconsistency management
     </section-title>
     <paragraph label="Proof">
      Let{a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉be an acyclic rMCS such that every{a mathematical formula}Ci,{a mathematical formula}1≤i≤n, is totally coherent, and{a mathematical formula}KBa configuration of knowledge bases for M. Then, M is strongly consistent with respect to{a mathematical formula}KB.Let {a mathematical formula}M=〈〈C1,…,Cn〉,IL,〈BR1,…,BRn〉〉 be an acyclic rMCS with totally coherent contexts. We first prove that M has an equilibrium given {a mathematical formula}KB and {a mathematical formula}I, for any knowledge base configuration {a mathematical formula}KB=〈kb1,…,kbn〉 for M and input {a mathematical formula}I for M.We prove this by induction on the number of contexts of M, making use of the following simple observation: if M does not have cycles, then there exists some {a mathematical formula}i∈{1,…,n} such that {a mathematical formula}refr(j,i) does not hold for any {a mathematical formula}j∈{1,…,n} and {a mathematical formula}r∈BRj, where {a mathematical formula}refr(j,i) holds precisely when r is a bridge rule of context {a mathematical formula}Cj and {a mathematical formula}i:b occurs in the body of r. It is quite easy to see that if this condition is violated then a cycle necessarily exists.Let {a mathematical formula}n=1. Then, since there are no cycles, no bridge rule in {a mathematical formula}BR1 contains atoms of the form {a mathematical formula}1:b in its body. Thus, {a mathematical formula}appinow(I,B) does not depend on {a mathematical formula}B. Total coherence then immediately implies that M has an equilibrium given {a mathematical formula}KB and {a mathematical formula}I.Let {a mathematical formula}n=m+1. We use the above observation, and assume, w.l.o.g., that {a mathematical formula}C1 is a context for which {a mathematical formula}refr(j,1) does not hold for any {a mathematical formula}j∈{1,…,m+1} and {a mathematical formula}r∈BRj. Then, the rMCS {a mathematical formula}M⁎=〈〈C2,…,Cm+1〉,IL,〈BR2,…,BRm+1〉〉 has m contexts and it is still acyclic. By induction hypothesis, we can conclude that {a mathematical formula}M⁎ has an equilibrium given {a mathematical formula}KB⁎=〈kb2,…,kbm+1〉 and {a mathematical formula}I. Let {a mathematical formula}B⁎=〈B2,…,Bm+1〉 be such equilibrium. Then, since {a mathematical formula}C1 is assumed to be a totally coherent context, there exists {a mathematical formula}B1∈BS1 such that {a mathematical formula}B=〈B1,B2,…,Bn〉 is an equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I. This follows easily from the fact that no set {a mathematical formula}appinow(I,B) depends on the choice of {a mathematical formula}B1.We have shown that the existence of an equilibrium for M is independent of the given knowledge base configuration {a mathematical formula}KB for M and input {a mathematical formula}I for M. This immediately implies that for any input stream {a mathematical formula}I for M (until τ), and any knowledge base configuration {a mathematical formula}KB for M, there exists an equilibria stream of M given {a mathematical formula}KB and {a mathematical formula}I.
     </paragraph>
     <paragraph label="Proof">
      Every equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}Iis a repaired equilibria stream of M given{a mathematical formula}KB,{a mathematical formula}Iand the empty repair{a mathematical formula}R∅.This result follows easily from the observation that {a mathematical formula}M[R∅]=M. In this case the conditions in the definition of an equilibria stream of M coincide with those in the definition of a repaired equilibria stream of M.
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}M=〈〈C1,…,Cn〉,IL,BR〉be an rMCS such that each{a mathematical formula}Ci,{a mathematical formula}i∈{1,…,n}, is totally coherent,{a mathematical formula}KBa configuration of knowledge bases for M, and{a mathematical formula}Ian input stream for M until τ. Then, there exists{a mathematical formula}R:[1..τ]→2brMand{a mathematical formula}B:[1..τ]→BelMsuch that{a mathematical formula}Bis a repaired equilibria stream given{a mathematical formula}KB,{a mathematical formula}Iand{a mathematical formula}R.Since each context of M is totally coherent, Proposition 1 guarantees the existence of an equilibrium if M is acyclic. Now just note that if we take {a mathematical formula}R:[1..τ]→2brM such that {a mathematical formula}Rt=brM for every t, then each {a mathematical formula}M[Rt] does not have bridge rules and it is therefore acyclic. Then, for every t, {a mathematical formula}M[Rt] is strongly consistent. Therefore we can easily inductively construct {a mathematical formula}B:[1..τ]→BelM such that {a mathematical formula}B is a repaired equilibria stream given {a mathematical formula}KB, {a mathematical formula}I and {a mathematical formula}R.
     </paragraph>
     <paragraph label="Proof">
      Every equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}Iis a partial equilibria stream of M given{a mathematical formula}KBand{a mathematical formula}I.This result follows easily from the observation that for an equilibria stream {a mathematical formula}B of M given {a mathematical formula}KB and {a mathematical formula}I, and every t, {a mathematical formula}Bt is never undefined. Therefore, in this case the conditions in the definition of partial equilibria stream coincide with those for equilibria stream.
     </paragraph>
     <paragraph label="Proof">
      Let M be an rMCS,{a mathematical formula}KBa configuration of knowledge bases for M, and{a mathematical formula}Ian input stream for M until τ. Then, there exists{a mathematical formula}B:[1..τ]↛BelMsuch that{a mathematical formula}Bis a partial equilibria stream given{a mathematical formula}KBand{a mathematical formula}I.We just need to note that if we take {a mathematical formula}B:[1..τ]↛BelM such that, for every t, {a mathematical formula}Bt is undefined, then {a mathematical formula}B is trivially a partial equilibria stream given {a mathematical formula}KB and {a mathematical formula}I.
     </paragraph>
    </section>
    <section label="Appendix B">
     <section-title>
      Proofs non-determinism and well-founded semantics
     </section-title>
     <paragraph>
      We first show some properties of the iteration defined in Definition 23 that will prove useful subsequently.
     </paragraph>
     <paragraph label="Lemma 1">
      Let M be a definite rMCS given{a mathematical formula}KB, and{a mathematical formula}Ian input for M. The following holds for the iteration inDefinition 23for all ordinals α:
     </paragraph>
     <list>
      <list-item label="1.">
       M is definite given{a mathematical formula}KBα;
      </list-item>
      <list-item label="2.">
       for any ordinal β with{a mathematical formula}β≤αwe have{a mathematical formula}kbiβ⊆kbiαfor{a mathematical formula}i∈{1,…,n}.
      </list-item>
     </list>
     <paragraph label="Proof">
      We have to show that the lemma holds for all ordinals α. For the (initial) limit ordinal {a mathematical formula}α=0, Claims 1 and 2 hold trivially.Now, suppose we have shown that 1 and 2 hold for all ordinals {a mathematical formula}α1≤α. First, consider a successor ordinal {a mathematical formula}α+1. Regarding Claim 1, i.e., M being definite given {a mathematical formula}KBα+1, Condition 1 of Definition 22 holds trivially as the bridge rules are fix, and Condition 2 follows from the fact that all {a mathematical formula}kbiα are already in reduced form, and from Condition 2 of Definition 21, which prevents the introduction of reducible content by any {a mathematical formula}mngi. Regarding Claim 2, we already know by the hypothesis that this holds for α, so we only have to show that {a mathematical formula}kbiα⊆kbiα+1 holds for all i as well. As all {a mathematical formula}acci for the definite rMCS are monotonic, we also know that {a mathematical formula}Bβ⊆Bα holds for all {a mathematical formula}β≤α. In fact, this holds for any of the β just as well, i.e., there is an increasing sequence of {a mathematical formula}Bβ associated to the iteration. Now, since the rMCS is definite, hence no negation occurs in bridge rules, and {a mathematical formula}I is fix, the sequence of all {a mathematical formula}appinow(I,KBβ) for each β is also increasing. But then, by Condition 3 of Definition 21, {a mathematical formula}kbiα⊆kbiα+1 holds for all i.Now consider a limit ordinal {a mathematical formula}α′ (with {a mathematical formula}α≤α′). Since in this case, all {a mathematical formula}kbiα′ are just the union of all {a mathematical formula}kbiβ with {a mathematical formula}β≤α′, the Claims 1 and 2 trivially follow.
     </paragraph>
     <paragraph label="Proof">
      With the help of Lemma 1, we can show that the iteration indeed yields a unique minimal equilibrium (of M given {a mathematical formula}KB and {a mathematical formula}I). Let M be a definite rMCS given{a mathematical formula}KB, and{a mathematical formula}Ian input for M. Then{a mathematical formula}〈B1∞,…,Bn∞〉is the unique minimal equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I. We call it grounded equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I, denoted by{a mathematical formula}GE(M,KB,I).We first note that {a mathematical formula}〈B1∞,…,Bn∞〉 is indeed an equilibrium. This follows directly from the definition of equilibria (Definition 9) and the fact that the fixpoint in Definition 23 precisely matches it.Concerning minimality, suppose it is not a minimal equilibrium. Then, there is some {a mathematical formula}〈B′,…,B′〉 which is also an equilibrium such that {a mathematical formula}Bi′⊆Bi∞ for all {a mathematical formula}i∈{1,…,n} and {a mathematical formula}Bi′⊂Bi∞ for at least one i. Therefore some belief {a mathematical formula}b∈Bi∞∖Bi′ and a least ordinal α exist such that {a mathematical formula}b∈Biα. We consider a b where α is least for all such beliefs. If {a mathematical formula}α=0, then {a mathematical formula}acci(kbi0)=Bi0 and since, by Lemma 1, M is definite given {a mathematical formula}KB0, this belief set is unique, hence {a mathematical formula}B′ cannot be an equilibrium (following from monotonicity of the iteration). If {a mathematical formula}α&gt;0, then necessarily some operation in a bridge rule head, applied when creating {a mathematical formula}kbiα, triggered the occurrence of b in {a mathematical formula}acci(kbiα)=Biα. Now, as M is definite given all {a mathematical formula}KBβ in the iteration of {a mathematical formula}KB∞ and since α is least, this head is also applicable by monotonicity w.r.t. {a mathematical formula}B′. Hence, we obtain a contradiction to {a mathematical formula}B′ being an equilibrium.Regarding uniqueness, suppose it is a minimal equilibrium, but not unique. Then, there is some {a mathematical formula}〈B′,…,B′〉 which is also a minimal equilibrium such that at least one of the following holds:
     </paragraph>
     <list>
      <list-item label="•">
       neither {a mathematical formula}Bi′⊆Bi∞ nor {a mathematical formula}Bi∞⊆Bi′ for at least one {a mathematical formula}i∈{1,…,n};
      </list-item>
      <list-item label="•">
       {a mathematical formula}Bi′⊂Bi∞ and {a mathematical formula}Bj′⊃Bj∞ for {a mathematical formula}i≠j with {a mathematical formula}i,j∈{1,…,n}.
      </list-item>
     </list>
     <paragraph label="Proof">
      Every grounded equilibrium of a reducible rMCS M given{a mathematical formula}KBand an input{a mathematical formula}Iis a minimal equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I.We first show that a grounded equilibrium {a mathematical formula}B is indeed an equilibrium. For this, note that {a mathematical formula}B is the unique minimal equilibrium of the definite {a mathematical formula}M(I,B) given {a mathematical formula}KB(I,B) and {a mathematical formula}I by Definition 25 and Proposition 6. Thus, by Definition 9 and since {a mathematical formula}M(I,B) is definite, we know for all {a mathematical formula}i∈{1,…,n}:{a mathematical formula} with {a mathematical formula}kbiBi=redi(kbi,Bi) by Definition 24. Now, according to Definition 24, {a mathematical formula}M(I,B) only differs from M on the sets of bridge rules {a mathematical formula}BRi(I,B), and the way these are obtained from the {a mathematical formula}BRi ensures that {a mathematical formula}appinow(I,B) is identical for both M and {a mathematical formula}M(I,B). Moreover, by 2. of Definition 21, (B.1) can be rewritten to (for all i):{a mathematical formula} In this case, by the definition of red, we know that, (for all i),{a mathematical formula} and this shows, by Definition 9, that {a mathematical formula}B is an equilibrium.Now suppose that {a mathematical formula}B is not minimal. Then there is an equilibrium {a mathematical formula}B′=〈B1′,…,Bn′〉 of M given {a mathematical formula}KB and {a mathematical formula}I such that {a mathematical formula}Bi′⊆Bi for all i with {a mathematical formula}1≤i≤n and {a mathematical formula}Bj′⊊Bj for some j with {a mathematical formula}j∈{1…n}. Since red is antitonic by definition, we know that {a mathematical formula}redi(kbi,Bi)⊆redi(kbi,Bi′) holds for all {a mathematical formula}i∈{1,…,n}. Also, by Definition 24, {a mathematical formula}BRi(I,Bα)⊆BR′i(I,B′α) for all i. It can thus be shown by induction on α for the monotonic iteration in Definition 23 that {a mathematical formula}Biα⊆B′iα holds for all {a mathematical formula}i∈{1,…,n}:
      <list>
       {a mathematical formula}α=0: this holds right away by monotonicity of {a mathematical formula}acci for reduced knowledge bases.Suppose the claim holds for all ordinals {a mathematical formula}α1≤α.Consider a successor ordinal {a mathematical formula}α+1. As {a mathematical formula}BRi(I,Bα)⊆BR′i(I,B′α) holds, and no bridge rule contains not due to the reduction, we have, by the induction hypothesis that {a mathematical formula}appinow(I,Bα)⊆appinow(I,B′α). Then, since {a mathematical formula}mngi in the iteration cannot remove beliefs (see 3. of Definition 21), we obtain {a mathematical formula}kbiα+1⊆kb′iα+1 and thus {a mathematical formula}Biα+1⊆B′iα+1.Consider a limit ordinal {a mathematical formula}α′ with {a mathematical formula}α≤α′. As the corresponding knowledge bases are simply the union of those of all smaller ordinals, we necessarily have {a mathematical formula}kbiα′⊆kb′iα′, and thus {a mathematical formula}Biα′⊆B′iα′.So suppose that
      </list>
      <paragraph>
       {a mathematical formula}B′ is an equilibrium, but not grounded. Then we know that, by Definition 9, for all {a mathematical formula}i∈{1,…,n}:{a mathematical formula} In this case, by the definition of red, we have for all i:{a mathematical formula} Therefore, by 2. of Definition 21:{a mathematical formula} Now, the {a mathematical formula}kbi0 used in the iteration of {a mathematical formula}Biα are precisely the {a mathematical formula}redi(kbi,Bi′) for all i. As argued in the proof of Lemma 1, the sequence of operations in the iteration is monotonically increasing. We consider two cases. First, the sequence reaches {a mathematical formula}appinow(I,B′). Then, for all {a mathematical formula}OPj⊆appinow(I,B′), {a mathematical formula}acci(mngi(OPj,kbiα))⊆Bi′. As {a mathematical formula}Bj′⊂B′j∞ holds for at least one {a mathematical formula}j∈{1,…,n}, the iteration has to continue beyond the step involving {a mathematical formula}appinow(I,B′), but this contradicts {a mathematical formula}B′ being an equilibrium. Alternatively, the sequence does not reach a step with precisely the operations in {a mathematical formula}appinow(I,B′). In this case, there is a least ordinal such that an operation not contained in {a mathematical formula}appinow(I,B′) occurs in the iteration, but this again contradicts that {a mathematical formula}B′ is an equilibrium following the argument applied in the proof of Proposition 6.
      </paragraph>
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}M=〈C,IL,BR〉be a normal, reducible rMCS given{a mathematical formula}KB,{a mathematical formula}Ian input for M,{a mathematical formula}WF(M,KB,I)=〈W1,…Wn〉, and{a mathematical formula}B=〈B1,…,Bn〉a grounded equilibrium of M given{a mathematical formula}KBand{a mathematical formula}I. Then{a mathematical formula}Wi⊆Bifor{a mathematical formula}i∈{1…n}.We show the claim by proving that {a mathematical formula}(γM,KB,I)2↑α)i⊆Bi holds for all grounded equilibria {a mathematical formula}B of M given {a mathematical formula}KB and {a mathematical formula}I. For the case {a mathematical formula}α=0, this holds trivially, as the initial belief state is {a mathematical formula}B⁎.Suppose the claim holds for all ordinals {a mathematical formula}α1≤α. Consider a successor ordinal {a mathematical formula}α+1. If {a mathematical formula}(γM,KB,I)2↑α=(γM,KB,I)2↑(α+1) then the claim trivially holds by the induction hypothesis. Thus, suppose that {a mathematical formula}(γM,KB,I)2↑α⊂(γM,KB,I)2↑(α+1), i.e., new beliefs are added in the step {a mathematical formula}α+1 for (at least) some i. Using Definition 23 and the induction hypothesis, it can be shown that these new beliefs are indeed contained in each grounded equilibrium, while all beliefs that do not occur in the intermediate fixpoint of the squared operator are not true in any grounded equilibrium of M given {a mathematical formula}KB and {a mathematical formula}I, in the very same way as usual for the alternating fixpoint, as e.g., for logic programs, on which this construction is based.Finally, regarding a limit ordinal {a mathematical formula}α′ with {a mathematical formula}α≤α′, the claim holds trivially by the induction hypothesis.
     </paragraph>
    </section>
    <section label="Appendix C">
     <section-title>
      Proofs complexity
     </section-title>
     <paragraph label="Proof">
      Table 1summarizes the complexities of membership of problems{a mathematical formula}Q∃and{a mathematical formula}Q∀for finite input steams (until some{a mathematical formula}τ∈N) depending on the context complexity. Hardness also holds if it holds for the context complexity.The membership results for the {a mathematical formula}Q∃ cases (with the exception of {a mathematical formula}CC(M,k:b)=EXPTIME) can be argued for as follows: a non-deterministic Turing machine can be used to guess a projected belief state {a mathematical formula}Bt=〈B1,…,Bn〉 for all τ inputs in {a mathematical formula}I in polynomial time. Then, iteratively for each of the consecutive inputs {a mathematical formula}It, first the context problems can be solved either polynomially or using an oracle for the context complexity (the guess of {a mathematical formula}Bt and the oracle guess can be combined which explains why we stay on the same complexity level for higher context complexity). If the answer is ‘yes’, {a mathematical formula}Bt is the projected equilibrium. We can check whether {a mathematical formula}b∈Bi, compute the updated knowledge bases and continue the iteration until reaching the last input. For PSPACE the same line of argumentation holds as {a mathematical formula}PSPACE=NPSPACE. In the case of {a mathematical formula}CC(M,k:b)=EXPTIME, we iterate through the exponentially many projected belief states for which we solve the context problem in exponential time and proceed as before. The argument is similar for the co-problem of {a mathematical formula}Q∀. Hardness holds because being able to solve {a mathematical formula}Q∃, respectively the co-problem of {a mathematical formula}Q∀, one can decide equilibrium existence for managed MCSs which is hard for the same complexity classes [10] given hardness for the context complexity of the managed MCS.
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}M=〈C,IL,BR〉be a finite, persistently reducible rMCS given{a mathematical formula}KB. Then membership and hardness results for{a mathematical formula}Q∃gand{a mathematical formula}Q∀gon grounded equilibria streams for finite input streams coincide with those for{a mathematical formula}Q∃and{a mathematical formula}Q∀inTheorem 1.As M is assumed to be finite and persistently reducible, the argument is exactly identical to that of Theorem 1. The only difference is here that we also have to guess the intermediate belief states in the iteration, but this does not raise the (worst-case) complexity itself.
     </paragraph>
     <paragraph label="Proof">
      Let{a mathematical formula}M=〈C,IL,BR〉be a finite, normal, persistently reducible rMCS given{a mathematical formula}KBsuch that{a mathematical formula}CC(M,k:b)=Pfor{a mathematical formula}Q∃wf. Then,{a mathematical formula}Q∃wfis inP. In addition, hardness holds provided{a mathematical formula}CC(M,k:b)=Pis hard.If {a mathematical formula}CC(M,k:b)=P, then deciding all context problems is polynomial. Also, no guessing of equilibria is required, as each equilibrium can be computed iteratively in polynomial time starting from the belief state containing all least elements of each belief set. Since the context complexity also determines the complexity of performing the update function to obtain the new configuration of knowledge bases, we conclude that the result holds. The result for hardness follows in the same manner as in the proofs of Theorem 1, Theorem 2.
     </paragraph>
     <paragraph label="Definition 31">
      Finally, to demonstrate the expressiveness of rMCSs and prove Proposition 9 we provide an rMCS {a mathematical formula}MTM that implements a service that reads the configuration of a Turing machine (TM) from external sources and simulates a run of the TM on request. The fixed rMCS {a mathematical formula}MTM comes with inexpressive context logics and management functions computable in linear time, thus showing that Turing-completeness arises from the interplay between the contexts over time. We use the following variant of TMs, where {a mathematical formula}S is the set of all tape symbols and {a mathematical formula}Q is the set of all states: A TM is a tuple {an inline-figure}, where
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}Q⊆Q is a finite, non-empty set of states,
      </list-item>
      <list-item label="•">
       {a mathematical formula}Γ⊆S is a finite, non-empty set of tape symbols,
      </list-item>
      <list-item label="•">
       {an inline-figure} is the blank symbol,
      </list-item>
      <list-item label="•">
       {a mathematical formula}Σ⊆Γ is the set of input symbols,
      </list-item>
      <list-item label="•">
       {a mathematical formula}q0 is the initial state,
      </list-item>
      <list-item label="•">
       {a mathematical formula}F⊆Q is the set of final states, and
      </list-item>
      <list-item label="•">
       {a mathematical formula}δ:Q∖F×Γ→Q×Γ×{←,→} is the (partial) transition function.
      </list-item>
     </list>
     <paragraph>
      We assume familiarity with the computation model of TMs, in particular what it means that a TM halts and accepts an input word {a mathematical formula}w∈Σ⁎. {a mathematical formula}MTM is an rMCS with four contexts. Context {a mathematical formula}Ct simulates a tape of a TM, {a mathematical formula}Cq contains information about TM states, {a mathematical formula}Cf encodes a transition function, and {a mathematical formula}Cc is a control context for operating the TM simulation and presenting results. All contexts use a storage logic as in Example 1, where the set of entries is respectively given by
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}Et=⋃p∈Z,s∈S{t(p,s),curP(p)},
      </list-item>
      <list-item label="•">
       {a mathematical formula}Eq=⋃q∈Q{final(q),curQ(q)},
      </list-item>
      <list-item label="•">
       {a mathematical formula}Ef={f(q,s,q′,s′,m)|q,q′∈Q,s,s′∈S,m∈{L,R}}, and
      </list-item>
      <list-item label="•">
       {a mathematical formula}Ec={computing,answer(yes),answer(no)}.
      </list-item>
     </list>
     <paragraph>
      The input of {a mathematical formula}MTM is provides by four streams over the languages
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}ILt=Et,
      </list-item>
      <list-item label="•">
       {a mathematical formula}ILq=Eq,
      </list-item>
      <list-item label="•">
       {a mathematical formula}ILf=Ef, and
      </list-item>
      <list-item label="•">
       {a mathematical formula}ILc={start,reset},
      </list-item>
     </list>
     <paragraph>
      where {a mathematical formula}ILt allows for setting an initial configuration for the tape, {a mathematical formula}ILq the allowed and final states of the TM to simulate, {a mathematical formula}ILf the transition function, and input over {a mathematical formula}ILc is used to start and reset the simulation.
     </paragraph>
     <paragraph>
      The bridge rule schemata of the tape context {a mathematical formula}Ct are given by:{a mathematical formula} The bridge rule schemata for the state context {a mathematical formula}Cq are the following:{a mathematical formula} The state {a mathematical formula}Cf for the transition function has the bridge rules schemata given next:{a mathematical formula} Finally, the schemata for {a mathematical formula}Cc are:{a mathematical formula} All contexts use the following management function:{a mathematical formula}
     </paragraph>
     <paragraph>
      Let {an inline-figure} be a TM and {a mathematical formula}w∈Σ⁎ an input word for T. We want to use {a mathematical formula}MTM with input stream {a mathematical formula}I to simulate T. Assume we start at time t. We first make sure that all knowledge bases are empty by setting {a mathematical formula}Ict={reset}. This activates the bridge rules in all contexts of {a mathematical formula}MTM that derive {a mathematical formula}next(clear). As a consequence, at time {a mathematical formula}t+1 the contents of all knowledge bases are deleted. Next, we feed T and w to {a mathematical formula}MTM by sending
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}final(q) for all {a mathematical formula}q∈F and {a mathematical formula}curQ(q0) on the input stream q,
      </list-item>
      <list-item label="•">
       {a mathematical formula}f(q,s,q′,s′) iff {a mathematical formula}δ(q,s)=〈q′,s′〉 on stream f, and
      </list-item>
      <list-item label="•">
       {a mathematical formula}curP(0) and {a mathematical formula}t(p,s) iff {a mathematical formula}s=sp for {a mathematical formula}w=s0,s1,s2,… on the tape stream t.
      </list-item>
     </list>
     <paragraph>
      Note that it does not matter whether we do this all at once at time {a mathematical formula}t+1 or scattered over multiple time points greater than t. Assume that we finished to incorporate all this information to the knowledge bases at time {a mathematical formula}t′. Then, we set {a mathematical formula}Icj={start} to initiate the simulation of T. At time {a mathematical formula}t′+1 the entry computing is contained in the knowledge base of context {a mathematical formula}Cc, activating the bridge rules in all contexts that are responsible for the simulation. From now on, depending on the current state {a mathematical formula}curQ(q) and the transition function, the bridge rules of tape context {a mathematical formula}Ct always change the content of the tape on the current tape position indicated by {a mathematical formula}curP(p). A new position {a mathematical formula}p′ of the tape head indicated by the transition function is reflected by deriving {a mathematical formula}nextP(p′). If such a belief is in the equilibrium so is nextPdefined and {a mathematical formula}curP(p′) is added at the next time point. For context {a mathematical formula}Cq the current state is updated according to the transition function. Note that the auxiliary belief nextPdefined is also used in the bridge rules of context {a mathematical formula}Cc for indicating that if the current state is not final and the transition function is undefined for the current state and input symbol, then the answer of the TM is no, indicated by {a mathematical formula}answer(′N′). Conversely, if we arrive at a final state then {a mathematical formula}answer(′Y′) is derived. If T does not halt on input w, then also the simulation in {a mathematical formula}MTM will continue forever, unless we stop the computation by sending reset on input stream {a mathematical formula}Ic once more.
     </paragraph>
    </section>
    <section label="Appendix D">
     <section-title>
      Comparative studies
     </section-title>
     <paragraph>
      In this part, selected related approaches are compared to rMCS in more detail by demonstrating how they can be implemented in our framework.
     </paragraph>
     <section label="D.1">
      <section-title>
       Reactive multi-context systems and stream reasoning
      </section-title>
      <paragraph>
       In the following, we relate rMCSs to two the frameworks for stream reasoning discussed in Section 7.1 by demonstrating how tasks suited for these approaches can be solved by an rMCS. Here, we focus at presenting the intuition on how problems can be modeled in the different approaches rather than presenting formal translations between them. As the involved frameworks are quite general, it would only make sense to look at technical mappings for well-defined restrictions of the general settings, which would limit their value for a general comparison. Moreover, such formal translations would have to mainly deal with bridging technical differences in semantics (e.g., between the equilibrium semantics of rMCS and the FLP semantics used in [7]) rather than giving insight into how we can model stream reasoning tasks in the respective approaches.
      </paragraph>
      <paragraph>
       LARS
      </paragraph>
      <paragraph>
       The LARS language [7] is built over a set of atoms {a mathematical formula}A defined over disjoint sets of predicates {a mathematical formula}P and constants {a mathematical formula}C as usual, where {a mathematical formula}P is divided into two disjoint subsets, the extensional predicates{a mathematical formula}PE, and the intensional predicates{a mathematical formula}PI. The former is intended to be used for input streams, and the latter for intermediate and output streams.
      </paragraph>
      <paragraph>
       Given {a mathematical formula}i,j∈N, an interval is a set of the form {a mathematical formula}[i,j]={k∈N|i≤k≤j}. An evaluation function over an interval T is a function {a mathematical formula}v:N→2A such that {a mathematical formula}v(t)=∅ if {a mathematical formula}t∉T. Then, a stream in LARS is a tuple {a mathematical formula}s=〈T,v〉, where T is an interval and v is an evaluation function over T. A stream is a data stream if it contains only extensional atoms. A stream {a mathematical formula}S=〈T,v〉 is a substream of a stream {a mathematical formula}S′=〈T′,v′〉, denoted by {a mathematical formula}S⊆S′, if {a mathematical formula}T⊆T′ and {a mathematical formula}v(t)⊆v′(t) for all {a mathematical formula}t∈T.
      </paragraph>
      <paragraph>
       The formulas of LARS are defined using the following grammar:{a mathematical formula} where {a mathematical formula}a∈A and {a mathematical formula}t∈N. The connectives {a mathematical formula}¬,∧,∨ and → are the usual classical connectives. Similarly to modal logics, the operators ⋄ and □ are used to represent that a formula holds for some and for each time instant within some interval for a given stream, respectively. The exact operator {a mathematical formula}@t represents the reference to some specific time {a mathematical formula}t∈N, and window operators of the form {a mathematical formula}⊞ιx allow focusing on more recent substreams, where ι represents the type of window and x the tuple of parameters for the respective type. Among the operators presented in [7] are, for example, time-based operators {a mathematical formula}⊞τn, which allow focusing on the last n time instants of a given stream, or the partition-based operators {a mathematical formula}⊞pidx,n, which first split the stream into substreams and then allow focusing on the last n tuples of a particular substream. LARS programs are based on rules composed of such LARS formulas in a way similar to those in logic programming. More precisely, a LARS rule is of the form{a mathematical formula} where {a mathematical formula}α,β1,…,βn are formulas and α contains only intentional predicates.
      </paragraph>
      <paragraph>
       Consider a simplified version of the example in [7] that models a scenario where we want to reason about a tram network, including, for example, the prediction of the expected arrival time of a tram at some stop. The key idea is that such information should not only depend on a fixed timetable, but also dynamically on real-time information about the arrival time at a previous stop and the expected travel time between stations (which heavily depends on real-time traffic jam information). LARS allows such combination of static knowledge with a stream of information. Here, static knowledge is composed of atoms of the form {a mathematical formula}plan(L,X,Y,T), where L is the line identifier, X and Y are consecutive tram stops on line L, and T is the expected travel time between X and Y, and atoms of the form {a mathematical formula}line(Id,L) mean that the tram Id operates on line L. The stream of information contains atoms of the form {a mathematical formula}tram(Id,X) meaning that tram Id is at stop X, and atoms of the form {a mathematical formula}jam(X) meaning that there is a traffic jam near station X. Consider the following example of a LARS rule:{a mathematical formula} The intuitive idea of the above rule is that the tram is expected to arrive at stop Y at time T whenever five conditions are met: i) the fact that tram Id stopped at X at time {a mathematical formula}T1 is the last information about stops of Id in the stream; ii) X and Y are consecutive stops of line L; iii) {a mathematical formula}T−T1 is the travel time between X and Y; iv) the tram Id is operating on line L; and v) there is no information about traffic jams near station X within the last 20 minutes. Note that the use of default negation not allows for the representation of exceptions, whereas the partition-based operator {a mathematical formula}⊞pidx,1 allows for the focus on the last item of the form {a mathematical formula}tram(X) in the stream, and the time-based operator {a mathematical formula}⊞τ20 allows for the focus on the last 20 time instants of the stream.
      </paragraph>
      <paragraph>
       The semantics of LARS is based on the FLP semantics of logic programs [20]. Given an input stream {a mathematical formula}D=〈T,v〉 and time point {a mathematical formula}t∈T, each LARS program P is associated with a set of streams, the answer streams of P for D at t. Since the semantics of a LARS program is defined for a fixed input data stream and for a particular time point, it is in fact mainly static.
      </paragraph>
      <paragraph>
       We now describe how rMCSs can be used to run a LARS program over a (possibly infinite) input stream. The idea is to define an rMCS with a LARS context and a recent substream of a (possibly infinite) input stream (in the sense of rMCSs). At each time point, the knowledge base of the LARS context contains the LARS program and the relevant substream of the input stream. Then, the answer streams of the program given the available data stream and the current time point can be computed.
      </paragraph>
      <paragraph>
       More precisely, we assume fixed sets of predicates {a mathematical formula}P and constants {a mathematical formula}C, a fixed window size {a mathematical formula}w∈N and a LARS program P over {a mathematical formula}A, the set of atoms obtained from {a mathematical formula}P and {a mathematical formula}C. Let {a mathematical formula}AE be the set of atoms that include only extensional predicates from {a mathematical formula}PE, and {a mathematical formula}AT be the set of time-tagged atoms, i.e., {a mathematical formula}AT={〈a,t〉|a∈A and t∈N}.
      </paragraph>
      <paragraph>
       Consider the rMCS {a mathematical formula}M=〈〈CLARS〉,〈IL1,Clock〉,〈BRCLARS〉〉 obtained from P and w in the following way:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}CLARS=〈L,OP,mng〉 where
       </list-item>
       <list-item label="•">
        {a mathematical formula}L=〈KB,BS,acc〉 is such that
       </list-item>
       <list-item label="•">
        {a mathematical formula}KB={P∪A∪{now(t)}|A⊆AT and t∈N}
       </list-item>
       <list-item label="•">
        {a mathematical formula}BS={S|S is a stream for A}
       </list-item>
       <list-item label="•">
        {a mathematical formula}acc(kb)={S|S is an answer stream of P for Dkb at time tkb}
       </list-item>
       <list-item label="•">
        {a mathematical formula}OP={add(δ)|δ∈AT}∪{del(δ)|δ∈AT}∪{add(now(t))|t∈N}
       </list-item>
       <list-item label="•">
        {a mathematical formula}mng(kb,op)=(kb∪{δ|add(δ)∈op})∖{δ|del(δ)∈op}
       </list-item>
       <list-item label="•">
        {a mathematical formula}IL1=AE
       </list-item>
       <list-item label="•">
        {a mathematical formula}Clock=N
       </list-item>
       <list-item label="•">
        {a mathematical formula}BRCLARS contains the following rules for managing history:
       </list-item>
      </list>
      <paragraph>
       Given an input stream {a mathematical formula}I for M and a time point {a mathematical formula}t∈N, we consider {a mathematical formula}ttI, the unique element of stream {a mathematical formula}Clock at step t, which represents the current time at step t. We also consider the LARS input data stream at time t, {a mathematical formula}DtI=〈T,v〉, such that {a mathematical formula}T=[ttI−w,ttI] and {a mathematical formula}v(t′)={a∈AE| there exists t″≤t such that t′=tt″I and a∈I1t″} for {a mathematical formula}t′∈T, and {a mathematical formula}v(t′)=∅ otherwise. Then, given an input stream {a mathematical formula}I for M, at each time point {a mathematical formula}t∈N, each equilibria stream {a mathematical formula}B for M given {a mathematical formula}KB=〈{P}〉 and {a mathematical formula}I is composed of an answer stream of P for {a mathematical formula}DtI at time {a mathematical formula}ttI.
      </paragraph>
      <paragraph>
       Note that at each time instant the knowledge base contains only the relevant part of the (possibly infinite) input stream, meaning that information no longer valid is really discarded, and that the current time, given by the stream {a mathematical formula}Clock, is decoupled from the time steps at which equilibria are evaluated. For the sake of presentation, we have assumed a fixed time window w, yet an extension in the spirit of what we presented in Section 3.5 can easily be imagined.
      </paragraph>
      <paragraph>
       STARQL
      </paragraph>
      <paragraph>
       Streams in the STARQL framework [37] come in the form of timestamped Description Logic assertions (called ABox assertions). Both, input as well as answers of STARQL queries are streams of this kind. A STARQL select expression is structured as follows.{a mathematical formula} For a comprehensive description of syntax and semantics of STARQL, we refer to Optique Deliverable 5.1 [37]. We make use of an example (partly taken from [37]) to explain components of STARQL queries and to describe the core aspects that are relevant for us. It is based on the following STARQL query that creates an output stream S_out that indicates temperature sensors whose readings were monotonically increasing for the past two seconds.{a mathematical formula} The considered input stream contains readings of sensors {a mathematical formula}s0, {a mathematical formula}s1:{a mathematical formula} In addition, the TBox at http://example.org/TBox contains the axiom{a mathematical formula} stating that every BurnerTipTempSensor is a temperature sensor, and the ABox at http://example.org/Astatic contains the assertion{a mathematical formula} stating that {a mathematical formula}s0 is of type BurnerTipTempSensor. The other sensor {a mathematical formula}s1 is thus not (derivable to be) a temperature sensor.
      </paragraph>
      <paragraph>
       Taking S as input, the query returns the output stream, represented here as a sequence of timestamped ABox assertions:{a mathematical formula} We observe that temperature sensor {a mathematical formula}s0 had two seconds of monotonic readings at time points 0s, 1s, 2s, and 5s. The FROM part of the query specifies that we consider S as input where the window expression 0s&lt;-[NOW-2s, NOW]-&gt;1s states that, at time point t of the evaluation, we are interested in assertions with a time stamp between {a mathematical formula}t−2s and t. The slide parameter (specified by -&gt;1s) expresses that every second the window moves forward in time. We also assume a pulse of one second, i.e., one query evaluation per second. In STARQL, such a pulse can be defined by a pulse expression declared separately from the SELECT query. The so-called slack parameter for handling out-of-order stream assertions is assumed to be zero (0s&lt;-) and not used in the initial version of STARQL.
      </paragraph>
      <paragraph>
       The input stream data that falls into the window is gathered in a temporal ABox, i.e., a set of timestamped ABox assertions:{a mathematical formula} Variable bindings for {a mathematical formula}x→ in the condition {a mathematical formula}Ψ(x→) of the WHERE clause of a query are determined by finding the certain answers for {a mathematical formula}x→ with respect to the ontology formed by the static ABoxes and TBoxes provided by the USING clause. In our example, that means that the variable ?sens is bound to the sensor named {a mathematical formula}s0, because the TBox at http://example.org/TBox together with ABox http://example.org/Astatic identify only this sensor to be a temperature sensor.
      </paragraph>
      <paragraph>
       The SEQUENCE directive of the query defines how to cluster the information in the temporal ABox obtained as above into a sequence of ABoxes. In the basic STARQL version, the only method for doing so is StdSeq which separates the assertions based on their timestamp. For example, at time 2s we get a sequence of three ABoxes: {a mathematical formula}{rd(s0,90),rd(s1,30)}〈1〉, {a mathematical formula}{rd(s0,93),rd(s1,32)}〈2〉, and {a mathematical formula}{rd(s0,94)〈3〉}. Note that the absolute timestamps are replaced by natural numbers marking the ordinal position of the ABox in the sequence.
      </paragraph>
      <paragraph>
       The HAVING clause of the query specifies a condition {a mathematical formula}Φ(x→,y→) that has to hold for this sequence of ABoxes, taking also the ontology parts from the USING clause into consideration. The variables in {a mathematical formula}x→ have already been bound by the WHERE clause, so here ?sens is being bound to {a mathematical formula}s0. The HAVING condition can either bind the remaining open variables in {a mathematical formula}y→ or, as in the example, act as a boolean condition when there are no further open variables. Here, the condition is true if, for all numbers i, j of the sequence (that is from {a mathematical formula}{1,2,3}) with i ≤ j, the condition holds that if there are sensor readings of {a mathematical formula}s0 in the ABoxes with sequence positions i and j, then the reading in ABox i is smaller or equal than that of ABox j.
      </paragraph>
      <paragraph>
       Finally, the expression following the SELECT keyword determines the form of the output stream. For every evaluation time in which the HAVING clause holds, an ABox assertion in the form of an RDF triple {?sens rdf:type MonIncTemp}&lt;NOW&gt; augmented with a timestamp is returned where ?sens is replaced by {a mathematical formula}s0 and NOW by the evaluation time.
      </paragraph>
      <paragraph>
       We want to illustrate next how STARQL queries can be realized as rMCSs (Fig. 4). Certainly, due to the abstract nature of rMCSs, there are many different ways to do so. Here, we aim at a setting where we assume a correspondence of one equilibrium computation per STARQL query evaluation, i.e., in our example there is one equilibrium evaluation per second. We assume one rMCS input stream {a mathematical formula}IS that corresponds to the STARQL input stream and one rMCS input stream {a mathematical formula}Ic that provides the current time as in Section 3.3. The data in {a mathematical formula}IS can either be timestamped assertions such as in the original STARQL approach, or unstamped raw data (such as pure sensor values) that will be automatically time-stamped by bridge rules using the current time provided by {a mathematical formula}Ic. While in the former approach it is possible to have timestamps in the current input that differs from the current time, such a situation is avoided with unstamped data. Both variants have their place and purpose. Here, we assume unstamped data.
      </paragraph>
      <paragraph>
       We reserve one rMCS context {a mathematical formula}CtA for the temporal ABox containing the data currently in the window. Its bridge rules add new data from {a mathematical formula}IS and timestamp it similar as in Section 3.3. Moreover, other bridge rules ensure that data not “visible” in the window is deleted from {a mathematical formula}CtA.
      </paragraph>
      <paragraph>
       There is one context {a mathematical formula}Cw that computes the variable bindings of the WHERE clause. Its knowledge base is a description logic ontology and its bridge rules import assertions and axioms according to the USING clause of the STARQL query. Thus, we assume that each static ABox and TBox mentioned in the query is available in a corresponding storage context of the rMCS. These axioms and assertions are also imported to DL contexts for evaluating the HAVING clause: we assume as many such contexts as there can be ABoxes in the sequence of ABoxes created by the SEQUENCE statement. In our example, we have three contexts of this type because there are assertions with at most three different timestamps in the temporal ABox representing the current window. Thus, the sequence operator StdSeq generates ABox sequences of at most size three. The reasoning contexts evaluate the different timepoints in the window. Fore example, the i-th context computes assignments for variable ?x of the expression { ?sens rd ?x }&lt;i&gt;. We still need to reason on top of the results for the individual DL contexts for fully evaluating the HAVING clause: In the example, this is the evaluation of the FORALL condition that ranges over different time points. This can be done with another context {a mathematical formula}Cr that also combines the results of the WHERE and HAVING clauses and produces output as specified in the SELECT statement. Thus, in an equilibrium for time t, the belief set for {a mathematical formula}Cr contains timestamped RDF triples of form {s0 rdf:type MonIncTemp}&lt;t&gt; whenever {a mathematical formula}s0 had monotonically increasing readings during the previous two seconds.
      </paragraph>
     </section>
     <section label="D.2">
      <section-title>
       EVOLP
      </section-title>
      <paragraph>
       We show that rMCSs are expressive enough to capture EVOLP [2] (discussed in Section 7.2) as a particular case. We assume a basic familiarity with logic programs as such, and only point out that a general logic program is a set of logic program rules that allow default negation in the head. Evolving logic programs are then defined as general logic programs built over a special language which allows them to express self-evolution. The language includes a reserved unary predicate, assert, whose argument may itself be a full-blown rule, thus making arbitrary nesting possible. Formally, given a propositional language {a mathematical formula}L, the extended language {a mathematical formula}Lassert over {a mathematical formula}L is defined inductively as follows:
      </paragraph>
      <list>
       <list-item label="1.">
        All propositional atoms in {a mathematical formula}L are atoms in {a mathematical formula}Lassert;
       </list-item>
       <list-item label="2.">
        if R is a rule over {a mathematical formula}Lassert then {a mathematical formula}assert(R) is an atom in {a mathematical formula}Lassert;
       </list-item>
       <list-item label="3.">
        nothing else is an atom in {a mathematical formula}Lassert.
       </list-item>
      </list>
      <paragraph>
       An evolving logic program over {a mathematical formula}L is a generalized logic program over {a mathematical formula}Lassert. We denote by {a mathematical formula}RL the set of all rules over {a mathematical formula}Lassert.
      </paragraph>
      <paragraph>
       The idea of EVOLP is that programs can update their own rules thus describing their possible self-evolution. Each self-evolution can be represented by a sequence of programs, each program corresponding to a state, and these sequences of programs can be treated as in Dynamic Logic Programs (DLPs) [1]. Dynamic logic programs are sequences {a mathematical formula}P1⊕…⊕Pn of generalized logic programs, whose semantics is based on the causal rejection principle. The idea is that the most recent rules are put in force, (where {a mathematical formula}Pn is to be seen as the most recent set of rules), and the previous rules are valid as far as possible, i.e., they are only kept if they do not conflict with more recent rules. Here, these intuitions about DLPs are sufficient, and we point to [1] for more details.
      </paragraph>
      <paragraph>
       The semantics of evolving logic programs is based on sequences of interpretations. More precisely, an evolution interpretation of length m of an evolving logic program P over a propositional language {a mathematical formula}L is a finite sequence {a mathematical formula}I=〈I1,…,Im〉 of sets of propositional atoms of {a mathematical formula}Lassert. The evolution trace associated with an evolution interpretation I is the sequence of programs {a mathematical formula}PI=〈P1,…,Pm〉 such that {a mathematical formula}P1=P and, for each {a mathematical formula}2≤j≤m, {a mathematical formula}Pj={r|assert(r)∈Ij−1}.
      </paragraph>
      <paragraph>
       Given an evolving logic program, the main intuition for the construction of a sequence of programs that corresponds to a possible evolution of P is that whenever an atom {a mathematical formula}assert(r) belongs to an interpretation in a sequence, then the rule r must belong to the program in the next state.
      </paragraph>
      <paragraph>
       Besides self-evolution, evolving logic programs also consider evolution caused by the addition of external rules. These rules, called events, are represented as a sequence of evolving logic programs. Given an evolving logic program P over {a mathematical formula}L, such an event sequence over P is a sequence of evolving logic programs over {a mathematical formula}L.
      </paragraph>
      <paragraph>
       This leads to the central model notion of evolving logic programs that also takes into account an incoming event sequence. Let P be an evolving logic program over {a mathematical formula}L, {a mathematical formula}I=〈I1,…,Im〉 an evolution interpretation of length m of P with evolution trace {a mathematical formula}PI=〈P1,…,Pm〉, and {a mathematical formula}E=〈E1,…,Eℓ〉 an event sequence over P such that {a mathematical formula}ℓ≥m. Then, I is an evolution stable model of P given E iff for every {a mathematical formula}1≤j≤m, we have that {a mathematical formula}Ij is a stable model of {a mathematical formula}P1⊕P2⊕…⊕(Pj∪Ej).
      </paragraph>
      <paragraph>
       We now show how EVOLP can be captured in the framework of rMCSs. For that, given an evolving logic program P we aim to construct an rMCS {a mathematical formula}MP whose equilibria streams corresponds to the evolution stable models of P. First of all, note that the events in EVOLP can be modeled by the input streams of rMCSs.
      </paragraph>
      <paragraph>
       The intuitive idea for the construction of {a mathematical formula}MP is that, at each instant, the incoming events are temporarily added to a knowledge base. To keep track of these, we consider a context C, whose possible knowledge bases are pairs. The first component of such is to keep track of the sequence of programs {a mathematical formula}P1⊕…⊕Pj, which corresponds to the trace of an interpretation until the current instant, and the second component is reserved for the current event {a mathematical formula}Ej. Given this intuition, it is clear that {a mathematical formula}acc(〈P1⊕…⊕Pj,E〉) should be defined as the set of stable models of {a mathematical formula}P1⊕…⊕Pj−1⊕(Pj∪E). To incorporate events, we consider an input language IL of {a mathematical formula}MP defined precisely as the language of events, i.e., the set of evolving logic programs. Moreover, context C contains bridge rules to access the current events, which are then used to update the event's component of the knowledge base. Also, context C has bridge rules designated to guarantee that the formulas that occur under the predicate assert at the current instant are used to update the knowledge base in the next instant. Finally, the management function mng of C is such that {a mathematical formula}mng(op,〈P,E〉) updates the program sequence component or the event component depending on whether op is a set of asserts, or a set of events, respectively.
      </paragraph>
      <paragraph>
       Formally, let P be an evolving logic program, and consider the following rMCS {a mathematical formula}MP=〈〈C〉,〈IL〉,〈BRC〉〉 where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}C=〈L,OP,mng〉 such that
       </list-item>
       <list-item label="•">
        {a mathematical formula}L=〈KB,BS,acc〉 is a logic such that
       </list-item>
       <list-item label="•">
        KB is the set of pairs {a mathematical formula}〈D,E〉 where D is a dynamic logic program over {a mathematical formula}L, and E is an evolving logic program over {a mathematical formula}L
       </list-item>
       <list-item label="•">
        BS is the set of all subsets of {a mathematical formula}Lassert
       </list-item>
       <list-item label="•">
        {a mathematical formula}acc(〈P1⊕…⊕Pj,E〉) is the set of stable models of {a mathematical formula}P1⊕…⊕Pj−1⊕(Pj∪E)
       </list-item>
       <list-item label="•">
        {a mathematical formula}OP={as(r)|r∈RL}∪{ob(r)|r∈RL}
       </list-item>
       <list-item label="•">
        {a mathematical formula}mng(op,〈D,E〉)={〈D⊕U,E′〉} where {a mathematical formula}U={r∈RL|as(r)∈op} and {a mathematical formula}E′={r∈RL|ob(r)∈op}
       </list-item>
       <list-item label="•">
        {a mathematical formula}IL=RL
       </list-item>
       <list-item label="•">
        {a mathematical formula}BRC={next(as(s))←1:assert(s)|assert(s)∈Lassert}∪{ob(s)←1::s|s∈IL}
       </list-item>
      </list>
      <paragraph>
       Evolution stable models of P are strongly related to the equilibria streams of {a mathematical formula}MP. Namely, given an event sequence {a mathematical formula}E=〈E1,…,Eℓ〉 over P consider its associated input stream {a mathematical formula}IE=〈〈E1〉,…,〈Eℓ〉〉. Then, {a mathematical formula}I=〈I1,…,Iℓ〉 is a evolution stable model of P given E iff I is an equilibria stream for {a mathematical formula}MP given {a mathematical formula}KB=〈〈P,∅〉〉 and {a mathematical formula}IE.
      </paragraph>
      <paragraph>
       This coincidence between evolution stable models in EVOLP and equilibria streams for rMCSs as defined above can be explained by the fact that, conceptionally, the operators next and assert are rather similar.
      </paragraph>
     </section>
    </section>
   </appendices>
  </root>
 </body>
</html>