<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    An initial study of time complexity in infinite-domain constraint satisfaction.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      This introductory section is divided into three parts: we begin by motivating our work, continue by discussing the problems that we study, and finally briefly present our results.
     </paragraph>
     <section label="1.1">
      <section-title>
       Motivation
      </section-title>
      <paragraph>
       The constraint satisfaction problem over a constraint language Γ ({a mathematical formula}CSP(Γ)) is the problem of finding a variable assignment which satisfies a set of constraints, where each constraint is constructed from a relation in Γ. This problem is a widely studied computational problem and it can be used to model many classical problems such as k-coloring and the Boolean satisfiability problem, in a natural and uniform way. In the context of artificial intelligence, CSPs have been used for formalizing a wide range of problems, cf. Rossi et al. [55]. Efficient algorithms for CSP problems are hence of great practical interest. If the domain D is finite, then a {a mathematical formula}CSP(Γ) instance I with variable set V can be solved in {a mathematical formula}O(|D||V|⋅poly(‖I‖)) time by enumerating all possible assignments. Hence, we have an obvious upper bound on the time complexity. This bound can, in many cases, be improved if additional information about Γ is known, cf. the survey by Woeginger [65] or the textbook by Gaspers [29]. There is also a growing body of literature concerning lower bounds[34], [39], [42], [61].
      </paragraph>
      <paragraph>
       When it comes to CSPs over infinite domains, there is a large number of results that identify polynomial-time solvable cases, cf. Ligozat [45] or Rossi et al. [55]. However, almost nothing is known about the time complexity of solving NP-hard CSP problems. One may conjecture that a large number of practically relevant CSP problems do not fall into the tractable cases, and this motivates a closer study of the time complexity of hard problems. Thus, we initiate such a study in this article.
      </paragraph>
     </section>
     <section label="1.2">
      <section-title>
       Computational problems
      </section-title>
      <paragraph>
       Assume that we are given an instance of {a mathematical formula}CSP(Γ) where Γ is a constraint language over an infinite domain. Which upper bounds can we provide for {a mathematical formula}CSP(Γ)? Clearly, the method for finite-domain CSPs, based on enumerating all possible variable assignments, no longer work since the domain is infinite. In fact, infinite-domain CSPs are in general undecidable[7]. A first step is therefore to only consider decidable infinite-domain CSPs. However, even for such problems, for every recursive function, one can find a decidable CSP problem which cannot be solved faster than this [4]. Hence, we first need to fix a class of constraint languages X such that {a mathematical formula}CSP(Γ) is included in a reasonable complexity class for every {a mathematical formula}Γ∈X. Througout this article we exclusively study the case when {a mathematical formula}CSP(Γ) is included in NP, since this is a natural and well-studied class of problems. However, when considering CSPs over infinite domains, representational issues also become highly important. A relation in a finite-domain CSP problem is easy to represent by simply listing the allowed tuples. When considering infinite-domain CSPs, the relations need to be implicitly represented. A natural way is to consider disjunctive formulas over a finite set of basic relations. Let {a mathematical formula}B denote some finite set of basic relations such that {a mathematical formula}CSP(B) is tractable. Let {a mathematical formula}B∨ω denote the closure of {a mathematical formula}B under finitary disjunctions, and let {a mathematical formula}B∨k be the subset of {a mathematical formula}B∨ω containing only disjunctions of length at most k. We first consider a finite-domain example for illustrative purposes: let {a mathematical formula}D={true,false} and let {a mathematical formula}B={B1,B2} where {a mathematical formula}B1={true} and {a mathematical formula}B2={false}. In other words a unary constraint of the form {a mathematical formula}B1(x) forces the variable x to be mapped to true, and {a mathematical formula}B2(y) forces the variable y to be mapped to false. It is then easy to see that {a mathematical formula}CSP(B∨ω) corresponds to the Boolean SAT problem while {a mathematical formula}CSP(B∨k) corresponds to the k-SAT problem. Early examples of disjunctive constraints over infinite-domains can be found in, for instance, temporal reasoning [43], [37], [58], reasoning about action and change [26], and deductive databases [41]. More recent examples include interactive graphics [48], rule-based reasoning [46], and set constraints (with applications in descriptive logics) [10]. There are also works studying disjunctive constraints from a general point of view [16], [21] but they are only concerned with the separation of polynomial cases from NP-hard cases, and do not further investigate the time complexity of the hard cases.
      </paragraph>
      <paragraph>
       There is also an important connection to constraint languages containing first-order definable relations (see Section 2.2 for details). Assume Γ is a finite constraint language containing relations that are first-order definable in {a mathematical formula}B, and that the first order theory of {a mathematical formula}B admits quantifier elimination. Then, upper bounds on {a mathematical formula}CSP(Γ) can be inferred from results such as those that will be presented in Sections 3 and 4. This indicates that studying the time complexity of {a mathematical formula}CSP(B∨ω) is worthwhile, especially since our understanding of first-order definable constraint languages is rapidly increasing [8].
      </paragraph>
      <paragraph>
       CSPs in certain AI applications are often based on binary basic relations and unions of them (instead of free disjunctive formulas). This is the predominant way of representing constraints in, for instance, spatial reasoning. Clearly, such relations are a subset of the relations in {a mathematical formula}B∨k and we let {a mathematical formula}B∨= denote this set of relations. We do not explicitly bound the length of disjunctions since they are bounded by {a mathematical formula}|B|. The literature on such CSPs is voluminous and we refer the reader to Renz and Nebel [54] for an introduction. We remark that there exists examples of undecidable CSP problems over constraint languages of the form {a mathematical formula}B∨=[32]. Hence, even for such restricted problems it is impossible to give general upper bounds, unless additional restrictions are imposed on the set {a mathematical formula}B of basic relations.
      </paragraph>
     </section>
     <section label="1.3">
      <section-title>
       Our results
      </section-title>
      <paragraph>
       Throughout the article, we primarily measure time complexity in the number of variables. Historically, this has been the most common way of measuring time complexity: the vast majority of work concerning finite-domain CSPs concentrates on the number of variables. One reason for this is that an instance may be massively larger than the number of variables — a SAT instance {a mathematical formula}I=(V,C) (where V is the set of variables and C is the set of clauses) may contain up to {a mathematical formula}22|V| distinct clauses if repeated literals are disallowed — and measuring in the instance size may give far too optimistic figures. This may be quite detrimental since naturally appearing test examples tend to contain a moderate number of constraints. In light of this, it is much more informative to know that SAT can be solved in {a mathematical formula}O(2|V|⋅poly(‖I‖)) time (where {a mathematical formula}‖I‖ denotes the total number of bits needed for representing I) instead of merely knowing that it is solvable in {a mathematical formula}O(2‖I‖⋅poly(‖I‖)) time (which of course is true since {a mathematical formula}|V|≤‖I‖). For instance, we immediately conclude from the bound {a mathematical formula}O(2|V|⋅poly(‖I‖)) that increasing the number of variables increases the run time much more rapidly than increasing the number of clauses. This is something that one cannot immediately infer from the bound {a mathematical formula}O(2‖I‖⋅poly(‖I‖)).
      </paragraph>
      <paragraph>
       Let us now turn to the time complexity of solving infinite-domain CSPs. To solve such problems in practice, backtracking algorithms are usually employed. The literature on heuristically guided backtracking algorithm and empirical analyses of such algorithms is huge: we refer the reader to any good textbook (such as Dechter [24] or the handbook edited by Rossi et al. [55]) on constraint satisfaction for more information about this. What we find lacking in the literature are analyses of the asymptotical performance of such algorithms, i.e. their worst-case behavior. Unfortunately, we show in Section 3 that they can be highly inefficient in the worst case. Let p denote the maximum arity of the relations in the set of basic relations {a mathematical formula}B, let {a mathematical formula}m=|B|, and let {a mathematical formula}|V| denote the number of variables in a given CSP instance. We show (in Section 3.1) that the time complexity ranges from {a mathematical formula}O(22m⋅|V|p⋅log⁡(m⋅|V|p)⋅poly(‖I‖)) (which is doubly exponential with respect to the number of variables) for {a mathematical formula}CSP(B∨ω) to {a mathematical formula}O(22m⋅|V|p⋅log⁡m⋅poly(‖I‖)) time for {a mathematical formula}B∨= (and the markedly better bound of {a mathematical formula}O(2|V|plog⁡m⋅poly(‖I‖)) if {a mathematical formula}B consists of pairwise disjoint relations). The use of heuristics can probably improve these figures in some cases, but we have not been able to find such results in the literature and it is not obvious how to analyze backtracking combined with heuristics. At this stage, we are mostly interested in obtaining a baseline: we need to know the performance of simple algorithms before we start studying more sophisticated ones. However, some of these bounds can be improved by utilizing standard methods described in the literature: we demonstrate this in Section 3.2 by applying the highly influential sparsification method by Impagliazzo, Paturi, and Zane [36].
      </paragraph>
      <paragraph>
       In Section 4 we switch strategy and show that disjunctive CSP problems can be solved significantly more efficiently via enumerative methods. By an enumerative method, we mean a method that is based on enumerating some kind of objects that can be used for determining whether the given instance has a solution or not. Let us for a moment go back to the simplest possible method for solving CSPs over a finite domain D: enumerate all assignments of values from D to the variable set V. This process yields a (very simple) algorithm running in {a mathematical formula}O(|D||V|⋅poly(‖I‖)) time. This is the archetypical example of an enumerative method. However, it is not directly applicable to infinite-domain CSPs due to the size of the set D.
      </paragraph>
      <paragraph>
       We introduce two enumerative methods in this article: structure enumeration and domain enumeration. Structure enumeration is inspired by model checking for finite structure: we enumerate a sequence of structures (which themselves are small CSP instances) and check whether the given instance is satisfied by the (implicitly represented) solutions of the structures. Domain enumeration is more closely related to the enumerative approach to finite-domain CSPs. In certain cases, one can identify finite sets of ‘canonical’ domain elements with the following property: there exists a solution if and only if there is a solution that only uses the canonical elements. There are several important differences between these two methods but there is a general rule of thumb: structure enumeration is typically easier to apply and it has a greater range of applicability but it gives worse complexity figures than domain enumeration.
      </paragraph>
      <paragraph>
       By using structure enumeration, we obtain the upper bound {a mathematical formula}O(2|V|p⋅m⋅poly(‖I‖)) for {a mathematical formula}CSP(B∨ω). If we additionally assume that {a mathematical formula}B is jointly exhaustive and pairwise disjoint then the running time is improved further to {a mathematical formula}O(2|V|p⋅log⁡m⋅poly(‖I‖)). This bound beats or equals every bound presented in Section 3. We then proceed to show even better bounds for certain choices of {a mathematical formula}B by using domain enumeration. For instance, we consider certain temporal CSPs.
      </paragraph>
      <paragraph>
       In the last part of the article (Section 5), we consider the problem of determining lower bounds for {a mathematical formula}CSP(B∨ω), i.e. identifying functions f such that no algorithm for {a mathematical formula}CSP(B∨ω) has a better running time than {a mathematical formula}O(f(|V|)). We accomplish this by relating CSP problems and certain complexity-theoretical conjectures, and obtain strong lower bounds for the majority of the problems considered in Section 4. As an example, we show that the temporal {a mathematical formula}CSP({&lt;,&gt;,=}∨ω) problem, where {a mathematical formula}&lt;,&gt; and = are the order relations on {a mathematical formula}Q, is solvable in time {a mathematical formula}O(2|V|log⁡|V|⋅poly(‖I‖)) but, assuming a conjecture known as the strong exponential time hypothesis (SETH), not solvable in {a mathematical formula}O(c|V|) time for any{a mathematical formula}c&gt;1. Hence, even though the algorithms we present are rather straightforward, there is, in many cases, very little room for improvement, unless the SETH fails. It appears much more difficult to obtain lower bounds for problems of the type {a mathematical formula}CSP(B∨=). However, we succeed in giving the lower bound {a mathematical formula}O((2)|V|) for Allen's interval algebra. This bound is not based on the (strong) exponential time hypothesis but on bounds on computing the chromatic number of graphs. The upper bound for Allen's algebra is {a mathematical formula}O(22|V|⋅(1+log⁡|V|)) so there is plenty of room for improvements in this case.
      </paragraph>
      <paragraph>
       This article is a revised and extend version of an earlier conference publication [38].
      </paragraph>
     </section>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      In this section, we formally define the constraint satisfaction problem, discuss first-order definable relations, and provide some basic definitions concerning SAT problems and the exponential time hypothesis.
     </paragraph>
     <section label="2.1">
      <section-title>
       Constraint satisfaction
      </section-title>
      <paragraph>
       We begin by providing a formal definition of the CSP problem when it is parameterized by a set of relations.
      </paragraph>
      <paragraph label="Definition 1">
       Let Γ be a set of finitary relations over some set D of values. The constraint satisfaction problem over Γ ({a mathematical formula}CSP(Γ)) is defined as follows:Instance: A set V of variables and a set C of constraints of the form {a mathematical formula}R(v1,…,vk), where k is the arity of R, {a mathematical formula}v1,…,vk∈V and {a mathematical formula}R∈Γ.Question: Is there a function {a mathematical formula}f:V→D such that {a mathematical formula}(f(v1),…,f(vk))∈R for every {a mathematical formula}R(v1,…,vk)∈C?
      </paragraph>
      <paragraph>
       The set Γ is referred to as the constraint language. Observe that we do not require Γ or D to be finite. Given an instance I of {a mathematical formula}CSP(Γ) we write {a mathematical formula}‖I‖ for the number of bits required to represent I. We now turn our attention to constraint languages based on disjunctions. Let D be a set of values and let {a mathematical formula}B={B1,…,Bm} denote a finite set of relations over D, i.e. {a mathematical formula}Bi⊆Dj for some {a mathematical formula}j≥1. Let the set {a mathematical formula}B∨ω denote the set of relations defined by finitary disjunctions over {a mathematical formula}B. That is, {a mathematical formula}B∨ω contains every p-ary relation R such that {a mathematical formula}R(x1,…,xp)if and only ifB1(x1)∨…∨Bt(xt) where {a mathematical formula}x1,…,xt are sequences of variables from {a mathematical formula}{x1,…,xp} such that the length of {a mathematical formula}xj equals the arity of {a mathematical formula}Bj, and {a mathematical formula}B1,…,Bt∈B. We refer to {a mathematical formula}B1(x1),…,Bt(xt) as the disjuncts of R. We assume, without loss of generality, that a disjunct occurs at most once in a disjunction. For {a mathematical formula}k≥1 we define {a mathematical formula}B∨k as the subset of {a mathematical formula}B∨ω where each relation is defined by a disjunction of length at most k. Hence, we also allow relations definable by disjunctions of length exactly k since, as was pointed out in Section 1.2 and will be evident in Section 2.3, it gives {a mathematical formula}CSP(B∨k) a natural relationship to k-SAT. It is common, especially in qualitative temporal and spatial constraint reasoning, to study a restricted variant of {a mathematical formula}B∨k where all relations in {a mathematical formula}B have the same arity p. Define {a mathematical formula}B∨= to contain every p-ary relation R such that {a mathematical formula}R(x)if and only ifB1(x)∨…∨Bt(x), where {a mathematical formula}x=(x1,…,xp).
      </paragraph>
      <paragraph>
       We adopt a simple representation of relations in {a mathematical formula}B∨ω: every relation R in {a mathematical formula}B∨ω is represented by its defining disjunctive formula. Note that two objects {a mathematical formula}R,R′∈B∨ω may denote the same relation. Hence, {a mathematical formula}B∨ω is not a constraint language in the sense of Definition 1. We avoid tedious technicalities by ignoring this issue and view constraint languages as multisets. Given an instance {a mathematical formula}I=(V,C) of {a mathematical formula}CSP(B∨ω) under this representation, we let{a mathematical formula} denote the set of all disjuncts appearing in I.
      </paragraph>
      <paragraph>
       We close this section by introducing some notions that are common in qualitative spatial and temporal reasoning problems. Let {a mathematical formula}B={B1,…,Bm} be a set of relations (over a domain D) such that all {a mathematical formula}B1,…,Bm have arity p. We say that {a mathematical formula}B is jointly exhaustive (JE) if {a mathematical formula}⋃B=Dp and that {a mathematical formula}B is pairwise disjoint (PD) if {a mathematical formula}Bi∩Bj=∅ whenever {a mathematical formula}i≠j. If {a mathematical formula}B is both JE and PD we say that it is JEPD or, in mathematical terminology, {a mathematical formula}B is a partitioning of the set {a mathematical formula}Dp. Observe that if {a mathematical formula}B1,…,Bm have different arity then these properties are clearly not relevant since the intersection between two such relations is always empty.
      </paragraph>
      <paragraph>
       Let Γ be an arbitrary set of relations with arity {a mathematical formula}p≥1. We say that Γ is closed under intersection if {a mathematical formula}R1∩R2∈Γ for all choices of {a mathematical formula}R1,R2∈Γ. Let R be an arbitrary binary relation. We define the converse{a mathematical formula}R⌣ of R such that {a mathematical formula}R⌣={(y,x)|(x,y)∈R}. If Γ is a set of binary relations, then we say that Γ is closed under converse if {a mathematical formula}R⌣∈Γ for all {a mathematical formula}R∈Γ.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       First-order definable relations
      </section-title>
      <paragraph>
       Languages of the form {a mathematical formula}B∨ω have a close connection to languages defined over first-order structures admitting quantifier elimination, i.e. every first-order definable relation can be defined by an equivalent formula without quantifiers. We have the following lemma.
      </paragraph>
      <paragraph label="Lemma 2">
       Let Γ be a finite constraint language first-order definable over a relational structure{a mathematical formula}(D,R1,…,Rm)admitting quantifier elimination, where{a mathematical formula}R1,…,Rmare JEPD. Then there exists a k such that
      </paragraph>
      <list>
       <list-item label="1.">
        {a mathematical formula}CSP(Γ)is polynomial-time reducible to{a mathematical formula}CSP({R1,…,Rm}∨k)and
       </list-item>
       <list-item label="2.">
        if{a mathematical formula}CSP({R1,…,Rm}∨k)is solvable in{a mathematical formula}O(f(|V|)⋅poly(‖I‖))time, then{a mathematical formula}CSP(Γ)is solvable in{a mathematical formula}O(f(|V|)⋅poly(‖I‖))time.
       </list-item>
      </list>
      <paragraph label="Proof">
       Assume that every relation {a mathematical formula}R∈Γ is definable through a quantifier-free first-order formula {a mathematical formula}ϕi over {a mathematical formula}R1,…,Rm. Let {a mathematical formula}ψi be {a mathematical formula}ϕi rewritten in conjunctive normal form. We need to show that every disjunction in {a mathematical formula}ψi can be expressed as a disjunction over {a mathematical formula}R1,…,Rm. Clearly, if {a mathematical formula}ψi only contains positive literals, then this is trivial. Hence, assume there is at least one negative literal. Since {a mathematical formula}R1,…,Rm are JEPD it is easy to see that for any negated relation in {a mathematical formula}{R1,…,Rm} there exists {a mathematical formula}Γ⊆{R1,…,Rm} such that the union of Γ equals the complemented relation. We can then reduce {a mathematical formula}CSP(Γ) to {a mathematical formula}CSP({R1,…,Rm}∨k) by replacing every constraint by its conjunctive normal formula over {a mathematical formula}R1,…,Rm. This reduction can be done in polynomial time with respect to {a mathematical formula}‖I‖ since each such definition can be stored in a table of fixed size. Moreover, since this reduction does not increase the number of variables, it follows that {a mathematical formula}CSP(Γ) is solvable in {a mathematical formula}O(f(|V|)⋅poly(‖I‖)) time whenever {a mathematical formula}CSP(B∨k) is solvable in {a mathematical formula}O(f(|V|)⋅poly(‖I‖)) time.  □
      </paragraph>
      <paragraph>
       As we will see in Section 4, this result is useful since we can use upper bounds for {a mathematical formula}CSP(B∨k) to derive upper bounds for {a mathematical formula}CSP(Γ), where Γ consists of first-order definable relations over {a mathematical formula}B. There is a large number of structures admitting quantifier elimination and interesting examples are presented in every standard textbook on model theory, cf. Hodges [33]. A selection of problems that are highly relevant for computer science and AI are discussed in Bodirsky [8].
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       SAT and the exponential time hypothesis
      </section-title>
      <paragraph>
       The propositional satisfiability problem (SAT) will be important both for obtaining upper and lower bounds in later parts of this article. We define the SAT problem as usual: given a set of propositional clauses, decide whether there is a satisfying assignment or not. We sometimes consider the SAT problem restricted to clauses of length at most k and we denote this problem k-SAT. We pointed out the following fact in the introduction but it is worth repeating: if {a mathematical formula}D={true,false} and {a mathematical formula}B={B1,B2} where {a mathematical formula}B1={true} and {a mathematical formula}B2={false}, then {a mathematical formula}CSP(B∨ω) corresponds to SAT while {a mathematical formula}CSP(B∨k) corresponds to k-SAT. Note that the problem {a mathematical formula}CSP(B∨=) is different in this respect since it can be seen as an alternative formulation of 1-SAT, i.e., SAT restricted to unary clauses. SAT and k-SAT are NP-complete problems when {a mathematical formula}k≥3 while 2-SAT and 1-SAT are solvable in polynomial time. We often use the domain {a mathematical formula}{0,1} for Boolean values where 1 is interpreted as ‘true’ and 0 as ‘false’.
      </paragraph>
      <paragraph>
       NP-hardness does not give us any information concerning the running times of algorithms for solving such problems (besides the fact that they are superpolynomial under the side condition that P ≠ NP). For instance, under the sole assumption P ≠ NP, we cannot, for instance, rule out that SAT can be solved in {a mathematical formula}O(|V|log⁡|V|) time. The existence of such efficient algorithms are considered unlikely and to rule out such algorithms we need complexity assumptions that are stronger than P ≠ NP. The exponential time hypothesis (ETH) and the strong exponential time hypothesis (SETH) have been suggested as plausible stronger assumptions. These two hypotheses have been used quite intensively in the study of central problems in AI such as planning and constraint satisfaction, cf. Bäckström and Jonsson [2], [3], Kanj and Szeider [42], and Traxler [61].
      </paragraph>
      <paragraph>
       The ETH states that there exists a {a mathematical formula}δ&gt;0 such that 3-SAT is not solvable in {a mathematical formula}O(2δ|V|) time by any deterministic algorithm, i.e. it is not solvable in subexponential time [34]. If the ETH holds, then there is an increasing sequence {a mathematical formula}δ3,δ4,… of reals such that k-SAT cannot be solved in time {a mathematical formula}2(δk−ϵ)|V| but it can be solved in {a mathematical formula}2(δk+ϵ)|V| time for arbitrary {a mathematical formula}ϵ&gt;0. The strong exponential-time hypothesis (SETH) is the conjecture that the limit of the sequence {a mathematical formula}δ3,δ4,… equals 1, and, as a consequence, that SAT is not solvable in time {a mathematical formula}O(2δ|V|) for any {a mathematical formula}δ&lt;1[34]. These conjectures have in recent years successfully been used for proving lower bounds of many NP-complete problems [47]. The plausibility of the (S)ETH is debatable due to the same reasons as the plausibility of P ≠ NP is debatable: our understanding of this kind of complexity questions is not sufficient. One ought to note, however, that the failure of any of these hypotheses would have far-reaching and surprising consequences in connection with, for instance, the existence of subexponential algorithms for many NP-complete problems [36], [39], [56], the complexity and approximability of optimization problems [18], [49], and parameterized complexity theory [19], [20].
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Fundamental algorithms
     </section-title>
     <paragraph>
      In this section we investigate the complexity of algorithms for {a mathematical formula}CSP(B∨ω) and {a mathematical formula}CSP(B∨k) based on branching on the disjuncts in constraints (Section 3.1) and the sparsification method (Section 3.2). Throughout this section we assume that {a mathematical formula}B is a set of basic relations such that {a mathematical formula}CSP(B) is in P. The reason behind this assumption is that the algorithms that we investigate in this section works by repeatedly choosing a set of disjuncts, and then checks whether this instance of {a mathematical formula}CSP(B) is satisfiable or not. Clearly, this assumption is not the only possible one, but in practice it is not a great restriction, since the most frequently studied problems of the form {a mathematical formula}CSP(B∨ω) satisfy this condition.
     </paragraph>
     <section label="3.1">
      <section-title>
       Branching on disjuncts
      </section-title>
      <paragraph>
       Let {a mathematical formula}B={B1,…,Bm} be a set of basic relations with maximum arity {a mathematical formula}p≥1. Assume we have an instance I of {a mathematical formula}CSP(B∨ω) with variable set V. Such an instance contains at most {a mathematical formula}2m⋅|V|p distinct constraints. Each such constraint contains at most {a mathematical formula}m⋅|V|p disjuncts so the instance I can be solved in{a mathematical formula} time by enumerating all possible choices of one disjunct out of every disjunctive constraint. The satisfiability of the resulting sets of constraints can be checked in polynomial time due to our initial assumptions. How does such an enumerative approach compare to a branching search algorithm? In the worst case, a branching algorithm without heuristic aid will go through all of these cases so the bound above is valid for such algorithms. Analyzing the time complexity of branching algorithms equipped with powerful heuristics is a very different (and presumably very difficult) problem.
      </paragraph>
      <paragraph>
       Assume instead that we have an instance I of {a mathematical formula}CSP(B∨k) with variable set V. There are at most {a mathematical formula}m⋅|V|p different disjuncts which leads to at most {a mathematical formula}∑i=0k(m|V|p)i≤k⋅(m|V|p)k distinct constraints. We can thus solve instances with {a mathematical formula}|V| variables in {a mathematical formula}O(kk⋅(m|V|p)k⋅poly(‖I‖))=O(2k⋅log⁡k⋅(m|V|p)k⋅poly(‖I‖)) time.
      </paragraph>
      <paragraph>
       Finally, let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨=) with variable set V. We analyze the size of C: given the variable set V, there are {a mathematical formula}|V|p variable sequences of length p and there are {a mathematical formula}2m different disjunctive relations over {a mathematical formula}B. Thus, there are at most {a mathematical formula}2m⋅|V|p distinct constraints in C and each such constraint has length at most m. Non-deterministic guessing gives that instances of this kind can be solved in{a mathematical formula} time. This may appear to be surprisingly slow but this is mainly due to the fact that we have not imposed any additional restrictions on the set {a mathematical formula}B of basic relations. Hence, assume that the relations in {a mathematical formula}B are PD. Given two relations {a mathematical formula}R1,R2∈B∨=, it is now clear that {a mathematical formula}R1∩R2 is a relation in {a mathematical formula}B∨=, i.e. {a mathematical formula}B∨= is closed under intersection. Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨=). For any sequence of variables {a mathematical formula}(x1,…,xp), we can assume that there is at most one constraint {a mathematical formula}R(x1,…,xp) in C. This implies that we can solve {a mathematical formula}CSP(B∨=) in {a mathematical formula}O(m|V|p⋅poly(‖I‖))=O(2|V|plog⁡m⋅poly(‖I‖)) time. Combining everything so far we obtain the following upper bounds.
      </paragraph>
      <paragraph label="Lemma 3">
       Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and let{a mathematical formula}m=|B|. Then
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}CSP(B∨ω)is solvable in{a mathematical formula}O(22m⋅|V|p⋅log⁡(m⋅|V|p)⋅poly(‖I‖))time,
       </list-item>
       <list-item label="•">
        {a mathematical formula}CSP(B∨k)is solvable in{a mathematical formula}O(2k⋅log⁡k⋅(m|V|p)k⋅poly(‖I‖))time,
       </list-item>
       <list-item label="•">
        {a mathematical formula}CSP(B∨=)is solvable in{a mathematical formula}O(22m⋅|V|p⋅log⁡m⋅poly(‖I‖))time, and
       </list-item>
       <list-item label="•">
        {a mathematical formula}CSP(B∨=)is solvable in{a mathematical formula}O(2|V|plog⁡m⋅poly(‖I‖))time if{a mathematical formula}Bis PD.
       </list-item>
      </list>
      <paragraph>
       A bit of fine-tuning is often needed when applying highly general results like Lemma 3 to concrete problems. For instance, Renz and Nebel [54] show that the RCC-8 problem can be solved in {a mathematical formula}O(c|V|22) for some (unknown) {a mathematical formula}c&gt;1. This problem can be viewed as {a mathematical formula}CSP(B∨=) where {a mathematical formula}B contains JEPD binary relations and {a mathematical formula}|B|=8. Lemma 3 implies that {a mathematical formula}CSP(B∨=) can be solved in {a mathematical formula}O(23|V|2) which is significantly slower if {a mathematical formula}c&lt;82. However, it is well known that {a mathematical formula}B is closed under converse. Let {a mathematical formula}I=({x1,…,xn},C) be an instance of {a mathematical formula}CSP(B∨=). Since {a mathematical formula}B is closed under converse, we can always assume that if {a mathematical formula}R(xi,xj)∈C, then {a mathematical formula}i≤j. Thus, we can solve {a mathematical formula}CSP(B∨=) in {a mathematical formula}O(m|V|22⋅poly(‖I‖))=O(2|V|22log⁡m⋅poly(‖I‖)) time. This figure matches the bound by Renz and Nebel better when c is small.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       Sparsification
      </section-title>
      <paragraph>
       The complexity of the algorithms proposed in Section 3 is dominated by the number of constraints. An idea for improving these running times is therefore to reduce the number of constraints within instances. One way of accomplishing this is by using sparsification[36]. This method was originally used for the k-SAT problem with the aim of proving that k-SAT instances with only a linear number (in {a mathematical formula}|V|) constraints are still NP-complete and, in fact, that the ETH is still true for such instances. Recall from Section 2.3 that the ETH states that 3-SAT is not solvable in subexponential time. Sparsification can intuitively be described as the process of picking a disjunct that appears in a relatively large number of constraints, and create two instances {a mathematical formula}I1 and {a mathematical formula}I2, corresponding to the case where this disjunct is either true or false. In {a mathematical formula}I1 we can safely remove all constraints where this disjunct appears, and in {a mathematical formula}I2 all such constraints contain at least one less disjunct. We can then check the satisfiability of I by answering yes if and only if {a mathematical formula}I1 or {a mathematical formula}I2 is satisfiable. By repeating this process, we end up with a sequence of instances {a mathematical formula}I1,…,Ik such that at least one of {a mathematical formula}I1,…,Ik is satisfiable if and only if the original instance is satisfiable.
      </paragraph>
      <paragraph>
       To concretize this idea, a sunflower is defined to be a set of clauses {a mathematical formula}{C1,…,Cm}, containing the same number of disjuncts, such that {a mathematical formula}C1∩…∩Cm≠∅. Here, we tacitly view a clause {a mathematical formula}Ci as a set of literals, and with this interpretation, the above condition states that the clauses have at least one literal in common. The clause {a mathematical formula}C1∩…∩Cm=C is the heart of the sunflower and the clauses {a mathematical formula}C1∖C,…,Cm∖C the petals of the sunflower. This structure is visualized in Fig. 1. By searching after a sunflower {a mathematical formula}C1,…,Cm where m is as large as possible we obtain the two instances {a mathematical formula}I1 and {a mathematical formula}I2 corresponding to the case where we branch on either the heart or the petals, and thus reducing either the number of constraints or the number of disjuncts in constraints. Sunflowers and related structures are important in combinatorics and there are several connections with central problems in computer science, cf. Alon et al. [1] or Jukna [40, Sec. 6]. For a more thorough and formal introduction to sparsification see Chapter 16.3 in Flum and Grohe [28]. Analyzing such a seemingly simple recursive strategy as described above is by no means trivial and we will not present the details. The analysis can be found in Impagliazzo et al. [36].
      </paragraph>
      <paragraph>
       We will now use sparsification for solving infinite-domain CSPs. We need a few additional definitions. A family of k-sets{a mathematical formula}(U,C) consists of a finite set U (the universe) and a collection {a mathematical formula}C={S1,…,Sm} where {a mathematical formula}Si⊆U and {a mathematical formula}|Si|≤k, {a mathematical formula}1≤i≤m. A hitting set for {a mathematical formula}C is a set {a mathematical formula}C⊆U such that {a mathematical formula}C∩Si≠∅ for each {a mathematical formula}Si∈C. Let {a mathematical formula}σ(C) be the set of all hitting sets of {a mathematical formula}C. {a mathematical formula}T is a restriction of {a mathematical formula}C if for each {a mathematical formula}S∈C there is a {a mathematical formula}T∈T with {a mathematical formula}T⊆S. If {a mathematical formula}T is a restriction of {a mathematical formula}C, then {a mathematical formula}σ(T)⊆σ(C). We then have the following result.{sup:1}
      </paragraph>
      <paragraph label="Theorem 4">
       Impagliazzo et al. [36]For all{a mathematical formula}ε&gt;0and positive k, there is a constant K and an algorithm that, given a family of k-sets{a mathematical formula}(U,C)where{a mathematical formula}|U|=n, produces a list of{a mathematical formula}t≤2ε⋅nrestrictions{a mathematical formula}T1,…,Ttof{a mathematical formula}Cso that{a mathematical formula}σ(C)=⋃i=1tσ(Ti)and so that for each{a mathematical formula}Ti,{a mathematical formula}|Ti|≤Kn. Furthermore, the algorithm runs in time{a mathematical formula}poly(n)⋅2ε⋅n.
      </paragraph>
      <paragraph label="Lemma 5">
       Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and let{a mathematical formula}m=|B|. Then{a mathematical formula}CSP(B∨k)is solvable in{a mathematical formula}O(2(ε+Klog⁡k)⋅|V|p⋅m⋅poly(‖I‖))time for every{a mathematical formula}ε&gt;0, where K is a constant depending only on ε and k.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨k) with {a mathematical formula}C={c1,…,cm}. To avoid unnecessary notation, we view each constraint {a mathematical formula}c=(R1(x1)∨…∨Rn(xn)) as a set {a mathematical formula}{R1(x1),…,Rn(xn)} in this proof. Note that I has a solution if and only if there exists a set {a mathematical formula}X⊆Disj(I) such that
       <list>
        {a mathematical formula}(V,X) is satisfiable and{a mathematical formula}X∩ci≠∅, {a mathematical formula}1≤i≤m, i.e. X is a hitting set of C.We will now apply
       </list>
       <paragraph>
        Lemma 5 on the family of k-sets {a mathematical formula}(U,C) where {a mathematical formula}U=Disj(I): choose some {a mathematical formula}ε&gt;0 and let {a mathematical formula}{T1,…,Tt} be the resulting set of restrictions. Note that each {a mathematical formula}(V,Ti) can be viewed as an instance of {a mathematical formula}CSP(B∨k) under the convention of viewing disjunctions as sets.We claim the following: there exists a {a mathematical formula}1≤i≤t such that {a mathematical formula}Ti is satisfiable if and only if I is satisfiable. Assume that I is satisfiable. Then there exists a hitting set {a mathematical formula}X⊆Disj(I) of C such that {a mathematical formula}(V,X) is satisfiable. Hence, {a mathematical formula}X∈σ(C). This implies that there exists a {a mathematical formula}1≤i≤t such that {a mathematical formula}X∈σ(Ti) since {a mathematical formula}σ(C)=⋃i=1tσ(Ti). Since {a mathematical formula}(V,X) is satisfiable, {a mathematical formula}(V,Ti) is satisfiable, too.Assume instead that there exists a {a mathematical formula}(V,Ti), {a mathematical formula}1≤i≤t, such that {a mathematical formula}(V,Ti) is satisfiable. Let s be a solution to {a mathematical formula}Ti. Let {a mathematical formula}X={R(x)∈Disj(I)|s satisfies R(x)} and note that {a mathematical formula}(V,X) is satisfiable and X is a hitting set of {a mathematical formula}Ti. The set {a mathematical formula}Ti is a restriction of C so for every {a mathematical formula}c∈C, there exists a {a mathematical formula}T∈Ti such that {a mathematical formula}T⊆c. It follows that X is a hitting set for {a mathematical formula}(V,C) which implies that s is a solution to {a mathematical formula}(V,C).We conclude that in order to prove that I is satisfiable, it is sufficient to find a satisfiable instance {a mathematical formula}(V,Ti). Each instance {a mathematical formula}(V,Ti) contains at most {a mathematical formula}K⋅|U|≤K⋅|V|p⋅m distinct constraints, where K is a constant depending on ε and k, and can therefore be solved in time {a mathematical formula}O(poly(‖I‖)⋅kK⋅|V|p⋅m) by exhaustive search as in Section 3.1. This gives a total running time of{a mathematical formula} since {a mathematical formula}t≤2ε⋅n.  □
       </paragraph>
      </paragraph>
      <paragraph>
       This procedure can be implemented using only polynomial space, just as the methods presented in Section 3.1. This follows from the fact that the restrictions {a mathematical formula}T1,…,Tt of {a mathematical formula}C can be computed one after another with polynomial delay [17, Theorem 5.15]. Although this running time still might seem excessively slow observe that it is significantly more efficient than the {a mathematical formula}2k⋅log⁡k⋅(m|V|p)k algorithm for {a mathematical formula}CSP(B∨k) in Lemma 3. However, in Theorem 6, Theorem 7, and Theorem 8 in Section 4.1 we will be able to improve upon this running time even further, by directly enumerating the hitting sets corresponding to the disjuncts of an instance, rather than reverting to backtracking algorithms as in Lemma 5. As we will demonstrate in Theorem 13, these bounds can also be strengthened for certain {a mathematical formula}CSP(B∨k) problems, by using an idea influenced by sparsification.
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Improved upper bounds
     </section-title>
     <paragraph>
      In this section, we show that it is possible to obtain markedly better upper bounds than the ones presented in Section 3. In Section 4.1 we consider algorithms for {a mathematical formula}CSP(B∨ω) based on structure enumeration, and in Section 4.2, we consider algorithms for {a mathematical formula}CSP(B∨ω) and {a mathematical formula}CSP(B∨k) based on domain enumeration.
     </paragraph>
     <section label="4.1">
      <section-title>
       Structure enumeration
      </section-title>
      <paragraph>
       We begin by presenting a general algorithm for {a mathematical formula}CSP(B∨ω) based on the idea of enumerating all variable assignments that are implicitly described in instances. As in the case of Section 3 we assume that {a mathematical formula}B is a set of basic relations such that {a mathematical formula}CSP(B) is solvable in {a mathematical formula}O(poly(‖I‖)) time.
      </paragraph>
      <paragraph label="Theorem 6">
       Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and let{a mathematical formula}m=|B|. Then{a mathematical formula}CSP(B∨ω)is solvable in{a mathematical formula}O(2m|V|p⋅poly(‖I‖))time.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨ω). Let {a mathematical formula}S=Disj(I) and note that {a mathematical formula}|S|≤m|V|p. For each subset {a mathematical formula}Si of S first determine whether {a mathematical formula}Si is satisfiable. Due to the initial assumption this can be done in {a mathematical formula}O(poly(‖I‖)) time since this set of disjuncts can be viewed as an instance of {a mathematical formula}CSP(B). Next, check whether {a mathematical formula}Si satisfies I by, for each constraint in C, determine whether at least one disjunct is included in {a mathematical formula}Si. Each such step can determined in time {a mathematical formula}O(poly(‖I‖)) time. The total running time for this algorithm is therefore in {a mathematical formula}O(2m|V|p⋅poly(‖I‖)).  □
      </paragraph>
      <paragraph>
       The advantage of this approach compared to the branching algorithm in Section 3 is that enumeration of variable assignments is much less sensitive to instances with a large number of constraints. At this point, it may be interesting to discuss what is actually meant by ‘a large number of constraints’. Assume we have a set {a mathematical formula}B={B1,…,Bm} of p-ary basic relations. Let us consider {a mathematical formula}CSP(B∨2) instances with {a mathematical formula}|V|2p constraints. The number of constraints is thus polynomially bounded in the number of variables. Theorem 6 shows that we solve such instances in {a mathematical formula}O(2m|V|p⋅poly(‖I‖)) time. A backtracking algorithm, on the other hand, needs {a mathematical formula}O(2|V|2p⋅poly(‖I‖)) time if we reason in the same way as in Section 3.1, i.e. we need to choose one disjunct out of every constraint and we need to try all possibilities in the worst case. Obviously, {a mathematical formula}2|V|2p&gt;2m|V|p even for quite small {a mathematical formula}|V| and this indicates that structure enumeration beats branching algorithms even when the number of constraints are polynomially bounded in the number of variables.
      </paragraph>
      <paragraph>
       We can speed up this result even further by making additional assumptions on the set {a mathematical formula}B. This allows us to enumerate smaller sets of constraints than in Theorem 6.
      </paragraph>
      <paragraph label="Theorem 7">
       Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and let{a mathematical formula}m=|B|. Then{a mathematical formula}CSP(B∨ω)solvable in{a mathematical formula}O(2|V|p⋅log⁡m⋅poly(‖I‖))time if{a mathematical formula}Bis JEPD.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨ω). Observe that every basic relation has the same arity p since {a mathematical formula}B is JEPD. Let F be the set of functions from {a mathematical formula}|V|p to {a mathematical formula}B and for every {a mathematical formula}f∈F, we let {a mathematical formula}Sf={Bj(x)|x∈Vp,f(x)=Bj}. The set {a mathematical formula}Sf contains the constraints that are specified by the function f so it contains one constraint for each tuple in {a mathematical formula}Vp. The size of the set is polynomially bounded in {a mathematical formula}(V,C) since p is a fixed constant that only depends on the choice of basic relations. We begin by proving two claims.Claim 1. I is satisfiable if and only if there exists an {a mathematical formula}f∈F such that {a mathematical formula}(V,C∪Sf) is satisfiable. If I is not satisfiable, then there trivially is no {a mathematical formula}f∈F such that {a mathematical formula}(V,C∪Sf) is satisfiable. Assume instead that I has a solution s. Arbitrarily choose a tuple {a mathematical formula}(x1,…,xp)∈Vp. Since {a mathematical formula}B is JEPD, the tuple {a mathematical formula}(s(x1),…,s(xp)) is a member of exactly one {a mathematical formula}B∈B. Thus, for every tuple {a mathematical formula}(x1,…,xp)∈Vp, there exists a unique {a mathematical formula}B∈B such that {a mathematical formula}(s(x1),…,s(xp))∈B. Define the function {a mathematical formula}g:Vp→B such that it returns this relation. By definition, g is a member of F. The function s is a solution to the CSP instance {a mathematical formula}(V,Sf) due to the choice of f and this implies that s is a solution to the instance {a mathematical formula}(V,C∪Sf), too.Claim 2. If {a mathematical formula}(V,Sf) is satisfiable for some {a mathematical formula}f∈F, then we can check in polynomial time whether {a mathematical formula}(V,C∪Sf) is satisfiable or not. Let s be a solution to {a mathematical formula}(V,Sf). Arbitrarily choose a constraint {a mathematical formula}c=(c1∨…∨ck)∈C. Consider {a mathematical formula}c1=Bi(x1) where {a mathematical formula}Bi∈B. There is a constraint {a mathematical formula}Bj(x1) in {a mathematical formula}Sf by the construction of {a mathematical formula}Sf. If {a mathematical formula}i=j, then s satisfies the disjunct {a mathematical formula}c1 and thus the constraint c. If {a mathematical formula}i≠j, then s does not satisfy {a mathematical formula}c1 since {a mathematical formula}B is PD. Otherwise, check the next disjunct and so on. If no disjunct {a mathematical formula}c1,…,ck passes the test, then {a mathematical formula}C∪Sf is not satisfiable. By repeating this process for all constraints in C, we can check whether {a mathematical formula}(V,C∪Sf) is satisfiable or not. This can be done in polynomial time in the size of {a mathematical formula}(V,C) since the size of the set {a mathematical formula}Sf is polynomially bounded in the size of {a mathematical formula}(V,C), as we noted in the beginning of the proof.Consider the following algorithm for solving {a mathematical formula}CSP(B∨ω):
       <list>
        {a mathematical formula}ans:=falsefor every {a mathematical formula}f∈F do the followingcompute {a mathematical formula}Sfif {a mathematical formula}(V,Sf) is satisfiable thenif {a mathematical formula}(V,C∪Sf) is satisfiable then {a mathematical formula}ans:=truereturn ansWe first verify that the algorithm is correct. If
       </list>
       <paragraph>
        {a mathematical formula}(V,C) is not satisfiable, then {a mathematical formula}(V,C∪Sf) is not satisfiable for any choice of {a mathematical formula}f∈F and the algorithm will answer {a mathematical formula}false. If {a mathematical formula}(V,C) is satisfiable, then there exists an {a mathematical formula}f∈F such that {a mathematical formula}(V,C∪Sf) is satisfiable by Claim 1 and the algorithm answers {a mathematical formula}true. Note here that {a mathematical formula}(V,Sf) is satisfiable, too, so the algorithm will indeed perform the test in Line 5.We continue by analyzing its time complexity. Computing {a mathematical formula}Sf takes polynomial time in the size of {a mathematical formula}(V,C) since p and {a mathematical formula}|B| are fixed constants that only depends on the choice of {a mathematical formula}B. Checking whether {a mathematical formula}(V,Sf) is satisfiable or not takes polynomial time since {a mathematical formula}CSP(B) is a polynomial-time solvable problem. Finally, checking whether {a mathematical formula}(V,C∪Sf) is satisfiable or not takes polynomial time due to Claim 2. The set F contains {a mathematical formula}|B||V|p=2|V|plog⁡m functions and these functions can be incrementally computed with negligible overhead. We conclude that the algorithm runs in {a mathematical formula}O(2|V|p⋅log⁡m⋅poly(‖I‖)) time.  □
       </paragraph>
      </paragraph>
      <paragraph>
       Let us reconsider the RCC-8 example from Section 3.1 and let {a mathematical formula}B denote the corresponding set of eight basic relations. We know (from Renz and Nebel [54]) that {a mathematical formula}CSP(B∨=) is solvable in {a mathematical formula}O(c|V|22) time for some {a mathematical formula}c&gt;1, and we obtained the concrete bound {a mathematical formula}O(23|V|22⋅poly(‖I‖)) time by utilizing a simple branching algorithm. Theorem 7(1) gives that {a mathematical formula}CSP(B∨ω) is solvable in {a mathematical formula}O(23|V|2⋅poly(‖I‖)) time. We can once again exploit the fact that {a mathematical formula}B is closed under converse and instead of enumerating all functions from {a mathematical formula}V2 to {a mathematical formula}B (as in the proof of Theorem 7), we assume that {a mathematical formula}V={x1,…,xn} and we merely enumerate the functions from {a mathematical formula}{(xi,xj)|1≤i&lt;j≤n} to {a mathematical formula}B. This gives us the time bound {a mathematical formula}O(23|V|22⋅poly(‖I‖)), i.e. we can solve {a mathematical formula}CSP(B∨ω) as fast as the severely restricted problem {a mathematical formula}CSP(B∨=). This indicates that there may be more efficient algorithms for {a mathematical formula}CSP(B∨=).
      </paragraph>
      <paragraph>
       If the set of basic relations {a mathematical formula}B are PD but not JE, then we get a slightly slower algorithm for {a mathematical formula}CSP(B∨ω).
      </paragraph>
      <paragraph label="Theorem 8">
       Let{a mathematical formula}Bbe a set of basic relations with arity p and let{a mathematical formula}m=|B|. Then{a mathematical formula}CSP(B∨ω)is solvable in{a mathematical formula}O(2|V|p⋅log⁡(m+1)⋅poly(‖I‖))time if{a mathematical formula}Bis PD.
      </paragraph>
      <paragraph label="Proof">
       Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(B∨ω). We introduce a symbol ⊤ for indicating that we do not care about the exact relation between the variables in a variable tuple. Let {a mathematical formula}F′ be the set of functions from {a mathematical formula}|V|p to {a mathematical formula}B∪{⊤} and for every {a mathematical formula}f∈F′ let {a mathematical formula}Sf={Bj(x)|x∈Vp,fi(x)=Bj≠⊤}.We say that a function {a mathematical formula}f∈F′ is compatible if {a mathematical formula}f(x)=B≠⊤ for at least one disjunct {a mathematical formula}B(x) in each constraint in C. We begin by proving an auxiliary result: I is satisfiable if and only if there exists a compatible {a mathematical formula}f∈F′ such that {a mathematical formula}(V,Sf) is satisfiable. Assume there exists an {a mathematical formula}f∈F′ such that {a mathematical formula}(V,Sf) has a solution s. The fact that f is compatible implies that at least one disjunct in each constraint in C is satisfied by s. Thus, {a mathematical formula}(V,C) is satisfiable.Assume instead that {a mathematical formula}(V,C) has the solution s. Let the set S contain one disjunct that is satisfied by s from each constraint in C. Define the function {a mathematical formula}f:Vp→B∪{⊤} such that {a mathematical formula}f(x)=B if {a mathematical formula}B(x)∈S and {a mathematical formula}f(x)=⊤ otherwise. Note that f is a well-defined function since it cannot be the case (due to PD) that {a mathematical formula}B(x) and {a mathematical formula}B′(x) are simultaneously in S if {a mathematical formula}B≠B′. Also note that f is compatible since the solution s satisfies at least one disjunct in each constraint.Consider the following algorithm for solving {a mathematical formula}CSP(B∨ω):
       <list>
        {a mathematical formula}ans:=falsefor every compatible {a mathematical formula}f∈F′ do the followingcompute {a mathematical formula}Sfif {a mathematical formula}(V,Sf) is satisfiable then {a mathematical formula}ans:=truereturn ansThe correctness of the algorithm was verified above. We continue by analyzing its time complexity. Computing
       </list>
       <paragraph>
        {a mathematical formula}Sf takes polynomial time in the size of {a mathematical formula}(V,C) since p and {a mathematical formula}|B| are fixed constants that only depends on the choice of {a mathematical formula}B. Checking whether {a mathematical formula}(V,Sf) is satisfiable or not takes polynomial time since {a mathematical formula}CSP(B) is a polynomial-time solvable problem. The set F contains {a mathematical formula}(|B|+1)|V|p=2|V|plog⁡(m+1) functions and these functions can be incrementally computed with negligible overhead. Furthermore, checking whether a function {a mathematical formula}f∈F′ is compatible or not can be done in polynomial time. We conclude that the algorithm runs in {a mathematical formula}O(2|V|p⋅log⁡(m+1)⋅poly(‖I‖)) time.  □
       </paragraph>
      </paragraph>
     </section>
     <section label="4.2">
      <section-title>
       Domain enumeration
      </section-title>
      <paragraph>
       A fundamental problem with structure enumeration is that the number of instances to be enumerated increases rapidly with the number of variables. This phenomenon is particularly noticeable if the basic relations have high arity: if the arity of the basic relations {a mathematical formula}{B1,…,Bm} is p, then we need to consider between {a mathematical formula}2m|V|p instances (in the general case) and {a mathematical formula}2log⁡m⋅|V|p instances (in the JEPD case). We will suggest an alternative enumeration method in this section, domain enumeration, that offers a partial solution to the problems with structure enumeration. This section contains four parts: we begin by presenting the method and giving temporal reasoning examples in Sections 4.2.1 and 4.2.2, respectively. We continue by elaborating upon the method in Sections 4.2.3 and 4.2.4.
      </paragraph>
      <section label="4.2.1">
       <section-title>
        Basics
       </section-title>
       <paragraph>
        A possible solution to the problem outlined above is to enumerate domain elements instead — a method that is analogous to the basic algorithm for solving finite-domain CSPs. This approach presents certain difficulties, though:
       </paragraph>
       <list>
        <list-item label="1.">
         there needs to exist some finite selection of elements that guarantees that solvable instances have solutions restricted to these elements,
        </list-item>
        <list-item label="2.">
         the elements need to be representable in some suitable way, and
        </list-item>
        <list-item label="3.">
         we need an efficient method for verifying whether a variable assignment using these elements is a solution or not.
        </list-item>
       </list>
       <paragraph>
        We concretize these requirements in the next theorem.
       </paragraph>
       <paragraph label="Theorem 9">
        Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and{a mathematical formula}m=|B|. Assume there exist functions{a mathematical formula}t,u:N→Nsuch that for arbitrary{a mathematical formula}n&gt;0
        <list>
         there exist finite sets{a mathematical formula}S1n,…,Sannfor some{a mathematical formula}an&gt;0such that for every solvable instance{a mathematical formula}I=(V,C)of{a mathematical formula}CSP(B)with{a mathematical formula}|V|=n, there exists a solution{a mathematical formula}f:V→Sinfor some{a mathematical formula}1≤i≤an,the set{a mathematical formula}{Sin|1≤i≤n}can be generated in{a mathematical formula}t(n)time, andit can be verified in{a mathematical formula}u(‖I‖)time whether a function{a mathematical formula}f:V→Si|V|is a solution to a given instance{a mathematical formula}I=(V,C)of{a mathematical formula}CSP(B∨ω).Let
        </list>
        <paragraph label="Proof">
         {a mathematical formula}bi=max⁡{|S1i|,…,|Saii|}. Then{a mathematical formula}CSP(B∨ω)is solvable in{a mathematical formula}O(t(|V|)+a|V|⋅2|V|log⁡b|V|⋅u(‖I‖)⋅poly(‖I‖))time.Let {a mathematical formula}I=(V,C) be an arbitrary instance of {a mathematical formula}CSP(B∨ω). If I has a solution, then there is a solution {a mathematical formula}f:V→Si|V| for some {a mathematical formula}1≤i≤a|V| by condition (1). Condition (2) allows us to compute the set {a mathematical formula}S={Sin|1≤i≤n}. For each {a mathematical formula}S∈S, we generate every function from V to S and check whether it is a solution or not — there is a method for this by condition (3). Generating the set {a mathematical formula}S takes {a mathematical formula}t(|V|) time by (2). Given an {a mathematical formula}S∈S, there are at most {a mathematical formula}(b|V|)|V|=2|V|⋅log⁡b|V| functions from V to S, and the size of {a mathematical formula}S is at most {a mathematical formula}a|V| by (1). Checking whether such a function is a solution or not can be done in {a mathematical formula}u(‖I‖) time by (3). Taken together, it follows that {a mathematical formula}CSP(B∨ω) is solvable in {a mathematical formula}O(t(|V|)+a|V|⋅2|V|log⁡b|V|⋅u(‖I‖)⋅poly(‖I‖)) time.  □
        </paragraph>
       </paragraph>
       <paragraph>
        A basic requirement for structure enumeration is that {a mathematical formula}CSP(B) is in P (or, at least, does not have too high time complexity). Observe that this is irrelevant in domain enumeration since it is sufficient to check whether concrete variable assignments are solutions or not.
       </paragraph>
      </section>
      <section label="4.2.2">
       <section-title>
        Two examples from temporal reasoning
       </section-title>
       <paragraph>
        Let {a mathematical formula}T={&lt;,&gt;,=} denote the JEPD order relations on {a mathematical formula}Q. The CSP problem for {a mathematical formula}T∨= is often referred to as the time point algebra and it has been intensively studied within the temporal reasoning community. It was realized quite early that {a mathematical formula}CSP(T) is tractable [63] and, soon after, that {a mathematical formula}CSP(T∨=) is tractable [62], too. It is also well-known that {a mathematical formula}CSP(T∨ω) is NP-complete. This follows from general results by Broxvall et al. [16] but it was known earlier: it can, for instance, quite easily be inferred from the original NP-hardness proof for Allen's algebra [63].
       </paragraph>
       <paragraph>
        We now recall that Theorem 7 implies that {a mathematical formula}CSP(T∨ω) can be solved in {a mathematical formula}O(2|V|2⋅log⁡3⋅poly(‖I‖)) time. We improve this bound using domain enumeration as follows.
       </paragraph>
       <paragraph label="Proof">
        {a mathematical formula}CSP(T∨ω)is solvable in{a mathematical formula}O(2|V|log⁡|V|⋅poly(‖I‖))time.Let {a mathematical formula}I=(V,C) be an arbitrary instance of {a mathematical formula}CSP(T∨ω). If I has a solution, then we claim that there is a solution {a mathematical formula}f:V→{1,…,|V|}. To see this, let {a mathematical formula}f′:V→Q be an arbitrary solution to I. Assume {a mathematical formula}{f′(v)|v∈V}={a1,…,ap} where {a mathematical formula}a1&lt;a2&lt;…&lt;ap. Define {a mathematical formula}f:V→{1,…,|V|} such that {a mathematical formula}f(v)=i if and only if {a mathematical formula}f′(v)=ai. We see that f is a solution to I since {a mathematical formula}f(v)&lt;f(v′) if and only if {a mathematical formula}f′(v)&lt;f′(v′), {a mathematical formula}f(v)=f(v′) if and only if {a mathematical formula}f′(v)=f′(v′), and {a mathematical formula}f(v)&gt;f(v′) if and only if {a mathematical formula}f′(v)&gt;f′(v′).The set {a mathematical formula}{1,…,|V|} has cardinality {a mathematical formula}|V| and it can be computed in {a mathematical formula}O(|V|⋅log⁡(|V|)) time. In other words, {a mathematical formula}a|V|=1, {a mathematical formula}b|V|=|V|, and {a mathematical formula}t,u are polynomials. Theorem 9 gives that {a mathematical formula}CSP(T∨ω) can be solved in{a mathematical formula} since {a mathematical formula}|V|≤‖I‖.  □
       </paragraph>
       <paragraph>
        As our second example, we consider CSPs for branching time temporal reasoning. Here, we will use domain enumeration in a more substantial way that in the previous example. The branching time model has been used in, for instance, planning [23] and the analysis and verification of concurrent systems [27]. Let F be the forest containing all oriented, finite trees where the indegree of each node is at most one and let {a mathematical formula}DF be the nodes in F. We then define the following four relations on F. Arbitrarily choose {a mathematical formula}x,y∈DF.
       </paragraph>
       <list>
        <list-item label="1.">
         {a mathematical formula}x=Fy if and only if there is a path from x to y and a path from y to x,
        </list-item>
        <list-item label="2.">
         {a mathematical formula}x&lt;Fy if and only if and there is a path from x to y but no path from y to x,
        </list-item>
        <list-item label="3.">
         {a mathematical formula}x&gt;Fy if and only if there is a path from y to x but no path from x to y, and
        </list-item>
        <list-item label="4.">
         {a mathematical formula}x‖Fy if and only if there is no path from x to y and no path from y to x.
        </list-item>
       </list>
       <paragraph>
        These four basic relations are known as the point algebra for branching time. We let {a mathematical formula}P={=F,&lt;F,&gt;F,‖F} and we note that {a mathematical formula}P is JEPD. The problem {a mathematical formula}CSP(P∨=) is in P [31] while the problem {a mathematical formula}CSP(P∨ω) is NP-complete [15].
       </paragraph>
       <paragraph label="Example 11">
        Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(P∨ω) where {a mathematical formula}V={x1,x2,x3,x4,x5} and C contains the constraints{a mathematical formula} where {a mathematical formula}xi≤Fxj is an abbreviation of {a mathematical formula}(xi&lt;Fxj)∨(xi=Fxj) and {a mathematical formula}xi&lt;&gt;Fxj an abbreviation of {a mathematical formula}(xi&lt;Fxj)∨(xi&gt;Fxj). This instance is satisfiable by e.g. the function {a mathematical formula}f(x1)=a, {a mathematical formula}f(x2)=b, {a mathematical formula}f(x3)=d, {a mathematical formula}f(x4)=e and {a mathematical formula}f(x5)=d, where a, b, d, e are the points in the forest in Fig. 2. But if we let {a mathematical formula}f′(x)=f(x) for {a mathematical formula}x∈{x1,x3,x4,x5} and {a mathematical formula}f′(x2)=g, then {a mathematical formula}f′ is not satisfying assignment since the constraint {a mathematical formula}x1&lt;&gt;Fx2 is not satisfied by the partial order in Fig. 2.
       </paragraph>
       <paragraph>
        From a formal viewpoint, we need to work with the structure F and view solutions as functions from variables to {a mathematical formula}DF. It is, however, quite impractical to work with the large and opaque structure F directly. It is easier to use the following observation: an instance {a mathematical formula}(V,C) of {a mathematical formula}CSP(P∨ω) has a solution if and only if there exist an oriented forest T with the property that
       </paragraph>
       <list>
        <list-item label="1.">
         the indegree of each node in T is at most one and
        </list-item>
        <list-item label="2.">
         the number of nodes in T equals {a mathematical formula}|V|,
        </list-item>
       </list>
       <paragraph>
        such that the relations in C are satisfied by T (according to the interpretation of the basic relations given above). In particular, Theorem 9 is still applicable but we do not have to explicitly give unique names to all elements in {a mathematical formula}DF and invent algorithms that work with this representation.
       </paragraph>
       <paragraph label="Theorem 12">
        We know from Theorem 7 that {a mathematical formula}CSP(P∨ω) can be solved in {a mathematical formula}O(2|V|2⋅log⁡4⋅poly(‖I‖))=O(22|V|2⋅poly(‖I‖)) time. We will now improve upon this result. Let {a mathematical formula}τ(n) denote the number of unlabeled trees on n vertices. Otter [51] has shown that there exist constants {a mathematical formula}C,α such that {a mathematical formula}limn→∞⁡τ(n)Cαnn−5/2=1 where {a mathematical formula}C&gt;0.53 and {a mathematical formula}α&lt;2.96. {a mathematical formula}CSP(P∨ω)is solvable in{a mathematical formula}O(2|V|+log⁡(τ(|V|))+|V|log⁡|V|⋅poly(‖I‖))time.
       </paragraph>
       <paragraph label="Proof">
        In this proof, we will utilize Theorem 9 so we need to define the constants {a mathematical formula}a1,a2,…, {a mathematical formula}b1,b2,…, the sets {a mathematical formula}S1n,…,Sann for arbitrary n, and the functions t and u. We will use the alternative representation of solutions that we outlined after Example 11 so the sets {a mathematical formula}S1n,…,Sann will be concrete forests and not subsets of {a mathematical formula}DF.Given some {a mathematical formula}n&gt;0, we first estimate the number of directed forests with n nodes where each node has indegree at most one. To enumerate all forests instead of trees, we can enumerate all unlabeled trees with {a mathematical formula}n+1 vertices and only consider the trees where the extra vertex is connected to all other vertices. By removing this vertex we obtain a forest with n vertices (which implies that {a mathematical formula}bn=n). Hence, there are at most {a mathematical formula}2nτ(n+1) directed forests with n nodes. The factor {a mathematical formula}2n stems from the observation that each forest contains at most n edges, where each edge has two possible directions. We then filter out the directed forests containing a tree where the indegree of any vertex is more than one, and we let {a mathematical formula}S1n,...,Sann denote these forests. It follows that we can upper bound {a mathematical formula}an with {a mathematical formula}2nτ(n+1).Next, we need a way to compute the set of all directed forests where each node has indegree at most one. The only non-constructive argument above is the generation of all directed labeled trees with n nodes. However, these can be efficiently enumerated (with polynomial delay) as demonstrated by Wright et al. [66]. Thus, {a mathematical formula}t(n)=2nτ(n+1)⋅poly(n).Finally, we need a way of checking whether a function {a mathematical formula}f:V→Si|V| is a solution to an instance {a mathematical formula}(V,C) of {a mathematical formula}CSP(P∨ω). Since {a mathematical formula}Si|V| is a forest, we can directly use the definitions of the basic relations in {a mathematical formula}P when verifying this condition. This can be done in polynomial time so the function u is some polynomial.Putting the pieces together with the aid of Theorem 9, we see that {a mathematical formula}CSP(P∨ω) is solvable in time{a mathematical formula} □
       </paragraph>
       <paragraph>
        A simpler algorithm is obtained if we enumerate all labeled trees (by, for instance, using Prüfer sequences[53]) instead of the unlabeled trees. However, there are {a mathematical formula}nn−2 such trees on n vertices according to Cayley's formula. This implies that the resulting algorithm runs in {a mathematical formula}O(2|V|+2|V|log⁡|V|⋅poly(‖I‖)) time. This is substantially slower than the algorithm in Theorem 12 since {a mathematical formula}log⁡τ|V|≤(1+ϵ)|V| (for arbitrary {a mathematical formula}ϵ&gt;0) when {a mathematical formula}|V| is sufficiently large.
       </paragraph>
      </section>
      <section label="4.2.3">
       <section-title>
        Bounded disjunctions
       </section-title>
       <paragraph>
        This section contains a more efficient method for solving {a mathematical formula}CSP(B∨k) when k is a fixed constant. In particular, such problems are interesting when studying finite constraint languages due to Lemma 2. The idea is to construct a number of k-SAT instances with the property that at least one of them is satisfiable if and only if the original instance has a solution. More or less similar ideas have been used frequently in the literature and examples include algorithms for k-SAT [22], algorithms for combinatorial optimization [60, Sec. 8], and derandomization of probabilistic CSP algorithms [50]. One may also see certain similarities to the sparsification method that we presented in Section 3.2: sparsification is also based on the idea of transforming a single CSP instance into a set of CSP instances with advantageous properties. In the statement of the following theorem, let {a mathematical formula}ck denote an arbitrary real number {a mathematical formula}ck&lt;1 such that there exists a deterministic algorithm solving k-SAT in {a mathematical formula}O(2ck⋅|V|) time.
       </paragraph>
       <paragraph label="Theorem 13">
        Let{a mathematical formula}Bbe a set of basic relations with maximum arity p and{a mathematical formula}m=|B|. Assume that the following holds for every{a mathematical formula}n&gt;0.
        <list>
         there exist finite sets{a mathematical formula}S1n,…,Sannsuch that for every solvable instance{a mathematical formula}I=(V,C)of{a mathematical formula}CSP(B), there exists a solution{a mathematical formula}f:V→Sinfor some{a mathematical formula}1≤i≤anandthe set{a mathematical formula}{Sin|1≤i≤n}can be generated in{a mathematical formula}u(n)time.Let
        </list>
        <paragraph label="Proof">
         {a mathematical formula}bi=max⁡{|S1i|,…,|Saii|}. Then{a mathematical formula}CSP(B∨k)is solvable in{a mathematical formula}O(u(|V|)+a|V|⋅2|V|(log⁡b|V|−1+log⁡(ckp))⋅poly(‖I‖))time.Let {a mathematical formula}I=(V,C) be an arbitrary instance of {a mathematical formula}CSP(B∨k). Assume {a mathematical formula}V={x1,…,xs}. If I has a solution, then there is a solution {a mathematical formula}f:V→Si|V| for some {a mathematical formula}1≤i≤a|V| by Condition (1). Thus, we begin by computing the set {a mathematical formula}S={Sin|1≤i≤n}. This is possible due to Condition (2). We assume, without loss of generality, that {a mathematical formula}|S| is even for every {a mathematical formula}S∈S and, for simplicity, we additionally assume that {a mathematical formula}S={1,…,2t} for some {a mathematical formula}t≥1. For each {a mathematical formula}S∈S, we construct a set of k-SAT instances {a mathematical formula}F1,…,Fp such that there exists (at least) one {a mathematical formula}Fi that is satisfiable if and only if there is a solution {a mathematical formula}f:V→S to I. We describe this construction next.Arbitrarily choose a vector {a mathematical formula}z=(z1,…,z|V|) where {a mathematical formula}zi∈{1,3,5,…,2t−1}, {a mathematical formula}1≤i≤|V|. We let {a mathematical formula}Fz denote the k-SAT instance associated with the vector z. The instance {a mathematical formula}Fz contains variable set {a mathematical formula}V′={x1′,…,xs′} where we interpret variable {a mathematical formula}xi as follows: if {a mathematical formula}xi′ is false, then variable {a mathematical formula}xi has value {a mathematical formula}zi and, otherwise, {a mathematical formula}xi has value {a mathematical formula}zi+1. Arbitrarily choose a constraint in C. For simplicity, we assume that the constraint has maximal arity kp and that it equals {a mathematical formula}R(x1,…,xkp). For each tuple{a mathematical formula} that is not a member of the set{a mathematical formula} add the clause that ‘forbids’ this assignment to the variables, given the interpretation of variables described above. Note that this clause has arity kp, too. Do this for all constraints in C. It follows that F is satisfiable if and only if there exists a satisfying solution {a mathematical formula}f:V→{1,…,2t} to I such that {a mathematical formula}f(x1)∈{z1,z1+1}, {a mathematical formula}f(x2)∈{z2,z2+1}, and so on.By choosing all possible vectors z, we end up with {a mathematical formula}(2t/2)|V|=(b|V|/2)|V|kp-SAT instances such that at least one of them is satisfiable if and only if I has a solution. We need to verify the time complexity of this procedure. Note first that computing {a mathematical formula}Fz can be done in polynomial time since the number of assignments that are forbidden by a constraint is at most {a mathematical formula}2p, and p is a fixed constant. Finally, the time needed for verifying the satisfiability of {a mathematical formula}Fa is {a mathematical formula}O(2ckp⋅|V|), and computing the set {a mathematical formula}S takes {a mathematical formula}u(|V|) time due to condition (2). It follows that{a mathematical formula} which concludes the proof.  □
        </paragraph>
       </paragraph>
       <paragraph>
        The change in time complexity may seem minimal in comparison with Theorem 9. However, note that{a mathematical formula} so there is an exponential speed-up even if we do not take the negative term {a mathematical formula}log⁡ckp into account. We remind the reader that the bounded length of disjunctions is vital for this method to work. If the length is unbounded, then there may be an exponential number of assignments that must be excluded by adding clauses to {a mathematical formula}Fz. This implies that the time needed for constructing {a mathematical formula}Fz adds an exponential factor to the complexity figure in Theorem 13.
       </paragraph>
       <paragraph>
        We will now turn our attention towards finite temporal constraint languages. Let us first consider total-ordered time. The computational complexity of such CSP problems has been intensively studied in the literature. In a breakthrough result, Bodirsky and Kára [13] have determined the complexity of {a mathematical formula}CSP(Γ) for all such Γ and their result shows that {a mathematical formula}CSP(Γ) is either tractable or NP-complete. It is well known that the first-order theory of {a mathematical formula}(Q,&lt;) admits quantifier elimination [13], [33]. Hence, we can exploit Lemma 2 and Theorem 13 to obtain the following corollary.
       </paragraph>
       <paragraph label="Corollary 14">
        Let Γ be a finite constraint language that is first-order definable in{a mathematical formula}(Q,&lt;). If{a mathematical formula}CSP(Γ)is NP-complete, then it is solvable in time{a mathematical formula}O(2|V|(log⁡|V|−1−sΓ)⋅poly(‖I‖))where{a mathematical formula}0≤sΓ≤1is a constant that only depends on the choice of Γ. Otherwise,{a mathematical formula}CSP(Γ)is polynomial-time solvable.
       </paragraph>
       <paragraph>
        Unfortunately, we cannot give a similar result for branching time since branching time does not admit quantifier elimination [8, Section 4.2] (so Lemma 2 is not applicable) and there is no complexity classification available. However, there are closely connected constraint languages on trees that have this property. Examples include the triple consistency problem with important applications in bioinformatics [14]: here we have both quantifier elimination and a complexity classification [11].
       </paragraph>
      </section>
      <section label="4.2.4">
       <section-title>
        Improved domain enumeration
       </section-title>
       <paragraph>
        In the proof of Theorem 9, we compute a set {a mathematical formula}{S1,…,Sn} of finite variable domains and then consider all possible functions {a mathematical formula}V→S1, {a mathematical formula}V→S2, …, {a mathematical formula}V→Sn. There are obviously cases where we do not need to enumerate all functions and this may lead to improved complexity figures. We demonstrate this by considering equality languages. An equality language is a set of relations definable through first-order formulas over the structure {a mathematical formula}(D,=). Such languages are of fundamental interest in complexity classifications for infinite domain CSPs, since a classification of CSP problems based on first-order definable relations over some fixed structure typically includes the classification of equality constraint language CSPs.
       </paragraph>
       <paragraph>
        Let {a mathematical formula}E={=,≠} over some countably infinite domain D. Note that {a mathematical formula}E∨ω is a sublanguage of {a mathematical formula}T∨ω so {a mathematical formula}CSP(E∨ω) can be solved in {a mathematical formula}O(2|V|log⁡|V|⋅poly(‖I‖)) time by Theorem 10 (which, in turn, is based on Theorem 9). We will now improve upon this bound but first we need some additional machinery. A partition of a set X with n elements is a pairwise disjoint set {a mathematical formula}{X1,…,Xm}, {a mathematical formula}m≤n such that {a mathematical formula}⋃i=1mXi=X. A set X with n elements has {a mathematical formula}Bn partitions, where {a mathematical formula}Bn is the n-th Bell number. Let {a mathematical formula}L(n)=0.792nln⁡(n+1). It is known that {a mathematical formula}Bn&lt;L(n)n[5] and that all partitions can be enumerated in {a mathematical formula}O(nBn) time [25], [59].
       </paragraph>
       <paragraph label="Theorem 15">
        {a mathematical formula}CSP(E∨ω)is solvable in{a mathematical formula}O(|V|2|V|⋅log⁡L(|V|)⋅poly(‖I‖))time.
       </paragraph>
       <paragraph label="Proof">
        Let {a mathematical formula}I=(V,C) be an instance of {a mathematical formula}CSP(E∨ω). For every partition {a mathematical formula}S1∪…∪Sn of V we interpret the variables in {a mathematical formula}Si as being equal and having the value i, i.e. a constraint {a mathematical formula}(x=y) holds if and only if x and y belong to the same set and {a mathematical formula}(x≠y) holds if and only if x and y belong to different sets. Then check in {a mathematical formula}poly(‖I‖) time if this partition satisfies I using the above interpretation. The complexity of this algorithm is therefore {a mathematical formula}O(|V|L|V|⋅poly(‖I‖))⊆O(|V|L(|V|)|V|⋅poly(‖I‖))=O(|V|2|V|⋅log⁡L(|V|)⋅poly(‖I‖)).  □
       </paragraph>
       <paragraph>
        The approach taken in Theorem 15 can be viewed as an opposite extreme of Theorem 9: here, we only consider one function per set of possible values.
       </paragraph>
       <paragraph>
        It is well known that equality constraint languages admit quantifier elimination [12]. Hence, we can use Lemma 2 to extend Theorem 15 to cover arbitrary equality constraint languages.
       </paragraph>
       <paragraph label="Corollary 16">
        Let Γ be a finite set of relations first-order definable over{a mathematical formula}(D,=). Then{a mathematical formula}CSP(Γ)is solvable in{a mathematical formula}O(|V|2|V|⋅log⁡L(|V|)⋅poly(‖I‖))time.
       </paragraph>
       <paragraph>
        Recall that {a mathematical formula}T∨k (and consequently {a mathematical formula}E∨k) can be solved in time {a mathematical formula}O(2|V|(log⁡|V|−1−sk)⋅poly(‖I‖)) where {a mathematical formula}0≤sk≤1. This bound is beaten by Corollary 16 whenever {a mathematical formula}log⁡L(|V|)&lt;(log⁡|V|−1−sk) and this occurs even for fairly small {a mathematical formula}|V| since{a mathematical formula}
       </paragraph>
      </section>
     </section>
    </section>
    <section label="5">
     <section-title>
      Lower bounds
     </section-title>
     <paragraph>
      The algorithms presented in Section 4 give improved upper bounds (compared to the bounds given in Section 3) for many constraint satisfaction problems. It is natural to also ask, given reasonable complexity theoretical assumptions, how much room there is for improvement. Even though providing systematic lower bounds appears to be a challenging problem, non-trivial lower bounds can be given in certain cases. Such results are typically obtained by reducing a problem, which is believed to have a particular lower bound, to the problem in question. The reduction needs to have certain properties in order to be useful: basically, the reduction is not allowed to blow up the parameter that we are interested in too much. Since we measure time complexity in the number of variables, we need reductions that introduce only a small number of additional variables.
     </paragraph>
     <paragraph>
      This section is divided into two parts. Section 5.1 contains lower bounds for {a mathematical formula}CSP(B∨ω) and {a mathematical formula}CSP(B∨k) based on the (strong) exponential time hypothesis, and Section 5.2, where we obtain lower bounds for Allen's interval algebra based on the Chromatic Number problem.
     </paragraph>
     <section label="5.1">
      <section-title>
       Lower bounds based on (S)ETH
      </section-title>
      <paragraph>
       We begin by providing a general lower bound for {a mathematical formula}CSP(B∨ω) (Theorem 17) and we immediately observe (Corollary 18) that this reduction is useful for analyzing {a mathematical formula}CSP(B∨k) when {a mathematical formula}k≥3, too. We continue by refining our results in Theorem 19: if {a mathematical formula}B is JEPD and contains the equality relation, then there is a stronger lower bound for {a mathematical formula}CSP(B∨ω) than the one given in Theorem 17. This result is not useful for studying {a mathematical formula}CSP(B∨k) since it introduces disjunctive constraints with many disjuncts.
      </paragraph>
      <paragraph label="Theorem 17">
       Let{a mathematical formula}B={R1,R2,…,Rm},{a mathematical formula}m&gt;1, be a set of nonempty p-ary basic relations such that{a mathematical formula}R1∩R2=∅. If the SETH holds, then{a mathematical formula}CSP(B∨ω)cannot be solved in{a mathematical formula}O(2δ|V|)time for any{a mathematical formula}δ&lt;1.
      </paragraph>
      <paragraph label="Proof">
       If the SETH holds then SAT cannot be solved in {a mathematical formula}O(2δ|V|) time for any {a mathematical formula}δ&lt;1. We provide a polynomial-time many-one reduction from SAT to {a mathematical formula}CSP(B∨ω) which only increases the number of variables by a constant (that only depends on the choice of {a mathematical formula}B) — hence, if {a mathematical formula}CSP(B∨ω) is solvable in {a mathematical formula}O(2δ|V|) time for some {a mathematical formula}δ&lt;1 then SAT is also solvable in {a mathematical formula}O(2δ|V|) time, contradicting the original assumption. We begin by constructing a useful gadget. Consider the following CSP instance:{a mathematical formula} This instance is satisfiable since both {a mathematical formula}R1 and {a mathematical formula}R2 are non-empty relations. Consider instead the instance{a mathematical formula} In this case, the instance can be either satisfiable or not satisfiable. If it is not satisfiable, then one may note that every solution f to instance {a mathematical formula}I1 has the property {a mathematical formula}f(u1)≠f(v1). If {a mathematical formula}I2 is satisfiable, then we can continue the process of identifying variables until we reach a non-satisfiable instance{a mathematical formula} We thus have the following satisfiable instance{a mathematical formula} and we can continue the process of identifying variables by introducing a fresh variable {a mathematical formula}z2 and arrive at the instance{a mathematical formula} Just as in the case when we introduced {a mathematical formula}z1, this instance may or may not be satisfiable. If it is not satisfiable, then {a mathematical formula}I4 is satisfiable and every solution f satisfies {a mathematical formula}f(uk)≠f(vk). Otherwise, we can continue the process described above. In the end, we will end up with a satisfiable instance{a mathematical formula}{a mathematical formula} such that every solution f satisfies {a mathematical formula}f(y)≠f(y′). Note that the property PD guarantees that the process above will stop at some point since {a mathematical formula}R1(x)∧R2(y) is not satisfiable when the variable vectors x and y are identical. We abbreviate the resulting instance {a mathematical formula}R1(z,y,u)∧R2(z,y′,v) and let {a mathematical formula}K=k1+…+km+2. Let {a mathematical formula}f⁎ be an arbitrary solution to {a mathematical formula}I⁎.We are now ready to present the reduction. Let {a mathematical formula}I=(V,C) be an instance of SAT, where V is a set of variables and C a set of clauses. First observe that since {a mathematical formula}m≥2 and since {a mathematical formula}B is PD, {a mathematical formula}B must be defined over a domain with two or more elements. Introduce the variables {a mathematical formula}z1,…,zm,vK,…,vp,uK,…,up. Given a variable x, define{a mathematical formula} and{a mathematical formula} For every clause {a mathematical formula}(ℓ1∨…ℓk)∈C, create the constraint {a mathematical formula}(ϕ(ℓ1)∨…∨ϕ(ℓk)). We prove that the resulting instance J is satisfiable if and only if I is satisfiable.Assume first that I has a solution {a mathematical formula}f:V→{0,1}. We construct a solution {a mathematical formula}g:V∪{z1,…,zm,vK,…,vp,uK,…,up}→D to J as follows. First let {a mathematical formula}g(zi)=f⁎(zi){a mathematical formula}(1≤i≤m), {a mathematical formula}g(ui)=f⁎(ui){a mathematical formula}(K≤i≤p), and {a mathematical formula}g(vi)=f⁎(vi){a mathematical formula}(K≤i≤p). Furthermore, let {a mathematical formula}g(x)=f⁎(y) if {a mathematical formula}f(x)=1 and let {a mathematical formula}g(x)=f⁎(y′) if {a mathematical formula}f(x)=0.Arbitrarily choose a clause {a mathematical formula}C=(ℓ1∨…∨ℓm) in C and recall that there is a corresponding constraint {a mathematical formula}C′=(ϕ(ℓ1)∨…∨ϕ(ℓm)) in J. Assume without loss of generality that {a mathematical formula}ℓ1 is satisfied by f. If {a mathematical formula}ℓ1=x1, then {a mathematical formula}f(x1)=1 and the corresponding relation in {a mathematical formula}C′ is {a mathematical formula}R1(z,x,u). Note that this relation (and thus the constraint {a mathematical formula}C′) is indeed satisfied by g, If {a mathematical formula}ℓ1=¬x1, then {a mathematical formula}f(x1)=0 and the corresponding relation in {a mathematical formula}C′ is {a mathematical formula}R2(z,x,v). Once again, the constraint {a mathematical formula}C′ is satisfied by g, and J is satisfiable.Assume instead that J has a solution f. This solution makes at least one disjunct in each constraint satisfied so we let the set S contain exactly one satisfied disjunct from each constraint. The set S cannot simultaneously contain the constraints {a mathematical formula}R1(z,x,u) and {a mathematical formula}R1(z,x,v) for any variable {a mathematical formula}x∈V. Thus we can construct a solution g for I as follows: if {a mathematical formula}R1(z,x,u)∈S, then {a mathematical formula}g(x)=1 and {a mathematical formula}g(x)=0 otherwise. Since there is a one-to-one correspondence between clauses in I and the disjunctive constraints in J, it follows that g must be a satisfying assignment to I.  □
      </paragraph>
      <paragraph>
       If the SAT instance I in the proof of Theorem 17 has clauses of length at most k, then the resulting CSP instance J is an instance of {a mathematical formula}CSP(B∨k). The ETH immediately gives us the following result.
      </paragraph>
      <paragraph label="Corollary 18">
       Let{a mathematical formula}B={R1,R2,…,Rm},{a mathematical formula}m&gt;1, be a set of nonempty p-ary basic relations such that{a mathematical formula}R1∩R2=∅. If the ETH holds, then{a mathematical formula}CSP(B∨k),{a mathematical formula}k≥3, cannot be solved in{a mathematical formula}O(2δk|V|)time.
      </paragraph>
      <paragraph>
       Theorem 17 and Corollary 18 have a wide range of applicability since the only restriction on the set {a mathematical formula}B is that it contains two distinct relations {a mathematical formula}R1,R2 such that {a mathematical formula}R1∩R2=∅. There are significantly better lower bounds if we impose additional restrictions on the set {a mathematical formula}B. By assuming that the relations are JEPD and that we have access to = (as usual, we let = denote the equality relation on a given domain), we can view several variables as a single variable and thus obtain stronger lower bounds. Similar techniques have been used when proving lower bounds by, for instance, Traxler [61] and Gutin and Wahlström [30].
      </paragraph>
      <paragraph label="Proof">
       Let{a mathematical formula}B={=,R1,…,Rm}be a set of binary JEPD relations over a countably infinite domain. If the SETH holds, then{a mathematical formula}CSP(B∨ω)cannot be solved in{a mathematical formula}O(c|V|)time for any{a mathematical formula}c&gt;1.First observe that the binary inequality relation ≠ over D can be defined as {a mathematical formula}⋃i=1mRi since {a mathematical formula}B is JEPD. In the proof we therefore use ≠ as an abbreviation for {a mathematical formula}⋃i=1mRi. Let {a mathematical formula}I=(V,C) be an instance of SAT with variables {a mathematical formula}V={x1,…,xn} and the set of clauses C. Let K be an integer such that {a mathematical formula}K&gt;log⁡c. Assume without loss of generality that n is a multiple of K. We will construct an instance of {a mathematical formula}CSP(B∨ω) with {a mathematical formula}nK+2K=nK+O(1) variables. First, introduce {a mathematical formula}2K fresh variables {a mathematical formula}v1,…,v2K and make them different by imposing ≠ constraints. Second, introduce {a mathematical formula}nK fresh variables {a mathematical formula}y1,…,ynK, and for each {a mathematical formula}i∈{1,…,nK} impose the constraint{a mathematical formula} Let {a mathematical formula}V1,…,VnK be a partition of V such that each {a mathematical formula}|Vi|=K. We will represent each set {a mathematical formula}Vi of Boolean variables by one {a mathematical formula}yi variable over D. To do this we will interpret each auxiliary variable {a mathematical formula}zi as a K-ary Boolean tuple. Let {a mathematical formula}h:{v1,…,v2K}→{0,1}K be an injective function which assigns a Boolean K-tuple for every variable {a mathematical formula}vi. Let {a mathematical formula}g+ be a function from {a mathematical formula}{1,…,K} to subsets of {a mathematical formula}{v1,…,v2K} such that {a mathematical formula}vi∈g(j) if and only if the j-th element in {a mathematical formula}h(vi) is equal to 1. Define {a mathematical formula}g− in the analogous way. Observe that {a mathematical formula}|g+(j)|=|g−(j)|=2K−1 for each {a mathematical formula}j∈{1,…,K}.For the reduction, let {a mathematical formula}(ℓi1∨…∨ℓin′), {a mathematical formula}ℓij=xij or {a mathematical formula}ℓij=¬xij, be a clause in C. We assume that {a mathematical formula}n′≤n since the clause contains repeated literals otherwise. For each literal {a mathematical formula}ℓij let {a mathematical formula}Vi′⊆V be the set of variables such that {a mathematical formula}xij∈Vi′. Each literal {a mathematical formula}ℓij is then replaced by{a mathematical formula} if {a mathematical formula}ℓij=xij, and with{a mathematical formula} if {a mathematical formula}ℓij=¬xij. This reduction can be done in polynomial time since a clause with {a mathematical formula}n′ literals is replaced by a disjunctive constraint with {a mathematical formula}n′2K−1 disjuncts (since K is a constant depending only on c). It follows that SAT can be solved in{a mathematical formula} for some {a mathematical formula}δ&lt;1, since {a mathematical formula}K&gt;log⁡c. Thus, the SETH does not hold.  □
      </paragraph>
      <paragraph>
       As an illustrative use of the theorem we see that the temporal problem {a mathematical formula}CSP(T∨ω) is solvable in {a mathematical formula}O(2|V|log⁡|V|⋅poly(‖I‖)) time but not in {a mathematical formula}O(c|V|) time for any {a mathematical formula}c&gt;1 if the SETH holds. Lower bounds can also be obtained for the branching time problem {a mathematical formula}CSP(P∨ω) since there is a trivial reduction from {a mathematical formula}CSP(T)∨ω which does not increase the number of variables: simply add a constraint {a mathematical formula}(x&lt;y∨x&gt;y∨x=y) for every pair of variables in the instance. Similarly, the equality constraint satisfaction problem {a mathematical formula}CSP(E∨ω) is not solvable in {a mathematical formula}O(c|V|) time for any {a mathematical formula}c&gt;1 either, unless the SETH fails. Hence, even though the algorithms that were presented in Section 4 might appear to be quite simple, there is very little room for improvement.
      </paragraph>
     </section>
     <section label="5.2">
      Lower bounds based on Chromatic Number
      <paragraph>
       The results in Section 5.1 show that the (S)ETH can be used for obtaining lower bounds for problems such as {a mathematical formula}CSP(B∨ω) and {a mathematical formula}CSP(B∨k). Unfortunately, it is not obvious how to obtain lower bounds for {a mathematical formula}CSP(B∨=) using this assumption. In this section, we present lower bounds for Allen's interval algebra using a conjecture concerning the time complexity of computing the chromatic number of graphs. The bound will not be as strong as the ones obtained by using the (S)ETH and it does not seem to (easily) generalize to other {a mathematical formula}CSP(B∨=) problems.
      </paragraph>
      <paragraph>
       We first recapitulate the basics of Allen's interval algebra. Allen's algebra is a well-known formalism for temporal reasoning where one considers relations between intervals of the form {a mathematical formula}[x,y], where {a mathematical formula}x,y∈R is the starting and ending point, respectively. Let Allen be the {a mathematical formula}213=8192 possible unions of the set of the thirteen relations in Table 1. For convenience we write constraints such as {a mathematical formula}(p∨m)(x,y) as {a mathematical formula}x{p,m}y, using infix notation and omitting explicit disjunction signs. The problem {a mathematical formula}CSP(Allen) is NP-complete and all tractable fragments have been identified [44].
      </paragraph>
      <paragraph>
       Given an instance {a mathematical formula}I=(V,C) of {a mathematical formula}CSP(Allen) we first create two fresh variables {a mathematical formula}xis and {a mathematical formula}xie for every {a mathematical formula}x∈V, intended to represent the startpoint and endpoint of the interval x. Then observe that a constraint {a mathematical formula}x{r1,…,rm}y∈C, where each {a mathematical formula}ri is a basic relation, can be represented as a disjunction of temporal constraints over {a mathematical formula}xs,xe,ys and {a mathematical formula}ye by using the definitions of each basic relation in Table 1. Applying Theorem 10 to the resulting instance gives the following result.
      </paragraph>
      <paragraph label="Corollary 20">
       {a mathematical formula}CSP(Allen)is solvable in{a mathematical formula}O(22|V|(1+log⁡|V|)⋅poly(‖I‖))time.
      </paragraph>
      <paragraph>
       We will now relate {a mathematical formula}CSP(Allen) to the Chromatic Number problem, i.e. the problem of computing the number of colors needed to color a given graph.
      </paragraph>
      <paragraph label="Proof">
       If{a mathematical formula}CSP(Allen)can be solved in{a mathematical formula}O(c|V|)time for some{a mathematical formula}c&lt;2, thenChromatic Numbercan be solved in{a mathematical formula}O((c+ϵ)|V|)time for arbitrary{a mathematical formula}ϵ&gt;0.We first present a polynomial-time many-one reduction from k-Colourability to {a mathematical formula}CSP(Allen) which introduces k fresh variables. Given an undirected graph {a mathematical formula}G=({v1,…,vn},E), introduce the variables {a mathematical formula}z1,…,zk and {a mathematical formula}v1,…,vn, and:
       <list>
        impose the constraints {a mathematical formula}z1{m}z2{m}…{m}zk,for each {a mathematical formula}vi, {a mathematical formula}1≤i≤n, add the constraints {a mathematical formula}vi{≡,s−1}z1, {a mathematical formula}vi{p,m,f−1,d−1}zj ({a mathematical formula}2≤j≤k−1), and {a mathematical formula}vi{p,m,f−1}zk,for each {a mathematical formula}(vi,vj)∈E, add the constraint {a mathematical formula}vi{s,s−1}vj.Consulting
       </list>
       <paragraph>
        Table 1, we see that for each {a mathematical formula}vi, it holds that its right endpoint must equal the right endpoint of some {a mathematical formula}zi, and its left endpoint must equal the left endpoint of {a mathematical formula}z1. Thus, there are exactly k possible choices for the right endpoint of {a mathematical formula}vi. If there is an edge {a mathematical formula}(vi,vj), then we have the constraint {a mathematical formula}vi{s,s−1}vj which ensures that the right endpoints of the corresponding variables differ. It follows that the resulting instance has a solution if and only if G is k-colorable. Hence, there is a polynomial-time Turing reduction from Chromatic Number to {a mathematical formula}CSP(Allen) by combining binary search (that will evaluate {a mathematical formula}log⁡n Allen instances) with the reduction above (recall that {a mathematical formula}O(log⁡n⋅cn)⊆O((c+ϵ)n) for every {a mathematical formula}ϵ&gt;0). Observe that if {a mathematical formula}k=n then the reduction introduces n fresh variables, which is where the constant {a mathematical formula}c in the expression {a mathematical formula}O(c|V|) stems from.  □
       </paragraph>
      </paragraph>
      <paragraph>
       The exact complexity of Chromatic Number has been analyzed and discussed in the literature. Björklund et al. [6] have shown that the problem is solvable in {a mathematical formula}2|V|⋅poly(‖I‖) time. Impagliazzo and Paturi [35] poses the following question: ‘Assuming SETH, can we prove a {a mathematical formula}2n−o(n) lower bound for Chromatic Number?’. Hence, an {a mathematical formula}O(c|V|), {a mathematical formula}c&lt;2, algorithm for {a mathematical formula}CSP(Allen) would also be a major breakthrough for Chromatic Number.
      </paragraph>
     </section>
    </section>
    <section label="6">
     <section-title>
      Research directions
     </section-title>
     <paragraph>
      The study of infinite-domain CSP time complexity is still in its infancy, and there is a large amount of open questions that need to be addressed. We present a small selection below.
     </paragraph>
     <paragraph>
      Analysis of algorithms. We have investigated several novel algorithms for solving disjunctive CSP problems, which, with respect to worst-case time complexity, are much more efficient than e.g. backtracking algorithms without heuristics. These bounds can likely be improved, but, due to the lower bounds in Section 5, probably not to a great degree. Despite this, algorithms for solving infinite domain constraint satisfaction problems are in practice used in many non-trivial applications. In light of this the following research direction is particularly interesting: how to formally analyze the time complexity of branching algorithms equipped with (powerful) heuristics? In the case of finite-domain CSPs and, in particular, DPLL-like algorithms for the k-SAT problem there are numerous results to be found in the literature, cf. the survey by Vsemirnov et al. [64]. This is not the case for infinite-domain CSPs, even though there is a considerable amount of empirical evidence that infinite-domain CSPs can be efficiently solved by such algorithms, so one ought to be optimistic about the chances of actually obtaining non-trivial bounds. Yet, sharp formal analyses appear to be virtually nonexistent in the literature.
     </paragraph>
     <paragraph>
      Quantified constraint satisfaction. In our article, we have limited ourselves to infinite-domain CSP problems included in NP. A natural generalization of the CSP problem is to consider instances which are allowed to also contain universally quantified variables, in addition to existentially quantified variables. This problem is in general known as the quantified constraint satisfaction problem (QCSP). For finite domains this problem is included in PSPACE, and this is also known to hold for many well-studied languages over infinite domains. For example, QCSP problems over equality constraint languages and temporal constraint languages are in general PSPACE-complete [9]. Would it be possible to exploit the algorithms for {a mathematical formula}CSP(E∨ω) and {a mathematical formula}CSP(T∨ω) in order to obtain upper bounds for their QCSP counterparts?
     </paragraph>
     <paragraph>
      Upper bounds. A natural step is to obtain upper bounds for spatial formalisms such as RCC-5 or RCC-8. We have encountered structure enumeration for formalisms with binary basic relations {a mathematical formula}B several times during the course of the article: the problem {a mathematical formula}CSP(B∨ω) can be solved in {a mathematical formula}c|V|2 where the constant c depends on {a mathematical formula}B. This bound is clearly applicable to RCC-5 and RCC-8 and it raises the question whether domain enumeration may lead to improved algorithms or not. A starting point may be to analyze the complexity of the point algebra for partially ordered time since the relations in this algebra is expressible in both RCC-5 and RCC-8. One possibility here is to construct an algorithm based on the algorithm for branching time in Section 4.2.2. It is known that there are slightly more than {a mathematical formula}2n2/4 partial orders on n nodes [52]. Thus, this approach will not immediately lead to a significantly faster algorithm than the {a mathematical formula}c|V|2 time algorithm based on structure enumeration, even if we have a polynomial delay algorithm for enumerating partial orders. It may, though, exist a domain enumeration algorithm running in {a mathematical formula}(c′)|V|2 time with {a mathematical formula}c′&lt;c. Such a speed-up may still be considered important.
     </paragraph>
     <paragraph>
      Lower bounds. Another obvious research direction is to strengthen the lower bounds in Section 5 even further. The probably most challenging problem here is to obtain stronger lower bounds for {a mathematical formula}CSP(B∨=). It appears that the (strong) exponential time hypothesis is not so useful since the use of disjunctions seems essential. We have seen that the conjecture for Chromatic Number was useful when studying Allen's algebra, even though the achieved bound is weaker than those obtained for more expressive disjunctive constraints. Unfortunately, it is not obvious how to generalize the Allen result to other problems of the type {a mathematical formula}CSP(B∨=).
     </paragraph>
     <paragraph>
      It would also be interesting to prove stronger lower bounds for {a mathematical formula}CSP(B∨k) for some concrete choices of {a mathematical formula}B and k. As an example, consider the temporal problem {a mathematical formula}CSP(T∨4). From Corollary 18 we see that {a mathematical formula}CSP(T∨4) is not solvable in {a mathematical formula}O(2s4|V|) time for some {a mathematical formula}s4&lt;log⁡1.6, assuming the ETH holds, since the currently best deterministic algorithm for 4-SAT runs in {a mathematical formula}O(1.6|V|) time [57]. On the other hand, if {a mathematical formula}CSP(T∨4) is solvable in {a mathematical formula}O(c|V|) time for some {a mathematical formula}c&lt;2, then Chromatic Number can be solved in {a mathematical formula}O((c+ϵ)|V|) time for arbitrary {a mathematical formula}ϵ&gt;0. This can be proven similar to the reduction in Theorem 21 but by making use of temporal constraints instead of interval constraints. Hence, for certain choices of {a mathematical formula}B and k it might be possible to improve upon the general bounds given in Section 5.
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>