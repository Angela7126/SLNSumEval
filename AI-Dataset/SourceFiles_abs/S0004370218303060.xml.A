<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Logical foundations of information disclosure in ontology-based data integration.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      Data integration systems expose information from multiple, heterogeneous data sources by means of a global schema, in which the mismatches between the individual schemata of the data sources have been reconciled [35], [43], [45], [56], [76]. In addition to reconciling the structure of the data sources, the global schema also enables uniform access to the data by providing users with the vocabulary for query formulation. The relationships between the data sources and the global schema are determined by mappings—that is, logical formulae that declaratively specify how each term in the global schema relates to the data in the sources. Queries issued against the global schema are typically answered by one of two approaches. In the first approach, an instance over the global schema is initially materialised using the mappings and the data in the sources; then, the query is answered over the materialised instance. In the second approach, no data is exported from the sources and the global schema remains virtual; this is achieved by first reformulating the user query on-the-fly into a set of queries over the sources, and then assembling back their results.
     </paragraph>
     <paragraph>
      In ontology-based data integration the global schema is extended to an ontology—that is, a first-order logic theory expressed in an ontology language such as the Web Ontology Language (OWL) [29]. In addition to defining a high-level conceptual view over the data, the formulae in the ontology also specify how terms in the vocabulary relate to each other, thus providing valuable domain background knowledge that can be exploited to enrich query answers with implicit information.
     </paragraph>
     <paragraph>
      An important instantiation of the ontology-based data integration paradigm is ontology-based data access (OBDA)[23], [68], where the ontology and mapping languages are typically restricted so as to ensure the first-order rewritability property: given an arbitrary conjunctive query q over the global schema, ontology {a mathematical formula}O and mappings {a mathematical formula}M in the relevant languages, it is possible to reformulate q into a first-order query {a mathematical formula}q′ over the source schema such that, for any source data instance {a mathematical formula}D, the answers to q over {a mathematical formula}O, {a mathematical formula}M and {a mathematical formula}D coincide with those to {a mathematical formula}q′ over {a mathematical formula}D alone. First-order rewritability therefore ensures that queries can be answered following the second, virtual approach, where the ontology axioms must now also be taken into account during query reformulation. Ontology languages with this property include the QL profile of OWL 2 [65], which is based on the Description Logic DL-Lite{a mathematical formula}R[22], as well as first-order rule formalisms such as linear tuple-generating dependencies (TGDs) [19], [47]. OBDA has received in recent years a great deal of attention in all its dimensions, including theoretical research [3], [4], [11], [12], [23], [40], [50], [55], system implementation [20], [21], [46], and industrial applications [25], [38], [44], [48], [49].
     </paragraph>
     <paragraph>
      An important aspect of ontology-based data integration that has so far received only relatively little attention is that of preventing unauthorised information disclosure [24], [26], [31], [66]. In practice, data sources often contain sensitive information, and it is well-known that information integration and linkage poses major threats to the confidentiality of such sensitive data even if it is only made available in an anonymised form [75]. In the context of ontology-based data integration, the risks of unauthorised information disclosure quickly become apparent since the information exposed to users depends on a complex combination of schema reconciliation, reasoning over the ontology, and access to data in the sources via the mappings.
     </paragraph>
     <paragraph>
      Our aim in this paper is to lay the logical foundations of information disclosure in ontology-based data integration. Our focus is on the semantic requirements that a data integration system should satisfy before it is made available to users for querying, as well as on the computational complexity of checking whether such requirements are fulfilled. These are fundamental initial steps towards the development and implementation of algorithms suitable for applications.
     </paragraph>
     <paragraph>
      In Section 3, we present a general logical framework for information disclosure that builds upon the work by Nash and Deutsch [66], Chirkova and Yu [26], and Benedikt et al. [7]. In line with existing logic-based approaches to data privacy and confidentiality enforcement in databases [7], [10], [26], [64], [66] and knowledge representation [16], [27], [31], [32], [34], [73], our framework assumes that sensitive information is represented by a query (the policy) over the source schema, and also that all schema-level information (ontology, mappings, source schema, and policy specification) is publicly available—this is a worst-case scenario for confidentiality enforcement. In contrast, the actual data is not made available directly, but rather only by means of queries over the global schema.
     </paragraph>
     <paragraph>
      In this setting, the information that users can gather about the actual source data is inherently incomplete: different source data instances may be indistinguishable, in the sense that users cannot tell the difference between them by querying the system. In Section 3.1 we define source instances {a mathematical formula}D and {a mathematical formula}D′ to be indistinguishable for ontology {a mathematical formula}O and mappings {a mathematical formula}M if, for every query q over the global schema, the answers to q over {a mathematical formula}O, {a mathematical formula}M, and {a mathematical formula}D coincide with the answers to q over {a mathematical formula}O, {a mathematical formula}M and {a mathematical formula}D′. In addition to playing a fundamental role in our framework, source indistinguishability is also an interesting notion in its own right. On the one hand, it has obvious applications in practice: for example, it can be used to determine whether given changes in the data can affect applications querying the system; on the other hand, indistinguishability notions akin to ours have received significant attention in the ontology literature in recent years [11], [18], [51].
     </paragraph>
     <paragraph>
      Disclosure in our framework occurs when users are able to uncover an answer to the policy query over the source data by querying the system and exploiting the availability of schema-level information (e.g., they are able to uncover that a specific hospital patient is an oncology patient, where the policy is a query asking for the list of all oncology patients). In particular, this happens when the policy answer holds in all the (possibly infinitely many) source instances indistinguishable from the real source instance. Indeed, in such a situation an attacker can in principle uncover the policy answer with certainty. If no such disclosure is possible, we say in Section 3.2 that the system complies to the policy.
     </paragraph>
     <paragraph>
      In order to meet the requirements of applications with stricter privacy requirements, we additionally introduce in Section 3.3 a stronger notion of compliance, where we additionally require that a user cannot uncover non-answers to the policy (e.g., to uncover that a specific hospital patient is not an oncology patient). Such negative information can be valuable to an attacker; for instance, by ruling out specific hospital patients as oncology patients, one may increase the likelihood that the remaining patients are indeed oncology patients. If a data integration system satisfies such stricter requirement, we say that it strongly complies to the policy.
     </paragraph>
     <paragraph>
      Our framework also specifies in Section 3.4 the natural data-independent variants of the aforementioned notions, where compliance must hold regardless of the specific data stored in the sources. Having guarantees that depend only on the (relatively static) definition of the ontology and mappings, but not on the actual contents of the data sources can be important in practice since data updates are frequent operations in many applications.
     </paragraph>
     <paragraph>
      Finally, Section 3.5 discusses the specific role that the ontology plays in information disclosure, and in particular on source indistinguishability and policy (strong) compliance.
     </paragraph>
     <paragraph>
      The core technical sections of our paper, the results of which are summarised in Section 4, are devoted to an in-depth study of the decision problems associated to source indistinguishability and compliance checking in all its aforementioned variants. In our analysis, we consider arbitrary first-order ontology languages and parameterise our main results in terms of the complexity for standard query answering for these languages (e.g., {an inline-figure}-complete for DL-Lite{a mathematical formula}R). Similarly, we consider the general case of GLAV (global-local-as-view) mappings as well as its well-known special cases GAV (global-as-view), CQ views, and LAV (local-as-view) [56]. In all cases, we put special emphasis on the results most relevant to standard OBDA settings where the ontology is expressed in DL-Lite{a mathematical formula}R and the mappings are GAV.
     </paragraph>
     <paragraph>
      In Section 5 we study the source indistinguishability problem and establish tight complexity bounds for a wide range of ontology and mapping languages. We show that source indistinguishability is often no harder than standard query entailment; however, in many other cases of practical relevance (including standard OBDA) indistinguishability checking is strictly harder than query entailment under standard complexity-theoretic assumptions.
     </paragraph>
     <paragraph>
      In Section 6, we study the computational properties of policy compliance and its stronger variant as defined in Sections 3.2 and 3.3. In Section 6.1 we propose a generic non-deterministic algorithm for (strong) compliance checking. The correctness of our algorithm shows that both versions of compliance are decidable whenever the ontology language of choice has a decidable query entailment problem. Furthermore, the analysis of our algorithm provides upper bounds for many of the most relevant cases, ranging from {an inline-figure} to {an inline-figure}, where the complexity for OBDA with DL-Lite{a mathematical formula}R ontologies and GAV mappings lies in the second level of the polynomial hierarchy in general and in {an inline-figure} in data complexity. In Section 6.2 we show that all the upper bounds provided by our generic compliance checking algorithm are tight, where many of our matching lower bounds hold already under the assumption that the ontology is empty. Finally, we address the practical concerns raised by the high complexity of compliance checking by identifying practically relevant islands of tractability.
     </paragraph>
     <paragraph>
      In Section 7, we study the data-independent notions of compliance defined in Section 3.4 and show that the problem is already undecidable for OBDA, even under the assumption that the ontology is empty. We then isolate a decidable case and study an additional restriction ensuring tractability.
     </paragraph>
     <paragraph>
      Our results have significant implications on related work, which are discussed in detail in Sections 8 and 9. On the one hand, they correct some of the complexity bounds claimed by Nash and Deutsch [66]; on the other hand, our work also closes open problems in data pricing—the problem of automatically assigning a fair price to a chunk of data given the price of a set of views [54]. In particular, we show that our results on policy compliance immediately imply a {a mathematical formula}Π2p lower bound to the so-called instance-based determinacy problem, which is at the core of the pricing framework by Koutris et al. [54].
     </paragraph>
     <paragraph>
      Some of the results of this paper appeared in an earlier conference publication [8].
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      In this section, we recapitulate the definitions of standard computational complexity classes and logical formalisms with their associated reasoning problems that we use in the rest of the paper.
     </paragraph>
     <section label="2.1">
      <section-title>
       Complexity classes
      </section-title>
      <paragraph>
       We use the standard definitions of the basic time complexity classes such as {an inline-figure}, {an inline-figure}, {an inline-figure}, {an inline-figure} and {an inline-figure}, as well as of the basic space complexity classes such as {an inline-figure}, {an inline-figure}, and {an inline-figure}[67]. For complexity classes {a mathematical formula}C and {a mathematical formula}C′, we denote with {a mathematical formula}CC′ the class of decision problems that can be solved by a Turing machine running in {a mathematical formula}C and using an oracle for decision problems in {a mathematical formula}C′. The polynomial hierarchy is then defined inductively as follows:{a mathematical formula} We also consider {an inline-figure}—the class of problems solvable in {an inline-figure} with nonadaptive calls to an {an inline-figure} oracle [77]. Note the difference between {an inline-figure} and {a mathematical formula}Δ2P, where the input of an oracle call can depend on the result of previous calls.
      </paragraph>
      <paragraph>
       Finally, we consider the class {an inline-figure} used in circuit complexity, which encompasses all families of circuits of constant depth and polynomial size with unlimited fan-in AND and OR gates (e.g., see [67]). The {an inline-figure} class is strictly contained in {an inline-figure} and is especially important in our setting as it corresponds to the data complexity of query evaluation in databases.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       Tuple-generating dependencies, ontologies, and queries
      </section-title>
      <paragraph>
       We adopt standard notions from function-free first-order logic over a vocabulary of relational names with fixed arities and constants. A fact is a ground atom, and an instance is a finite set of facts. We denote with {a mathematical formula}ADom(D) the set of constants occurring in an instance {a mathematical formula}D.
      </paragraph>
      <paragraph>
       A tuple-generating dependency (TGD) is an implicitly universally quantified sentence of the form {a mathematical formula}φ(x,z)→∃y.ψ(x,y), where x, y, and z are disjoint tuples of distinct variables, while the body{a mathematical formula}φ(x,z) and the head{a mathematical formula}ψ(x,y) are conjunctions of atoms such that each term is either a constant or a variable in {a mathematical formula}x∪z and {a mathematical formula}x∪y, respectively, and {a mathematical formula}φ(x,z) mentions all variables x. Variables x, common for the head and the body, are called the frontier variables. A TGD is full if it does not have existentially quantified variables and the head consists of a single atom; it is linear if its body consists of a single atom.
      </paragraph>
      <paragraph>
       In this paper, we adopt a very general notion of an ontology, which is not constrained to specific fragments of first-order logic, such as description logics. In particular, we often refer to an ontology language{a mathematical formula}O to denote any first-order fragment, and define an ontology in {a mathematical formula}O as a finite set of first-order sentences belonging to {a mathematical formula}O. Many of our complexity results, however, are specific to ontologies consisting of TGDs of a specific form. In such cases, the relevant restrictions will be pointed out explicitly; for example, an ontology is full (or linear) if it consists of full (or linear, respectively) TGDs, and an ontology language is full (or linear) if it consists of full (or linear, respectively) ontologies. Another ontology language that is widely used in practice in the context of data integration is the description logic DL-Lite{a mathematical formula}R[23], which can be seen as the fragment consisting of linear TGDs of the following forms, where A and B are unary relational names while R and S are binary relational names:{a mathematical formula} Finally, some of our results are formulated for the trivial ontology language that contains only the empty ontology.
      </paragraph>
      <paragraph>
       A conjunctive query (CQ) {a mathematical formula}q(x) with free variables x is a formula {a mathematical formula}∃y.φ(x,y), where {a mathematical formula}φ(x,y) is a conjunction of atoms such that it mentions all variables x and each term is a constant or a variable in {a mathematical formula}x∪y. Note that the head of a TGD is always a CQ, so we may sometimes refer to it as the head CQ. A union{a mathematical formula}q(x) of CQs (UCQ) with free variables x is a disjunction of CQs with free variables x. The arity of a (U)CQ {a mathematical formula}q(x) is the number of variables in x; (U)CQs of arity 0 are Boolean.
      </paragraph>
      <paragraph>
       The basic reasoning problem we consider is CQ entailment for an ontology language {a mathematical formula}O: a Boolean CQ q is entailed by an ontology {a mathematical formula}O in {a mathematical formula}O and an instance {a mathematical formula}D if and only if {a mathematical formula}O∪D⊨q. Fact entailment is the restriction of CQ entailment where the input CQ is a fact. It is well-known that both CQ and fact entailment are undecidable for the language of all TGDs, whereas both problems become {an inline-figure}- and {an inline-figure}-complete for full and linear TGDs, respectively [1], [47]. Finally, CQ entailment for DL-Lite{a mathematical formula}R is {an inline-figure}-complete, whereas fact entailment is {an inline-figure}-complete and thus tractable [23].
      </paragraph>
      <paragraph>
       We also consider data complexity of CQ and fact entailment—that is, the complexity of the same problems under the assumption that only {a mathematical formula}D constitutes the input, while {a mathematical formula}O and q are fixed. It is known that both problems are undecidable even in data complexity for arbitrary TGDs, while they are P -complete and in {an inline-figure} in data complexity for full TGDs and linear TGDs (and hence DL-Lite{a mathematical formula}R), respectively. Sometimes we require, for complexity classes {a mathematical formula}C and {a mathematical formula}C′, CQ (or fact) entailment to be in {a mathematical formula}C with {a mathematical formula}C′ data complexity: by this we mean that there should exist an algorithm witnessing both bounds.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       Ontology-based data integration
      </section-title>
      <paragraph>
       Following [56], we assume that the set of the relational names in a vocabulary is split into two disjoint subsets: source and global schema. The arity of such a schema is the maximal arity of its relational names.
      </paragraph>
      <paragraph>
       A GLAV (global-local-as-view) mapping, or simply mapping, for short, is a TGD with the body mentioning relational names only in the source schema and the head mentioning relational names only in the global schema. Following a common convention, we call full mappings GAV (global-as-view) and linear mappings LAV (local-as-view). Note that these notions are incomparable, and a mapping can be both GAV and LAV at the same time.
      </paragraph>
      <paragraph>
       A set of mappings {a mathematical formula}M is GAV (or LAV) if so are all the mappings in {a mathematical formula}M. The frontier size of {a mathematical formula}M is the maximum number of frontier variables in a mapping from {a mathematical formula}M. Finally, {a mathematical formula}M is a set of CQ views if it is GAV and no two mappings in {a mathematical formula}M share the same head relation name.
      </paragraph>
      <paragraph>
       A mapping language{a mathematical formula}M consists of finite sets of mappings. It is GAV (or CQ views, or LAV) if so are all {a mathematical formula}M in {a mathematical formula}M. Its source (or global) arity is bounded by a fixed integer k if the arity of the source (or global, respectively) schema of each {a mathematical formula}M∈M is at most k, and it is of bounded source (or global, respectively) arity if there exists such an integer k. Similarly, its frontier is bounded by a fixed integer k if the frontier size is at most k, and it is of bounded frontier if there exists such an integer k. Note that, for GAV (and, hence, CQ views) mapping languages, bounded global arity implies bounded frontier; similarly, for LAV mapping languages, bounded source arity implies bounded frontier.
      </paragraph>
      <paragraph>
       A data integration setting is a triple {a mathematical formula}(O,M,D), where {a mathematical formula}O is an ontology over the global schema, {a mathematical formula}M is a finite set of mappings, and {a mathematical formula}D is an instance over the source schema. The standard setting in ontology-based data access (OBDA) is when {a mathematical formula}O is restricted to be a DL-Lite{a mathematical formula}R ontology and {a mathematical formula}M to be GAV; in this case, the frontier and global arity are automatically bounded by 2.
      </paragraph>
      <paragraph>
       An interpretation I over the global schema is a model of a data integration setting {a mathematical formula}(O,M,D) if {a mathematical formula}I⊨O and, for each mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and each tuple of constants a, it holds that {a mathematical formula}I⊨∃y.ψ(a,y) whenever {a mathematical formula}D⊨∃z.φ(a,z). For {a mathematical formula}q(x) a CQ over the global schema, a tuple a of constants is a certain answer to {a mathematical formula}q(x) over {a mathematical formula}(O,M,D) if {a mathematical formula}I⊨q(a) for all models I of {a mathematical formula}(O,M,D).
      </paragraph>
      <paragraph>
       The virtual image{a mathematical formula}VM,D of a set of mappings {a mathematical formula}M and an instance {a mathematical formula}D is the following set of Boolean CQs:{a mathematical formula} The following simple proposition establishes the connection between computing certain answers in data integration and standard CQ entailment in first-order logic.
      </paragraph>
      <paragraph label="Proposition 1">
       A tupleaof constants is a certain answer to a CQ{a mathematical formula}q(x)over the global schema over a data integration setting{a mathematical formula}(O,M,D)if and only if{a mathematical formula}O∪VM,D⊨q(a).
      </paragraph>
      <paragraph label="Proof">
       It suffices to show that an interpretation I is a model of {a mathematical formula}(O,M,D) if and only if {a mathematical formula}I⊨O∪VM,D. Assume that {a mathematical formula}I⊨O∪VM,D and let a be a tuple of constants satisfying {a mathematical formula}D⊨∃z.φ(a,z) for a mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M. Since {a mathematical formula}I⊨VM,D, we have that {a mathematical formula}I⊨∃y.ψ(a,y) and hence, since a and the mapping are arbitrary as well as {a mathematical formula}I⊨O, interpretation I is a model of {a mathematical formula}(O,M,D). Conversely, if I is a model of {a mathematical formula}(O,M,D) then {a mathematical formula}I⊨O. To see that {a mathematical formula}I⊨VM,D, let {a mathematical formula}∃y.ψ(a,y) be an arbitrary Boolean CQ in {a mathematical formula}VM,D; by construction of {a mathematical formula}VM,D, we have that {a mathematical formula}D⊨∃z.φ(a,z) for a mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M. But then, the fact that I is a model of {a mathematical formula}(O,M,D) ensures that {a mathematical formula}I⊨∃y.ψ(a,y), as required. □
      </paragraph>
     </section>
    </section>
    <section label="3">
     <section-title>
      Framework for information disclosure
     </section-title>
     <paragraph>
      In this section, we present our framework for information disclosure and define the associated reasoning problems. All the definitions are accompanied by simple motivating examples.
     </paragraph>
     <paragraph>
      To start with, let us consider the information system of a hospital where data about patient appointments is stored in various databases. Although various departments store appointment data using different schemata, they all share basic attributes, such as the IDs for patients, and doctors, as well as the appointment dates.{sup:1} For instance, the oncology department database contains a relation{a mathematical formula} where PatientID and DoctorID represent patient and doctor IDs, Date represents the date of the appointment, and Treatment represents the prescribed treatment. The paediatrics department may use a database containing a relation{a mathematical formula} where Location indicates the room in which the appointment took place.
     </paragraph>
     <paragraph>
      To integrate this data, the hospital relies on a global schema capturing the common terminology in all appointments. This global schema includes relational names such as {a mathematical formula}Appointment(PatientID,DoctorID,Date), {a mathematical formula}OncologistRecord(DoctorID,Date), and {a mathematical formula}PaediatricianRecord(DoctorID,Date). The following simple mappings {a mathematical formula}Mex, which are both GAV and LAV, relate the source schema to the global schema:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} The data integration system may also come with an ontology, which establishes the relationships between the relational names in the global schema. For instance, the following ontology {a mathematical formula}Oex establishes that oncologist and paediatrician records are doctor records, and that a person mentioned in a doctor's record has a medical degree:{a mathematical formula}{a mathematical formula}{a mathematical formula} The schema designers may not want to disclose the relationship between patients and the departments the patients have visited. However, the confidentiality of such information is at risk. For example, consider the following simple instance {a mathematical formula}D1ex providing information about two oncology appointments and two paediatrics appointments as per the aforementioned schemata.{a mathematical formula} The accessible information is determined by the virtual image of {a mathematical formula}D1ex, which instantiates the global relations mentioned in the mappings as given next.{a mathematical formula}
     </paragraph>
     <paragraph>
      By querying {a mathematical formula}OncologistRecord, an attacker can determine that doctors D1 and D2 had oncology appointments on the 30th of November and the 10th of June, respectively. Furthermore, from {a mathematical formula}Appointment, the attacker has access to a list of all the appointments a doctor had on a given date; in particular, patients P1 and P2 were the only ones to have appointments with doctors D1 and D2, respectively, on the aforementioned dates. As a result, the attacker can infer that patients P1 and P2 had oncology appointments.
     </paragraph>
     <paragraph>
      In this case, the unauthorised disclosure depends on the attacker's ability to “trace back” using the mappings the exact relation in the source that exported each tuple in the extension of the relevant global relations. In particular, the definition of the mappings is assumed to be available; thus, an attacker knows, on the one hand, that the list of appointments consists of the union of the oncology and paediatrics appointment data at the source and, on the other hand, that the oncologist records are solely derived from the oncology appointment data.
     </paragraph>
     <paragraph>
      In what follows, we will make these intuitions precise.
     </paragraph>
     <section label="3.1">
      <section-title>
       Source indistinguishability
      </section-title>
      <paragraph>
       In a data integration setting, users (including malicious attackers) can only interact with the system by posing queries against the global schema. Users have no direct access to the source instances and hence the information they can gather about the source data is inherently incomplete. As a result of this incompleteness, different source instances may be indistinguishable, in the sense that users cannot tell the difference between them by querying the system. In our motivating example, users cannot access any information about prescribed treatments or appointment locations in the source relations since these attributes are not exposed by the mappings. As a result, the following source instance {a mathematical formula}D2ex cannot be told apart from {a mathematical formula}D1ex by means of user queries against the global schema; in particular we can observe that their virtual images {a mathematical formula}VM,D1ex and {a mathematical formula}VM,D2ex coincide.{a mathematical formula}
      </paragraph>
      <paragraph label="Definition 2">
       Source instances {a mathematical formula}D and {a mathematical formula}D′ are indistinguishable for an ontology {a mathematical formula}O and mappings {a mathematical formula}M if, for every CQ q over the global schema, the certain answers to q over {a mathematical formula}(O,M,D) and {a mathematical formula}(O,M,D′) coincide.The associated decision problem for an ontology language {a mathematical formula}O and mapping language {a mathematical formula}M is defined as follows, where {a mathematical formula}O ranges over {a mathematical formula}O and {a mathematical formula}M over {a mathematical formula}M: {an inline-figure} is true if and only if {a mathematical formula}D and {a mathematical formula}D′ are indistinguishable for {a mathematical formula}O and {a mathematical formula}M. We consider not only the combined complexity of {an inline-figure}, but also its data complexity—that is, the complexity under assumption that {a mathematical formula}O and {a mathematical formula}M are fixed, while only {a mathematical formula}D and {a mathematical formula}D′ form the input.
      </paragraph>
      <paragraph>
       The notion of indistinguishability in Definition 2 can be used to formalise information disclosure. Intuitively, by knowing {a mathematical formula}O and {a mathematical formula}M, all a malicious attacker querying the system can gather from the source instance {a mathematical formula}D is that it must be one of the (possibly infinitely many) source instances {a mathematical formula}D′ indistinguishable from {a mathematical formula}D. We next provide a fundamental characterisation of source indistinguishability, which we exploit extensively throughout this paper. Our characterisation can be seen as an extension of Theorem 1 of [66] to the setting with an ontology.
      </paragraph>
      <paragraph label="Lemma 3">
       The following are equivalent for any ontology{a mathematical formula}O, mappings{a mathematical formula}M, and source instances{a mathematical formula}Dand{a mathematical formula}D′:
      </paragraph>
      <list>
       <list-item>
        {an inline-figure}istrue;
       </list-item>
       <list-item>
        for each mapping in{a mathematical formula}Mwith head CQ q, the certain answers to q over{a mathematical formula}(O,M,D)and{a mathematical formula}(O,M,D′)coincide; and
       </list-item>
       <list-item>
        {a mathematical formula}O∪VM,Dand{a mathematical formula}O∪VM,D′are logically equivalent.
       </list-item>
      </list>
      <paragraph label="Proof">
       Statement 1 implies Statement 2 by definition. Furthermore, Statement 2 implies Statement 3 by Proposition 1. We next show that Statement 3 implies Statement 1. Assume that {a mathematical formula}O∪VM,D and {a mathematical formula}O∪VM,D′ are equivalent. Let {a mathematical formula}q(x) be a CQ over the global schema, and let a be a certain answer to {a mathematical formula}q(x) over {a mathematical formula}(O,M,D). We show that the same holds over {a mathematical formula}(O,M,D′). Assume to the contrary that this is not the case. Then, there exists an interpretation {a mathematical formula}I′ over both source and global schemata that satisfies both {a mathematical formula}M and {a mathematical formula}O, has source part corresponding precisely to {a mathematical formula}D′, and does not satisfy {a mathematical formula}q(a). Let I be an interpretation formed by replacing the interpretations of the source relational names in {a mathematical formula}I′ by the part corresponding to {a mathematical formula}D. Clearly, I satisfies {a mathematical formula}O∧¬q(a) since these mention only the global relational names, which are unchanged from {a mathematical formula}I′. Also, the source part of I corresponds to {a mathematical formula}D by definition. To see that I satisfies {a mathematical formula}M, consider any homomorphism h from the body of a mapping into {a mathematical formula}D. The corresponding image of the mapping's head is in {a mathematical formula}VM,D and thus, by hypothesis, it is implied by {a mathematical formula}O∪VM,D′. However, {a mathematical formula}I′ satisfies {a mathematical formula}O∪VM,D′, and thus {a mathematical formula}I′ satisfies the image of the head as well. Since I agrees with {a mathematical formula}I′ on the global relations, the desired contradiction follows. Arguing symmetrically, we see that a certain answer of q over {a mathematical formula}(O,M,D′) is a certain answer of q over {a mathematical formula}(O,M,D). □
      </paragraph>
      <paragraph>
       The second statement in the lemma shows that, to check indistinguishability, we can restrict ourselves to consider only those CQs that appear in the head of the mappings (rather than the infinitely many possible queries that can be formed using the global vocabulary). The third statement shows that indistinguishability checking amounts to solving a logical entailment problem involving the ontology and the virtual images of the relevant source instances over the mappings.
      </paragraph>
     </section>
     <section label="3.2">
      <section-title>
       Policies, information disclosure, and policy compliance
      </section-title>
      <paragraph>
       The sensitive information in a data integration setting can be declaratively represented by a query over the source schema, which we refer to as the policy.
      </paragraph>
      <paragraph label="Definition 4">
       A policy is a CQ over the source schema. A policy language{a mathematical formula}P is a set of policies. It is of arity bounded by a fixed integer m if every CQ in {a mathematical formula}P has at most m free variables. It is of bounded arity if it is of arity bounded by some m. It is ground if it consists of conjunctions of facts.
      </paragraph>
      <paragraph>
       In our motivating example, the requirement that the identity of patients with an oncology appointment cannot be disclosed can be represented by the following policy:{a mathematical formula}
      </paragraph>
      <paragraph>
       Intuitively, disclosure of sensitive information occurs whenever there is a certain answer to the policy that holds in all the source instances that are indistinguishable from the point of view of the attacker. In such a situation the attacker would be able to uncover the aforementioned answer. If no such disclosure can occur, we say that the data integration setting complies to the policy.
      </paragraph>
      <paragraph label="Definition 5">
       A data integration setting {a mathematical formula}(O,M,D)complies to a Boolean policy p if there exists a source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D for {a mathematical formula}O and {a mathematical formula}M such that {a mathematical formula}D⊨p implies {a mathematical formula}D′⊭p. Furthermore, {a mathematical formula}(O,M,D)complies to a policy {a mathematical formula}p(x) with m free variables x if it complies to {a mathematical formula}p(a) for all m-tuples a of constants from {a mathematical formula}D.The associated decision problem for an ontology language {a mathematical formula}O, mapping language {a mathematical formula}M, and policy language {a mathematical formula}P is defined as follows, where {a mathematical formula}O ranges over {a mathematical formula}O, {a mathematical formula}M over {a mathematical formula}M, and p over {a mathematical formula}P: {an inline-figure} is true if and only if {a mathematical formula}(O,M,D) complies to p. Data complexity of the compliance problem assumes that all {a mathematical formula}O, {a mathematical formula}M and p are fixed, while only {a mathematical formula}D forms the input.
      </paragraph>
      <paragraph>
       In our example, the data integration setting {a mathematical formula}(Oex,Mex,D1ex) does not comply to policy {a mathematical formula}pex since {a mathematical formula}pex(P1) and {a mathematical formula}pex(P2) hold over all source instances indistinguishable from {a mathematical formula}Dex1 for {a mathematical formula}Oex and {a mathematical formula}Mex (and in particular they hold over {a mathematical formula}D2ex).
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       Strong compliance
      </section-title>
      <paragraph>
       Definition 5 ensures that no positive information about the policy can be disclosed. It does not, however, preclude a malicious attacker from finding out potentially valuable negative information about the policy. For instance, even if compliance for our example policy is ensured, an attacker may still be able to find out that a specific hospital patient is not an oncology patient. This information can be valuable since, by ruling out many patients, the likelihood that the remaining ones are indeed oncology patients is increased (even if nothing certain can be said about them). In particular, consider the following source instance {a mathematical formula}D3ex.{a mathematical formula} Instance {a mathematical formula}D3ex induces the following virtual image over the global relational names.{a mathematical formula}
      </paragraph>
      <paragraph>
       We can observe that {a mathematical formula}(Oex,Mex,D3ex) complies to our example policy {a mathematical formula}pex. This is because doctor D1 had both oncology and paediatrics appointments on the 30th of November and hence an attacker cannot determine with certainty that patient P1 (or P4) is an oncology patient; in particular, there is a source instance indistinguishable from {a mathematical formula}D3ex in which the oncology appointments table has an entry for patient P4 visiting doctor D1 on the 30th of November and the paediatrics appointment table has an entry for patient P1 visiting the same doctor on the same day. Although this example satisfies the requirements of Definition 5, an attacker can obtain valuable information about the policy, namely that patient P3 did not have an oncology appointment; indeed, P3 had appointments only with a doctor D3 that we know did not have any oncology appointments. Consequently, an attacker may find out that P1 and P4 are the only possible oncology patients despite the fact of not being able to identify for sure which of them is in the oncology appointment relation.
      </paragraph>
      <paragraph>
       In order to meet the requirements of applications with stricter privacy requirements, we introduce a stronger notion of compliance ensuring that neither positive nor negative information about the policy is disclosed.
      </paragraph>
      <paragraph label="Definition 6">
       A data integration setting {a mathematical formula}(O,M,D)strongly complies to a Boolean policy p if there exists a source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D for {a mathematical formula}O and {a mathematical formula}M such that {a mathematical formula}D⊨p if and only if {a mathematical formula}D′⊭p. Furthermore, {a mathematical formula}(O,M,D)strongly complies to a policy {a mathematical formula}p(x) with n free variables x if it strongly complies to {a mathematical formula}p(a) for all n-tuples a of constants from {a mathematical formula}D.The associated decision problem for an ontology language {a mathematical formula}O, mapping language {a mathematical formula}M, and policy language {a mathematical formula}P is defined as follows, where {a mathematical formula}O ranges over {a mathematical formula}O, {a mathematical formula}M over {a mathematical formula}M, and p over {a mathematical formula}P: {an inline-figure} is true if and only if {a mathematical formula}(O,M,D) strongly complies to p. Data complexity of the strong compliance problem assumes that all {a mathematical formula}O, {a mathematical formula}M and p are fixed, while only {a mathematical formula}D forms the input.
      </paragraph>
      <paragraph>
       We can check that our example data integration setting {a mathematical formula}(Oex,Mex,D3ex) does not strongly comply to our example policy {a mathematical formula}pex. Indeed, {a mathematical formula}pex(P3) does not hold over all source instances indistinguishable from {a mathematical formula}D3ex for {a mathematical formula}Oex and {a mathematical formula}Mex.
      </paragraph>
     </section>
     <section label="3.4">
      <section-title>
       Data-independent compliance
      </section-title>
      <paragraph>
       Finally, observe that both Definition 5, Definition 6 provide guarantees for a specific source instance only. In particular, a compliant policy may become non-compliant if the data in the source instances is modified (even if neither the ontology nor the mappings change). For example, if we recall our example ontology {a mathematical formula}Oex mappings {a mathematical formula}Mex and policy {a mathematical formula}pex, we already determined that compliance holds for source instance {a mathematical formula}D3ex but not for {a mathematical formula}D1ex. Since database updates are relatively frequent operations, it makes sense in practice to consider also data-independent notions of compliance.
      </paragraph>
      <paragraph label="Definition 7">
       Let {a mathematical formula}O be an ontology language, let {a mathematical formula}M be a mapping language, and let {a mathematical formula}P be a policy language. We define the following decision problems, where {a mathematical formula}O ranges over {a mathematical formula}O, {a mathematical formula}M over {a mathematical formula}M, and p over {a mathematical formula}P:
      </paragraph>
      <list>
       <list-item label="–">
        {an inline-figure} is true if and only if {an inline-figure} is true for all source instances {a mathematical formula}D; and
       </list-item>
       <list-item label="–">
        {an inline-figure} is true if and only if {an inline-figure} is true for all source instances {a mathematical formula}D.
       </list-item>
      </list>
      <paragraph>
       In order to ensure that our example policy, mappings, and ontology satisfy the compliance requirements for every source instance, we could remove from {a mathematical formula}Oex the TGDs (5) and (6), and replace mappings (2) and (4) with the following mappings:{a mathematical formula}{a mathematical formula} With this modification, attackers can no longer query for the relations {a mathematical formula}OncologistRecord and {a mathematical formula}PaediatricianRecord and hence they are no longer able to exploit that information in order to discern whether an appointment in the global relation {a mathematical formula}Appointment stems from an oncology or a paediatrics appointment in the source instance.
      </paragraph>
      <paragraph>
       Note that there is no notion of data complexity for the problems in Definition 7 since the data is not part of the input. Furthermore, since the problems are data-independent, we assume that ontologies and mappings are constant-free and that policies are constant-free and Boolean.
      </paragraph>
     </section>
     <section label="3.5">
      <section-title>
       The role of the ontology
      </section-title>
      <paragraph>
       The main purpose of an ontology in data integration is, on the one hand, to provide a common vocabulary for users to formulate queries against disparate sources and, on the other hand, to enrich query answers with information that is not explicitly stated in the source instances. In this section we argue that the presence of an ontology also impacts information disclosure.
      </paragraph>
      <paragraph>
       We start by discussing the influence of ontology axioms on source indistinguishability. For this, let us consider once again our running example as well as the following source instance {a mathematical formula}D4ex:{a mathematical formula} Clearly, instances {a mathematical formula}D1ex and {a mathematical formula}D4ex are not indistinguishable for {a mathematical formula}Oex and {a mathematical formula}Mex since {a mathematical formula}∃Date.OncologistRecord(D3,Date) holds over {a mathematical formula}(Oex,Mex,D4ex), but not over {a mathematical formula}(Oex,Mex,D1ex). Assume, however, that we now extend {a mathematical formula}Oex with the TGD{a mathematical formula} stating that every paediatrician record is also an oncologist record (i.e., consider the situation where the database about paediatrics actually refers only to appointments made by specialists in oncological paediatrics). Then, it can be checked that {a mathematical formula}D1ex and {a mathematical formula}D4ex become indistinguishable. Our example shows that the addition of a TGD to an ontology can cause indistinguishability of two instances. The following proposition establishes that the converse is not possible—that is, if two source instances are indistinguishable, they will remain so regardless of any extension of the ontology.
      </paragraph>
      <paragraph label="Proposition 8">
       Let{a mathematical formula}Mbe a set of mappings, let{a mathematical formula}Oand{a mathematical formula}O′be ontologies such that{a mathematical formula}O⊆O′, and let{a mathematical formula}D1and{a mathematical formula}D2be source instances. If{a mathematical formula}D1and{a mathematical formula}D2are indistinguishable for{a mathematical formula}Oand{a mathematical formula}M, then they are also indistinguishable for{a mathematical formula}O′and{a mathematical formula}M.
      </paragraph>
      <paragraph label="Proof">
       Assume that {a mathematical formula}D1 and {a mathematical formula}D2 are indistinguishable for {a mathematical formula}O and {a mathematical formula}M. By Lemma 3 we have that {a mathematical formula}O∪VM,D1 and {a mathematical formula}O∪VM,D2 are logically equivalent. By the monotonicity of first-order logic {a mathematical formula}O∪VM,D1⊨VM,D2 implies {a mathematical formula}O′∪VM,D1⊨VM,D2 and, conversely, {a mathematical formula}O∪VM,D2⊨VM,D1 implies {a mathematical formula}O′∪VM,D2⊨VM,D1; as a result, {a mathematical formula}O′∪VM,D1 and {a mathematical formula}O′∪VM,D2 are also logically equivalent. Consequently, again by Lemma 3, {a mathematical formula}D1 is also indistinguishable from {a mathematical formula}D2 for {a mathematical formula}O′ and {a mathematical formula}M, as required. □
      </paragraph>
      <paragraph>
       Our previous example also illustrates the influence of ontologies on compliance checking. In particular, recall that our example policy {a mathematical formula}pex does not comply to the data integration setting {a mathematical formula}(Oex,Mex,D1ex). However, if we extend {a mathematical formula}Oex with (10) and{a mathematical formula} then {a mathematical formula}pex becomes compliant, since there is an instance indistinguishable from {a mathematical formula}D1ex where the relation {a mathematical formula}OncologyAppointment is empty; thus, it is no longer possible for an attacker to determine whether {a mathematical formula}pex(P1) or {a mathematical formula}pex(P2) hold in the source instance. Using Proposition 8 we can show that the converse situation cannot occur: if compliance (or strong compliance) holds, then it continues to hold for any extended ontology; this immediately implies that the same holds for data-independent versions of the problems.
      </paragraph>
      <paragraph label="Proposition 9">
       If a data integration setting{a mathematical formula}(O,M,D)complies (or strongly complies) to a policy p, then, for any ontology{a mathematical formula}O′such that{a mathematical formula}O⊆O′, the setting{a mathematical formula}(O′,M,D)also complies (or strongly complies, respectively) to p.
      </paragraph>
      <paragraph label="Proof">
       For the compliance case, assume that {a mathematical formula}(O,M,D) complies to p. This means that for every tuple of constants a there must exist a source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D for {a mathematical formula}O and {a mathematical formula}M such that {a mathematical formula}D′⊭p(a). By Proposition 8, {a mathematical formula}D and {a mathematical formula}D′ are also indistinguishable for {a mathematical formula}O′ and {a mathematical formula}M and hence {a mathematical formula}(O′,M,D) complies to p, as required.The proof for the strong compliance case is analogous, the only difference is that the indistinguishable {a mathematical formula}D′ is such that {a mathematical formula}D⊨p(a) if and only if {a mathematical formula}D′⊭p(a). □
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Summary of results
     </section-title>
     <paragraph>
      Our core technical results in Sections 5 and 6 provide a complete picture of the computational complexity of indistinguishability, compliance, and strong compliance for all combinations of ontology, mapping and policy languages introduced in Section 2. These results are summarised for the convenience of the reader in Table 1 and come with forward pointers to the relevant theorems and propositions. The results are clustered into ranges (column groups going across) that satisfy a given complexity bound. The most expressive combination in the range is denoted with “upper”, and the least expressive with “lower”. Note that there can be multiple column groups with the same bound (e.g., for {a mathematical formula}Π2p combined complexity), since these represent cases incomparable in expressiveness. All the results in the table are given for the empty ontology, and the results relevant for standard OBDA mappings—that is, (possibly restricted) GAV mappings with global arity and frontier bounded by 2—are highlighted in bold font. For non-trivial ontology languages, the complexity of standard CQ (or fact) entailment may dominate over that of indistinguishability or compliance. In those cases, the results in the table should be amended as given next.
     </paragraph>
     <list>
      <list-item label="–">
       For the ontology language of full TGDs, all the combined complexity results below ExpTime become ExpTime by
      </list-item>
      <list-item label="–">
       For the ontology language of linear TGDs, all the combined complexity results below PSpace become PSpace by the same theorems and propositions as for full TGDs, and the {an inline-figure} data complexity results become {an inline-figure} also by the same theorems and propositions as for full TGDs.
      </list-item>
      <list-item label="–">
       For DL-Lite{a mathematical formula}R (and thus for OBDA), the {an inline-figure} combined complexity becomes NLogSpace by
      </list-item>
     </list>
     <paragraph>
      We next summarise the main take-away messages from our results in the table.
     </paragraph>
     <list>
      <list-item label="–">
       Indistinguishability checking is decidable and we can obtain tractability in {an inline-figure} in data complexity whenever the data complexity of reasoning in the ontology language of choice is also in {an inline-figure}. Indeed, the fundamental characterisation of source indistinguishability in terms of logical entailment provided by Lemma 3 in Section 3 suggests a basic algorithm, the analysis of which provides the relevant upper bounds. In the first step, the algorithm constructs the virtual images of the input mappings and source instances; then, in the second step, it checks whether the computed virtual images are logically equivalent with respect to the input ontology.
      </list-item>
      <list-item label="–">
       Despite its simplicity, the complexity analysis of the aforementioned indistinguishability checking algorithm is rather subtle. For instance, it is interesting to observe that, for conventional OBDA where the arity of the global schema is bounded to 2, source indistinguishability can be checked in {an inline-figure}—the class of problems solvable in polynomial time using non-adaptive calls to an {an inline-figure} oracle; however, considering unbounded arity of global relational names immediately yields a complexity jump to the second level of the polynomial hierarchy.
      </list-item>
      <list-item label="–">
       We obtain matching lower bounds for source indistinguishability checking for all relevant cases. Many of these bounds (in particular those for the empty ontology, where indistinguishability checking is often harder than query entailment for the ontology language of choice) are rather challenging to show and are interesting in their own right.
      </list-item>
      <list-item label="–">
       Compliance checking is a more computationally demanding task than source indistinguishability. Although {an inline-figure} and {an inline-figure} are also decidable for any ontology language with decidable query entailment problem, tractability in data complexity is much more limited and requires significant restrictions on both the mappings and the policy. To establish decidability of compliance checking, it suffices to observe that we only need to consider finitely many candidate source instances that are compatible with the information observable by an attacker. Essentially, we are only interested in the (finitely many) different ways in which the body of the mappings can match to the source instance to yield information in the observable virtual image. Intuitively, such candidate source instances can be guessed and the policy subsequently checked against each of them, although in many cases there is a need for guessing candidate source instances of exponential size.
      </list-item>
      <list-item label="–">
       As in the case of indistinguishability checking, the detailed complexity analysis for all relevant cases of the generic compliance checking algorithm we just sketched in the previous point is rather subtle. Furthermore, if the input ontology consists of linear TGDs (as is the case of standard OBDA), then the generic algorithm does not provide optimal upper bounds and we need a specialised algorithm.
      </list-item>
      <list-item label="–">
       Matching lower bounds for compliance checking are provided for all cases. As for source indistinguishability, the lower bounds for the cases where query entailment is not the dominating source of complexity are rather challenging to prove and interesting in their own right. For instance, the {an inline-figure} lower bound in Theorem 24, which is based on an involved reduction from a suitable variant of the domino tiling problem, shows that guessing exponential size candidate source instances when checking compliance is unavoidable even if we take the ontology to be empty and impose very strict requirements on the mappings. The lower bounds in Theorem 19, Theorem 24 also contradict some of the upper bounds provided in [66] and show that the problems investigated there are actually much harder than previously thought. Our lower bounds in Theorem 25, Theorem 26 also deserve especial attention since they transfer directly to the instance-based determinacy problem and close some existing open problems in the theory of data pricing [54] (see Section 8.2 for further details).
      </list-item>
     </list>
     <paragraph>
      Section 7 presents our results on the data-independent problem ComplyAll. Our first result is negative, showing that the problem is undecidable. While undecidability for a rich ontology and mapping language was expected, we show a more surprising result in Theorem 30: the problem is undecidable even for empty ontologies and GAV mappings of bounded source and global arities; furthermore, undecidability extends to CQ views as mappings if we allow for any of the ontology languages mentioned in this paper. These undecidability results depend on a rather sophisticated encoding of the halting problem for Turing machines, where non-compliant instances represent halting computations.
     </paragraph>
     <paragraph>
      Then, we go on to show that, in the absence of an ontology and when mappings are restricted to CQ views, the problem becomes decidable. This is a surprising result, which makes a novel use of the idea of constructing a “critical instance” from prior work [4], [7], [28], [39], [63], [70]. In particular, we show that we can reduce the data-independent compliance problem to the data-dependent one on the aforementioned critical instance and that this reduction yields a (tight) {an inline-figure} upper bound.
     </paragraph>
     <paragraph>
      We leave open the decidability of {an inline-figure} for LAV mappings. A related result has been proved in [6, Theorem 41], but where only source instances not satisfying p are considered, and the policy query is allowed to be a UCQ rather than a CQ.
     </paragraph>
     <paragraph>
      More importantly, we leave the computational properties of the data-independent problem {an inline-figure} open. Our attempts to establish (un)decidability of this problem have so far been unsuccessful. We conjecture that the undecidability results of Theorem 30 and Corollary 38 extend to {an inline-figure}; our construction showing undecidability is, however, not sufficient and it is unclear whether it can be suitably modified. We thus believe that {an inline-figure} is an interesting and very challenging problem to be tackled in future work.
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Source indistinguishability
     </section-title>
     <paragraph>
      In this section we study the complexity of the source indistinguishability problem—that is, the problem of checking whether two given source instances are indistinguishable from the point of view of users of a data integration system. The results in this section will be relevant to the study of policy compliance later on. Source indistinguishability is also an interesting problem in its own right. On the one hand, it has obvious applications in practice, e.g., it can be used to determine whether given changes in the source instances can affect applications querying the system; on the other hand, as discussed in our related work section, indistinguishability problems akin to ours have recently received significant attention in the ontology literature motivated by applications in ontology reuse, ontology integration, and modular ontology design [11], [18], [51].
     </paragraph>
     <section label="5.1">
      <section-title>
       Decidability and complexity upper bounds
      </section-title>
      <paragraph>
       We begin our study by providing upper bounds for the indistinguishability problem. In the next section we will show that all these bounds are tight.
      </paragraph>
      <paragraph>
       Let us recall Lemma 3 in Section 3, which provides a fundamental characterisation of source indistinguishability in terms of logical entailment. The lemma suggests a basic algorithm that decides {an inline-figure} for any ontology language with decidable CQ entailment problem: in the first step, the algorithm constructs the virtual images {a mathematical formula}VM,D and {a mathematical formula}VM,D′; then, in the second step, it checks whether {a mathematical formula}O∪VM,D and {a mathematical formula}O∪VM,D′ are equivalent.
      </paragraph>
      <paragraph>
       Analysis of this algorithm reveals that source indistinguishability is no harder than CQ entailment in many cases; for instance, if the ontology language has sufficiently high complexity for CQ entailment then this complexity dominates over that of constructing the virtual images.
      </paragraph>
      <paragraph label="Theorem 10">
       Problem{an inline-figure}for{a mathematical formula}Oin an ontology language{a mathematical formula}Oand{a mathematical formula}Min a mapping language{a mathematical formula}Mis in
      </paragraph>
      <list>
       <list-item>
        {an inline-figure}, if{a mathematical formula}Ohas CQ entailment in{an inline-figure}with{an inline-figure}data complexity; and
       </list-item>
       <list-item>
        a complexity class{a mathematical formula}C, for{an inline-figure}, if
       </list-item>
      </list>
      <paragraph>
       Before proving the theorem, we note that the set of complexity classes that {a mathematical formula}C is ranging over in Cases (2) and (3) is motivated just by the CQ and fact entailment problems for the ontology languages considered in this paper. This set can be extended by many other standard complexity classes, such as {an inline-figure}—the only requirement is that the class should be closed under {an inline-figure} reductions and intersection (the proofs of the statements would be the same). Case (1) can be relativised in the same way: {an inline-figure} can be replaced with any usual complexity class subsuming {an inline-figure}, such as {an inline-figure} and {an inline-figure}; in this case, however, we need stronger, more difficult to formulate, closure properties, which we omit here. Finally, recall from Section 2 that the requirement in Case (1) means the existence of an algorithm whose running time is bounded exponentially in general and polynomially in the size of data; for example, Case (1) gives us an {an inline-figure} upper bound for indistinguishability when {a mathematical formula}O is the language of full TGDs.
      </paragraph>
      <paragraph label="Proof">
       Case (1) follows by analysis of our basic algorithm based on Lemma 3, which first constructs {a mathematical formula}VM,D and {a mathematical formula}VM,D′, and then checks equivalence of {a mathematical formula}O∪VM,D and {a mathematical formula}O∪VM,D′. Let {a mathematical formula}so, {a mathematical formula}sm, {a mathematical formula}sd and {a mathematical formula}sd′ be the sizes of (binary representations of) {a mathematical formula}O, {a mathematical formula}M, {a mathematical formula}D and {a mathematical formula}D′, respectively. There exist polynomials {a mathematical formula}p1 and {a mathematical formula}p2 such that (the representations of) {a mathematical formula}VM,D and {a mathematical formula}VM,D′ can be constructed in time {a mathematical formula}sv=p1(sm+sd+sd′)p2(sm), and, therefore, the sizes of {a mathematical formula}VM,D and {a mathematical formula}VM,D′ are bounded by {a mathematical formula}sv as well. Then, equivalence of {a mathematical formula}O∪VM,D and {a mathematical formula}O∪VM,D′ can be checked by means of {a mathematical formula}sv CQ entailments, each of which can be done, for polynomials {a mathematical formula}p3 and {a mathematical formula}p4, in time {a mathematical formula}p3(so+sm+sv)p4(so+sm) (since CQ entailment is in {an inline-figure} and in {an inline-figure} in data complexity for {a mathematical formula}O). So, overall, indistinguishability can be checked in time {a mathematical formula}sv+sv⋅p3(so+sm+sv)p4(so+sm), as required.Case (2a) follows by analysis of the same algorithm. Since entailment of each CQ in {a mathematical formula}VM,D′ by {a mathematical formula}O∪VM,D can be checked in {a mathematical formula}C (and the same holds for {a mathematical formula}VM,D and {a mathematical formula}O∪VM,D′) and {a mathematical formula}C is closed under {an inline-figure} reductions and intersection, checking equivalence of {a mathematical formula}O∪VM,D and {a mathematical formula}O∪VM,D′ can also be done in {a mathematical formula}C. Since the mappings {a mathematical formula}M are LAV, {a mathematical formula}VM,D and {a mathematical formula}VM,D′ are of polynomial size in the sizes of {a mathematical formula}M, {a mathematical formula}D and {a mathematical formula}D′, and it is possible to construct them in {an inline-figure}. Therefore, since {a mathematical formula}C is closed under {an inline-figure} reductions, the overall algorithm for indistinguishability in is {a mathematical formula}C as well.Cases (2b), (3a), and (3b) can be proved in the same way as Case (2a). The only difference is that in Cases (2b) and (3b) the mappings {a mathematical formula}M are GAV, so we are interested in fact entailment instead of CQ entailment, while in Cases (3a) and (3b) we are interested in data complexity, so linearity of {a mathematical formula}M is not necessary. □
      </paragraph>
      <paragraph>
       If the ontology consists of linear TGDs, as is the case in standard OBDA settings, the basic algorithm is in fact not optimal. In particular, we can avoid the explicit construction of the virtual images by exploiting the following property of linear ontologies: to check whether {a mathematical formula}O∪VM,D⊨q with a Boolean CQ q in {a mathematical formula}VM,D′ it suffices to consider only a set of instantiations of the frontier of {a mathematical formula}M over {a mathematical formula}D with the size polynomially bounded in the size of q.
      </paragraph>
      <paragraph label="Lemma 11">
       Let{a mathematical formula}Obe a linear ontology,{a mathematical formula}Mbe a set of mappings, and{a mathematical formula}D,{a mathematical formula}D′be source instances. Then,{a mathematical formula}O∪VM,D⊨VM,D′if and only if the following condition holds: for each mapping{a mathematical formula}φ(x,z)→∃y.ψ(x,y)in{a mathematical formula}Mand tuple of constants{a mathematical formula}a,cwith (all facts of){a mathematical formula}φ(a,c)in{a mathematical formula}D′there are an integer k bounded by the number{a mathematical formula}|ψ|of atoms in ψ, mappings{a mathematical formula}φi(xi,zi)→∃yi.ψi(xi,yi)in{a mathematical formula}Mand tuples of constants{a mathematical formula}ai,ci, for{a mathematical formula}i=1,…,k, such that{a mathematical formula}φi(ai,ci)is in{a mathematical formula}Dfor all i and{a mathematical formula}O∪{∃yi.ψi(ai,yi)|i=1,…,k}⊨∃y.ψ(a,y).
      </paragraph>
      <paragraph label="Proof">
       We start with the backwards direction. For this, assume that the condition in the lemma holds. Pick a CQ {a mathematical formula}∃y.ψ(a,y) in {a mathematical formula}VM,D′. By the definition of {a mathematical formula}VM,D′, there exists a mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M such that {a mathematical formula}D′⊨∃z.φ(a,z). But then, there must exist a tuple of constants c such that all facts of {a mathematical formula}φ(a,c) are in {a mathematical formula}D′. By the condition of the lemma, there exist mappings {a mathematical formula}φi(xi,zi)→∃yi.ψi(xi,yi) and tuples of constants {a mathematical formula}ai,ci, for {a mathematical formula}i=1,…,k, {a mathematical formula}k≤|ψ|, such that all facts of {a mathematical formula}φi(ai,ci) are in {a mathematical formula}D for all i and {a mathematical formula}O∪{∃yi.ψi(ai,yi)|i=1,…,k}⊨∃y.ψ(a,y). Since {a mathematical formula}{∃yi.ψi(ai,yi)|i=1,…,k}⊆VM,D we have that {a mathematical formula}O∪VM,D⊨∃y.ψ(a,y).For the forward direction, assume that {a mathematical formula}O∪VM,D⊨VM,D′. Let {a mathematical formula}φ(x,z)→∃y.ψ(x,y) be a mapping in {a mathematical formula}M and {a mathematical formula}a,c be a tuple of constants such that {a mathematical formula}φ(a,c)⊆D′. By the definition of {a mathematical formula}VM,D′ we have that {a mathematical formula}∃y.ψ(a,y)∈VM,D′, and hence by our assumption we have that {a mathematical formula}O∪VM,D⊨∃y.ψ(a,y). In the following argument, we use the properties of the classic chase procedure [47] applied to linear TGDs. In particular, we use the property that, for linear TGDs, each inference step in the chase procedure depends of at most one fact [47], and hence all facts in the chase are “reachable” from a single input fact. Now, the completeness of the chase ensures that {a mathematical formula}O∪VM,D⊨∃y.ψ(a,y) implies the existence of a tuple of constants b such that {a mathematical formula}ψ(a,b) is contained in the chase of {a mathematical formula}O union the input facts obtained from {a mathematical formula}VM,D by one-to-one substituting of all existentially quantified variables with fresh constants. Since {a mathematical formula}O consists of linear TGDs, each fact in {a mathematical formula}ψ(a,b) ultimately depends on a single input fact. By the definition of {a mathematical formula}VM,D, each input fact of the chase is justified by a mapping {a mathematical formula}φi(xi,zi)→∃yi.ψi(xi,yi) in {a mathematical formula}M and tuples of constants {a mathematical formula}ai,ci such that all the facts of {a mathematical formula}φi(ai,ci) are in {a mathematical formula}D, which implies the claim. □
      </paragraph>
      <paragraph>
       Lemma 3, Lemma 11 suggest a simple algorithm for checking {an inline-figure} if the input ontology {a mathematical formula}O is linear:
      </paragraph>
      <list>
       <list-item label="1.">
        for each mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and tuple a such that {a mathematical formula}D′⊨∃z.φ(a,z)
       </list-item>
       <list-item label="2.">
        repeat the previous step with {a mathematical formula}D and {a mathematical formula}D′ swapped and return true afterwards.
       </list-item>
      </list>
      <paragraph>
       By analysing this algorithm, we can provide upper bounds to source indistinguishability for several other relevant cases.
      </paragraph>
      <paragraph label="Theorem 12">
       Problem{an inline-figure}for{a mathematical formula}Oin an ontology language{a mathematical formula}Oand{a mathematical formula}Min a mapping language{a mathematical formula}Mis in
      </paragraph>
      <list>
       <list-item>
        {an inline-figure}, if{a mathematical formula}Ois linear;
       </list-item>
       <list-item>
        {a mathematical formula}Π2p, if
       </list-item>
       <list-item>
        {an inline-figure}, if
       </list-item>
      </list>
      <paragraph>
       Before proving this theorem, consider the following remarks. First, according to Case (3) (either (a) or (b)), the indistinguishability problem is in {an inline-figure} for standard OBDA settings, where mappings are GAV and the ontology is in DL-Lite{a mathematical formula}R (it is in {an inline-figure} in data complexity by Case (3b) of Theorem 10). Second, Cases (2) and (3) can be relativised in a similar way as Cases (2) and (3) of Theorem 10; for example, if CQ entailment is in a complexity class {a mathematical formula}C for {a mathematical formula}O and {an inline-figure}, then {an inline-figure} is in the class {an inline-figure}.
      </paragraph>
      <paragraph label="Proof">
       Case (1) follows immediately from the analysis of the algorithm: all mappings {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and tuples a are checked, one by one, whether either {a mathematical formula}D′⊭∃z.φ(a,z) or there is a set of mappings {a mathematical formula}φi(xi,zi)→∃yi.ψi(xi,yi) in {a mathematical formula}M and tuples of constants {a mathematical formula}ai with {a mathematical formula}i=1,…,k, {a mathematical formula}k≤|ψ|, such that {a mathematical formula}O∪{∃yi.ψi(ai,yi)|i=1,…,k}⊨∃y.ψ(a,y); then the same is done for {a mathematical formula}D and {a mathematical formula}D′ swapped. If CQ entailment is in {an inline-figure}, then all this can be done in {an inline-figure} as well.Case (2a) is similar to Case (1): to falsify indistinguishability, a mapping {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and tuple a is guessed and then {an inline-figure} oracles are called two times, one to check whether {a mathematical formula}D′⊭∃z.φ(a,z) and the other to check whether there exists a set of mappings and a set of tuples satisfying the required properties, and then two more times for {a mathematical formula}D and {a mathematical formula}D′ swapped. Case (2b) is the same as Case (2a), except that y is empty, and hence we need to check for fact entailment over ontology instead of CQ entailment.Cases (3a) and (3b) is also very similar: since the frontier—that is, the size of a—is bounded, we do not need to guess {a mathematical formula}φ(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and a because we can check all of them one by one in polynomial time. □
      </paragraph>
     </section>
     <section label="5.2">
      <section-title>
       Complexity lower bounds
      </section-title>
      <paragraph>
       We begin our study of lower bounds by showing that source indistinguishability is at least as hard as CQ entailment under mild assumptions on the mapping language.
      </paragraph>
      <paragraph label="Proposition 13">
       Problem{an inline-figure}is{a mathematical formula}C-hard, for a complexity class{a mathematical formula}C, when{a mathematical formula}Oranges over an ontology language{a mathematical formula}Oand{a mathematical formula}Mover a mapping language{a mathematical formula}Msuch that
      </paragraph>
      <list>
       <list-item>
        CQ entailment is{a mathematical formula}C-hard for{a mathematical formula}O, and{a mathematical formula}Mcontains all sets of LAV mappings, or
       </list-item>
       <list-item>
        fact entailment is{a mathematical formula}C-hard for{a mathematical formula}O, and{a mathematical formula}Mcontains all sets of mappings that are CQ views and LAV;
       </list-item>
      </list>
      <paragraph>
       In particular, recall that CQ and fact entailment are {an inline-figure}- and {an inline-figure}-complete for full and linear ontologies, respectively, so these bounds propagate to the hardness of indistinguishability for these ontology languages. Moreover, this proposition provides matching lower bounds for all the cases of Theorem 10 and Case (1) of Theorem 12.
      </paragraph>
      <paragraph label="Proof">
       The same proofs work for the statements about bounded arity and data complexity. □
      </paragraph>
      <paragraph>
       Checking indistinguishability can be, however, strictly harder than CQ entailment. CQ entailment in the absence of an ontology is in {an inline-figure}, while the following theorem proves that even with no ontology {an inline-figure} can be {a mathematical formula}Π2p-hard.
      </paragraph>
      <paragraph label="Theorem 14">
       Problem{an inline-figure}is{a mathematical formula}Π2p-hard if{a mathematical formula}Ois empty and{a mathematical formula}Mranges over an ontology language{a mathematical formula}Msuch that either
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Mcontains all sets of mappings with source and global arity both bounded by 2, or
       </list-item>
       <list-item>
        {a mathematical formula}Mcontains all sets of CQ views with source arity bounded by 2.
       </list-item>
      </list>
      <paragraph>
       This theorem provides matching lower bounds to Case (2) of Theorem 12. Note that there are two incomparable lower bounds, and, according to Case (3) of Theorem 12, if we join the conditions for these bounds then the problem becomes easier, in {an inline-figure} (the matching lower bound for that case is shown in Theorem 15).
      </paragraph>
      <paragraph label="Proof">
       We start with Case (b) and show {a mathematical formula}Π2p-hardness by reduction of the {an inline-figure} problem, and then explain how to adapt the reduction to Case (a).Let {a mathematical formula}Φ=∀u.∃v.Ψ, where Ψ is a propositional formula in 3CNF over variables {a mathematical formula}u∪v—that is, a conjunction of clauses of the form {a mathematical formula}ℓ1∨ℓ2∨ℓ3 with propositional literals {a mathematical formula}ℓ1, {a mathematical formula}ℓ2, {a mathematical formula}ℓ3 over {a mathematical formula}u∪v (i.e., each {a mathematical formula}ℓj is either a variable in {a mathematical formula}u∪v or the negation of such a variable). Let also {a mathematical formula}u=u1,…,un.On the base of Φ we construct source instances {a mathematical formula}D and {a mathematical formula}D′ as well as a set of CQ views {a mathematical formula}M with source arity bounded by 2 such that Φ is true if and only if {an inline-figure}.We first define the source schema of the setting. Let {a mathematical formula}Clγ be a unary source relational name for each clause γ in Ψ, and let {a mathematical formula}Argj for {a mathematical formula}j=1,2,3, and {a mathematical formula}UVal be binary source relational names.Next we define source instance {a mathematical formula}D, and start with describing the constants that {a mathematical formula}D uses. Each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ mentions at most 3 variables, so there are at most 8 possible assignments of these variables with at most 7 of them satisfying γ. Instance {a mathematical formula}D uses a constant {a mathematical formula}aγπ for each such satisfying assignment π of variables of γ. Also, {a mathematical formula}D uses constants {a mathematical formula}fw and {a mathematical formula}tw for each variable {a mathematical formula}w∈u∪v, representing assignments of w to false and true, respectively. Finally, {a mathematical formula}D uses two constants 0 and 1. Let {a mathematical formula}D consist of the following facts over the introduced constants:
       <list>
        {a mathematical formula}Clγ(aγπ),Arg1(aγπ,b1),Arg2(aγπ,b2),Arg3(aγπ,b3) for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ and each satisfying assignment π of γ, where {a mathematical formula}bj=fw if {a mathematical formula}π(w)=false and {a mathematical formula}bj=tw if {a mathematical formula}π(w)=true for each {a mathematical formula}j=1,2,3 and w the variable in {a mathematical formula}ℓj;{a mathematical formula}UVal(fu,0) and {a mathematical formula}UVal(tu,1) for all variables u in u.Source instance
       </list>
       <paragraph>
        {a mathematical formula}D′ mentions the same constants as {a mathematical formula}D, except that it uses a constant {a mathematical formula}aγπ for each assignment π of variables of each clause γ in Ψ (as opposed to each satisfying assignment in case of {a mathematical formula}D), so each γ has at most 8 such constants in {a mathematical formula}D′ (as opposed to up to 7 in case of {a mathematical formula}D). Hence, {a mathematical formula}D′ consists of the same facts as {a mathematical formula}D except that it has facts {a mathematical formula}Clγ(aγπ), {a mathematical formula}Arg1(aγπ,b1), {a mathematical formula}Arg2(aγπ,b2), {a mathematical formula}Arg3(aγπ,b3) for each γ in Ψ and each assignment π of variables in γ (as opposed to each satisfying assignment).The global schema consists of a single n-ary relational name {a mathematical formula}Target.Finally, we define {a mathematical formula}M as consisting of a single GAV mapping, for {a mathematical formula}wγj the propositional variable in a literal {a mathematical formula}ℓj with number {a mathematical formula}j=1,2,3 of a clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3,{a mathematical formula} over variables {a mathematical formula}zγ for γ in Ψ, {a mathematical formula}zw for {a mathematical formula}w∈u∪v, and {a mathematical formula}xu for {a mathematical formula}u∈u.We argue that Φ is true if and only if {an inline-figure}. According to the mapping, {a mathematical formula}VM,D′ contains facts {a mathematical formula}Target(c1,…,cn) for all {a mathematical formula}ci∈{0,1} and {a mathematical formula}1≤i≤n. It is routine to check that {a mathematical formula}VM,D consists of exactly the same facts (thus making {a mathematical formula}D and {a mathematical formula}D′ indistinguishable) if and only if Φ is true. Indeed, by construction, {a mathematical formula}VM,D contains {a mathematical formula}Target(c1,…,cn) with each {a mathematical formula}ci∈{0,1} if and only if there exists an assignment of all variables {a mathematical formula}w∈u∪v that agrees with {a mathematical formula}c1,…,cn on u and satisfies all the clauses in Ψ. Therefore, {a mathematical formula}VM,D contains all {a mathematical formula}Target(c1,…,cn) if and only if each assignment of u has an assignment of v turning Ψ to true.The proof for Case (b) can be easily modified to work for Case (a): the only difference is that instead of a single n-ary relational name {a mathematical formula}Target the global schema consists of n binary relational names {a mathematical formula}Targeti, {a mathematical formula}i=1,…,n, and the head of the single mapping in {a mathematical formula}M is not {a mathematical formula}Target(xu1,…,xun), but{a mathematical formula} Correctness of this reduction follows immediately from the correctness of the reduction for Case (a). □
       </paragraph>
      </paragraph>
      <paragraph>
       Finally, if we join the conditions of Cases (a) and (b) of Theorem 14 (as in DL-Lite{a mathematical formula}R), the problem stays hard for {an inline-figure}.
      </paragraph>
      <paragraph label="Theorem 15">
       Problem{an inline-figure}is{an inline-figure}-hard if{a mathematical formula}Ois empty and{a mathematical formula}Mranges over an ontology language that contains all sets of CQ views with source arity bounded by 2 and global arity bounded by 0.
      </paragraph>
      <paragraph>
       Recall that in this setting the bound on the global arity implies the same bound on the frontier. Note that this theorem provides the matching lower bound to Case (3) of Theorem 12, and hence is applicable to DL-Lite{a mathematical formula}R ontologies.
      </paragraph>
      <paragraph label="Proof">
       We show {an inline-figure}-hardness by reduction of {an inline-figure}, a known {an inline-figure}-complete problem [72]. The input of this problem consists of two satisfiable propositional formulae {a mathematical formula}Ψ1 and {a mathematical formula}Ψ2 in 3CNF and the question is whether {a mathematical formula}maxtrue⁡(Ψ1)=maxtrue⁡(Ψ2); here, for a satisfiable propositional formula Ψ in 3CNF, {a mathematical formula}maxtrue⁡(Ψ) is the maximum of the number of variables assigned to true over all satisfying assignments of Ψ.For the reduction, we proceed as follows. First, for each propositional formula Ψ in 3CNF we construct a source instance {a mathematical formula}DΨ and a set of CQ views {a mathematical formula}MΨ with the required bounds on the frontier, source arity, and target arity. Second, we show, for two formulae {a mathematical formula}Ψ1 and {a mathematical formula}Ψ2, that {an inline-figure} is true if and only if {a mathematical formula}maxtrue⁡(Ψ1)=maxtrue⁡(Ψ2). At this point, even if {a mathematical formula}MΨ is a set of CQ views, {a mathematical formula}MΨ1∪MΨ2 is not, because the global schema of {a mathematical formula}MΨ does not depend on Ψ; therefore, on the final step we show how to modify the reduction in a way that {a mathematical formula}MΨ1 and {a mathematical formula}MΨ2 are the same set of mappings, which suffices for the proof.Consider a propositional formula Ψ in 3CNF over variables {a mathematical formula}u1,…,un, which is a conjunction of clauses of the form {a mathematical formula}ℓ1∨ℓ2∨ℓ3 for {a mathematical formula}ℓj either a propositional variable from {a mathematical formula}u1,…,un or the negation of such a variable; for each such clause γ and each {a mathematical formula}j=1,2,3 denote {a mathematical formula}uγj the variable in {a mathematical formula}ℓj. In this proof, we assume that variables {a mathematical formula}u1,…,un are ordered; this order plays a technical role and can be arbitrary (but fixed).Similarly to the {a mathematical formula}Π2p-hardness proof of Theorem 14, the source schema has unary relational name {a mathematical formula}ClγΨ for each clause γ in Ψ as well as binary relational names {a mathematical formula}Argj for {a mathematical formula}j=1,2,3, while source instance {a mathematical formula}DΨ uses a constant {a mathematical formula}aγπ for each satisfying assignment π of variables of each clause γ in Ψ and constants {a mathematical formula}fui and {a mathematical formula}tui for each variable {a mathematical formula}ui. Besides this, the source schema has binary relational names {a mathematical formula}PartSum, {a mathematical formula}PreVal and {a mathematical formula}CurrVal, as well as unary relational names {a mathematical formula}Summ, for {a mathematical formula}m=1,…,n. Also, the source instance {a mathematical formula}DΨ uses constants {a mathematical formula}dik for each {a mathematical formula}i=1,…,n and {a mathematical formula}k=0,…,i, as well as constants {a mathematical formula}cik0 and {a mathematical formula}cik1 for each {a mathematical formula}i=2,…,n and {a mathematical formula}k=0,…,i−1.Instance {a mathematical formula}DΨ consists of
       <list>
        the facts {a mathematical formula}ClγΨ(aγπ),Arg1(aγπ,b1),Arg2(aγπ,b2),Arg3(aγπ,b3) for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ and each satisfying assignment π of γ, where, for each {a mathematical formula}j=1,2,3, {a mathematical formula}bj=fuγj if {a mathematical formula}π(uγj)=false and {a mathematical formula}bj=tuγj if {a mathematical formula}π(uγj)=true;the facts {a mathematical formula}PartSum(fu1,d10) and {a mathematical formula}PartSum(tu1,d11);for each i and k such that {a mathematical formula}2≤i≤n and {a mathematical formula}0≤k≤i−1, the facts{a mathematical formula}the fact {a mathematical formula}Summ(dnk), for each k and m such that {a mathematical formula}0≤m≤k≤n.Let the global schema consists of nullary relational names
       </list>
       <paragraph>
        {a mathematical formula}Summ′, for {a mathematical formula}m=1,…,n.Finally, let {a mathematical formula}MΨ consist of the following mappings, for each {a mathematical formula}0≤m≤n, over variables {a mathematical formula}zγ for γ in Ψ, {a mathematical formula}zui and {a mathematical formula}si for {a mathematical formula}i=1,…,n, and {a mathematical formula}ri for {a mathematical formula}i=2,…,n:{a mathematical formula}The key property of {a mathematical formula}MΨ and {a mathematical formula}DΨ is that {a mathematical formula}VMΨ,DΨ⊨Summ′() for an integer m if and only if {a mathematical formula}m≤maxtrue⁡(Ψ). Indeed, consider a satisfying assignment σ of Ψ. Note that the bodies of all the mappings in {a mathematical formula}MΨ differ only in the last atoms {a mathematical formula}Summ(sn). As before, the {a mathematical formula}ClγΨ and {a mathematical formula}Argj atoms of the body of any mapping can be uniquely mapped to {a mathematical formula}DΨ in such that way that each {a mathematical formula}zui is mapped to {a mathematical formula}fui or {a mathematical formula}tui depending of the Boolean value {a mathematical formula}σ(ui). If {a mathematical formula}zu1 is mapped to {a mathematical formula}fu1, then variable {a mathematical formula}s1 can be sent only to {a mathematical formula}d10: intuitively, {a mathematical formula}PartSum(fui,d10) in the image of the homomorphism represents that 0 variables are assigned to true among the first 1 variables. If {a mathematical formula}zu1 is mapped to {a mathematical formula}tu1 then {a mathematical formula}s1 is sent to {a mathematical formula}d11, representing a similar fact. Having a homomorphism defined for all the variables up to {a mathematical formula}si−1, which is sent to {a mathematical formula}di−1k, we know that exactly k variables are assigned to true among the first {a mathematical formula}i−1 ones. If the current variable {a mathematical formula}ui is assigned to false by σ—that is, {a mathematical formula}zui is sent to {a mathematical formula}fui—then {a mathematical formula}ri can be sent only to {a mathematical formula}cik0, and, hence, {a mathematical formula}si is sent to {a mathematical formula}dik. Similarly, if {a mathematical formula}ui is assigned to true, then {a mathematical formula}si is sent to {a mathematical formula}dik+1. At the end, {a mathematical formula}sn is sent to {a mathematical formula}dnk where k is the total number of variables assigned to true by σ; since {a mathematical formula}DΨ contains {a mathematical formula}Sum0(dnk),…,Sumk(dnk), virtual image {a mathematical formula}VMΨ,DΨ contains atoms {a mathematical formula}Sum0′(),…,Sumk′(). This process goes through for all satisfying assignments, so the key property indeed holds.Consequently, {an inline-figure} is true if and only if {an inline-figure} is true.As already mentioned, {a mathematical formula}MΨ1 and {a mathematical formula}MΨ2 have mappings with same heads, so even if {a mathematical formula}MΨ1 and {a mathematical formula}MΨ2 are sets of CQ views, their union is not. The difference between {a mathematical formula}MΨ1 and {a mathematical formula}MΨ2 is that the body of each of their mappings has the conjunction {a mathematical formula}ClγΨk(zγ)∧⋀j=13Argj(zγ,zuγj) for each clause, for {a mathematical formula}k=1,2, while {a mathematical formula}Ψ1 and {a mathematical formula}Ψ2 may have different triples of variables in clauses. One of the ways to overcome this is to modify {a mathematical formula}Ψ1 and {a mathematical formula}Ψ2 such that the corresponding sets of mappings would be the same (minor modifications are needed for the rest of the reduction as well). We proceed as follows. First, we may assume that {a mathematical formula}Ψ1 and {a mathematical formula}Ψ2 use the same variables {a mathematical formula}u1,…,un (ordered in the same way). Then, we can translate each {a mathematical formula}Ψk, {a mathematical formula}k=1,2, to an equivalent propositional formula {a mathematical formula}Ψk′ in 4CNF over the same variables such that for each three literals {a mathematical formula}ℓ1,ℓ2,ℓ3 over {a mathematical formula}u1,…,un (possibly with repetitions) {a mathematical formula}Ψk′ has a clause {a mathematical formula}ℓ1∨ℓ2∨ℓ3∨ℓ1′, where {a mathematical formula}ℓ1′ is {a mathematical formula}ℓ1 if {a mathematical formula}ℓ1∨ℓ2∨ℓ3 is in {a mathematical formula}Ψk and the negation of {a mathematical formula}ℓ1 otherwise. Since the conjunctions {a mathematical formula}ClγΨk(zγ)∧⋀j=13Argj(zγ,zuγj) depend only on the variables in literals and not on their signs, the sets of mappings in {a mathematical formula}MΨ1′ and {a mathematical formula}MΨ2′ (constructed in the same way as {a mathematical formula}MΨk except that j ranges over 1 to 4 instead of 1 to 3), differ only in the superscripts of relational names {a mathematical formula}ClγΨk. Therefore we can use the same relational names {a mathematical formula}Clγ instead of {a mathematical formula}ClγΨ1 and {a mathematical formula}ClγΨ2 in the instances and mappings, and then the union of {a mathematical formula}MΨ1′ and {a mathematical formula}MΨ2′ is just the set of CQ views {a mathematical formula}MΨ1′. □
       </paragraph>
      </paragraph>
     </section>
    </section>
    <section label="6">
     <section-title>
      Policy compliance and strong compliance
     </section-title>
     <paragraph>
      We now turn our attention to the policy compliance problems and show that both {an inline-figure} and {an inline-figure} are decidable for any ontology language with decidable query entailment problem. Furthermore, we establish matching complexity bounds for both problems in the most common cases. In fact, the complexity of both problems coincide for all the studied cases, and the proof techniques required are also very similar.
     </paragraph>
     <section label="6.1">
      <section-title>
       Decidability and complexity upper bounds
      </section-title>
      <paragraph>
       Consider an arbitrary input {a mathematical formula}(O,M,D,p) to {an inline-figure} (or to {an inline-figure}). By Definition 5, a correct procedure must return true if and only if, for every tuple a, there exists a source instance {a mathematical formula}Da indistinguishable from {a mathematical formula}D such that {a mathematical formula}D⊨p(a) implies {a mathematical formula}Da⊭p(a) (respectively, such that {a mathematical formula}D⊨a if and only if {a mathematical formula}Da⊭p(a)).
      </paragraph>
      <paragraph>
       We start our discussion of a decision procedure with two basic observations. First, for a source instance {a mathematical formula}D′ to be indistinguishable from {a mathematical formula}D, the virtual image of {a mathematical formula}D′ via the mappings can only contain constants from {a mathematical formula}ADom(D). Second, the virtual image of {a mathematical formula}D′ is fully determined by the way in which the body of the mappings matches homomorphically to {a mathematical formula}D′ and, in particular, on the instantiation of the frontier variables of the mappings in such homomorphisms. These observations motivate the following definition of a source type.
      </paragraph>
      <paragraph label="Definition 16">
       A source typeτ for a data integration setting {a mathematical formula}(O,M,D) is a function assigning true or false to each sentence of the form {a mathematical formula}∃z.φ(a,z), with a a tuple of constants from {a mathematical formula}ADom(D) and {a mathematical formula}φ(x,z) the body of a mapping in {a mathematical formula}M. The image of τ, denoted {a mathematical formula}Vτ, is the set of sentences {a mathematical formula}∃y.ψ(a,y) such that {a mathematical formula}φ(x,z)→∃y.ψ(x,y) is a mapping in {a mathematical formula}M and τ returns true when applied to {a mathematical formula}∃z.φ(a,z).
      </paragraph>
      <paragraph label="Definition 17">
       Intuitively, each {a mathematical formula}Vτ associated to a source type τ represents a candidate virtual image. To decide compliance and strong compliance we are interested only in those source types that are realisable and strongly realisable, respectively. Following Definition 5, a source type τ is realisable if it has a witnessing source instance {a mathematical formula}Dτ that refutes some answer to the policy. Analogously, following Definition 6, τ is strongly realisable if it has a witnessing {a mathematical formula}Dτ such that the evaluation of the policy over {a mathematical formula}Dτ disagrees with that over {a mathematical formula}D. Let {a mathematical formula}(O,M,D) be a data integration setting and p be a Boolean policy. A source type τ for {a mathematical formula}(O,M,D) is
      </paragraph>
      <list>
       <list-item label="–">
        p-realisable if there exists a source instance {a mathematical formula}Dτ such that {a mathematical formula}VM,Dτ=Vτ and {a mathematical formula}Dτ⊭p; and
       </list-item>
       <list-item label="–">
        strongly p-realisable if there exists {a mathematical formula}Dτ such that {a mathematical formula}VM,Dτ=Vτ and {a mathematical formula}Dτ⊨p if and only if {a mathematical formula}D⊭p.
       </list-item>
      </list>
      <paragraph>
       Note that the notions of realisability in Definition 17 depend on the mappings {a mathematical formula}M and the source instance {a mathematical formula}D, but are independent from the ontology {a mathematical formula}O. Indeed, the intention behind realisability is to capture the different ways in which the body of the mappings match the source data, and this is independent from the contents of the ontology.
      </paragraph>
      <paragraph>
       The following lemma shows that realisability in both its flavours can be characterised as a satisfiability problem over a logical theory consisting of a Boolean combination of existentially quantified sentences. As a result, whenever the aforementioned logical theory is satisfiable, it has a model of polynomial size that can be guessed by a non-deterministic algorithm.
      </paragraph>
      <paragraph label="Lemma 18">
       Let τ be a source type for a data integration setting{a mathematical formula}(O,M,D)and{a mathematical formula}ρτbe the conjunction of the following sentences:{a mathematical formula}Then, given a Boolean policy p, τ is
      </paragraph>
      <list>
       <list-item label="–">
        p-realisable if and only if{a mathematical formula}ρτ∧¬pis satisfiable; and
       </list-item>
       <list-item label="–">
        strongly p-realisable if and only if either{a mathematical formula}D⊨pand{a mathematical formula}ρτ∧¬pis satisfiable, or{a mathematical formula}D⊭pand{a mathematical formula}ρτ∧pis satisfiable.
       </list-item>
      </list>
      <paragraph label="Proof">
       We prove the statement in the lemma concerning p-realisability. The proof for the statement about strong p-realisability is analogous. Denote for the proof {a mathematical formula}σ=ρτ∧¬p.Assume that σ is satisfiable. Observe that p and each ξ in {a mathematical formula}ρτ are existentially quantified sentences; furthermore, a formula {a mathematical formula}∀x,z.(ϕ(x,z)→⋀x∈x⋁a∈ADom(D)x=a) is equivalent to {a mathematical formula}¬∃x,z.(ϕ(x,z)∧⋁x∈x⋀a∈ADom(D)x≠a). Thus, σ is equivalent to a Boolean combination of existentially quantified sentences and, as a result, a satisfiable σ must have a polynomial size Herbrand model I that satisfies each ξ such that {a mathematical formula}τ(ξ)=true by mapping each existentially quantified variable to a constant in {a mathematical formula}ADom(D). Such model corresponds directly to the source instance {a mathematical formula}Dτ required by Definition 17.Conversely, if τ is p-realisable, then a source instance {a mathematical formula}Dτ satisfying the conditions of Definition 17 must exist. Such {a mathematical formula}Dτ satisfies ¬p by definition, as well as every formula in {a mathematical formula}ρτ by the requirement that {a mathematical formula}VM,Dτ=Vτ. Hence, σ is satisfiable. □
      </paragraph>
      <paragraph>
       Lemma 18 gives us a way to find a candidate for a witness for compliance and strong compliance if the policy is Boolean. For general policies {a mathematical formula}p(x) we need to find such a witness for every {a mathematical formula}p(a), where a is a tuple of constants in {a mathematical formula}ADom(D). Of course, by Lemma 3 in the previous section, a realisable type τ must satisfy an additional property to witness (strong) compliance: {a mathematical formula}O∪Vτ must be equivalent to {a mathematical formula}O∪VM,D.
      </paragraph>
      <paragraph>
       With these ingredients, we are ready to present alternating algorithms for {an inline-figure} and {an inline-figure} for a data integration setting {a mathematical formula}(O,M,D) and a policy p. The first one proceeds according to the following steps:
      </paragraph>
      <list>
       <list-item label="1.">
        universally guess a tuple a of constants from {a mathematical formula}ADom(D) of the same arity as p;
       </list-item>
       <list-item label="2.">
        existentially guess a source type τ for {a mathematical formula}(O,M,D);
       </list-item>
       <list-item label="3.">
        verify whether
       </list-item>
       <list-item label="4.">
        accept if both hold and reject otherwise.
       </list-item>
      </list>
      <paragraph>
       The procedure for checking {an inline-figure} is analogous, with the only difference that it verifies strong {a mathematical formula}p(a)-realisability instead of {a mathematical formula}p(a)-realisability.
      </paragraph>
      <paragraph>
       Correctness of these algorithms follows from Lemma 3 and the definition of (strong) realisable type. Furthermore, by analysing these algorithms (and variants thereof), as well as by exploiting the logical characterisation of realisability in Lemma 18, we can obtain decidability and complexity upper bounds for a wide range of practically relevant cases.
      </paragraph>
      <paragraph label="Theorem 19">
       Problems{an inline-figure}and{an inline-figure}for{a mathematical formula}Oin an ontology language{a mathematical formula}O,{a mathematical formula}Min a mapping language{a mathematical formula}M, and p in a policy language{a mathematical formula}Pare in
      </paragraph>
      <list>
       <list-item>
        {an inline-figure}, if
       </list-item>
       <list-item>
        {a mathematical formula}Π3p, if
       </list-item>
       <list-item>
        {a mathematical formula}Σ2p, if the condition of Case (2) holds, and{a mathematical formula}Phas bounded arity.
       </list-item>
      </list>
      <paragraph>
       Note that, in particular, the {a mathematical formula}Π3p bound in combined complexity and the {an inline-figure} bound in data are applicable to OBDA settings where ontologies are DL-Lite{a mathematical formula}R and mappings are GAV. Also, Cases (2) and (3) can be relativised in the same way as Cases (2) and (3) of Theorem 12. For example, if {a mathematical formula}O has CQ (or fact) entailment in a complexity class {a mathematical formula}C with {a mathematical formula}Σ2p⊆C and all other conditions of Case (2a) (or (2b), respectively) of Theorem 19 hold, then {an inline-figure} and {an inline-figure} are both in {an inline-figure}; in particular, if CQ (or fact) entailment is in {an inline-figure}, as for full TGDs, or in {an inline-figure}, as for linear TGDs, then {an inline-figure} and {an inline-figure} are also in {an inline-figure} or {an inline-figure}, respectively. Cases (1) and (4) can be relativised as well, but we need stronger closure properties of the complexity class for entailment. Therefore, we just note that Case (1) holds with the same proof if {an inline-figure} is replaced with any of the usual complexity class subsuming {an inline-figure}, such as {an inline-figure}, while Case (4) holds if {an inline-figure} is replaced with {an inline-figure}, {an inline-figure}, etc. Also, in a similar way, we can prove decidability of our compliance problems (both in combined or data complexity) whenever the corresponding entailment problems for the ontology language at hand are decidable.
      </paragraph>
      <paragraph label="Proof">
       All the cases follow from the analysis of the algorithm presented before the theorem. We concentrate on problem {an inline-figure}, and the argument for {an inline-figure} is analogous.In Case (1) there is no need to guess a tuple a of constants, because there are only exponential number of them, and we can go through them one by one deterministically. Then, any source type τ is of exponential size (same as {a mathematical formula}Vτ), so we can guess it in {an inline-figure}. Checking for {a mathematical formula}p(a)-realisability of τ can also be done in {an inline-figure}: first we guess an interpretation of exponential size and then verify that it is a model of {a mathematical formula}ρτ and {a mathematical formula}¬p(a). Note that the verification can be done in exponential time in the size of the input, because each existentially quantified subformula of {a mathematical formula}ρτ∧¬p(a) is of polynomial size. Finally, checking for equivalence of {a mathematical formula}O∪Vτ and {a mathematical formula}O∪VM,D can also be done in {an inline-figure} by checking exponential number of CQ or fact entailments (in Case (1a) or (1b), respectively), which are in {an inline-figure} with {an inline-figure} data complexity.In Case (2) the mappings in {a mathematical formula}M have bounded frontier. Therefore, any source type for {a mathematical formula}(O,M,D) is of polynomial size. So, we can reformulate the algorithm presented before the theorem as follows in order to directly justify the {a mathematical formula}Π3p upper bound:
       <list>
        universally guess a tuple a of constants;existentially guessuniversally guess non-witnesses that I is a model of the negative elements of {a mathematical formula}ρτ and {a mathematical formula}¬p(a);check that the witnesses indeed satisfy the required properties—that is, τ is {a mathematical formula}p(a)-realisable, and {a mathematical formula}O∪Vτ and {a mathematical formula}O∪VM,D are equivalent.For
       </list>
       <paragraph>
        Case (3) we can use almost the same variant of the algorithm as for Case (2). The only difference is that instead of guessing on the first step we can go through all the tuples a one by one, because their size—that is, the arity of p—is bounded.Case (4) again requires a very similar variant of the algorithm as the previous two cases. However, since {a mathematical formula}M, {a mathematical formula}O, and p are fixed, we only need to guess I and witnesses for entailments. □
       </paragraph>
      </paragraph>
      <paragraph>
       Similarly to indistinguishability, compliance can be done more efficiently if the ontology is linear and mappings are LAV. This is justified by the following lemma, which claims that we can restrict ourselves to source instances of polynomial size.
      </paragraph>
      <paragraph label="Lemma 20">
       Let{a mathematical formula}(O,M,D)be a data integration setting with linear{a mathematical formula}Oand LAV{a mathematical formula}M, and let p be a Boolean policy. If there exists a p-realisable (or strongly p-realisable) source type τ for{a mathematical formula}(O,M,D)such that{a mathematical formula}O∪Vτand{a mathematical formula}O∪VM,Dare equivalent, then there exists a source type with the same properties that istrueon at most{a mathematical formula}|M|2⋅|D|⋅kmaxsentences, where{a mathematical formula}kmaxis the maximal number of atoms in heads of mappings in{a mathematical formula}M.
      </paragraph>
      <paragraph label="Proof">
       The proof is based on Lemma 11. Again, we concentrate of realisability, and the case of strong realisability is similar.Since τ is p-realisable, there exists a source instance {a mathematical formula}Dτ such that {a mathematical formula}VM,Dτ=Vτ and {a mathematical formula}Dτ⊭p. Then, {a mathematical formula}O∪VM,Dτ⊨VM,D, and, by Lemma 11, for each mapping {a mathematical formula}R(x,z)→∃y.ψ(x,y) in {a mathematical formula}M and tuple of constants {a mathematical formula}a,c with {a mathematical formula}R(a,c)∈D there are an integer k bounded by the number {a mathematical formula}|ψ| of atoms in ψ, mappings {a mathematical formula}Ri(xi,zi)→∃yi.ψi(xi,yi) in {a mathematical formula}M and tuples of constants {a mathematical formula}ai,ci, for {a mathematical formula}i=1,…,k, such that {a mathematical formula}Ri(ai,ci)∈Dτ for all i and {a mathematical formula}O∪{∃yi.ψi(ai,yi)|i=1,…,k}⊨∃y.ψ(a,y). Consider the sub-instance {a mathematical formula}Dτ′ of {a mathematical formula}Dτ that consists of all those {a mathematical formula}Ri(ai,ci). On the one hand, by construction, {a mathematical formula}O∪VM,Dτ′ and {a mathematical formula}O∪VM,D are equivalent, as well as {a mathematical formula}Dτ′⊭p. On the other, again by construction, {a mathematical formula}Dτ′ consists of at most {a mathematical formula}|M|⋅|D|⋅kmax facts. Hence, the source type {a mathematical formula}τ′ that is true on {a mathematical formula}∃z.R(a,z) if and only if there is c with {a mathematical formula}R(a,c)∈Dτ′ satisfies all the properties required in the claim of the lemma. □
      </paragraph>
      <paragraph>
       This lemma gives us a possibility to optimise the algorithm from Theorem 19 and obtain better upper bounds in the case when the ontology is linear and mappings are LAV.
      </paragraph>
      <paragraph label="Theorem 21">
       Problems{an inline-figure}and{an inline-figure}for{a mathematical formula}Oin an ontology language{a mathematical formula}O,{a mathematical formula}Min a mapping language{a mathematical formula}M, and p in a policy language{a mathematical formula}Pare in
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Π3p, if
       </list-item>
       <list-item>
        {a mathematical formula}Σ2p, if the condition of Case (1) holds, and{a mathematical formula}Pis of bounded arity; and
       </list-item>
       <list-item>
        {an inline-figure}, if the condition of Case (1) holds, and{a mathematical formula}Pis ground.
       </list-item>
      </list>
      <paragraph>
       Note that the best upper bound we can get from Theorem 19 for all three cases is {an inline-figure}, and we will prove the matching lower bound for non-LAV mappings and even empty ontologies in Theorem 24. Again, the Cases (1) and (2) can be relativised as usual, while {an inline-figure} in Case (3) can be replaced with the standard complexity classes subsuming {an inline-figure}.
      </paragraph>
      <paragraph label="Proof">
       For Case (1) we can use almost the same variant of the algorithm as for Case (2) of Theorem 19: we just restrict ourselves to source instances τ and interpretations I of polynomial size, which is enough by Lemma 18, Lemma 20.Case (2) differs from Case (1) in the same way as Case (3) of Theorem 19 differs from its Case (2): there is no need to guess a because the arity of p is bounded.For Case (3) we analyse the algorithm closer. Since {a mathematical formula}M contains only LAV mappings, there is no need to guess witnesses that the interpretation I is a model for elements of {a mathematical formula}ρτ, both positive and negative. Moreover, even if the domain of τ can be of exponential size, we need to verify its value on only a polynomial number of sentences. In particular, we can just check which mappings in {a mathematical formula}M match which facts holding in I, and this can be done in polynomial time. Because of this and the fact that p is ground, there is no need for the second universal guess, and the problem can be solved with a polynomial existential guess. □
      </paragraph>
      <paragraph>
       As we will see in the next section, the upper bounds established in Theorem 19, Theorem 21 are tight. These bounds, in particular those concerning data complexity, can be seen as rather discouraging for practical applications. Next we address these concerns to the extent possible by identifying practically relevant islands of tractability for policy compliance and strong compliance. In particular, we show that if the ontology language has tractable fact entailment (as is the case for DL-Lite{a mathematical formula}R), the mappings are GAV and LAV, policies are ground, and the arity of the source schema is bounded, then the problems are also tractable even in combined complexity. If we consider data complexity, then we can drop the requirement of bounded source arity, because it is implicit. Note that all of the aforementioned assumptions are required to obtain tractability: as we will show in the next section, any relaxation leads to {an inline-figure}-hardness of compliance and strong compliance.
      </paragraph>
      <paragraph>
       Thus, we next present high-level algorithms that decide {an inline-figure} and {an inline-figure} under the aforementioned assumptions. For {an inline-figure}, the algorithm proceeds according to the following steps, where C is a set of {a mathematical formula}smax distinct fresh constants with {a mathematical formula}smax the maximal source arity of {a mathematical formula}M:
      </paragraph>
      <list>
       <list-item label="1.">
        construct {a mathematical formula}VM,D;
       </list-item>
       <list-item label="2.">
        for each fact γ in p
       </list-item>
       <list-item label="3.">
        return false.
       </list-item>
      </list>
      <paragraph>
       The algorithm attempts to construct a source instance witnessing compliance. Each such instance should miss at least one fact from p, so the algorithm iterates through all such facts γ, checking whether the maximal set {a mathematical formula}Dγ of facts that does not include γ and does not violate the virtual image of {a mathematical formula}D is indistinguishable from {a mathematical formula}D. Such {a mathematical formula}Dγ for any γ is a witness for compliance. Moreover, since the mappings are LAV, we can restrict the facts in the pool to only those that use constants {a mathematical formula}ADom(D)∪C—that is, we only need a few constants that do not propagate through the mappings.
      </paragraph>
      <paragraph>
       Note that the aforementioned algorithm can be easily modified to decide {an inline-figure} under the same assumptions. The modification first checks whether {a mathematical formula}D⊨p; if it holds, then the procedure for {an inline-figure} is evaluated; otherwise, true is returned if and only if {a mathematical formula}O∪VM,D⊨VM,D′, where {a mathematical formula}D′ is the extension of {a mathematical formula}D with all the facts in p.
      </paragraph>
      <paragraph>
       The tractability results in the following theorem are justified by the correctness of our algorithms and the analysis of their running time.
      </paragraph>
      <paragraph label="Theorem 22">
       Problems{an inline-figure}and{an inline-figure}for{a mathematical formula}Oin an ontology language{a mathematical formula}O,{a mathematical formula}Min a mapping language{a mathematical formula}M, and p in a policy language{a mathematical formula}Pare in{an inline-figure}if
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Ohas CQ entailment in{an inline-figure},{a mathematical formula}Mis LAV and of bounded source and global arities, and{a mathematical formula}Pis ground; or
       </list-item>
       <list-item>
        {a mathematical formula}Ohas fact entailment in{an inline-figure},{a mathematical formula}Mis GAV, LAV and of bounded source and global arities, and{a mathematical formula}Pis ground.
       </list-item>
      </list>
      <paragraph>
       Note that in case of combined complexity the conditions for {a mathematical formula}M imply bounded frontier. All cases except Case (a) for combined complexity are applicable to the settings with empty ontology, and the data complexity bounds is applicable to the settings with DL-Lite{a mathematical formula}R ontologies. As usual, in all cases {an inline-figure} can be replaced with any of the standard complexity classes, such as {an inline-figure}, {an inline-figure} and {an inline-figure}. In particular, in combined complexity, CQ entailment is {an inline-figure}-, {an inline-figure}-, {an inline-figure}-, and {an inline-figure}-complete for full TGDs, linear TDGs, DL-Lite{a mathematical formula}R, and empty ontologies, respectively, so Case (a) of the theorem implies that both {an inline-figure} and {an inline-figure} are in {an inline-figure}, {an inline-figure}, {an inline-figure}, and {an inline-figure}, respectively, for the corresponding settings; next, fact entailment is {an inline-figure}-, {an inline-figure}-, and {an inline-figure}-complete for full TGDs, linear TDGs, and DL-Lite{a mathematical formula}R, respectively, so Case (b) implies that both problems are in {an inline-figure}, {an inline-figure}, and {an inline-figure}, respectively; finally, in data complexity, CQ and fact entailment are {an inline-figure}- and {an inline-figure}-complete for full and linear TDGs, respectively, so the data complexity results imply that {an inline-figure} and {an inline-figure} are in {an inline-figure} and {an inline-figure}, respectively.
      </paragraph>
      <paragraph label="Proof">
       The proofs are based on the algorithms provided before the theorem. We start with compliance.We first claim that the algorithm is sound and complete—that is, it returns true if and only if {an inline-figure} is true. The forward direction follows immediately from Lemma 3 and the fact that, by construction, the algorithm found a source instance {a mathematical formula}Dγ such that {a mathematical formula}Dγ⊭p, and {a mathematical formula}O∪VM,D is equivalent to {a mathematical formula}O∪VM,Dγ. Next we concentrate on backward direction. By Lemma 3, it is enough to show that if there exists a source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D with {a mathematical formula}D′⊭p then there exists a fact γ in p such that {a mathematical formula}Dγ is indistinguishable from {a mathematical formula}D′ (and hence from {a mathematical formula}D). Note that, by construction, {a mathematical formula}O∪VM,D′⊨VM,Dγ so we only argue that {a mathematical formula}O∪VM,Dγ⊨VM,D′. Let {a mathematical formula}∃y.ψ(a,y) be any CQ in {a mathematical formula}VM,D′, and let {a mathematical formula}α′ be a fact in {a mathematical formula}D′ such that {a mathematical formula}∃y.ψ(a,y)∈VM,{α′}—that is, the fact witnessing the CQ in {a mathematical formula}D′. Then a fact α obtained from {a mathematical formula}α′ by replacing all the constants not in {a mathematical formula}ADom(D) by (distinct) constants in C is such that {a mathematical formula}VM,{α}=VM,{α′}; in particular, {a mathematical formula}∃y.ψ(a,y)∈VM,{α}. Moreover, since {a mathematical formula}α′≠γ, {a mathematical formula}α≠γ as well. Therefore, since {a mathematical formula}VM,D′=VM,D, we have that {a mathematical formula}α∈Dγ. So, overall, {a mathematical formula}VM,D′⊆VM,Dγ—that is, {a mathematical formula}O∪VM,Dγ⊨VM,D′ as required for the correctness.Finally, we argue that our algorithm is feasible in {an inline-figure} under the conditions of the theorem (essentially, the same proof works for both cases and both for combined and data complexity). This is implied by the following observations:
       <list>
        the bound on the arity of the source schema allows us to construct all facts over this schema in {an inline-figure} (recall that in the case of data complexity the bound is implicit);the fact that the mappings are LAV implies that the virtual images of instances can also be constructed in {an inline-figure};the complexity bound on CQ or fact entailment implies that the checks required for each fact α as well as the entailment in the last step of the cycle are all feasible in {an inline-figure}.This concludes the proof for the compliance problem. The case of strong compliance is analogous when
       </list>
       <paragraph>
        {a mathematical formula}D⊨p, and straightforward when {a mathematical formula}D⊭p. □
       </paragraph>
      </paragraph>
     </section>
     <section label="6.2">
      <section-title>
       Complexity lower bounds
      </section-title>
      <paragraph>
       An obvious drawback of our generic algorithm for (strong) compliance presented in the previous section is that, in many cases, there is a need for guessing a source type, which can be of exponential size. Unfortunately, as we show in this section, our generic algorithm cannot be improved in general: all the upper bounds in Section 6.1 are tight.
      </paragraph>
      <paragraph>
       As we did in Section 5.2 for source indistinguishability, we begin with the observation that query entailment reduces to compliance checking under rather mild conditions on the mapping and policy languages. As a result, complexity lower bounds on standard entailment problems for ontologies easily transfer to compliance checking.
      </paragraph>
      <paragraph label="Proposition 23">
       Problems{an inline-figure}and{an inline-figure}are{a mathematical formula}C-hard, for a complexity class{a mathematical formula}C, if{a mathematical formula}Oranges over an ontology language{a mathematical formula}O,{a mathematical formula}Mover a mapping language{a mathematical formula}M, and p ranges over a policy language{a mathematical formula}Psuch that
      </paragraph>
      <list>
       <list-item>
        CQ entailment is{a mathematical formula}C-hard for{a mathematical formula}Oand{a mathematical formula}Mcontains all sets of LAV mappings of source arity bounded by 0, or
       </list-item>
       <list-item>
        fact entailment is{a mathematical formula}C-hard for{a mathematical formula}Oand{a mathematical formula}Mcontains all sets of mappings that are GAV, LAV, and of source arity bounded by 0,
       </list-item>
      </list>
      <paragraph>
       Recall that in this setting the bound on the source arity implies the same bound on the frontier. Note also that, in combined complexity, CQ entailment is {an inline-figure}-complete even for empty ontologies, so this proposition provides a matching lower bound for Case (3) of Theorem 21 (another, incomparable lower bound for this case will be obtained in Theorem 28). It also provides matching lower bounds to Cases (2a)–(3b) of Theorem 19, Cases (1a)–(3b) of Theorem 21 and Cases (a) and (b) of Theorem 22 for settings with non-empty ontologies (e.g., full TGDs, linear TGDs, and DL-Lite{a mathematical formula}R) when CQ or fact entailment dominates the complexity of other steps of the corresponding algorithms.
      </paragraph>
      <paragraph label="Proof">
       We again concentrate on {an inline-figure}, and the proof for {an inline-figure} is analogous.For Case (a), consider an input to the CQ entailment problem consisting of an ontology {a mathematical formula}O0, an instance {a mathematical formula}D0, and a Boolean CQ {a mathematical formula}q0. We construct a set of LAV mappings {a mathematical formula}M with source arity bounded by 0, a source instance {a mathematical formula}D, and a fact α such that {a mathematical formula}O0,D0⊨q0 if and only if {an inline-figure} is true.Let the source schema consists of two nullary relational names, {a mathematical formula}D and {a mathematical formula}P, the source instance {a mathematical formula}D consist of two facts {a mathematical formula}D() and {a mathematical formula}P(), and the policy fact α be {a mathematical formula}P().Let also the global schema consist of all relational names in {a mathematical formula}D0, while the set {a mathematical formula}M of GAV and LAV mappings consist of{a mathematical formula}Note that {a mathematical formula}VO,{D()}=D0, so it is immediate to check that
       <list>
        if {a mathematical formula}O0,D0⊨q0 then the source instance {a mathematical formula}{D()} witnesses {an inline-figure}, andif {an inline-figure} then the witnessing source instance, which is either ∅ or {a mathematical formula}{D()}, guarantees that {a mathematical formula}O0,D0⊨q0.Case (b)
       </list>
       <paragraph>
        The same proofs work for the statements about ontologies of bounded arity and data complexity. □
       </paragraph>
      </paragraph>
      <paragraph>
       In the rest of this section we give matching lower bounds for different versions of the compliance and strong compliance problems for the cases when entailment checking is not the dominating source of complexity.
      </paragraph>
      <paragraph>
       Recall that, according to Case (1) of Theorem 19, in the most general settings for empty ontologies compliance and strong compliance are in {an inline-figure}. We start by showing two rather strong incomparable matching lower bounds: the first holds already if we restrict the input ontology to be empty, the mappings to be of bounded source and global arities, and the policy to be just a fact, while the second additionally restricts the mappings to be CQ views (and hence GAV), but does not bound the global arity.
      </paragraph>
      <paragraph>
       Our proof uses an encoding of the well-known {an inline-figure}-complete version of the domino tiling problem. In the source, there are relational names associating “cell objects” with vertical and horizontal coordinates, and also with tile types. The only information exported by the mappings is that adjacent coordinates are associated with some cells and with some tile type assignments which are compatible. In fact, in the input source instance {a mathematical formula}D, a cell will be associated with every tile type, since there is only one cell object. But this information is not exported by the mappings, and thus source instances indistinguishable from {a mathematical formula}D may be better behaved. The policy p is chosen so that indistinguishable source instances where p fails correspond to those where coordinates are assigned a unique tiling type.
      </paragraph>
      <paragraph label="Theorem 24">
       The problems{an inline-figure}and{an inline-figure}are{an inline-figure}-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language{a mathematical formula}M, and p ranges over a policy language{a mathematical formula}Psuch that either
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Mcontains all sets of mappings with source and global arity bounded by 2, or
       </list-item>
       <list-item>
        {a mathematical formula}Mcontains all sets of CQ views with source arity bounded by 2,
       </list-item>
      </list>
      <paragraph>
       As mentioned before, this theorem gives two incomparable matching lower bounds for Case (1) of Theorem 19. By Theorem 19, Theorem 21, these bounds cannot be improved along the dimensions considered in this paper; for example, if we join the requirements of Cases (a) and (b), then the problem is in {a mathematical formula}Σ2p by Case (3) of Theorem 19 (or, alternatively, by Case (2) of Theorem 21).
      </paragraph>
      <paragraph label="Proof">
       We show the {an inline-figure} lower bounds stated in the theorem by means of reductions of a corresponding variation of the tiling problem. The input of this problem is a tiling instance{a mathematical formula}(T,RH,RV), with a finite set of tile types {a mathematical formula}T, horizontal compatibility relation {a mathematical formula}RH⊆T×T and vertical compatibility relation {a mathematical formula}RV⊆T×T, while the answer is true —that is, the instance has a solution—if and only if it is possible to tile a {a mathematical formula}2n×2n square, for {a mathematical formula}n=|T|, according to {a mathematical formula}RH and {a mathematical formula}RV.We first describe the reduction and prove its correctness for Case (b), and then explain how to adapt it to Case (a).Let {a mathematical formula}(T,RH,RV) be a tiling instance, and let {a mathematical formula}n=|T|. We will first show how to construct a set of GAV mappings {a mathematical formula}M, a Boolean UCQ p and a source instance {a mathematical formula}D such that {an inline-figure} if and only if the instance has a solution. Afterwards, we discuss how this construction can be modified to make the set of mappings consist of CQ views and the policy be a single Boolean CQ. To complete the proof for Case (b), we show how, with a minor modification of the previous construction, we can further restrict p to be a fact.It is important to note that {a mathematical formula}D and p we will construct are such that {a mathematical formula}D⊨p. In this case the notions of compliance and strong compliance coincide, and therefore the reductions show {an inline-figure}-hardness of {an inline-figure} as well.We start with the definition of the source schema: let it consist of unary relational names {a mathematical formula}Zero, {a mathematical formula}One and {a mathematical formula}Tiledt for each {a mathematical formula}t∈T, as well as binary relational names {a mathematical formula}HBiti and {a mathematical formula}VBiti for each i such that {a mathematical formula}n≥i≥1.Then, let source instance {a mathematical formula}D consist of the following facts over constants 0, 1, and e:{a mathematical formula}Let now the target schema consists of relational names {a mathematical formula}HValidi and {a mathematical formula}VValidi, with {a mathematical formula}n≥i≥1, all with arity 3n.We next construct {a mathematical formula}M. For the sake of readability, we allow for (safe) equalities of variables in the bodies of mappings, which clearly does not add any power to the language and can be eliminated by a polynomial transformation. We also introduce some abbreviations. First, for tuples of variables {a mathematical formula}u=un,…,u1 and {a mathematical formula}v=vn,…,v1, let{a mathematical formula} Intuitively, {a mathematical formula}Nexti(u,v) is true whenever u and v represent in binary consecutive numbers of the form {a mathematical formula}bn…bi+101…1 and {a mathematical formula}bn…bi+110…0, respectively, with {a mathematical formula}bj∈{0,1} for {a mathematical formula}n≤j&lt;i. Also, let, for {a mathematical formula}x=xn,…,x1 and {a mathematical formula}y=yn,…,y1,{a mathematical formula}We next exploit these abbreviations to define set of mappings {a mathematical formula}M. For each i, {a mathematical formula}n≥i≥1, and {a mathematical formula}(t1,t2)∈RH, let {a mathematical formula}M include the following mapping, which checks that all horizontally adjacent cells are assigned to tile types in accordance with {a mathematical formula}RH:{a mathematical formula} Similarly, let {a mathematical formula}M include, for each i, {a mathematical formula}n≥i≥1, and {a mathematical formula}(t1,t2)∈RV, the following mapping, which checks that all vertically adjacent cells are assigned according to {a mathematical formula}RV:{a mathematical formula}Finally, let p be the following Boolean UCQ with all parameters implicitly existentially quantified variables:{a mathematical formula}We claim that {a mathematical formula}(∅,M,D) complies to p if and only if the tiling instance {a mathematical formula}(T,RH,RV) has a solution. To prove this in the forward direction, assume that there exists a source instance {a mathematical formula}D′ that is indistinguishable from {a mathematical formula}D and satisfies ¬p. Since {a mathematical formula}D and {a mathematical formula}D′ are indistinguishable, we know that for each pair of bit vectors {a mathematical formula}bx,by there is at least one cell object c and tile type t such that {a mathematical formula}Coords(c,bx,by) and {a mathematical formula}Tiledt(c) are in {a mathematical formula}D′. Further, the fact that ¬p holds guarantees that there is at most one such t for c. We define a tiling by setting tile type t at coordinates {a mathematical formula}bx,by, and indistinguishability further guarantees that the compatibility relations are satisfied. Conversely, if the tiling instance has a solution, we can define a source instance {a mathematical formula}D′ by creating a unique c for each pair of bit vectors {a mathematical formula}bx,by, associating c with {a mathematical formula}bx,by via Coords, and adding fact {a mathematical formula}Tiledt(c) only for the tile type t given to {a mathematical formula}bx,by in the solution. It is easy to see that the resulting {a mathematical formula}D′ is indistinguishable from {a mathematical formula}D and satisfies ¬p. This completes the proof of correctness of our reduction.Observe, however, that the mappings {a mathematical formula}M in our reduction are not CQ views since there is a mapping with head relational name {a mathematical formula}HValidi for every pair {a mathematical formula}(t1,t2) of horizontally compatible types in {a mathematical formula}RH (and, similar mappings for {a mathematical formula}VValidi); moreover, the policy is a UCQ. Next, we show how to transform these disjunctions into conjunctions. The idea is to have tile types as objects in a new “type storage” relation, along with a relation storing compatibility.Next we make this intuition formal. Instead of unary relational names {a mathematical formula}Tiledt, the source schema contains binary relational names {a mathematical formula}TypeOf, {a mathematical formula}DiffTypes, {a mathematical formula}HComp, and {a mathematical formula}VComp. In turn, the global schema, besides {a mathematical formula}HValidi and {a mathematical formula}VValidi, contains the mirror binary relational names {a mathematical formula}DiffTypes′, {a mathematical formula}HComp′, and {a mathematical formula}VComp′.In turn, let the source instance {a mathematical formula}D1 be the same as {a mathematical formula}D, except that instead of the facts {a mathematical formula}Tiledt(e), for {a mathematical formula}t∈T, it contains the following facts over constants e and {a mathematical formula}dt, {a mathematical formula}t∈T:{a mathematical formula}Let {a mathematical formula}M1 contain the mappings{a mathematical formula} and, for each i with {a mathematical formula}n≥i≥1, the mappings{a mathematical formula} Mappings {a mathematical formula}M1 are CQ views as required. Finally, let {a mathematical formula}p1 be the following Boolean CQ, where all parameters are implicitly existentially quantified variables:{a mathematical formula}We claim that {a mathematical formula}(∅,M1,D1) complies to {a mathematical formula}p1 if and only if the tiling instance {a mathematical formula}(T,RH,RV) has a solution. For the forward direction, assume that there is an indistinguishable from {a mathematical formula}D1 source instance {a mathematical formula}D′ satisfying {a mathematical formula}¬p1. As in the previous case, each coordinate pair is associated with a tile type in a way that horizontally and vertically adjacent cells have compatible types. Moreover, since {a mathematical formula}D′ satisfies {a mathematical formula}¬p1, this type is unique for each cell. The other direction is also very similar to the previous case.Next, we further modify the reduction to make the policy a fact. To this end, we extend the source schema with unary relational names {a mathematical formula}Choice, {a mathematical formula}Check and {a mathematical formula}Trigger, while the global schema with unary {a mathematical formula}Choice′ and {a mathematical formula}Check′ as well as nullary {a mathematical formula}Trigger′ and {a mathematical formula}HasTwoTypes.Then, we define a source instance {a mathematical formula}D2 as an extension of {a mathematical formula}D1 with the following atoms, where d is a fresh constant:{a mathematical formula} We also define {a mathematical formula}M2 as an extension of {a mathematical formula}M1 with the mappings{a mathematical formula} and the mapping{a mathematical formula} where β is the body of {a mathematical formula}p1.Finally, the policy {a mathematical formula}p2 is now the fact{a mathematical formula}We claim that {a mathematical formula}(∅,M2,D2) complies to {a mathematical formula}p2 if and only if the tiling instance {a mathematical formula}(T,RH,RV) has a solution. Indeed, the virtual image of {a mathematical formula}M2 and {a mathematical formula}D2 contains the facts {a mathematical formula}Choice′(e), {a mathematical formula}Choice′(d), {a mathematical formula}Check′(e), and {a mathematical formula}Trigger′(), but does not contain {a mathematical formula}HasTwoTypes(). So, any indistinguishable instance contains either {a mathematical formula}Trigger(e) or {a mathematical formula}Trigger(d). Since {a mathematical formula}Trigger(d) is the policy, an indistinguishable instance witnessing compliance contains {a mathematical formula}Trigger(e). Since it also contains {a mathematical formula}Check(e), the last mapping is not applicable, which is required by indistinguishability, if and only if {a mathematical formula}p1 does not have a match in {a mathematical formula}D2.We next discuss how to adapt the reduction for Case (b) to Case (a), where the target arity is bounded by 2 but mappings are not required to be CQ views (or even GAV). We can do it in the same way as in Theorem 14: instead of 3n-ary global relational names {a mathematical formula}HValidi and {a mathematical formula}VValidi, we can use, for each i, 6n binary relational names {a mathematical formula}HValidij and {a mathematical formula}VValidij, for {a mathematical formula}1≤j≤3n. Then, instead of the heads {a mathematical formula}HValidi(x1,x2,y) in the mappings we can use{a mathematical formula} with {a mathematical formula}vj the j'th component of the vector {a mathematical formula}x1,x2,y; the mappings with heads {a mathematical formula}VValidi(x,y1,y2) can be modified similarly.To conclude the proof, we note that {a mathematical formula}D2⊨p2; thus, the notions of compliance and strong compliance coincide in this case. □
      </paragraph>
      <paragraph>
       According to Case (2) of Theorem 19, the {an inline-figure} upper bound for (strong) compliance can be improved to {a mathematical formula}Π3p if the frontier of the mappings is bounded; if additionally the arity of the policy is bounded, then, according to Case (3) of the same theorem, the problems are in {a mathematical formula}Σ2p. By Cases (1) and (2) of Theorem 21, the same bounds can be obtained if instead of bounded frontier we restrict the mappings to be LAV. In the next two theorems we give matching lower bounds for these algorithms. In the first of them, Theorem 25, we show that the problems are {a mathematical formula}Π3p-hard even if the ontology is empty and the mappings are both CQ views and LAV with bounded source arity; if, additionally, the policy is Boolean, then the problems are {a mathematical formula}Σ2p-hard. In the second one, Theorem 26, we show that if instead of linearity of mappings we restrict policies to be ground, the problem is also {a mathematical formula}Σ2p-hard.
      </paragraph>
      <paragraph label="Theorem 25">
       The problems{an inline-figure}and{an inline-figure}are
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Π3p-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language containing all sets of mappings that are CQ views, LAV and of source and global arities bounded by 2, and p ranges over a policy language containing all policies; and
       </list-item>
       <list-item>
        {a mathematical formula}Σ2p-hard if the same restrictions as in Case (1) hold except that the source and global arities are bounded by 3, and the policy language contains all Boolean policies.
       </list-item>
      </list>
      <paragraph>
       Recall that in these settings the bound on the source arity implies the same bound on the frontier. As already mentioned, this theorem provides matching lower bounds for Cases (2) and (3) of Theorem 19 as well as Cases (1) and (2) of Theorem 21. By Theorem 21, Theorem 22, these bounds cannot be improved along the dimensions considered in this paper; for example, if we additionally require the policy to be ground, then the problems are in {an inline-figure} by Case (b) of Theorem 22.
      </paragraph>
      <paragraph label="Proof">
       First, for the setting of Case (1), we show {a mathematical formula}Σ3p-hardness of the complement of {an inline-figure} by reduction of the {an inline-figure} problem. Then we argue that this reduction works essentially verbatim for showing {a mathematical formula}Π2p-hardness of the complement of {an inline-figure} for the setting of Case (2). Note that, unlike other proofs in this section, these reductions do not directly work for {an inline-figure}, so in the end of the proof we show how to modify them for this problem.We start with the {a mathematical formula}Σ3p reduction. Let {a mathematical formula}Φ=∃s.∀u.∃v.Ψ be a {a mathematical formula}∃∀∃3CNF formula, where s, u, and v are tuples of distinct propositional variables, while Ψ is a conjunction of clauses of the form {a mathematical formula}ℓ1∨ℓ2∨ℓ3 for each {a mathematical formula}ℓj either a variable from {a mathematical formula}s∪u∪v or the negation of such a variable. We need to construct a set {a mathematical formula}M of LAV CQ views of source and global arities bounded by 2, a source instance {a mathematical formula}D, and a CQ p such that {an inline-figure} if and only if Φ is true.Similarly to the previous proofs, the source schema has a unary relational name {a mathematical formula}Clγ for each clause γ in Ψ and binary relational names {a mathematical formula}Argj for each {a mathematical formula}j=1,2,3, while source instance {a mathematical formula}D uses a constant {a mathematical formula}aγπ for each satisfying assignment π of variables of each clause γ in Ψ and constants {a mathematical formula}fw and {a mathematical formula}tw for each variable w in {a mathematical formula}s∪u∪v. Besides this, the source schema has binary relational names {a mathematical formula}UVaru and unary relational names {a mathematical formula}Chosenu for each {a mathematical formula}u∈u. The source instance also uses constants {a mathematical formula}cu− and {a mathematical formula}cu+ for each {a mathematical formula}u∈u.Next we define the source instance {a mathematical formula}D. Let it consist of the following facts:
       <list>
        {a mathematical formula}Clγ(aγπ), {a mathematical formula}Arg1(aγπ,b1), {a mathematical formula}Arg2(aγπ,b2), and {a mathematical formula}Arg3(aγπ,b3), for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ and satisfying assignment π of γ, where {a mathematical formula}bj=fw if {a mathematical formula}π(w)=false and {a mathematical formula}bj=tw if {a mathematical formula}π(w)=true with w the variable of {a mathematical formula}ℓj,{a mathematical formula}UVaru(fu,cu−), {a mathematical formula}UVaru(tu,cu−), {a mathematical formula}UVaru(fu,cu+), {a mathematical formula}UVaru(tu,cu+), and {a mathematical formula}Chosenu(cu+), for each {a mathematical formula}u∈u.Let policy
       </list>
       <paragraph>
        p be the CQ over free variables {a mathematical formula}xs for {a mathematical formula}s∈s, and existential variables {a mathematical formula}xγ for γ in Ψ, {a mathematical formula}xw for {a mathematical formula}w∈u∪v and {a mathematical formula}yu for {a mathematical formula}u∈u, with the following atoms:{a mathematical formula}Next we define the global schema. It has “mirror” binary relational names {a mathematical formula}Argj′ for {a mathematical formula}j=1,2,3 and “mirror” unary relational names {a mathematical formula}Clγ′ for each γ in Ψ and {a mathematical formula}Chosenu′ for each {a mathematical formula}u∈u. Besides these, the global schema contains unary relational names {a mathematical formula}UVaru′ and {a mathematical formula}Choiceu for each {a mathematical formula}u∈u.Finally, let {a mathematical formula}M consist of mappings{a mathematical formula}Next we give an intuition for the reduction, assuming for simplicity that s is empty—that is, p is Boolean. Source instance {a mathematical formula}D encodes all the satisfying assignments of all the clauses. In particular, it has a constant {a mathematical formula}aγπ for each assignment π of variables of each clause γ, as well as constants {a mathematical formula}fw and {a mathematical formula}tw for true and false values of each propositional variable w (no matter whether it is universally or existentially quantified). Each universally quantified variable u is additionally associated with two constants {a mathematical formula}cu− and {a mathematical formula}cu+. Each constant {a mathematical formula}aγπ is connected to the corresponding values of its variables by means of binary relational names {a mathematical formula}Argj. Both constants {a mathematical formula}fu and {a mathematical formula}tu for the values of each universally quantified variable u are additionally connected to both of the corresponding constants {a mathematical formula}cu− and {a mathematical formula}cu+ by relational name {a mathematical formula}UVaru. Mappings {a mathematical formula}M copy all the source instance, except {a mathematical formula}UVaru, which is exported only by means of projections {a mathematical formula}UVaru′ and {a mathematical formula}Choiceu to the first and the second argument, respectively. Therefore, all the source instances indistinguishable from {a mathematical formula}D differ from {a mathematical formula}D only in {a mathematical formula}UVaru: the attacker knows that each of {a mathematical formula}fu and {a mathematical formula}tu, for all universally quantified u, is connected by {a mathematical formula}UVaru to at least one of {a mathematical formula}cu− and {a mathematical formula}cu+, and, conversely, each of {a mathematical formula}cu− and {a mathematical formula}cu+ is connected to at least one of {a mathematical formula}fu and {a mathematical formula}tu. In other words, these indistinguishable source instances represent all possible assignments of universally quantified variables by means of the value constants connected to corresponding {a mathematical formula}cu+ (the source instances with both value constants of some u connected to {a mathematical formula}cu+ may be seen as representing several assignments). The task of the attacker is to check that the policy query p holds in all these source instances, which correspond to all possible assignments of u. A homomorphism from p to any source instance sends each clause variable {a mathematical formula}xγ to one of its assignment variables {a mathematical formula}aγπ, while each {a mathematical formula}xw to one of its value constants {a mathematical formula}fw and {a mathematical formula}tw. If w is existential then the choice is free. However, if w is universal, then {a mathematical formula}xw must be sent to the value constant that is connected to {a mathematical formula}cw+, because only {a mathematical formula}cw+ is in {a mathematical formula}Chosenw as required by p. Therefore, such a homomorphism exists if and only if for all assignments to u (i.e., for all indistinguishable source instances) there exists an assignment to v that satisfies all the clauses of Ψ.Next, we formally show the correctness of our reduction. For the forward direction, suppose first that Φ holds—that is, there exists an assignment of s such that for any assignment of u there is an assignment of v such that Ψ evaluates to true. We need to show that {an inline-figure} does not hold—that is, there exists a tuple of constants a of the same size as s such that for each source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D there is a homomorphism from {a mathematical formula}p(a) to {a mathematical formula}D′. We first construct a, and do it according to the assignment σ of s in the straightforward way: if {a mathematical formula}σ(s)=false for some s in s then the corresponding a in a is {a mathematical formula}fs, and if {a mathematical formula}σ(s)=true then a is {a mathematical formula}ts. Consider now any {a mathematical formula}D′ indistinguishable from {a mathematical formula}D. By construction, for each {a mathematical formula}u∈u at least one of {a mathematical formula}UVaru(fu,cu+) and {a mathematical formula}UVaru(tu,cu+) is in {a mathematical formula}D′. Extend the assignment σ to u in such a way that, for every u, {a mathematical formula}σ(u)=false if {a mathematical formula}UVaru(fu,cu+) is in {a mathematical formula}D′ and {a mathematical formula}σ(u)=true otherwise. Since Φ holds, σ can be extended to v such that Ψ evaluates to true under the overall σ. Taking such an extension, let, for every {a mathematical formula}w∈u∪v, {a mathematical formula}dw be {a mathematical formula}fw if {a mathematical formula}σ(w)=false and {a mathematical formula}tw otherwise. Consider now the mapping h of variables of {a mathematical formula}p(a) to constants of {a mathematical formula}D′ such that
       </paragraph>
       <list>
        <list-item label="1.">
         {a mathematical formula}h(xγ)=aγπ, for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3, where π is the assignment mapping w of each {a mathematical formula}ℓj to {a mathematical formula}σ(w);
        </list-item>
        <list-item label="2.">
         {a mathematical formula}h(xw)=dw, for each {a mathematical formula}w∈u∪v; and
        </list-item>
        <list-item label="3.">
         {a mathematical formula}h(yu)=cu+, for each {a mathematical formula}u∈u.
        </list-item>
       </list>
       <paragraph>
        By construction, h is a homomorphism from {a mathematical formula}p(a) to {a mathematical formula}D′.Suppose now that {an inline-figure} does not hold—that is, there exists a tuple a of constants of the same size as s such that for each source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D there is a homomorphism from {a mathematical formula}p(a) to {a mathematical formula}D′. We need to show that Φ is true —that is, there exists an assignment of s such that for any assignment of u there exists an assignment of v such that Ψ evaluates to true under the overall assignment. By construction, the existence of a homomorphism implies that each constant a in a is either {a mathematical formula}fs or {a mathematical formula}ts for the corresponding variable s in s. Let σ be the assignment of s such that {a mathematical formula}σ(s)=false if the corresponding a is {a mathematical formula}fs, and {a mathematical formula}σ(s)=true otherwise. Consider any extension of the assignment σ to variables u. By construction, there is an indistinguishable {a mathematical formula}D′ such that, for any {a mathematical formula}u∈u, {a mathematical formula}UVaru(fu,cu+) is in {a mathematical formula}D′ and {a mathematical formula}UVaru(tu,cu+) is not if {a mathematical formula}σ(u)=false and vice versa otherwise. Consider a homomorphism h from {a mathematical formula}p(a) to {a mathematical formula}D′. Again by construction, it agrees with σ in the sense that, for every u, {a mathematical formula}h(xu)=fu if {a mathematical formula}σ(u)=false and {a mathematical formula}h(xu)=tu otherwise. Extend σ to v in the same way: let, for each {a mathematical formula}v∈v, {a mathematical formula}σ(v)=false if {a mathematical formula}h(xv)=fv and {a mathematical formula}σ(v)=true otherwise. By construction, σ is an assignment satisfying Ψ, as required.For Case (2), note that we can reuse the reduction for Case (1) when s is empty and p is Boolean. In fact, the intuition for the construction above is given for this simplified setting.As already mentioned, unlike other proofs in this section, these reductions do not apply as is to {an inline-figure}. The problem is that, for some tuples of constants a, {a mathematical formula}p(a) does not hold in the constructed {a mathematical formula}D. This may happen even in Case (2)—that is, when p is Boolean—because we cannot guarantee that Ψ is satisfiable. It is harmless for {an inline-figure}, because we just look for an indistinguishable source instance in which {a mathematical formula}p(a) holds, regardless of the fact whether it holds in {a mathematical formula}D or not. But for {an inline-figure}, in case of {a mathematical formula}D⊭p(a), we need to find an indistinguishable instance in which {a mathematical formula}p(a) does hold, which may be problematic for the reduction: any attempt to satisfy {a mathematical formula}p(a) in a source instance may make it distinguishable due to fact that {a mathematical formula}M exports everything for almost all the relational names in p.Therefore, we modify the reduction as follows. First, we increase the arity of all relational names in the source schema by one—that is, unary names, such as {a mathematical formula}Clγ, become binary and binary names, such as {a mathematical formula}Argj, become ternary (however, the target relational names stay intact). Second, the source instance {a mathematical formula}D just repeats the first argument twice in each fact, for example, {a mathematical formula}UVaru(fu,cu−) becomes {a mathematical formula}UVaru(fu,fu,cu−). Third, the mappings {a mathematical formula}M are modified in the similar way, by repeating the first variable in the body atom twice; for example, we obtain the mapping {a mathematical formula}Argj(x,x,y)→Argj′(x,y). Finally, policy p does not repeat the variables; instead, it uses a fresh existentially quantified variable as the second argument of each atom; for example, it has an atom {a mathematical formula}UVaru(xu,z,yu) instead of {a mathematical formula}UVaru(xu,yu), where z does not appear anywhere else in the body of p.The resulting reduction still works for {an inline-figure}, with the same justification. However, now we can easily find an indistinguishable instance in which {a mathematical formula}p(a) holds for any tuple a such that {a mathematical formula}D⊭p(a). For example, {a mathematical formula}D∪Dp(a) would serve the need, where {a mathematical formula}Dp(a) is the set of all facts obtained from atoms of {a mathematical formula}p(a) be replacing each existential variable by a fresh constant. Indeed, {a mathematical formula}D∪Dp(a) is indistinguishable from {a mathematical formula}D because the facts in {a mathematical formula}Dp(a) are not exported by {a mathematical formula}M since they have different first two arguments. Moreover, {a mathematical formula}D∪Dp(a)⊨p(a) by construction. □
       </paragraph>
      </paragraph>
      <paragraph>
       We now focus on another {a mathematical formula}Σ2p lower bound for (strong) compliance, which is incomparable to the one of Case (2) of Theorem 25: instead of requiring mappings to be LAV it requires the policy to be a fact (i.e., ground).
      </paragraph>
      <paragraph label="Theorem 26">
       The problems{an inline-figure}and{an inline-figure}are{a mathematical formula}Σ2p-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language containing all sets of CQ views of source and global arities bounded by 2, and p ranges over a policy language containing all facts.
      </paragraph>
      <paragraph>
       Recall again that the bound on the global arity in this setting implies the same bound on the frontier. As already mentioned, this theorem provides a matching lower bound for Case (3) of Theorem 19 and Case (2) of Theorem 21; this bound is incomparable with the bound in Case (2) of Theorem 25. By Theorem 21, Theorem 22, these bounds cannot be improved along the dimensions considered in this paper; for example, if we join the requirements for these two {a mathematical formula}Σ2p lower bounds, then the problems are in {an inline-figure} by Case (b) of Theorem 22.
      </paragraph>
      <paragraph label="Proof">
       We show {a mathematical formula}Π2p-hardness of the complement of {an inline-figure} by reduction of the {an inline-figure} problem. Our proof applies verbatim to {an inline-figure} since our reduction always constructs an instance of compliance where {a mathematical formula}D⊨p.Let {a mathematical formula}Φ=∀u.∃v.Ψ, where u and v are tuples of distinct propositional variables, and Ψ is a conjunction of clauses of the form {a mathematical formula}ℓ1∨ℓ2∨ℓ3 for {a mathematical formula}ℓj either a variable from {a mathematical formula}u∪v or the negation of such a variable. We need to construct a set of CQ views {a mathematical formula}M of source and global arities bounded by 2, a source instance {a mathematical formula}D, and a fact p such that {an inline-figure} if and only if Φ is true.Similarly to the {a mathematical formula}Π2p-hardness proof of Theorem 14, the source schema has a unary relational name {a mathematical formula}Clγ for each clause γ in Ψ as well as binary relational names {a mathematical formula}Argj for {a mathematical formula}j=1,2,3, while source instance {a mathematical formula}D uses a constant {a mathematical formula}aγπ for each satisfying assignment π of variables of each clause γ in Ψ and constants {a mathematical formula}fw and {a mathematical formula}tw for each variable w in {a mathematical formula}u∪v (recall that there are at most 7 satisfying assignments for each clause). Besides this, the source schema has unary relational names {a mathematical formula}Choice, {a mathematical formula}Trigger, {a mathematical formula}Check, as well as {a mathematical formula}Valueu for each {a mathematical formula}u∈u and {a mathematical formula}Assignedw for each {a mathematical formula}w∈u∪v. The source instance also uses two constants d and e.Next we define the source instance {a mathematical formula}D. Let it consist of the following facts:
       <list>
        {a mathematical formula}Clγ(aγπ), {a mathematical formula}Arg1(aγπ,b1), {a mathematical formula}Arg2(aγπ,b2), and {a mathematical formula}Arg3(aγπ,b3), for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ and satisfying assignment π of γ, where {a mathematical formula}bj=fw if {a mathematical formula}π(w)=false and {a mathematical formula}bj=tw if {a mathematical formula}π(w)=true with w the variable of {a mathematical formula}ℓj,{a mathematical formula}Valueu(fu) and {a mathematical formula}Valueu(tu), for each {a mathematical formula}u∈u,{a mathematical formula}Assignedw(fw) and {a mathematical formula}Assignedw(tw), for each {a mathematical formula}w∈u∪v,{a mathematical formula}Choice(d), {a mathematical formula}Trigger(d), {a mathematical formula}Choice(e), and {a mathematical formula}Check(e).Next we define the global schema. It has “mirror” binary relational names
       </list>
       <paragraph>
        {a mathematical formula}Argj′ for {a mathematical formula}j=1,2,3, and “mirror” unary relational names {a mathematical formula}Choice′, {a mathematical formula}Check′, as well as {a mathematical formula}Clγ′ for each γ in Ψ, {a mathematical formula}Valueu′ for each {a mathematical formula}u∈u and {a mathematical formula}Assignedv′ for each {a mathematical formula}v∈v. In addition to these, the global schema contains nullary {a mathematical formula}Trigger′, {a mathematical formula}HasAssignment, and {a mathematical formula}Assignedu′ for each {a mathematical formula}u∈u.Let {a mathematical formula}M consist of the following mappings:{a mathematical formula} and the mapping{a mathematical formula} where ξ is the conjunction of the following atoms, for each clause {a mathematical formula}γ=ℓ1∨ℓ2∨ℓ3 in Ψ:{a mathematical formula}We now show correctness of the construction, namely that {an inline-figure} if and only if Φ is true. First observe that, by knowing the virtual image of {a mathematical formula}D and {a mathematical formula}M, attackers know all of {a mathematical formula}D except atoms over {a mathematical formula}Assignedu and {a mathematical formula}Trigger; instead, they know that at least one of {a mathematical formula}Trigger(d) and {a mathematical formula}Trigger(e), and, for each {a mathematical formula}u∈u, at least one of {a mathematical formula}Assignedu(fu) and {a mathematical formula}Assignedu(tu) hold. Furthermore, if {a mathematical formula}Trigger(e) holds in some source instance {a mathematical formula}D′, then the shape of the last mapping in {a mathematical formula}M ensures that {a mathematical formula}HasAssignment() is exported only if {a mathematical formula}D′ contains either {a mathematical formula}Assignedu(fu) or {a mathematical formula}Assignedu(tu) for every {a mathematical formula}u∈u. Since {a mathematical formula}HasAssignment() is not in the image of {a mathematical formula}D, the shape of ξ also ensures that the following properties hold:
       </paragraph>
       <list>
        <list-item label="–">
         if Φ is true and a source instance {a mathematical formula}D′ without {a mathematical formula}Trigger(d) is indistinguishable from {a mathematical formula}D, then {a mathematical formula}D′⊨ξ,
        </list-item>
        <list-item label="–">
         if Φ is false then there exists an indistinguishable {a mathematical formula}D′ without {a mathematical formula}Trigger(d) such that {a mathematical formula}D′⊭ξ.
        </list-item>
       </list>
       <paragraph>
        With this in mind, let us assume that {an inline-figure}. This implies that every {a mathematical formula}D′ indistinguishable from {a mathematical formula}D satisfies {a mathematical formula}Trigger(d)—that is, the policy. Let us assume for the sake of contradiction that Φ is false; by the properties above we have that there exists a source instance {a mathematical formula}D′ indistinguishable from {a mathematical formula}D such that {a mathematical formula}D′⊭ξ; but then, we additionally have the freedom to require that {a mathematical formula}Trigger(e)∈D′ but {a mathematical formula}Trigger(d)∉D′ without breaking indistinguishability. Such a {a mathematical formula}D′ is hence a witness to compliance, which yields a contradiction to our assumption that {an inline-figure}.For the converse, assume that Φ is true. By the properties above we have that {a mathematical formula}D′⊨ξ for every {a mathematical formula}D′ indistinguishable from {a mathematical formula}D. But then, we must require, on the one hand, that {a mathematical formula}Trigger(e)∉D′ (otherwise the image of {a mathematical formula}D′ would contain {a mathematical formula}HasAssignment() thus breaking indistinguishability) and, on the other hand, that {a mathematical formula}Trigger(d)∈D′ (in order to ensure that the image of {a mathematical formula}D′ contains {a mathematical formula}Trigger′()). As a result, every {a mathematical formula}D′ indistinguishable from {a mathematical formula}D must include the policy and hence {an inline-figure}, as required. □
       </paragraph>
      </paragraph>
      <paragraph>
       Case (3) of Theorem 21 gives us an {an inline-figure} upper bound for compliance and strong compliance when the mappings are LAV and the policy is ground. In Proposition 23 we have already obtained a matching lower bound, even in the case when additionally the ontology is empty and the source and global arities (and, hence, the frontier) are bounded. We next prove an incomparable matching lower bound, for the case when instead of the bound on the source arity we restrict the mappings to be sets of CQ views (note that the global arity and hence the frontier can still be bounded).
      </paragraph>
      <paragraph>
       We make use of the following variation of the satisfiability problem: let {an inline-figure} take as input a propositional formula Ψ in CNF such that the assignment of all its variables to true is satisfying, and returns true if and only if there is a satisfying assignment of Ψ mapping at least one variable to false.
      </paragraph>
      <paragraph label="Proof">
       The problem{an inline-figure}is{an inline-figure}-complete.Membership in {an inline-figure} is immediate, and hardness is justified by a simple reduction of the standard {an inline-figure} problem. Specifically, given a propositional formula Φ in CNF, the reduction distinguishes the following two cases. First, if the assignment of all variables of Φ to true is satisfying, then {a mathematical formula}Ψ=u1∨u2 for fresh propositional variables {a mathematical formula}u1 and {a mathematical formula}u2. Otherwise, Ψ is the CNF of the formula {a mathematical formula}(v1∧…∧vn)∨Φ, where {a mathematical formula}v1,…,vn are all the variables of Φ. Note that conversion to CNF increases the size of the formula at most quadratically. It is immediate to check that {an inline-figure} if and only if {an inline-figure}. □
      </paragraph>
      <paragraph label="Theorem 28">
       The problems{an inline-figure}and{an inline-figure}are{an inline-figure}-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language containing all sets of mappings that are CQ views, LAV and of global arity bounded by 2, and p ranges over a policy language containing all facts.
      </paragraph>
      <paragraph>
       Recall that in this setting the bound on the global arity implies the same bound on the frontier. This theorem provides a matching lower bound for Case (3) of Theorem 21, which is incomparable to the bound from Case (a) of Proposition 23. By Theorem 22, these bounds cannot be improved along the dimensions considered in this paper; for example, if we join the requirements for the two lower bounds, then the problems are in {an inline-figure} by Case (b) of Theorem 22.
      </paragraph>
      <paragraph label="Proof">
       The proof for {an inline-figure} is by reduction of the {an inline-figure} problem, which is {an inline-figure}-hard by Lemma 27. As usual, the source instance in the reduction satisfies the policy, so the same reduction works also for {an inline-figure}. Let Ψ be a propositional formula in CNF over variables {a mathematical formula}v1,…,vn such that the assignment of all its variables to true is satisfying.The source schema in the reduction consists of a single relational name {a mathematical formula}Assignment of arity {a mathematical formula}n+4. Then, let {a mathematical formula}D consist of the following facts over constants 0 and 1:{a mathematical formula} Also, let policy p be fact α.The global schema consists of a binary relational name {a mathematical formula}Header, unary relational names {a mathematical formula}Zero, {a mathematical formula}One, and {a mathematical formula}Valuei for each {a mathematical formula}i=1,…,n, and nullary relational names {a mathematical formula}Falsifiedγ for each clause γ in Ψ. Then, let {a mathematical formula}M contain mappings{a mathematical formula} the mappings{a mathematical formula} and, assuming without loss of generality that the bodies of mappings can have equalities of variables as conjuncts, the mapping{a mathematical formula} for each clause γ in Ψ over variables {a mathematical formula}v1,…,vk among {a mathematical formula}v1,…,vn, where, for each {a mathematical formula}i=1,…,k, {a mathematical formula}ti=yzero if {a mathematical formula}π(viγ)=false and {a mathematical formula}ti=yone if {a mathematical formula}π(viγ)=true for the only assignment π of {a mathematical formula}v1,…,vk falsifying γ.Intuitively, the third position of {a mathematical formula}Assignment stores the value 0 and the fourth stores the value 1 (these positions are included in the relation just to avoid the use of constants in the mappings). A tuple in {a mathematical formula}Assignment in which the first two “header” elements are equal represents an assignment, given by the final n positions. Call such an assignment {a mathematical formula}Assignment-generated. In {a mathematical formula}D the only {a mathematical formula}Assignment-generated assignment sends all variables to true, which is assumed to be a satisfying. The last set of mappings then guarantee that in an indistinguishable instance all {a mathematical formula}Assignment-generated assignments must be satisfying. The policy guarantees that we are interested in indistinguishable instances where we do not have an {a mathematical formula}Assignment-generated assignment that has all variables set to true.We claim that {a mathematical formula}NonTotalSAT(Ψ) is true if and only if {an inline-figure} is true. Indeed, consider first the virtual image {a mathematical formula}VM,D available to the attacker:{a mathematical formula} In particular, {a mathematical formula}VM,D does not contain any of {a mathematical formula}Falsifiedγ() facts, since, by assumption, fact α represents a satisfying assignment, while fact β has distinct values at first two positions and, hence, does not trigger any of the corresponding mappings.In other words, the attacker knows that
      </paragraph>
      <list>
       <list-item label="1.">
        there are at least two {a mathematical formula}Assignment facts in the source, one with {a mathematical formula}1,1 at the first two positions, and another with {a mathematical formula}0,1;
       </list-item>
       <list-item label="2.">
        all facts have 0 at the third position and 1 at the fourth;
       </list-item>
       <list-item label="3.">
        all facts have either 0 or 1 at every position {a mathematical formula}i=5,…,n+4; moreover, for each position and each constant 0 and 1 there is a fact with the constant at the position; and
       </list-item>
       <list-item label="4.">
        the facts with {a mathematical formula}1,1 at the first two positions encode satisfying assignments by values at positions {a mathematical formula}5,…,n+4.
       </list-item>
      </list>
      <paragraph>
       Theorem 24, Theorem 25, Theorem 26, Theorem 28, together with Proposition 23, complete the picture for combined complexity of compliance and strong compliance along all the dimensions considered in this paper. In what follows we do the same for data complexity, where the ontology {a mathematical formula}O, mappings {a mathematical formula}M and policy p are considered fixed and only the source instance {a mathematical formula}D forms the input.
      </paragraph>
      <paragraph>
       From Theorem 19, Theorem 22, we know that both problems inherit the upper bound for data complexity of CQ (or fact) entailment for the ontology language if this complexity includes {an inline-figure} or if the mappings are LAV (or both GAV and LAV, respectively) while the policy is ground. In particular, for the empty ontology, the problems are in {an inline-figure} in general and in {an inline-figure} if the mappings are LAV while the policy is ground. Next we prove two more incomparable matching lower bounds for the general {an inline-figure} upper bound of Case (4) of Theorem 19, one when the mappings are CQ views and LAV, but the policy is arbitrary, and one when the mappings are arbitrary CQ views, but the policy is ground.
      </paragraph>
      <paragraph label="Theorem 29">
       In data complexity, the problems{an inline-figure}and{an inline-figure}are{an inline-figure}-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language{a mathematical formula}M, and p ranges over a policy language{a mathematical formula}Psuch that either
      </paragraph>
      <list>
       <list-item>
        {a mathematical formula}Mcontains all sets of CQ views and{a mathematical formula}Pcontains all facts, or
       </list-item>
       <list-item>
        {a mathematical formula}Mcontains all sets of mappings that are CQ views and LAV, and{a mathematical formula}Pcontains all Boolean policies.
       </list-item>
      </list>
      <paragraph>
       Note that source arity, global arity, and frontier are implicit bounded when studying data complexity. As already mentioned, this theorem provides a matching lower bound for Case (4) of Theorem 19.
      </paragraph>
      <paragraph label="Proof">
       In both cases, the policy constructed in the reduction holds in the source instance, so the proof works for both compliance and strong compliance. As usual, we concentrate on the first.In Case (a) we reduce {an inline-figure} problem, which is {an inline-figure}-complete by Lemma 27. In particular, we give a set of CQ views {a mathematical formula}M and a fact {a mathematical formula}αp such that for any propositional formula Ψ in CNF such that the assignment of all its variables to true is satisfying we can construct, in polynomial time, a source instance {a mathematical formula}D such that {an inline-figure} is true if and only if NonTotalSat(Ψ) is true.Let the source schema consist of binary relational names {a mathematical formula}Arg, {a mathematical formula}Value, and {a mathematical formula}Assigned, as well as unary relational names {a mathematical formula}Zero, {a mathematical formula}One, and {a mathematical formula}SZero. Then, let the global schema consist of “mirror” binary relational names {a mathematical formula}Arg′ and {a mathematical formula}Value′, unary relational names {a mathematical formula}Zero′, {a mathematical formula}One′, {a mathematical formula}HasAssigned, {a mathematical formula}Valid, {a mathematical formula}SZero′ and {a mathematical formula}SOne′, and nullary relational names {a mathematical formula}Clash and {a mathematical formula}Secret.We now construct the CQ views and the policy. In particular, let {a mathematical formula}M be the (non-LAV) CQ view mappings{a mathematical formula} and let {a mathematical formula}αp be the fact {a mathematical formula}SZero(s), for a constant s.Consider now a propositional formula Ψ in CNF over variables v such that the assignment of all its variables to true is satisfying. Based on this, let {a mathematical formula}D consist of the following atoms, over constants {a mathematical formula}aγ for each clause γ in Ψ, {a mathematical formula}fv and {a mathematical formula}tv for each {a mathematical formula}v∈v, as well as a and s (where s is already used in the policy):{a mathematical formula}We claim that {an inline-figure} is true if and only if {an inline-figure} is true. Informally, the conjunction of {a mathematical formula}Assigned and {a mathematical formula}Value represents a desired truth assignment. Consider the virtual image {a mathematical formula}VM,D available to the attacker. A major difference from {a mathematical formula}D is that {a mathematical formula}Assigned is projected to the first argument and {a mathematical formula}SZero is exported for all {a mathematical formula}fv, but not for s (plus, {a mathematical formula}Valid(aγ) for all γ and {a mathematical formula}Secret are exported). Therefore, the attacker knows that
       <list>
        all variables are assigned to false or true (by means of the mapping with {a mathematical formula}HasAssigned head),no variables are assigned to both, because {a mathematical formula}Clash() is not exported (note that, in {a mathematical formula}D, {a mathematical formula}Value associates both true and false to a variable, but {a mathematical formula}Assigned only true),the assignment is satisfying, because all {a mathematical formula}Valid(aγ) are exported,either one of the variables are assigned to false, or the policy holds, because {a mathematical formula}Secret() is exported.Formally, assume first that
       </list>
       <paragraph>
        {an inline-figure}. We need to show that {an inline-figure}. Let {a mathematical formula}D′ be an indistinguishable source instance without the policy fact {a mathematical formula}SZero(s). By the observation above, the constant corresponding to every propositional variable is related by {a mathematical formula}Assigned and {a mathematical formula}Value to either a constant satisfying {a mathematical formula}Zero or a constant satisfying {a mathematical formula}One, but not both. Thus we can define a truth assignment to variables accordingly. Also by the observation, this assignment is satisfying. We now claim that there exists v such that {a mathematical formula}Assigned(av,fv) holds—that is, the assignment has a variable assigned to false. Indeed, {a mathematical formula}Secret() is exported, so {a mathematical formula}Value(z,y)∧Assigned(z,y)∧SZero(y) should hold for some z and y. Since there is a mapping exporting {a mathematical formula}Value by its own, {a mathematical formula}(z,y) can be only either {a mathematical formula}(a,s) or one of {a mathematical formula}(av,fv) and {a mathematical formula}(av,tv) for some {a mathematical formula}v∈v. The first is not possible because policy {a mathematical formula}SZero(s) does not hold in {a mathematical formula}D′. None of {a mathematical formula}(av,tv) is possible, because otherwise we would have {a mathematical formula}SOne′(y) exported. So, the only possibility is that {a mathematical formula}Value(av,fv)∧Assigned(av,fv)∧SZero(fv) holds for some v. Also, {a mathematical formula}Assigned(av,tv) cannot hold for this v, because otherwise we would export {a mathematical formula}Clash(). Thus, v is assigned to false in the assignment, as required.For the converse direction, let {an inline-figure}. We need to show that {an inline-figure}. Consider an assignment σ to v satisfying Ψ with at least one v in v such that {a mathematical formula}σ(v)=false. Let {a mathematical formula}D′ be the source instance that agrees with {a mathematical formula}D on {a mathematical formula}Arg, {a mathematical formula}Zero, {a mathematical formula}One and {a mathematical formula}Value, as well as contains the following atoms:{a mathematical formula} It is immediate to check that source instance {a mathematical formula}D′ is indistinguishable and does not contain the policy fact, as required.In Case (b), we reduce the 3-Colourability problem, whose input is a (directed) graph G and 3-Colourability(G) is true if and only if G is 3-colourable. In particular, we give a set of mappings {a mathematical formula}M that are both CQ views and LAV, and a Boolean policy p such that for any directed graph G we can construct, in polynomial time, a source instance {a mathematical formula}D such that {an inline-figure} is true if and only if 3-Colourability(G) is true. The reduction is analogous to that in Lemma 3.8 in [54] for the problem of instance-based determinacy (see Section 8 for a discussion on the connection between this problem and policy compliance).Let the source schema consist of two binary relational names {a mathematical formula}Edge and {a mathematical formula}Colour, and the global schema consists of a “mirror” binary relational name {a mathematical formula}Edge′ and “projection” unary relational names {a mathematical formula}Node and {a mathematical formula}Colour′. Let then the set of CQ views {a mathematical formula}M has mappings{a mathematical formula} and the policy p be the Boolean CQ{a mathematical formula}Consider an instance of 3-colourability consisting of a graph {a mathematical formula}G=(V,E) with vertices V and edges E. Without loss of generality we assume that it has at least one edge. Then, the source instance {a mathematical formula}D uses constants r, g, b, and {a mathematical formula}av for each {a mathematical formula}v∈V, and consists of facts{a mathematical formula} It is immediate to see that G is 3-colourable if and only if {an inline-figure}. □
       </paragraph>
      </paragraph>
     </section>
    </section>
    <section label="7">
     <section-title>
      Data-independent compliance
     </section-title>
     <paragraph>
      We now turn our attention to our data-independent notions of compliance defined in Section 3.4, which require that all possible source instances (strongly) comply to the policy. This is a very desirable property for (the schema of) a data integration system to satisfy: it ensures that the policy is not revealed to a malicious attacker, regardless of the underlying source instance (and hence regardless of any updates in the source instances). Recall that in the data-independent case we consider only ComplyAll leaving StrComplyAll for future work. We also concentrate on constant-free ontologies and mappings, as well as policies that are Boolean CQs and also constant-free.
     </paragraph>
     <paragraph>
      Unfortunately, we show in Section 7.1 that the data-independent compliance problem is undecidable under rather strong restrictions on the input. Then, in Section 7.2 we identify a decidable case and also a tractable restriction thereof.
     </paragraph>
     <section label="7.1">
      <section-title>
       Undecidability
      </section-title>
      <paragraph>
       In this section, we show that {an inline-figure} is undecidable, even for empty ontology, GAV mappings, and bounded arity of the global schema. As an immediate corollary, we obtain that the data-independent compliance problems are undecidable even for CQ views in the presence of ontologies that can enforce equivalence of global relations. Note that full TGDs, linear TGDs, and DL-LiteR satisfy this condition.
      </paragraph>
      <paragraph>
       The proof is via an involved reduction of the well-known domino tiling problem [9], which we elaborate in the remainder of this section. Our reduction exploits a variant of the “challenge method” by Benedikt et al. [7], where special “challenge” relational names are introduced in the mappings and policy to ensure confluence and hence close the grid.
      </paragraph>
      <paragraph label="Theorem 30">
       Problem{an inline-figure}is undecidable if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language containing all mappings that are constant-free, GAV and of source and global arities bounded by 2, and p ranges over a policy language containing all constant-free and Boolean policies.
      </paragraph>
      <paragraph>
       Recall that in this setting the bound on the global arity implies the same bound on the frontier.
      </paragraph>
      <paragraph label="Proof">
       First, we give a reduction of the undecidable problem of tiling an infinite grid to the complement of data-independent compliance problem assuming that p may be a Boolean UCQ and source instances are allowed to be infinite; later on, we discuss how to adapt the proof to dispense with the additional assumptions.Similarly to the NExpTime-complete version of the tiling problem used in the proof of Theorem 24, the undecidable version takes as input a tiling instance {a mathematical formula}(T,RH,RV), with a finite set of tile types {a mathematical formula}T, horizontal compatibility relation {a mathematical formula}RH⊆T×T and vertical compatibility relation {a mathematical formula}RV⊆T×T. The instance has a solution if and only if it is possible to tile the whole positive quarter {a mathematical formula}N×N of the plane according to {a mathematical formula}RH and {a mathematical formula}RV (and not just the {a mathematical formula}2n×2n square, for {a mathematical formula}n=|T|, as in the {an inline-figure} case). Equivalently, it suffices to enforce a structure over unary relational names {a mathematical formula}Tiledt for {a mathematical formula}t∈T, and binary relational names {a mathematical formula}Hor and {a mathematical formula}Ver, such that
       <list>
        any element has outgoing {a mathematical formula}Hor and {a mathematical formula}Ver edges such that traversing a {a mathematical formula}Hor edge and then a {a mathematical formula}Ver edge leads to the same element as traversing first a {a mathematical formula}Ver edge and then a {a mathematical formula}Hor edge;relational names {a mathematical formula}Hor and {a mathematical formula}Ver are functional;each element is assigned with at least one relational name {a mathematical formula}Tiledt; andthe assignment of {a mathematical formula}Tiledt is unique and agrees with {a mathematical formula}RH and {a mathematical formula}RV.Let
       </list>
       <paragraph label="Claim 32">
        {a mathematical formula}(T,RH,RV) be a tiling instance. We show how to construct GAV mappings {a mathematical formula}M with source and global arities bounded by 2, and a Boolean UCQ p over the source schema such that there is a (possibly infinite) source instance {a mathematical formula}D with {an inline-figure} if and only if it is possible to tile an infinite plane with the tiling instance (note that here we abuse notation by extending the range of the second and the third arguments of Comply). Intuitively, the only possibility for any such source instance will be to “represent” the tiling of the plane.We construct mappings {a mathematical formula}M and query p in several steps, proving in parallel the properties of the corresponding components. Query p will in fact be a conjunction of Boolean CQs and UCQs, and its transformation to a single UCQ is standard. To avoid multiple indexes, we will use the same variables in the conjuncts of p. Since we also omit existential quantifiers as usual, the reader should keep in mind that the variables are local for the conjuncts.We first show how to enforce the existence of a “square of successors” for each element. Let the first block {a mathematical formula}M1 of {a mathematical formula}M be{a mathematical formula} where {a mathematical formula}Hor and {a mathematical formula}Ver are source binary relational names responsible for horizontal and vertical successors, respectively, {a mathematical formula}Hor′ and {a mathematical formula}Ver′ are their copies in the global schema, while {a mathematical formula}ConfCh and {a mathematical formula}ConfCh⁎ are special “challenge” relational names. Let the first conjunct of p be defined as follows (recall that all the variables are implicitly existentially quantified):{a mathematical formula}Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p1. Then,{an inline-figure}if and only if for each fact{a mathematical formula}Hor(ax,a)in{a mathematical formula}Dthere are also facts{a mathematical formula}in{a mathematical formula}Dfor some constants{a mathematical formula}ay,{a mathematical formula}az,{a mathematical formula}au,{a mathematical formula}avand{a mathematical formula}aw.We start with the forward direction. Since {a mathematical formula}D⊨p1, we have that {a mathematical formula}M1∪D⊨ConfCh⁎(). On the one hand, all source instances {a mathematical formula}D′ indistinguishable from {a mathematical formula}D differ from {a mathematical formula}D only in the precise element {a mathematical formula}ax such that {a mathematical formula}Hor(ax,a) and {a mathematical formula}ConfCh(ax) (and, possibly, some irrelevant atoms). On the other, since {an inline-figure}, for all indistinguishable {a mathematical formula}D′ it holds that {a mathematical formula}D′⊨p1. Therefore, each element {a mathematical formula}ax with {a mathematical formula}Hor(ax,a) in {a mathematical formula}D′ for some a must also have atoms (12) in {a mathematical formula}D′ as required.We now show the backward direction. Again, since {a mathematical formula}D⊨p1, {a mathematical formula}M1∪D⊨ConfCh⁎(). Thus, each indistinguishable {a mathematical formula}D′ has atoms {a mathematical formula}Hor(ax,a) and {a mathematical formula}ConfCh(ax) for some {a mathematical formula}ax. Since it also contains atoms (12) for {a mathematical formula}ax, we have that {a mathematical formula}D′⊨p1, as required. □Next, we enforce functionality of {a mathematical formula}Hor and {a mathematical formula}Ver, which together with the previous property guarantees that they form a grid-like structure. Let the second block {a mathematical formula}M2 of mappings in {a mathematical formula}M be{a mathematical formula} where {a mathematical formula}HorChi, {a mathematical formula}VerChi, {a mathematical formula}H⁎ and {a mathematical formula}V⁎ are again special “challenge” relational names. Let the second conjunct of p be defined as follows:{a mathematical formula} The intuition is that the “challenge” relational names represent a test of a pair of {a mathematical formula}ax,ay1 and {a mathematical formula}ax,ay2 that are both in the {a mathematical formula}Hor relation or both in the {a mathematical formula}Ver relation. By setting the “challenge” relational names to only these particular {a mathematical formula}ay1 and {a mathematical formula}ay2 we get an indistinguishable instance, and non-compliance would imply that this instance must satisfy the query, which would imply that {a mathematical formula}ay1=ay2.Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p1∧p2. Then,{an inline-figure}if and only if
       </paragraph>
       <list>
        <list-item label="–">
         the condition inClaim 31holds; and
        </list-item>
        <list-item label="–">
         {a mathematical formula}Horand{a mathematical formula}Verare functional in{a mathematical formula}D.
        </list-item>
       </list>
       <paragraph label="Claim 33">
        Suppose {an inline-figure} and one of the conditions above fails. By the previous claim we see that it cannot be the first item. If {a mathematical formula}Hor is not functional then for some {a mathematical formula}ax and distinct {a mathematical formula}ay1, {a mathematical formula}ay2 we have that {a mathematical formula}D contains {a mathematical formula}Hor(ax,ay1) and {a mathematical formula}Hor(ax,ay2). We create {a mathematical formula}D′ by letting {a mathematical formula}HorCh1 hold only of {a mathematical formula}ay1 and {a mathematical formula}HorCh2 hold only of {a mathematical formula}ay2. Thus {a mathematical formula}D′ does not satisfy {a mathematical formula}p2 (and will not satisfy {a mathematical formula}p1 as before). The second item implies that {a mathematical formula}D will have {a mathematical formula}H⁎() in its virtual instance, and the first mapping will imply that {a mathematical formula}D′ will have {a mathematical formula}H⁎() as well. Using this, we can see that {a mathematical formula}D′ and {a mathematical formula}D are indistinguishable, contradicting the hypothesis that {an inline-figure}. The case of {a mathematical formula}Ver is argued similarly.Assume now that the conditions above hold, but {an inline-figure} with a witness {a mathematical formula}D′ indistinguishable from {a mathematical formula}D. Indistinguishability of {a mathematical formula}D′ and {a mathematical formula}D coupled with the fact that {a mathematical formula}D⊨p1∧p2 imply that {a mathematical formula}D′ contains constants {a mathematical formula}ax, {a mathematical formula}ay1, and {a mathematical formula}ay2 with {a mathematical formula}Hor(ax,ay1), {a mathematical formula}Hor(ax,ay2), {a mathematical formula}HorCh1(ay1), and {a mathematical formula}HorCh2(ay2) as well as constants {a mathematical formula}bx, {a mathematical formula}by1, and {a mathematical formula}by2 with {a mathematical formula}Ver(bx,by1), {a mathematical formula}Ver(bx,by2), {a mathematical formula}VerCh1(by1), and {a mathematical formula}VerCh2(by2). Since {a mathematical formula}D′ cannot satisfy {a mathematical formula}p2 we have either {a mathematical formula}ay1≠ay2 or {a mathematical formula}by1≠by2; either of these contradicts the second item of the claim. □The immediate consequence is that a non-compliant possibly infinite {a mathematical formula}D contains a positive quadrant of a plane—that is, there exists a homomorphism from the infinite grid on {a mathematical formula}Hor and {a mathematical formula}Ver with a start point to {a mathematical formula}D (note that the nodes of the grid do not need to be unique—that is, {a mathematical formula}D is not necessarily infinite).The next step is to ensure that each grid node is assigned with a tile type. Let the third block {a mathematical formula}M3 of {a mathematical formula}M consist of the mappings{a mathematical formula} for unary tiling relational names {a mathematical formula}Tiledt in the source schema, their copies {a mathematical formula}Tiledt′ in the global schema, and “challenge” relational names {a mathematical formula}TileCh and {a mathematical formula}TileCh⁎. Let the third conjunct of p be defined as follows:{a mathematical formula}Intuitively, {a mathematical formula}TileCh is a relational name “challenging” that a particular node has some tile type. Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p1∧p2∧p3. Then,{an inline-figure}if and only if
       </paragraph>
       <list>
        <list-item label="–">
         the conditions inClaim 32hold (including the one fromClaim 31); and
        </list-item>
        <list-item label="–">
         for every{a mathematical formula}axsuch that{a mathematical formula}Hor(ax,ay)is in{a mathematical formula}Dfor some{a mathematical formula}aythere is{a mathematical formula}t∈Twith{a mathematical formula}Tiledt(ax)in{a mathematical formula}D.
        </list-item>
       </list>
       <paragraph label="Claim 34">
        Assume {an inline-figure} is false. The first item holds as before. To see the second item, given {a mathematical formula}Hor(ax,ay)∈D we modify {a mathematical formula}D to {a mathematical formula}D′ by letting {a mathematical formula}TileCh hold only on {a mathematical formula}ax. Then {a mathematical formula}D′ is indistinguishable from {a mathematical formula}D, and hence satisfies {a mathematical formula}p3 by assumption on {a mathematical formula}D, which is only possible if {a mathematical formula}Tiledt(ax) holds in {a mathematical formula}D.Assume now that {a mathematical formula}D satisfies the properties in the claim and consider any {a mathematical formula}D′ indistinguishable from {a mathematical formula}D. The fact that {a mathematical formula}D⊨p1∧p2∧p3 implies that {a mathematical formula}TileCh⁎() is exported from {a mathematical formula}D, and hence must be exported from {a mathematical formula}D′ as well. Thus there are {a mathematical formula}ax and {a mathematical formula}ay in {a mathematical formula}D′ satisfying {a mathematical formula}TileCh(ax)∧Hor(ax,ay). Further since in the other mappings {a mathematical formula}Hor is exported, we must have {a mathematical formula}Hor(ax,ay) holding in {a mathematical formula}D as well. By the second item {a mathematical formula}Tiledt(ax) holds in {a mathematical formula}D for some {a mathematical formula}t∈T. Since other mappings export {a mathematical formula}Tiledt, we know that {a mathematical formula}Tiledt(ax) holds in {a mathematical formula}D′, which guarantees that {a mathematical formula}p3 holds in {a mathematical formula}D′ as required. □The final step is to guarantee that no constant is assigned with two different tile types and the assignment is compatibility-preserving. Let the fourth block {a mathematical formula}M4 of {a mathematical formula}M be{a mathematical formula} for “challenge” relational names {a mathematical formula}OverlapCh and {a mathematical formula}OverlapCh⁎, and let the fourth conjunct of p be defined as{a mathematical formula} Finally, let {a mathematical formula}M=M1∪M2∪M3∪M4 and {a mathematical formula}p=p1∧p2∧p3∧p4.Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p. Then,{an inline-figure}if and only if
       </paragraph>
       <list>
        <list-item label="–">
         the conditions inClaim 33hold; and
        </list-item>
        <list-item label="–">
         the assignment of tile types in{a mathematical formula}Dby relational names{a mathematical formula}Tiledtis unique and agrees with compatibility relations{a mathematical formula}RHand{a mathematical formula}RV.
        </list-item>
       </list>
       <paragraph label="Claim 36">
        The following claim establishes that in non-compliant instances each element has the “path gadget” attached to it.Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p1′. Then,{an inline-figure}if and only if for each fact{a mathematical formula}Hor(ax,a)in{a mathematical formula}Dthere are also facts{a mathematical formula}in{a mathematical formula}Dfor some constants{a mathematical formula}ay,{a mathematical formula}az,{a mathematical formula}au,{a mathematical formula}av,{a mathematical formula}aw, as well as{a mathematical formula}axtand{a mathematical formula}axtsfor all{a mathematical formula}t,s∈Tsuch that{a mathematical formula}s≠t.Note that the first set of facts is as in Claim 31.We start with the forward direction. Since {a mathematical formula}D⊨p1′, and {a mathematical formula}M1′ includes {a mathematical formula}M1, the virtual image of {a mathematical formula}D satisfies {a mathematical formula}ConfCh⁎(). All source instances {a mathematical formula}D′ indistinguishable from {a mathematical formula}D differ from {a mathematical formula}D only in the precise element {a mathematical formula}ax such that {a mathematical formula}Hor(ax,a) and {a mathematical formula}ConfCh(ax) (and, possibly, some atoms that will be irrelevant for the remainder of the argument). Since {an inline-figure}, for all indistinguishable {a mathematical formula}D′, we know that {a mathematical formula}D′⊨p1′. Therefore, keeping in mind that {a mathematical formula}p1′ contains all atoms of {a mathematical formula}p1, each element {a mathematical formula}ax with {a mathematical formula}Hor(ax,a) in {a mathematical formula}D′ for some a must also have the required atoms in {a mathematical formula}D′.Next we show the backward direction. Again, since {a mathematical formula}D⊨p1′, {a mathematical formula}M1′∪D⊨ConfCh⁎(). Therefore, each indistinguishable {a mathematical formula}D′ contains atoms {a mathematical formula}Hor(ax,a) and {a mathematical formula}ConfCh(ax) for some {a mathematical formula}ax and a. Since it also contains the required atoms ({a mathematical formula}GadgetConnects atoms and the confluence-related atoms) for this {a mathematical formula}ax, we have that {a mathematical formula}D′⊨p1′, as required. □Next, we use these additions to guarantee that every {a mathematical formula}ax with {a mathematical formula}Hor(ax,a) is indeed assigned with a type. Let {a mathematical formula}M3′ be{a mathematical formula} and let {a mathematical formula}p3′ be the Boolean CQ{a mathematical formula}Let{a mathematical formula}Dbe a possibly infinite source instance such that{a mathematical formula}D⊨p1′∧p2∧p3′. Then,{an inline-figure}if and only if
       </paragraph>
       <list>
        <list-item label="–">
         the condition inClaim 35and the second condition inClaim 32hold; and
        </list-item>
        <list-item label="–">
         for every{a mathematical formula}axsuch that{a mathematical formula}Hor(ax,a)∈Dfor some a there is{a mathematical formula}t∈Twith{a mathematical formula}Tiledt(ax)∈D.
        </list-item>
       </list>
       <paragraph label="Fact 37">
        Recall that infinite source instances are not allowed in the general settings of this paper. Next we explain how to make the proof work for the case when only finite source instances are considered. We start with a definition and a known fact.A solution of a tiling instance {a mathematical formula}(T,RH,RV) is periodic if there exist positive numbers n and m such that the tile types assigned to {a mathematical formula}(i,j), {a mathematical formula}(n+i,j) and {a mathematical formula}(i,m+j) are the same for all {a mathematical formula}i,j∈N. A periodic tiling can be seen as a tiling of a torus, since column {a mathematical formula}n+1 and row {a mathematical formula}m+1 can be “glued” with the left-most column and bottom row, respectively.Let {a mathematical formula}Stiling denote the set of all tiling instances that allow for solutions, and {a mathematical formula}Speriod denote the set of all tiling instances that allow for periodic solutions. Our proof is based on the following fact.[17], [42]Sets {a mathematical formula}Stiling and {a mathematical formula}Speriod are recursively inseparable—that is, there is no recursive set S of tiling instances such that {a mathematical formula}Speriod⊆S⊆Stiling.To use this fact for undecidability of {an inline-figure} over finite source instances, it is enough to show that
       </paragraph>
       <list>
        <list-item label="1.">
         if a tiling instance {a mathematical formula}(T,RH,RV) is in {a mathematical formula}Speriod then {an inline-figure} for {a mathematical formula}M and p based on {a mathematical formula}(T,RH,RV) as in the reduction above;
        </list-item>
        <list-item label="2.">
         if {an inline-figure} for {a mathematical formula}M and p based on a tiling instance {a mathematical formula}(T,RH,RV) as in the reduction above then {a mathematical formula}(T,RH,RV)∈Stiling.
        </list-item>
       </list>
       <paragraph>
        In fact, item 2 follows immediately from the correctness of the reduction for possibly infinite source instances. Item 1 is also straightforward: since the tiling is periodic, the infinite source instance witnessing data-independent compliance in the reduction can be easily transformed to a finite torus-like source instance by appropriately identifying constants in the grid. □
       </paragraph>
      </paragraph>
      <paragraph>
       The proof of Theorem 30 relies on the fact that different mappings may use the same relational names in the head—that is, they are not CQ views. In the next section we will see that this is critical, and for CQ views the problems are decidable (provided the ontology is empty as before). However, the effect of GAV mappings with the same head relational name can be easily simulated by means of full linear TGDs of the form {a mathematical formula}R1(x)→R2(x) for any global relational names {a mathematical formula}R1 and {a mathematical formula}R2 of the same arity.
      </paragraph>
      <paragraph label="Corollary 38">
       Problem{an inline-figure}is undecidable if{a mathematical formula}Oranges over an ontology language containing all sets of full linear TGDs,{a mathematical formula}Mranges over a mapping language containing all sets of mappings that are constant-free, CQ views and of source and global arities bounded by 2, and p ranges over a policy language containing all constant-free Boolean CQs.
      </paragraph>
      <paragraph>
       In the passing, we conjecture that the undecidability results in Theorem 30 and Corollary 38 extend to the setting of {an inline-figure}. However, the current construction is not sufficient, since when no tiling exists, the negation of p may still be revealed. Ideally, one would modify the construction so that the negation of p is never revealed regardless of whether a tiling exists. However, this has proved to be rather challenging technically, and we leave it for future work.
      </paragraph>
     </section>
     <section label="7.2">
      <section-title>
       Decidable cases
      </section-title>
      <paragraph>
       We now complement the picture for data-independent compliance by showing that the problem is decidable when the mappings are restricted to CQ views and there is no ontology.
      </paragraph>
      <paragraph>
       We exploit the critical instance method, which has been used to establish both decidability and undecidability results for a number of reasoning problems [4], [7], [28], [39], [63], [70]. The idea in our setting is to reduce data-independent compliance checking to checking the usual data-dependent notion over a single “canonical” instance. In particular, we show that if there is any non-compliant source instance, then the critical instance for the source relation names mentioned in the mappings is also a witness to non-compliance.
      </paragraph>
      <paragraph label="Definition 39">
       The critical instance{a mathematical formula}CR for a schema (i.e., set of relational names) R is the instance whose domain consists of a single constant ⁎ and whose facts are {a mathematical formula}R(⁎,…,⁎) for all relational names {a mathematical formula}R in R.
      </paragraph>
      <paragraph>
       Note that every Boolean policy over the relevant relations holds on the critical instance for the source schema, and thus it is intuitively the “hardest” instance to get to comply. The key property of the critical instance is established by the following lemma.
      </paragraph>
      <paragraph label="Lemma 40">
       Let{a mathematical formula}Mbe a set of constant-free CQ views with source schemaSand p be a constant-free Boolean policy. Then,{an inline-figure}if and only if{an inline-figure}.
      </paragraph>
      <paragraph label="Proof">
       The proof of the lemma relies on a more general result established in [7], which we formulate next.Let G denote the global schema (without loss of generality, we assume that for each relational name in G there exists a mapping in {a mathematical formula}M with this relational name in the head). Let {a mathematical formula}T be a set of TGDs over both S and G; in particular, {a mathematical formula}T might contain TGDs relating source and global relations, as well as TGDs over source or over global schema only. Given an instance {a mathematical formula}G over G, an instance {a mathematical formula}F over both S and G is a realisation of {a mathematical formula}G if {a mathematical formula}F satisfies {a mathematical formula}T and the restriction of {a mathematical formula}F to G is {a mathematical formula}G. Instance {a mathematical formula}G is realisable for {a mathematical formula}T if it admits a realisation. For a Boolean CQ p over both schemata, {an inline-figure} is true if and only if there is a realisation {a mathematical formula}F satisfying {a mathematical formula}T such that p does not hold in {a mathematical formula}F. Note that {an inline-figure} is vacuously false if {a mathematical formula}G is not realisable. We use {an inline-figure} here to stress that input instances are over the global schema, while the compliance problems we have studied so far admit source instances as input. Let now {an inline-figure} be true if and only if {an inline-figure} is true for every realisable instance {a mathematical formula}G over G.We are now ready to state the result from [7], which establishes that {an inline-figure} can always be reduced to {an inline-figure} over the critical instance for the global schema.[7]For a set {a mathematical formula}T of constant-free TGDs and a constant-free Boolean CQ p over both S and G, {an inline-figure} is true if and only if {an inline-figure} is true.The full proof of this fact can be found in [6, Theorem 10] (note that the result is stated there in terms of the complement of {an inline-figure}).We now discuss how this result can be exploited to show the lemma. Let {a mathematical formula}TM extend {a mathematical formula}M with the inverse mapping{a mathematical formula}R(x)→∃z.ϕ(x,z) for each mapping {a mathematical formula}ϕ(x,z)→R(x) in {a mathematical formula}M. The following claim relates the compliance problems studied in [7] to those in our paper for the particular case where the input mappings are CQ views.For a set of constant-free CQ views{a mathematical formula}M, source instance{a mathematical formula}D, and constant-free Boolean policy p,{an inline-figure}istrueif and only if{an inline-figure}istrue.For the forward direction, suppose {a mathematical formula}D′ witnesses {an inline-figure}—that is, {a mathematical formula}D′ is indistinguishable from {a mathematical formula}D for {a mathematical formula}M and satisfies ¬p. Let {a mathematical formula}F be the union of {a mathematical formula}D and {a mathematical formula}VM,D. Then, {a mathematical formula}F witnesses {an inline-figure}, as required.For the backward direction, assume that an instance {a mathematical formula}F over both S and G witnesses {an inline-figure}—that is, {a mathematical formula}F is a realisation of {a mathematical formula}VM,D that satisfies ¬p. Let {a mathematical formula}D′ be the restriction of {a mathematical formula}F to S. Then, {a mathematical formula}D′ is indistinguishable from {a mathematical formula}D for {a mathematical formula}M. Since p mentions only source relational names, {a mathematical formula}D′⊨¬p. Thus {a mathematical formula}D′ witnesses {an inline-figure}. □We finally argue that Fact 41 and Claim 42 imply the statement in our theorem:{a mathematical formula} Note that at the last step we use the assumption that all relational names in G are mentioned in {a mathematical formula}M. □
      </paragraph>
      <paragraph>
       From Theorem 19 and Lemma 40, we immediately obtain decidability of {an inline-figure} in {a mathematical formula}Σ2p under the assumption that {a mathematical formula}M is a set of constant-free CQ views and p is a constant-free Boolean CQ. This upper bound is, however, not tight since we can exploit the special structure of the critical instance to obtain more favourable complexity. By Lemma 40, in this case {an inline-figure} is equivalent to checking {an inline-figure}, which requires evaluating p over all the source instances indistinguishable from {a mathematical formula}CS for {a mathematical formula}M. Using again an idea from [7], we argue that it suffices to evaluate the policy over a single “universal” indistinguishable source instance, as in the following algorithm for {an inline-figure}:
      </paragraph>
      <list>
       <list-item label="1.">
        set source instance {a mathematical formula}Duniv to ∅;
       </list-item>
       <list-item label="2.">
        for each mapping {a mathematical formula}φ(x,z)→R(x) in {a mathematical formula}M
       </list-item>
       <list-item label="3.">
        while there is a mapping {a mathematical formula}φ(x,z)→R(x) in {a mathematical formula}M and a function h such that {a mathematical formula}Duniv⊨φ(h(x),h(z)) and h maps a variable in x to a constant different from ⁎
       </list-item>
       <list-item label="4.">
        return true if and only if {a mathematical formula}Duniv⊭p.
       </list-item>
      </list>
      <paragraph>
       The following lemma establishes the universality property of {a mathematical formula}Duniv constructed in the algorithm, justifying its correctness.
      </paragraph>
      <paragraph label="Lemma 43">
       Let{a mathematical formula}Mbe a set of constant-free CQ views{a mathematical formula}M, p be a constant-free Boolean policy, and{a mathematical formula}Dunivbe the source instance constructed by the algorithm. For any instance{a mathematical formula}D′indistinguishable from the critical source instance{a mathematical formula}CSfor{a mathematical formula}M, there exists a homomorphism from{a mathematical formula}Dunivto{a mathematical formula}D′.
      </paragraph>
      <paragraph label="Proof">
       First, note that, by construction, {a mathematical formula}Duniv is indistinguishable from {a mathematical formula}CS. Consider now an arbitrary {a mathematical formula}D′ indistinguishable from {a mathematical formula}CS. The source instance {a mathematical formula}Duniv is the fixpoint of a sequence of structures {a mathematical formula}Dunivi, where {a mathematical formula}Duniv0 is {a mathematical formula}Duniv upon completion of the first cycle, and {a mathematical formula}Dunivi+1 is {a mathematical formula}Duniv on a step of the second cycle, formed from {a mathematical formula}Dunivi by identifying constants with ⁎. We show that there is a function h that serves as a homomorphism from each {a mathematical formula}Dunivi into {a mathematical formula}D′. Note that in {a mathematical formula}Duniv0 each constant is either ⁎ or a fresh constant generated to satisfy an inverse mapping {a mathematical formula}R(x)→∃z.φ(x,z), and this mapping should be satisfied by {a mathematical formula}D′ as well. We let h map ⁎ to itself and each fresh constant {a mathematical formula}az generated to witness each {a mathematical formula}z∈z with the corresponding constant witnessing z in {a mathematical formula}D′. Function h is a homomorphism from {a mathematical formula}Duniv0 to {a mathematical formula}Duniv. Next we show, by induction on i, that h is a homomorphism from each {a mathematical formula}Dunivi into {a mathematical formula}D′ as well. In the inductive step, suppose we identify a constant a with ⁎ in going from {a mathematical formula}Dunivi to {a mathematical formula}Dunivi+1. Then we know that {a mathematical formula}h(a)=⁎ in {a mathematical formula}D′. From this and the inductive hypothesis, we can argue that the new facts added in {a mathematical formula}Dunivi+1 are already preserved by h. □
      </paragraph>
      <paragraph label="Theorem 44">
       Problem{an inline-figure}for empty{a mathematical formula}O,{a mathematical formula}Min a mapping language{a mathematical formula}M, and p in a policy language{a mathematical formula}Pis in
      </paragraph>
      <list>
       <list-item>
        {an inline-figure}, if{a mathematical formula}Mconsists of constant-free CQ views and{a mathematical formula}Pconsists of constant-free Boolean policies; and
       </list-item>
       <list-item>
        {an inline-figure}, if the condition of Case (1) holds and{a mathematical formula}Mis also LAV.
       </list-item>
      </list>
      <paragraph label="Proof">
       By Lemma 40, Lemma 43 we conclude that the algorithm correctly decides {an inline-figure}. Note that the construction of {a mathematical formula}Duniv can be equivalently described as a monotone process, by first forming an initial set {a mathematical formula}Duniv0 as in Lemma 43, and then adding at each step new equality facts (corresponding to the equalities described above between freshly introduced constants and the special constant ⁎) and new facts (formed via congruence). The process must reach a fixpoint in polynomially many steps since only linearly many fresh constants are introduced in {a mathematical formula}Duniv0 and in each step at least one such constant is identified with ⁎; we abuse notation by letting {a mathematical formula}Duniv0,…,Dunivn denote this monotone sequence. The initial set of facts {a mathematical formula}Duniv0 can be formed in polynomial time. For {a mathematical formula}Dunivi+1 we can guess the required homomorphisms that support the new equality and verify both that they are homomorphisms and that all new facts in {a mathematical formula}Dunivi+1 are generated from {a mathematical formula}Dunivi using the newly-generated equality and the congruence rules for equality. Since we can also guess a homomorphism from p and verify it, we get the desired {an inline-figure} bound for Case (1).Finally, for Case (2), note that if the mappings are LAV, then {a mathematical formula}Duniv can be constructed in {an inline-figure}. Furthermore, in evaluating p, we can leverage that any joined variable of p can hold in {a mathematical formula}Duniv only on ⁎, and thus after substituting this we need only check the individual atoms separately. □
      </paragraph>
      <paragraph>
       Next we give the matching lower bound to the Case 1 of Theorem 44.
      </paragraph>
      <paragraph label="Proof">
       Problem{an inline-figure}is{an inline-figure}-hard if{a mathematical formula}Ois empty,{a mathematical formula}Mranges over a mapping language containing all sets of constant-free CQ views of source arity bounded by 2 and global arity bounded by 0, and p ranges over a policy language containing all constant-free Boolean CQs.We provide a reduction of graph homomorphism, a canonical {an inline-figure}-hard problem, to the complement of {an inline-figure}. We employ a variation of an argument in [7] to do this. Given directed graphs {a mathematical formula}G1 and {a mathematical formula}G2, let {a mathematical formula}q1 and {a mathematical formula}q2 be the corresponding Boolean CQs over the binary relational name {a mathematical formula}Edge. Let the source schema consist of this relational name and the global schema consist of a nullary relational name {a mathematical formula}Good. Let also {a mathematical formula}M simply state {a mathematical formula}q1→Good() and the policy p be {a mathematical formula}q2. We claim that {a mathematical formula}G2 has a homomorphism to {a mathematical formula}G1 exactly when {an inline-figure} is false.First, suppose there is a non-compliant source instance {a mathematical formula}D. We claim that {a mathematical formula}q1 must hold on {a mathematical formula}D. Indeed, otherwise the empty instance would be indistinguishable from {a mathematical formula}D, and, since the empty instance clearly satisfies ¬p, we obtain a contradiction to the assumption that {a mathematical formula}D is non-compliant. Thus, non-compliance of {a mathematical formula}D implies that every {a mathematical formula}D′ having {a mathematical formula}q1true also has {a mathematical formula}q2true, which is equivalent to a homomorphism from {a mathematical formula}G2 to {a mathematical formula}G1.Conversely, suppose {a mathematical formula}G2 has a homomorphism to {a mathematical formula}G1. Take the source instance representing {a mathematical formula}G1 as {a mathematical formula}D. Then, {a mathematical formula}Good() will hold on its image, and every {a mathematical formula}D′ indistinguishable from {a mathematical formula}D must have a homomorphism from {a mathematical formula}q1 (i.e., {a mathematical formula}G1), and hence from {a mathematical formula}G2. □
      </paragraph>
      <paragraph>
       To conclude this section, we remind that we leave open the questions on decidability and precise complexity of ComplyAll in the settings where the mappings are LAV.
      </paragraph>
     </section>
    </section>
    <section label="8">
     <section-title>
      Implications of our results
     </section-title>
     <paragraph>
      In this section we discuss the implications of our work. We first argue that our results correct certain erroneous complexity bounds claimed in [66]. We then show that our results also close an open problem in the area of data pricing in databases [54].
     </paragraph>
     <section label="8.1">
      <section-title>
       Privacy in GLAV information integration
      </section-title>
      <paragraph>
       Nash and Deutsch [66] considered problems similar to ours in the context of data integration via GLAV mappings. In particular, their key privacy guarantee (Guarantee 2 in [66]) coincides, in the case of Boolean policies, with our notion of strong compliance in Section 3.3 with no ontology. In contrast to our work, however, they did not formulate their complexity results in terms of the size of mappings {a mathematical formula}M, source dataset {a mathematical formula}D, and policy p, but rather in terms of the size of {a mathematical formula}D, p, and rewritings of the heads of mappings, as defined next.
      </paragraph>
      <paragraph label="Definition 46">
       Let {a mathematical formula}M be a set of mappings and q be a CQ over the global schema. A UCQ {a mathematical formula}q′ over the source schema is a rewriting of q over {a mathematical formula}M if, for every source instance {a mathematical formula}D and tuple c of constants, {a mathematical formula}D⊨q′(c) if and only if c is a certain answer to q over the data integration setting {a mathematical formula}(∅,M,D).The decision problem {an inline-figure} is defined exactly as {an inline-figure}, except that there is an additional input that is the rewritings {a mathematical formula}qm over {a mathematical formula}M of the heads of the mappings m in {a mathematical formula}M. Data complexity of problem {an inline-figure} assumes that {a mathematical formula}M, p, and {a mathematical formula}{qm}m∈M are fixed, while only {a mathematical formula}D forms the input.
      </paragraph>
      <paragraph>
       The result on checking Guarantee 2, established in [66, Corollary 3], can then be reformulated using our notation as follows.
      </paragraph>
      <paragraph label="Statement 47">
       [66]Problem {an inline-figure}, for {a mathematical formula}M ranging over all mappings, p ranging over Boolean policies, and rewritings {a mathematical formula}{qm}m∈M of the heads of the mappings in {a mathematical formula}M, is in {an inline-figure}.
      </paragraph>
      <paragraph>
       Note that, if {a mathematical formula}M consists of CQ views, then the rewriting of the head of any mapping in {a mathematical formula}M is just its body. Thus, any lower bound for {an inline-figure}, for {a mathematical formula}M ranging over sets of CQ views, also applies to {an inline-figure}. We can hence obtain the following result as a corollary of our Theorem 19, Theorem 24, which contradicts the {an inline-figure} upper bound in Statement 47 and shows that the problem is much harder.
      </paragraph>
      <paragraph label="Corollary 48">
       Problem{an inline-figure}for{a mathematical formula}Mranging over sets of CQ views, p ranging over Boolean policies, and rewritings{a mathematical formula}{qm}m∈Mof the heads of the mappings in{a mathematical formula}M, is{an inline-figure}-complete.
      </paragraph>
      <paragraph>
       Nash and Deutsch also provided a tractable case in data complexity, where they required {a mathematical formula}M to satisfy the so-called “tagged-union” property (see [66, Theorem 4]). In our notation, their result can be reformulated as follows.
      </paragraph>
      <paragraph label="Statement 49">
       [66]Problem {an inline-figure}, for {a mathematical formula}M ranging over sets of mappings having tagged-unions, p ranging over Boolean policies, and rewritings {a mathematical formula}{qm}m∈M of the heads of the mappings in {a mathematical formula}M, is in {an inline-figure} in data complexity.
      </paragraph>
      <paragraph>
       It is immediate to check that any set of CQ views have tagged-unions. Therefore, Statement 49 is in contradiction with our {an inline-figure}-hardness given in Case (a) of Theorem 29, which applies already if {a mathematical formula}M ranges over sets of mappings that are CQ views and LAV (the matching upper bound follows from Case (4) of Theorem 19).
      </paragraph>
      <paragraph label="Corollary 50">
       Problem{an inline-figure}, for{a mathematical formula}Mranging over sets of mappings having tagged-unions, p ranging over Boolean policies, and rewritings{a mathematical formula}{qm}m∈Mof the heads of the mappings in{a mathematical formula}M, is{an inline-figure}-complete in data complexity.
      </paragraph>
     </section>
     <section label="8.2">
      <section-title>
       Instance-based determinacy and data pricing
      </section-title>
      <paragraph>
       In [54], Koutris et al. study the problem of query-based data pricing, where the goal is to automatically assign a price to a chunk of data (say, in a Web-based marketplace) given the price already assigned to a set of views. The data pricing framework in [54] has been used as a foundation for a growing body of work in the database community [33], [53], [57], [58], [59].
      </paragraph>
      <paragraph>
       A central element to this framework is the notion of instance-based determinacy. Intuitively, a set of CQ views determines a query if we can compute all answers to the query only from the results of given views and without having access to the underpinning data. Using our notation, we can equivalently define instance-based determinacy as follows.
      </paragraph>
      <paragraph label="Definition 51">
       A set of CQ views {a mathematical formula}Mdetermines a CQ p over the source schema given a source instance {a mathematical formula}D if, for each source instance {a mathematical formula}D′ such that {a mathematical formula}VM,D′ coincides with {a mathematical formula}VM,D, the answers to p over {a mathematical formula}D and {a mathematical formula}D′ also coincide.Then, {an inline-figure} is true if and only if {a mathematical formula}M determines p given {a mathematical formula}D, while {an inline-figure} is the same problem, but with the virtual image {a mathematical formula}VM,D as an additional parameter.{sup:2}
      </paragraph>
      <paragraph>
       Koutris et al. showed in [54] that {an inline-figure} is in {a mathematical formula}Π2p, but left the lower bound open. Furthermore, they did not study the (arguably more natural) problem {an inline-figure}.
      </paragraph>
      <paragraph label="Corollary 52">
       It is immediate to see that, for the empty ontology and Boolean policies, {an inline-figure} is precisely the complement of {an inline-figure}. Thus, our results in Theorem 19, Theorem 24, Theorem 25, Theorem 26 transfer directly to instance-based determinacy as given next. Problem{an inline-figure}is{an inline-figure}-complete when{a mathematical formula}Mranges over sets of CQ views and p ranges over Boolean CQs, and the lower bound holds already if p ranges over facts. Problem{an inline-figure}is{a mathematical formula}Π2p-hard if either{a mathematical formula}Mranges over a mapping language containing all sets of CQ views of bounded source arity and p ranges over a policy language containing all facts, or if{a mathematical formula}Mranges over a mapping language containing all set of mappings that are CQ views, LAV and of bounded source arity, and p ranges over a policy language containing all Boolean CQs.
      </paragraph>
      <paragraph>
       Our results also significantly refine the {an inline-figure} lower bounds in data complexity for determinacy given in [54]. In particular, from Theorem 29 we immediately have that {an inline-figure} and {an inline-figure} are both {an inline-figure}-hard in data complexity if either {a mathematical formula}M ranges over a mapping language containing all CQ views and p ranges over a policy language containing all facts, or {a mathematical formula}M ranges over a mapping language containing all sets that are both CQ views and LAV, and p ranges over a policy language containing all Boolean CQs.
      </paragraph>
     </section>
    </section>
    <section label="9">
     <section-title>
      Other related work
     </section-title>
     <paragraph>
      The problem of preventing disclosure of sensitive data in information systems has received significant attention in recent years. The high-level goal in most existing approaches is to release (or provide access to) a dataset to the public in such a way that the data remains maximally accessible to users without compromising the privacy of sensitive information.
     </paragraph>
     <paragraph>
      Many different models have been proposed in the literature, and they can be roughly divided into the following three kinds.
     </paragraph>
     <list>
      <list-item label="1.">
       Perturbation models, where (typically numeric) data is modified by the introduction of noise (e.g., in the form of a random variable with suitable properties). In this setting, the goal is for the data to remain useful for statistical analysis, rather than to preserve its integrity. This includes, for instance, work on differential privacy[36].
      </list-item>
      <list-item label="2.">
       Anonymisation and abstraction models, where some data is suppressed (e.g., by replacing constants with generated anonymous identifiers), or generalised (e.g., by replacing a concrete numeric value with a value range) in a way that preserves data integrity. This includes, for instance, work on k-anonymity and related notions in databases [5], [62], [69], [75] as well as work on anonymisation in linked data and ontologies [30], [31].
      </list-item>
      <list-item label="3.">
       View-based models, where the data made accessible (or inaccessible) to users is declaratively defined by means of views expressed in some logic-based language [7], [24], [26], [64], [78]. In contrast to other approaches, data in view-based models is not modified; instead, access to it is controlled by means of a declaratively specified layer.
      </list-item>
     </list>
     <paragraph>
      We focus the further discussion on view-based models, which are the closest to our work.
     </paragraph>
     <paragraph>
      Miklau and Suciu in [64] study the problem of whether a set of CQ views {a mathematical formula}M logically discloses information about a secret CQ q. Although their framework is probabilistic, the key notion of perfect privacy has a logical counter-part, which requires that (the bodies of) {a mathematical formula}M and p do not have a common critical tuple; here, a critical tuple of a CQ q is a fact α such that there is an instance {a mathematical formula}D with different sets of answers to q on {a mathematical formula}D and {a mathematical formula}D∖{α}, and a critical tuple of a CQ is such a tuple for every set containing this CQ (see [52] for more details on critical tuples).
     </paragraph>
     <paragraph>
      A number of works focus not on policy analysis at design time, as we do, but on policy enforcement at query time. Calvanese et al. [24] study privacy-aware data access in the presence of ontologies, by extending the database authorisation framework by Zhang and Mendelzon [78]. In their setting, users are assigned a set of authorisation views, and each query is then answered by the system using only the information that follows from the ontology and their respective views. In contrast to our approach, the framework in [24], [78] does not provide means for explicitly representing sensitive information—answers to user queries that do not follow from the ontology and the materialisation of the views over the datasource are assumed to be sensitive by default; as a consequence, their technical results are incomparable to ours. From a practical perspective, our results can be seen as complementing the framework of [24], [78]: the compliance problems studied in our paper can be exploited at design time to validate a set of authorisation views against a policy, thus ensuring that the views cannot reveal sensitive information.
     </paragraph>
     <paragraph>
      In the controlled query evaluation (CQE) framework, a censor ensures that query answers that may compromise the policy are either distorted, or not returned to users. CQE was introduced by [71] for databases and has received significant attention since (e.g., see [13], [14], [15]). CQE has been recently extended to ontologies in [16], [30], [31], [74]. Furthermore, [41] compares policy enforcement and policy restriction based approaches, in the absence of an ontology but for richer query languages (e.g., full relational calculus).
     </paragraph>
     <paragraph>
      Chirkova and Yu [26] considered the information-leak disclosure problem, which is similar to our compliance. In our terms, the input to their problem is a set of CQ views {a mathematical formula}M, a CQ policy p, a set Σ of source constraints—that is, TGDs and equality generating dependencies (EGDs) over the source schema,—and an instance MV over the target schema. The question is whether there is a potential information leak—that is, a tuple a of constants such that {a mathematical formula}p(a) holds in every source instance {a mathematical formula}D such that {a mathematical formula}D⊨Σ and {a mathematical formula}VM,D=MV. So, the difference between information leak disclosure and compliance (over CQ views) is that source constraints are allowed, ontologies are disallowed, and a virtual image is given as input instead of a source instance. Chirkova and Yu [26] developed an algorithm that constructs all information leaks, provided Σ is weakly-acyclic [37]. They also showed that the algorithm works in polynomial space in the size of MV and p (i.e., under the assumption that {a mathematical formula}M and Σ are fixed). In fact, an inspection of the algorithm shows that the assumption on {a mathematical formula}M is not necessary, and the size of {a mathematical formula}M may be counted without changing the complexity bound. We can exploit this algorithm to solve {an inline-figure} for the case when {a mathematical formula}O is empty and {a mathematical formula}M is a set of CQ views: we just need to materialise the virtual image {a mathematical formula}VM,D and input it to the algorithm as MV, together with empty Σ as well as with unchanged {a mathematical formula}M and p. However, the materialisation may be expensive in general, and to preserve the {an inline-figure} complexity we should require bounded target arity (and hence bounded frontier)—this guarantees that the materialisation can be done in polynomial time. Nonetheless, our results in Case (2) of Theorem 19 and Case (1) of Theorem 25 show that the {an inline-figure} complexity bound is not optimal, and this version of compliance is {a mathematical formula}Π3p-complete. We also hypothesise that the ideas of the algorithm underlying Theorem 19 can be exploited to improve the {an inline-figure} upper bound for the information-leak disclosure problem both for empty and for weakly-acyclic (but fixed) source constraints Σ.
     </paragraph>
     <paragraph>
      Benedikt et al. [7] considered the scenario where the materialised contents of some relations over a relational schema are visible to users, whereas the contents of all other relations are invisible. A background theory provides semantic information about both visible and invisible relations. The secret information is specified by a Boolean UCQ, and the goal is to determine whether (positive or negative) information about the UCQ can be derived by looking only at the contents of the visible relations and the background theory. A data-independent version is defined accordingly. Disclosure in this setting is related to the problem of query answering with “closed predicates”, which has drawn much recent attention in the knowledge representation community [2], [61]. For CQ views, empty ontology, and Boolean policy, both our data-dependent and data-independent compliance problems can be reduced to the corresponding settings in [7]. In particular, given a set of CQ views {a mathematical formula}M, a source dataset {a mathematical formula}D, and a Boolean policy p as an input to {an inline-figure}, we can create an input to the data-dependent disclosure problem of [7] as follows: let the target relational names of {a mathematical formula}M be visible and the source relational names be invisible; then let, for each CQ view {a mathematical formula}φ(x,z)→P(x) in {a mathematical formula}M, the background theory contain the corresponding integrity constraint {a mathematical formula}∀x.(∃z.φ(x,z)↔P(x)); finally, let the data instance be {a mathematical formula}D and the secret query be p. It is easy to verify that {an inline-figure} is true if and only if there is no disclosure for the constructed input. Moreover, since the reduction above is uniform in data, we get a corresponding reduction from {an inline-figure} to the data-independent version of the disclosure problem of [7]. The first reduction can be used to establish decidability results for {an inline-figure}, but the bounds that follow are not tight: the results of [7] only provide the {an inline-figure} upper bound in general and an {an inline-figure} upper bound in data complexity. The second, data-independent reduction is used, as Fact 41, in this paper in the proof of Theorem 44 on decidability of {an inline-figure} for the case of CQ views and empty ontology. Benedikt et al. also provide an undecidability result for the general data-independent version of their problem, and the proof of our Theorem 30 exploits similar techniques. The undecidability result of [7], however, requires constraints involving the source relational names, which are not allowed in our setting; therefore, the result does not directly imply Theorem 30. Beyond GAV mappings, there is no obvious connection between our work and [7], because GLAV mappings coupled with an ontology over the global schema are incompatible with the assumptions of [7].
     </paragraph>
     <paragraph>
      Finally, source indistinguishability is related to query inseparability in knowledge bases as studied by [18]. However, the emphasis in query inseparability is on having distinct ontologies (and not data) and mappings are not present; as a result, the techniques applied are different. Data-independent variants of ontology inseparability were studied in [11], [51].
     </paragraph>
    </section>
    <section label="10">
     <section-title>
      Conclusions and future work
     </section-title>
     <paragraph>
      In this paper, we have provided an analysis of disclosure of source data in ontology-based integration. For indistinguishability, we have been able to prove tractability in data complexity for standard OBDA. In the case of compliance problems, we have still obtained very general decidability results; however, achieving tractability for standard OBDA requires additional restrictions on both the mappings and the policy. Finally, we have shown that instance-independent compliance is decidable for the important case of CQ view mappings and empty ontology, but becomes undecidable as soon as this setting is slightly generalised. As shown in Section 8, our results provide some significant modifications of the complexity landscape outlined in prior work.
     </paragraph>
     <paragraph>
      Our results lead to a number of directions for future research. From a theoretical perspective, it would be interesting to address the problems mentioned next.
     </paragraph>
     <list>
      <list-item label="–">
       The decidability (and complexity) of {an inline-figure} for LAV mappings, which was left open in Section 7.
      </list-item>
      <list-item label="–">
       The computational properties of {an inline-figure}, which remain completely unexplored.
      </list-item>
      <list-item label="–">
       Databases are typically equipped with different types of integrity constraints such as primary and foreign keys, which may provide valuable additional information to an attacker. We believe that most of our decidability results extend to the setting where source constraints are allowed. It would be interesting to confirm this hypothesis and study the impact of source constraints on the complexity of our reasoning problems (by this, extending the results of Chirkova and Yu [26]).
      </list-item>
      <list-item label="–">
       Our notion of compliance does not limit the computational resources of the attacker. Although Lemma 3 shows that the attacker can always make due with polynomially many queries, our lower bounds can be seen as showing that it may be hard in general for an attacker to determine if the policy holds. Thus, a main open issue is to distinguish the combinations of schemata and queries that are computationally easy for an attacker from those that are hard (as the data varies). Lutz et al. in [60] and [61] performed a similar kind of analysis for hybrid closed-and-open world query answering, and their techniques may be directly relevant.
      </list-item>
     </list>
     <paragraph>
      From a practical perspective, we see our complexity bounds for source indistinguishability and (strong) compliance in the setting of standard OBDA as rather favourable. In particular, source indistinguishability has {an inline-figure} data complexity and, if we assume mappings to be LAV, it is also tractable in combined complexity; in turn, compliance and strong compliance both have {an inline-figure} data complexity under the assumption that mappings are LAV and the policy is ground. We believe that these are all reasonable assumptions in practice, and we are planning to develop and implement practical, rewriting-based, compliance checking algorithms for the aforementioned cases. In contrast, our bounds for the compliance problem in more general settings (and especially the intractability results in data complexity), paint a rather pessimistic picture. We conjecture that for source databases arising in practice, the data can be abstracted—for example, by grouping values with similar types—in such a way that the abstraction is orders of magnitude smaller than the source data, while compliance results about the source can be inferred from compliance results about the abstraction. We believe that criteria for a sound abstraction technique can be extracted from the critical instance technique described in Section 7. We will investigate this technique both from a practical and theoretical perspective in the future.
     </paragraph>
    </section>
   </content>
  </root>
 </body>
</html>