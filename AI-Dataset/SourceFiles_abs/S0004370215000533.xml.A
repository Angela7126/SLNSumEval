<?xml version="1.0" encoding="utf-8"?>
<html>
 <body>
  <root>
   <title>
    Ordered completion for logic programs with aggregates.
   </title>
   <content>
    <section label="1">
     <section-title>
      Introduction
     </section-title>
     <paragraph>
      In this paper, we consider to translate first-order Answer Set Programming (ASP), a predominant declarative programming paradigm in the area of knowledge representation and logic programming [3], [20], [24], [25], into first-order logic. Work in this direction is not only of theoretical interests but also of practical relevances as it suggests an alternative way to implement ASP.
     </paragraph>
     <paragraph>
      Recently, Asuncion et al. [2] proposed a notion of ordered completion (a first-order sentence with some extra predicates) for first-order normal logic programs, and showed that the stable models of a normal program are exactly corresponding to the classical models of its ordered completion on finite structures. Interestingly, there is no such translation on arbitrary structures nor prohibiting extra predicates. Based on this translation, they developed a new ASP solver, which first translates a program to its ordered completion, then grounds this first-order sentence, and finally calls an SMT solver. This is significantly different from previous ASP solvers, which ground the first-order programs directly. A first implementation shows that this new solver is promising as it performs relatively well for the Hamiltonian Circuit program, particularly on big instances [2].
     </paragraph>
     <paragraph>
      However, their work cannot handle aggregates, a very important building block for modern Answer Set Programming. The reason why aggregates are crucial in answer set solving is twofold. Firstly, they enhance the expressive power of ASP, and often they can simplify the representation task. For many applications, one can write a simpler and more elegant logic program by using aggregates, for instance, the job scheduling program [28]. Secondly and more importantly, aggregates can improve the efficiency of ASP solving [19]. Normally, the program using aggregates can be solved much faster [12].
     </paragraph>
     <paragraph>
      In this paper, we consider the problem of extending ordered completion for programs with aggregates. This is a challenging task as some programs with aggregates are expressive enough to capture disjunctive logic programming (see in [16]), thus can never be captured in first-order logic with the same type of aggregates providing some general assumptions in the computational complexity theory (see Proposition 6 in [2]).
     </paragraph>
     <paragraph>
      Hence, an important task is to draw a boundary between the normal programs with aggregates that can be captured in first-order logic with the same type of aggregates and those programs that cannot. For this purpose, we extend the notion of convex constraints proposed by Liu and Truszczyński [23] into first-order convex aggregates. We show that the class of convex aggregates is exactly the boundary we need in the sense that
     </paragraph>
     <list>
      <list-item label="•">
       First-order normal logic programs with convex aggregates can always be captured in first-order logic with the same type of aggregates on finite structures. More precisely, we extend the notion of ordered completion for first-order normal logic programs with convex aggregates, and show that every stable model of such a program is corresponding to a classical model of its enhanced ordered completion.
      </list-item>
      <list-item label="•">
       Given any non-convex aggregate context, there exists a normal program under this context such that it can never be translated into first-order sentences with the same type of aggregates unless {a mathematical formula}NP=coNP.
      </list-item>
     </list>
     <paragraph>
      In fact, the class of convex aggregates is expressive enough to capture both monotone and antimonotone aggregates [23] as well as the aggregates appearing in most benchmark programs [5]. Therefore, based on our theoretical results, we are able to develop an alternative ASP solver for first-order normal programs with convex aggregates. Following this idea, we implement a new ASP solver GROCv2. Our experimental results demonstrate that GROCv2 is comparable to the state-of-the-art ASP solvers.
     </paragraph>
     <paragraph>
      The paper is organized as follows. Section 2 reviews basic concepts and notations that we will need through out the paper. Section 3 presents the ordered completion for logic programs with aggregates, and proves the main theorems. Section 4 introduces the implementation of the ASP solver GROCv2, and reports some experimental results. Finally, Sections 5 and 6 discuss some related work and draw our conclusions respectively. We leave the very long proofs of some theorems to Appendix A for a more fluent reading.
     </paragraph>
    </section>
    <section label="2">
     <section-title>
      Preliminaries
     </section-title>
     <paragraph>
      We consider a second-order language without functions but with equality =. A signature contains a finite set of constants and a finite set of predicates. A term is either a variable or a constant. A standard atom is an expression {a mathematical formula}P(t), where P is a predicate and t is a tuple of terms which matches the arity of P. An equality atom is an expression {a mathematical formula}t1=t2, where {a mathematical formula}t1 and {a mathematical formula}t2 are terms.
     </paragraph>
     <paragraph>
      A multiset (also called a bag) is a pair {a mathematical formula}M=(Ms,Mf), where {a mathematical formula}Ms is a set and {a mathematical formula}Mf is a function, called the multiplicity function, from {a mathematical formula}Ms to {a mathematical formula}N, i.e., the set of positive integers {a mathematical formula}{1,2,3,…}. A multiset {a mathematical formula}(Ms,Mf) is finite if {a mathematical formula}Ms is finite. Let M and {a mathematical formula}M′ be two multisets. We denote by {a mathematical formula}M⊆M′ if {a mathematical formula}Ms⊆Ms′ and for all elements {a mathematical formula}a∈Ms, {a mathematical formula}Mf(a)≤Mf′(a). We write {a mathematical formula}M=M′ if {a mathematical formula}M⊆M′ and {a mathematical formula}M′⊆M. For convenience, a multiset M, where {a mathematical formula}Ms={a1,…,an} and {a mathematical formula}Mf(ai)=ci ({a mathematical formula}1≤i≤n), is also denoted as {a mathematical formula}{{a1,…,a1︸c1,…,ai,…,ai︸ci,…,an,…,an︸cn}}. The order of the elements is irrelevant. For example, {a mathematical formula}{{a,a,b,c}} is the multiset M, where {a mathematical formula}Ms={a,b,c} and {a mathematical formula}Mf(a)=2, {a mathematical formula}Mf(b)=Mf(c)=1.
     </paragraph>
     <section label="2.1">
      <section-title>
       The syntax of aggregates
      </section-title>
      <paragraph>
       Aggregate is a crucial auxiliary building block for answer set programming [12], [13], [16], [19], [22], [23], [28]. We first define the syntax of aggregates in the first-order case. We assume a set of aggregate symbols {a mathematical formula}AG and a (fixed) set of comparison operators on numbers {a mathematical formula}CO={&lt;,≤,=,≠,≥,&gt;}.
      </paragraph>
      <paragraph label="Definition 1">
       An aggregate atom δ is an expression of the form{a mathematical formula} where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}op∈AG is an aggregate symbol,
       </list-item>
       <list-item label="•">
        {a mathematical formula}Qi(yi) ({a mathematical formula}1≤i≤s) and {a mathematical formula}Rj(zj) ({a mathematical formula}1≤j≤t) are standard atoms or equality atoms. In addition,{a mathematical formula} is called the body of δ, denoted by {a mathematical formula}Bd(δ),
       </list-item>
       <list-item label="•">
        v and w are tuples of variables mentioned in (2), and {a mathematical formula}v∩w=∅,
       </list-item>
       <list-item label="•">
        {a mathematical formula}⪯∈CO is a comparison operator on numbers,
       </list-item>
       <list-item label="•">
        t is a term, and we assume that variables occurring in t are not in {a mathematical formula}v∪w.
       </list-item>
      </list>
      <paragraph>
       For convenience, we use {a mathematical formula}Ps(δ) and {a mathematical formula}Ng(δ) to denote the sets {a mathematical formula}{Q1(y1),…,Qs(ys)} and {a mathematical formula}{R1(z1),…,Rt(zt)} respectively. Given an aggregate atom δ of the form (1), a variable in δ is a free variable if it is not a variable in {a mathematical formula}v∪w.
      </paragraph>
      <paragraph label="Example 1">
       Let sum and card be aggregate symbols in {a mathematical formula}AG. The following are two aggregate atoms:{a mathematical formula} Intuitively, they are equivalent to the weight constraints{a mathematical formula} in smodels [29], and the aggregate atoms{a mathematical formula} in DLV [14] and ASP-Core-2.{sup:2} □
      </paragraph>
      <paragraph>
       An atom is either an equality atom, or a standard atom, or an aggregate atom. A first-order formula with aggregates (or formula for short) is built from atoms and logical connectives as usual. A formula without aggregate atom is called a classical formula in this paper. The free variable of a formula is defined as usual. We use {a mathematical formula}free(ϕ) to denote the set of free variables of a formula ϕ.
      </paragraph>
     </section>
     <section label="2.2">
      <section-title>
       The semantics for first-order logic with aggregates
      </section-title>
      <paragraph>
       As aggregate is an extra building block, we need to extend the standard semantics for classical first-order logic for incorporating aggregates, in which aggregates are considered as predefined function symbols.
      </paragraph>
      <paragraph label="Definition 2">
       An aggregate context{a mathematical formula}AC is a tuple of the form:{a mathematical formula} where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}ACag={op1,…,opn} is a subset of {a mathematical formula}AG;
       </list-item>
       <list-item label="•">
        {a mathematical formula}ACco⊆CO is a set of comparison operators;
       </list-item>
       <list-item label="•">
        {a mathematical formula}ACnum⊆Z is a set of numbers;
       </list-item>
       <list-item label="•">
        for every aggregate symbol {a mathematical formula}opi∈AG ({a mathematical formula}1≤i≤n), there is a partial function {a mathematical formula}opiAC from the set of multisets over tuples on {a mathematical formula}ACnum to {a mathematical formula}ACnum.
       </list-item>
      </list>
      <paragraph label="Example 2">
       Consider an aggregate context {a mathematical formula}AC1, where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}AC1ag={card,sum,min,max}, for cardinality, sum, minimum, and maximum respectively;
       </list-item>
       <list-item label="•">
        {a mathematical formula}AC1co={&lt;,≤,=,≥,&gt;};
       </list-item>
       <list-item label="•">
        {a mathematical formula}AC1num=N;
       </list-item>
       <list-item label="•">
        given a multiset {a mathematical formula}M={{a1,…,ak}}, where each {a mathematical formula}ai{a mathematical formula}(1≤i≤k) is a tuple of numbers,
       </list-item>
      </list>
      <paragraph>
       The aggregate context {a mathematical formula}AC1 in Example 2 presents the most common aggregate functions in the current ASP solvers. However, the following example shows that it is possible to define more general aggregates in our setting theoretically.
      </paragraph>
      <paragraph label="Example 3">
       Consider an aggregate context {a mathematical formula}AC4, where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}AC4ag={sumall,sat}, where sumall and sat are two aggregate symbols in {a mathematical formula}AG;
       </list-item>
       <list-item label="•">
        {a mathematical formula}AC4co={&lt;,≤,=,≥,&gt;};
       </list-item>
       <list-item label="•">
        {a mathematical formula}AC4num=N;
       </list-item>
       <list-item label="•">
        given a multiset {a mathematical formula}M={{a1,…,ak}}, where each {a mathematical formula}ai, {a mathematical formula}(1≤i≤k) is a tuple of numbers,
       </list-item>
      </list>
      <paragraph label="Definition 3">
       Given a signature σ, an extended structure{a mathematical formula}A of σ is a tuple{a mathematical formula} where
      </paragraph>
      <list>
       <list-item label="•">
        A is the domain of {a mathematical formula}A, denoted by {a mathematical formula}Dom(A),
       </list-item>
       <list-item label="•">
        {a mathematical formula}fA is a total function from A to {a mathematical formula}Z,
       </list-item>
       <list-item label="•">
        {a mathematical formula}ciA ({a mathematical formula}1≤i≤l) is the interpretation for constant {a mathematical formula}ci;
       </list-item>
       <list-item label="•">
        {a mathematical formula}PjA ({a mathematical formula}1≤j≤m) is the interpretation for predicate {a mathematical formula}Pj.
       </list-item>
      </list>
      <paragraph>
       An extended structure is finite if its domain is finite. Note that the only difference between the extended structure defined above and the structure in first-order logic is the partial function {a mathematical formula}fA which maps domain elements to numbers. This enables us to freely use variables and constants in aggregate functions. Since aggregate functions such as sum are defined over numbers but not over arbitrary domain elements, we use a two step approach to interpret an aggregate atom. First, using the standard first-order semantics, we map the terms (i.e., constants and variables) into domain elements. Then, we use the function {a mathematical formula}fA to further map these domain elements into numbers so that the aggregate atoms are well defined. We extend the function {a mathematical formula}fA for a tuple of domain elements and for a multiset. By {a mathematical formula}fA(c), we denote the tuple {a mathematical formula}(fA(c1),…,fA(cn)), where {a mathematical formula}c=(c1,…,cn) is a tuple. By {a mathematical formula}fA(A), we denote the multiset {a mathematical formula}{{fA(a1),…,fA(ak)}}, where {a mathematical formula}A={{a1,…,ak}} is a multiset. In the following, an extended structure is simply called a structure when it is clear from the context.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}A be a structure. An assignment is an expression of the form {a mathematical formula}x/a, where x is a tuple of distinct variables and {a mathematical formula}a∈Dom(A)|x| is a tuple of domain elements. Assignments can be extended for terms. Let t be a tuple of terms, in which the variables are from x. We use {a mathematical formula}t[x/a] to denote the tuple of domain elements by simultaneously replacing the variables in x via the assignment {a mathematical formula}x/a and constant c by {a mathematical formula}cA.
      </paragraph>
      <paragraph>
       Under an aggregate context {a mathematical formula}AC, the satisfaction relation between a structure {a mathematical formula}A and a formula {a mathematical formula}φ(x) (with aggregate atoms) together with an assignment {a mathematical formula}x/a is defined recursively as follows:
      </paragraph>
      <list>
       <list-item label="•">
        If φ is {a mathematical formula}P(t), then {a mathematical formula}A⊨φ[x/a] iff {a mathematical formula}t[x/a]∈PA;
       </list-item>
       <list-item label="•">
        If φ is {a mathematical formula}t1=t2, then {a mathematical formula}A⊨φ[x/a] iff {a mathematical formula}t1[x/a]=t2[x/a];
       </list-item>
       <list-item label="•">
        If φ is ¬ψ, then {a mathematical formula}A⊨φ[x/a] iff {a mathematical formula}A⊭ψ[x/a];
       </list-item>
       <list-item label="•">
        If φ is {a mathematical formula}ψ∧ξ, then {a mathematical formula}A⊨φ[x/a] iff {a mathematical formula}A⊨ψ[x/a] and {a mathematical formula}A⊨ξ[x/a];
       </list-item>
       <list-item label="•">
        If φ is {a mathematical formula}∀yψ, then {a mathematical formula}A⊨φ[x/a] iff for all {a mathematical formula}b∈Dom(A), {a mathematical formula}A⊨ψ[xy/ab];
       </list-item>
       <list-item label="•">
        Finally, if φ is an aggregate atom δ of the form (1) in the aggregate context {a mathematical formula}AC, then {a mathematical formula}A⊨φ[x/a] iff
       </list-item>
      </list>
      <paragraph label="Example 4">
       Consider the aggregate context {a mathematical formula}AC2 and a signature σ with only one predicate P. For any structure {a mathematical formula}A with the domain {a mathematical formula}{a,b} and {a mathematical formula}fA(a)=2 and {a mathematical formula}fA(b)=3, we have{a mathematical formula} and{a mathematical formula}  □
      </paragraph>
      <paragraph>
       Let {a mathematical formula}AC be an aggregate context. An aggregate {a mathematical formula}op∈ACag is polynomial if the problem of checking {a mathematical formula}opAC(M)⪯n can be done in polynomial time with respect to {a mathematical formula}|M| for every multiset M and number n, where {a mathematical formula}|M|, the length of M, is defined as the sum of the length of all tuples in M[16]. {a mathematical formula}AC is polynomial if all aggregates in it are polynomial. It can be verified that all three aggregate contexts in Example 2 are polynomial, while {a mathematical formula}AC4 in Example 3 is not polynomial unless {a mathematical formula}P=NP.
      </paragraph>
     </section>
     <section label="2.3">
      <section-title>
       The stable model semantics for normal logic programs with aggregates
      </section-title>
      <paragraph>
       We now propose the stable model semantics for first-order normal logic programs with aggregates. A normal program with aggregates (or program for short) is a finite set of rules of the form{a mathematical formula} where α is either a standard atom or ⊥, {a mathematical formula}βi ({a mathematical formula}1≤i≤l) and {a mathematical formula}γj ({a mathematical formula}1≤j≤m) are atoms.
      </paragraph>
      <paragraph>
       A rule of the form (4) is called a constraint if α is ⊥. By {a mathematical formula}Π⊥, we denote the set of constraints in program Π. Let r be a rule of the form (4). We call α the head of r and {a mathematical formula}{β1,…,βl,notγ1,…,notγm} the body of r. A variable is called a local variable of r if it occurs in a standard atom, equality atom, or occurs freely in an aggregate atom in the body of r but it does not occur in the head of r. For convenience, we use {a mathematical formula}Head(r) and {a mathematical formula}Body(r) to denote α and {a mathematical formula}β1∧⋯∧βl∧¬γ1∧⋯∧¬γm, respectively. We also use {a mathematical formula}Pos(r) and {a mathematical formula}PosAgg(r) to denote the set of positive atoms and the set of positive aggregate atoms from the body of r, respectively. By {a mathematical formula}rˆ, we denote the universal closure of the formula{a mathematical formula} By {a mathematical formula}Πˆ, we denote the formula {a mathematical formula}⋀r∈Πrˆ.
      </paragraph>
      <paragraph>
       The signature of a program Π, denoted by {a mathematical formula}τ(Π), consists of all constants and predicate symbols occurring in Π. A predicate in a program is said to be intensional if it occurs in the head of some rule in the program, and extensional otherwise. We use {a mathematical formula}Pint(Π) to denote the set of all intensional predicates of Π.
      </paragraph>
      <paragraph label="Example 5">
       Consider the following program {a mathematical formula}Π1 with an aggregate atom{a mathematical formula}{a mathematical formula}{a mathematical formula} Here, sum is an aggregate symbol, P is intensional and {a mathematical formula}R1,R2,R3 are extensional. □
      </paragraph>
      <paragraph>
       The stable model semantics of a program is defined by a second-order sentence. We first introduce some notations. Let P and Q be two predicates or predicate variables of the same arity. We use {a mathematical formula}P&lt;Q to denote the formula{a mathematical formula} Let {a mathematical formula}P=P1⋯Pk and {a mathematical formula}P′=P1′⋯Pk′ be two tuples of predicates or predicate variables such that for every {a mathematical formula}1≤i≤k, {a mathematical formula}Pi and {a mathematical formula}Pi′ have the same arity. We use {a mathematical formula}P&lt;P′ to denote the formula{a mathematical formula}
      </paragraph>
      <paragraph>
       Let Π be a program such that {a mathematical formula}Pint(Π)={P1,…,Pn}. Let {a mathematical formula}U=U1…Un be a tuple of new predicates such that each {a mathematical formula}Ui ({a mathematical formula}1≤i≤n) matches the arity of {a mathematical formula}Pi. Given an atom ρ, {a mathematical formula}ρ⁎ is defined as
      </paragraph>
      <list>
       <list-item label="•">
        ρ itself, if ρ is an equality atom or an atom of the form {a mathematical formula}P(x), where P is an extensional predicate;
       </list-item>
       <list-item label="•">
        {a mathematical formula}Ui(x), if ρ is an atom of the form {a mathematical formula}Pi(x), where {a mathematical formula}Pi is an intensional predicate;
       </list-item>
       <list-item label="•">
        {a mathematical formula}(op〈v:∃wBd(δ)⁎〉⪯t)∧(op〈v:∃wBd(δ)〉⪯t), if ρ is an aggregate atom δ of the form (1), where{a mathematical formula}
       </list-item>
      </list>
      <paragraph>
       Let r be a rule of the form (4) which is not a constraint. We use {a mathematical formula}Body(r)⁎ to denote the formula{a mathematical formula} and {a mathematical formula}r⁎ the universal closure of the formula{a mathematical formula} Finally, by {a mathematical formula}SM(Π), we denote the following second-order sentence{a mathematical formula}
      </paragraph>
      <paragraph label="Definition 4">
       Stable modelLet Π be a program and {a mathematical formula}AC an aggregate context. A structure {a mathematical formula}A on {a mathematical formula}τ(Π) is said to be a stable model of Π if {a mathematical formula}A is a model of {a mathematical formula}SM(Π).
      </paragraph>
      <paragraph>
       For normal programs without aggregates, the definition of {a mathematical formula}SM(Π) is exactly the same as those presented in [2] and [17]. For the stable model semantics of propositional programs with aggregates, there are several alternative definitions [4], [8], [10], [13], [16], [18], [27], [30]. The Ferraris' semantics and the FLP semantics have recently been extended into the first-order case [4], [18], [22]. Our definition of {a mathematical formula}SM(Π) can be considered as another first-order extension of the Ferraris' semantics [16], [18]. Nevertheless, if the aggregate atoms only occur in the positive bodies of rules and the bodies of these aggregates contain no negative atoms (this is actually the case in many benchmark programs), these two semantics coincide.
      </paragraph>
      <paragraph label="Example 6">
       Example 5 continuedConsider the aggregate context {a mathematical formula}AC1 in Example 2 and three structures {a mathematical formula}M1,M2,M3 on {a mathematical formula}τ(Π1) such that for {a mathematical formula}i=1,2,3,{a mathematical formula}{a mathematical formula}{a mathematical formula} and{a mathematical formula}
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}M1 is not a stable model of {a mathematical formula}Π1 since it is not a model of {a mathematical formula}r3ˆ. To see this, note that {a mathematical formula}M1⊨sum〈y:P(y)∧R3(x,y)[x/d] and {a mathematical formula}M1⊭P(x)[x/d].
       </list-item>
       <list-item label="•">
        Both {a mathematical formula}M2 and {a mathematical formula}M3 are models of {a mathematical formula}⋀r∈Π1rˆ, but {a mathematical formula}M3 is not a stable model of {a mathematical formula}Π1, as {a mathematical formula}M3 is not a model of the second-order sentence (8). Indeed, let {a mathematical formula}U′={b,c,d}⊂PM3. Then, we have {a mathematical formula}M3⊨U&lt;P[U/U′] and {a mathematical formula}M3⊨⋀r∈Π1r⁎[U/U′], so that {a mathematical formula}M3⊭¬∃U(U&lt;P∧⋀r∈Π1r⁎).
       </list-item>
       <list-item label="•">
        It can be verified that {a mathematical formula}M2 is the only stable model of {a mathematical formula}Π1. Roughly speaking, {a mathematical formula}M2 is obtained as follows:
       </list-item>
      </list>
     </section>
    </section>
    <section label="3">
     <section-title>
      Ordered completion for normal logic programs with aggregates
     </section-title>
     <paragraph>
      Ordered completion, introduced by Asuncion et al. [2] for normal logic program without aggregates, is a modification of Clark's completion [7] by adding some auxiliary predicates to capture the derivation order during the program's evaluation. It is showed that, on finite structures, the stable models of a normal logic program are exactly corresponding to the classical models of its ordered completion.
     </paragraph>
     <paragraph>
      From a theoretical point of view, ordered completion makes an important contribution on understanding first-order answer set programming. Firstly, it shows that the stable model semantics can be captured by Clark's completion plus derivation order. Secondly, it clarifies the relationship between first-order normal ASP and first-order logic. More precisely, every normal answer set program can be captured by a first-order sentence with some new predicates on finite structures. Interestingly, this result does not hold on arbitrary structures nor if no new predicate symbol is used [2].
     </paragraph>
     <paragraph>
      In addition, ordered completion is relevant from a practical point of view. It initiates a new direction of developing an alternative ASP solver by first translating a normal logic program to its ordered completion, then working on finding a model of this first-order sentence. A first implementation shows that this new approach is promising as it performs good on the Hamiltonian Circuit program [25], especially on very large instances. However, ordered completion can hardly be used beyond the Hamiltonian Circuit program because it cannot handle aggregates – a crucial building block widely used in many applications in ASP.
     </paragraph>
     <paragraph>
      Extending ordered completion for dealing with aggregates is not an easy task. First of all, the aggregate atoms in a logic program are highly interacted with the rest parts. Hence, a naive extension of ordered completion by simply treating aggregate atoms as extensional atoms would not work.
     </paragraph>
     <paragraph>
      Another observation is from a computational complexity point of view. In the propositional case, it is shown that checking the existence of stable models of normal program with aggregates is {a mathematical formula}Σ2P complete for both the Ferraris' semantics and the FLP semantics [11], [16], which lies on a higher complexity level than the same task for normal programs without aggregates. Together with some well known results in finite model theory, this probably suggests that, in general, first-order normal programs with arbitrary aggregates cannot be captured in first-order logic with the same type of aggregates at all. In this paper, we shall show that this is indeed the case.
     </paragraph>
     <paragraph>
      Nevertheless, it is also observed that normal programs with some type of aggregate atoms still have the same complexity as normal programs without aggregates [16]. This means that, simply from a complexity point of view, it is possible to capture this class of programs in first-order logic with the same type of aggregate atoms. In fact, two important classes of such aggregate atoms are well discussed in the literature [4], [13], [16], [27], [31], namely monotone and anti-monotone aggregate atoms.
     </paragraph>
     <paragraph label="Definition 5">
      Let {a mathematical formula}AC be an aggregate context, {a mathematical formula}op∈ACag be an aggregate symbol, and {a mathematical formula}⪯∈ACco a comparison operator. We say that op is monotone with respect to ⪯ if for any two multisets {a mathematical formula}M1,M2 such that {a mathematical formula}M1⊆M2,
     </paragraph>
     <list>
      <list-item label="•">
       if {a mathematical formula}M1 is in the domain of {a mathematical formula}opAC, then {a mathematical formula}M2 is also in the domain of {a mathematical formula}opAC, and
      </list-item>
      <list-item label="•">
       for any {a mathematical formula}n∈ACnum, if {a mathematical formula}opAC(M1)⪯n then {a mathematical formula}opAC(M2)⪯n.
      </list-item>
     </list>
     <paragraph>
      Consider aggregate symbols card and sum in the aggregate context {a mathematical formula}AC1 in Example 2. They are either monotone or anti-monotone with respect to the comparison symbols in {a mathematical formula}{&lt;,≤,≥,&gt;}, but neither monotone nor anti-monotone with respect to =.
     </paragraph>
     <paragraph>
      As we shall show in the paper, normal logic programs with these two types of aggregates can indeed be captured in first-order logic with the same type of aggregates. However, they are not powerful enough to capture all. For instance, a commonly used aggregate is of the form {a mathematical formula}sum(M)=n, which is neither monotone nor anti-monotone, but can be expressed as the conjunction of the two monotone and anti-monotone aggregates: {a mathematical formula}sum(M)&gt;n−1 and {a mathematical formula}sum(M)&lt;n+1. Therefore, normal logic programs with the aggregate type {a mathematical formula}sum(M)=n can be expressed in first-order logic with this aggregate as well.
     </paragraph>
     <paragraph>
      Hence, an important task is to draw a boundary. That is, does there exist a class of aggregates such that first-order normal programs with this type of aggregates can always be captured in first-order logic with the same type of aggregates, while this cannot be done for normal programs with any other aggregates not in this class?
     </paragraph>
     <paragraph>
      For this purpose, we extend Liu and Truszczyński's notion of convex constraints [23] to first-order convex aggregates and show that this is exactly the boundary we need. That is, first-order normal logic programs with convex aggregates can always be captured in first-order logic with the same type of aggregates. On the contrary, for any non-convex aggregates, we can always construct a normal program with this aggregate such that it can never be captured in first-order logic with the same type of aggregates providing some general assumptions in the computational complexity theory.
     </paragraph>
     <paragraph label="Definition 6">
      Let {a mathematical formula}AC be an aggregate context, {a mathematical formula}op∈ACag an aggregate symbol, and {a mathematical formula}⪯∈ACco a comparison operator. Then, op is convex with respect to ⪯ if there does not exist finite multisets of tuples of the same arities{sup:4}{a mathematical formula}M1⊆M2⊆M3 and {a mathematical formula}n∈Z such that {a mathematical formula}opAC(M1)⪯n and {a mathematical formula}opAC(M3)⪯n holds, while {a mathematical formula}opAC(M2)⪯n does not hold.An aggregate context {a mathematical formula}AC is convex, if for every aggregate symbol {a mathematical formula}op∈ACag and comparison operator {a mathematical formula}⪯∈ACco, op is convex with respect to ⪯.
     </paragraph>
     <paragraph label="Example 7">
      Consider the aggregate contexts in Example 2.
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}AC3 is non-convex since sum is non-convex with respect to ≥. As an example, both {a mathematical formula}sumAC3({{−1,1}})≥0 and {a mathematical formula}sumAC3(∅)≥0 hold, but {a mathematical formula}sumAC3({{−1}})≥0 does not hold.
      </list-item>
      <list-item label="•">
       If we restrict to non-negative numbers, sum is convex with respect to ≥, but {a mathematical formula}AC2 is still non-convex, since sum is non-convex with respect to ≠. As an example, we can see that {a mathematical formula}sumAC2({{1,2}})≠1 and {a mathematical formula}sumAC2(∅)≠1 hold, while {a mathematical formula}sumAC2({{1}})≠1 does not hold.
      </list-item>
      <list-item label="•">
       It can be verified that {a mathematical formula}AC1 is convex. Note that aggregates card and sum are convex with respect to =, though they are neither monotone nor anti-monotone. □
      </list-item>
     </list>
     <paragraph>
      In fact, both monotone and antimonotone aggregates are subclasses of convex aggregates.
     </paragraph>
     <paragraph label="Proposition 1">
      Let{a mathematical formula}ACbe an aggregate context,{a mathematical formula}op∈ACagbe an aggregate symbol and{a mathematical formula}⪯∈ACcoa comparison operator. Ifopis (anti)monotone with respect to ⪯, thenopis convex with respect to ⪯.
     </paragraph>
     <paragraph label="Proof">
      It suffices to show that if op is non-convex with respect to ⪯, then it is neither monotone nor anti-monotone with respect to ⪯.If op is non-convex with respect to ⪯, then there exist multisets {a mathematical formula}M1⊆M2⊆M3 and {a mathematical formula}n∈Z such that {a mathematical formula}opAC(M1)⪯n and {a mathematical formula}opAC(M3)⪯n hold, while {a mathematical formula}opAC(M2)⪯n does not hold. Since {a mathematical formula}M1⊆M2, {a mathematical formula}opAC(M1)⪯n holds but {a mathematical formula}opAC(M2)⪯n does not hold, op is not anti-monotone. Similarly, since {a mathematical formula}M2⊆M3, {a mathematical formula}opAC(M3)⪯n holds but {a mathematical formula}opAC(M1)⪯n does not hold, then op is not monotone.  □
     </paragraph>
     <section label="3.1">
      <section-title>
       Ordered completion
      </section-title>
      <paragraph>
       Now we define ordered completion for normal logic programs with aggregates. Let σ be a signature. By {a mathematical formula}σ≤, we denote the signature σ together with the set of new predicates{a mathematical formula} where the arity of {a mathematical formula}≤PQ is the sum of the arities of P and Q.{sup:5} The ordered completion of a program Π is defined as a formula over the signature {a mathematical formula}τ(Π)≤.
      </paragraph>
      <paragraph>
       Let Π be a program. Then by {a mathematical formula}Trans(Π), we denote the formula{a mathematical formula} Also, given two predicates P and Q, we use {a mathematical formula}P(x)&lt;Q(y)ˆ to denote the formula{a mathematical formula}
      </paragraph>
      <paragraph label="Definition 7">
       Ordered completion with aggregatesLet Π be a program. Then the modified completion of Π, denoted by {a mathematical formula}MComp(Π), is the formula{a mathematical formula} where
       <list>
        {a mathematical formula}Πˆ is {a mathematical formula}⋀r∈Πrˆ,{a mathematical formula}Pos(r)&lt;P(x)ˆ is the formula{a mathematical formula}{a mathematical formula}PosAgg(r)&lt;P(x)ˆ is the formula{a mathematical formula} in which {a mathematical formula}Ps(δ)&lt;P(x)ˆ is a shorthand of{a mathematical formula}Finally, the
       </list>
       <paragraph>
        ordered completion of Π, denoted by {a mathematical formula}OC(Π), is the formula{a mathematical formula}
       </paragraph>
      </paragraph>
      <paragraph>
       Let us take a closer look at Definition 7. First of all, for non-aggregate atoms in {a mathematical formula}Body(r), we treat them the same way as in the original definition of ordered completion [2]. That is, for each positive non-aggregate atom in {a mathematical formula}Pos(r), we introduce the comparison atoms via the formula {a mathematical formula}Pos(r)&lt;P(x)ˆ. However, this is not done for negative non-aggregate atoms.
      </paragraph>
      <paragraph>
       For aggregate atoms occurring in {a mathematical formula}Body(r), similar to non-aggregate atoms, we also distinguish between the negative and positive occurrences. For negative occurrences, we also do not introduce the comparison atoms into these aggregates. However, for positive occurrences, we need to introduce the comparison assertions via {a mathematical formula}PosAgg(r)&lt;P(x)ˆ, where {a mathematical formula}PosAgg(r)&lt;P(x)ˆ denotes the formula:{a mathematical formula} which simply introduces the comparison atoms into the positive body {a mathematical formula}Ps(δ) of each aggregate atom in {a mathematical formula}PosAgg(r), i.e., via the formulas of the form {a mathematical formula}Ps(δ)&lt;P(x)ˆ. The reason that we introduce the comparison atoms for these positive aggregates is that we need to keep track of the derivation order as implied by the stable model semantics.
      </paragraph>
      <paragraph label="Example 8">
       Example 5 continuedThe ordered completion of {a mathematical formula}Π1, denoted by {a mathematical formula}OC(Π1), is the conjunction of {a mathematical formula}Trans(Π1) and the following sentences:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} Now consider again the aggregate context {a mathematical formula}AC1 in Example 2 and the structures {a mathematical formula}M1,M2,M3 in Example 6.
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}M1 is not a model of (12). So it cannot be expanded to a model of {a mathematical formula}OC(Π1).
       </list-item>
       <list-item label="•">
        Both {a mathematical formula}M2 and {a mathematical formula}M3 are models of (10), (11), (12).
       </list-item>
       <list-item label="•">
        Let {a mathematical formula}M2′ be a structure expanded from {a mathematical formula}M2 by the additional interpretation for {a mathematical formula}≤PP:{a mathematical formula} It can be verified that{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} So, {a mathematical formula}M2′ is a model of {a mathematical formula}OC(Π1).
       </list-item>
       <list-item label="•">
        Let {a mathematical formula}M3′ be a model of {a mathematical formula}Trans(Π1) expanded from {a mathematical formula}M3. Now we show that {a mathematical formula}M3′ is not a model of {a mathematical formula}OC(Π1). Indeed, since we have{a mathematical formula} we also have{a mathematical formula}{a mathematical formula} Therefore, {a mathematical formula}M3′ is not a model of (13). □
       </list-item>
      </list>
      <paragraph>
       In general, we have the following theorem.
      </paragraph>
      <paragraph label="Theorem 1">
       Main theoremLet{a mathematical formula}ACbe a convex aggregate context, Π a program and{a mathematical formula}Aa finite structure of{a mathematical formula}τ(Π). Then,{a mathematical formula}Ais a stable model of Π on{a mathematical formula}ACif and only if{a mathematical formula}Acan be expanded to a model of{a mathematical formula}OC(Π).
      </paragraph>
     </section>
     <section label="3.2">
      The proof of Theorem 1
      <paragraph>
       To prove Theorem 1, we need to use the notion of externally supported set [6]. Roughly speaking, a set of ground atoms is externally supported if there exists a ground atom in the set and an associated rule that supports the atom (i.e., the atom is the head of the ground rule) and whose positive body could be satisfied by external ground atoms (i.e., ground atoms not in this set). Then, we provide a lemma showing that a structure is a stable model of a program if and only if it is a model of the program and every subset of ground atoms included in this structure is externally supported. Then based on this lemma, we finally give the proof of the main theorem.
      </paragraph>
      <paragraph>
       Let Π be a program and {a mathematical formula}A a structure of signature σ such that {a mathematical formula}τ(Π)⊆σ. Then a ground atom is an expression of the form {a mathematical formula}P(a), where P is a predicate and a is a tuple of domain elements matching the arity of P. By {a mathematical formula}[Pint(Π)]A, we denote the set of ground atoms {a mathematical formula}{P(a)|a∈PA,P∈Pint(Π)}.
      </paragraph>
      <paragraph label="Definition 8">
       Externally supported setLet {a mathematical formula}AC be an aggregate context, Π a program, and {a mathematical formula}A a structure of σ such that {a mathematical formula}τ(Π)⊆σ. A set of ground atoms {a mathematical formula}S⊆[Pint(Π)]A is externally supported (under {a mathematical formula}AC, Π, and {a mathematical formula}A) if there exists a ground atom {a mathematical formula}P(a)∈S and a rule r of the form {a mathematical formula}P(x)←Body(r) with local variables {a mathematical formula}yr, such that for some assignment of the form {a mathematical formula}xyr/abr,
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}A⊨Body(r)[xyr/abr];
       </list-item>
       <list-item label="•">
        {a mathematical formula}(Pos(r)∖PosAgg(r))[xyr/abr]∩S=∅;
       </list-item>
       <list-item label="•">
        For all aggregate atoms {a mathematical formula}δ∈PosAgg(r) of the form (1),{a mathematical formula} where α is the assignment of the form {a mathematical formula}xyrwv/abrcwcv, and {a mathematical formula}cw and {a mathematical formula}cv are tuples of domain elements.
       </list-item>
      </list>
      <paragraph label="Lemma 1">
       {sup:6}Let{a mathematical formula}ACbe an aggregate context, Π a program, and{a mathematical formula}Aa structure of{a mathematical formula}τ(Π). Then,{a mathematical formula}Ais a stable model of Π if and only if{a mathematical formula}A⊨Πˆand every{a mathematical formula}S⊆[Pint(Π)]Ais externally supported.
      </paragraph>
      <paragraph label="Proof">
       Suppose that {a mathematical formula}Pint(Π)={P1,…,Pn}. Let {a mathematical formula}U={U1,…,Un} be a set of new predicates such that for each {a mathematical formula}1≤i≤n, {a mathematical formula}Ui has the same arity of {a mathematical formula}Pi.(⇒) Since {a mathematical formula}A⊨SM(Π), we have {a mathematical formula}A⊨Πˆ. It suffices to show that every set {a mathematical formula}S⊆[Pint(Π)]A is externally supported. We prove this by contradiction. Assume that there exists a set {a mathematical formula}S⊆[Pint(Π)]A that is not externally supported. We construct a structure {a mathematical formula}U of {a mathematical formula}τ(Π)∪U as follows:
       <list>
        {a mathematical formula}Dom(U)=Dom(A) and {a mathematical formula}fU and {a mathematical formula}fA are identical;{a mathematical formula}cU=cA for each constant {a mathematical formula}c∈τ(Π);{a mathematical formula}PU=PA for each predicate {a mathematical formula}P∈τ(Π);{a mathematical formula}UiU=PiA∖{a|Pi(a)∈S} for {a mathematical formula}1≤i≤n.As we assume that
       </list>
       <paragraph>
        S is not externally supported, by Definition 8, we have
       </paragraph>
       <list>
        <list-item label="(1)">
         either there exists an atom {a mathematical formula}β∈Pos(r)∖PosAgg(r) such that {a mathematical formula}β[xyr/abr]∈S,
        </list-item>
        <list-item label="(2)">
         or there exists an aggregate atom δ of the form (1) such that{a mathematical formula} does not hold.
        </list-item>
       </list>
       <paragraph>
        In both cases, we will show that {a mathematical formula}U⊭Body(r)⁎[xyr/abr], which is a contradiction.(1) We already have {a mathematical formula}β[xyr/abr]∈S, so {a mathematical formula}U⊭β⁎[xyr/abr]. It follows {a mathematical formula}U⊭Body(r)⁎[xyr/abr].(2) By the construction of {a mathematical formula}U, for every {a mathematical formula}cw∈Dom(A)|w| and {a mathematical formula}cv∈Dom(A)|v|,{a mathematical formula} if and only if{a mathematical formula} Therefore,{a mathematical formula} By (14), we have that{a mathematical formula} does not hold. Therefore,{a mathematical formula} and {a mathematical formula}U⊭Body(r)⁎[xyr/abr].(⇐) Since {a mathematical formula}A⊨Πˆ, it suffices to show that{a mathematical formula} Again, we prove this by contradiction. Otherwise, let {a mathematical formula}U be a structure of {a mathematical formula}τ(Π)∪U such that {a mathematical formula}U is an expansion of {a mathematical formula}A and{a mathematical formula} Let {a mathematical formula}S={P(a)|a∈PiA∖UiU,Pi∈Pint(Π)}. By (16), S is not empty. Since S is externally supported, there exist a rule r of the form (4) and an assignment {a mathematical formula}xyr/abr such that
       </paragraph>
       <list>
        <list-item label="•">
         {a mathematical formula}Head(r)[xyr/abr]∈S and {a mathematical formula}A⊨Body(r)[xyr/abr];
        </list-item>
        <list-item label="•">
         {a mathematical formula}(Pos(r)∖PosAgg(r))[xyr/abr]∩S=∅;
        </list-item>
        <list-item label="•">
         For all aggregate atoms {a mathematical formula}δ∈PosAgg(r) of the form (1),{a mathematical formula}
        </list-item>
       </list>
       <paragraph>
        By the construction of {a mathematical formula}U, we have {a mathematical formula}U⊨Body(r)⁎[xyr/abr] since
       </paragraph>
       <list>
        <list-item label="•">
         for negative atoms, {a mathematical formula}U⊨¬γj[xyr/abr],(1≤j≤m);
        </list-item>
        <list-item label="•">
         for positive non-aggregate atoms {a mathematical formula}β∈Pos(r)∖PosAgg(r), {a mathematical formula}U⊨β⁎[xyr/abr];
        </list-item>
        <list-item label="•">
         for positive aggregate atoms {a mathematical formula}δ∈PosAgg(r),{a mathematical formula} and{a mathematical formula}
        </list-item>
       </list>
       <paragraph>
        We also have that {a mathematical formula}U⊭Head(r)⁎[xyr/abr]. This is a contradiction since {a mathematical formula}U⊨r⁎[xyr/abr] by (16). This completes our proof.  □
       </paragraph>
      </paragraph>
      <paragraph>
       Now, we are ready to prove our main theorem.
      </paragraph>
      <paragraph label="Proof">
       (⇒) By Lemma 1, for every set {a mathematical formula}S⊆[Pint(Π)]A, S is externally supported. We first define a level mapping, denoted by lm, from the set of ground atoms {a mathematical formula}[Pint(Π)]A to the numbers. Consider the following procedure:
       <list>
        Let {a mathematical formula}i=0, and {a mathematical formula}T=[Pint(Π)]A be the set of atoms whose levels are still undefined.If {a mathematical formula}T=∅, then quit. Otherwise, T is externally supported, so there exist a ground atom {a mathematical formula}P(a)∈T and a rule r of the form {a mathematical formula}P(x)←Body(r) with local variables {a mathematical formula}yr, such that for some assignment of the form {a mathematical formula}xyr/abr,Let {a mathematical formula}lm(P(a))=i, {a mathematical formula}i=i+1, and {a mathematical formula}T=T∖{P(a)}.Go back to (II).(⇐) Since
       </list>
       <paragraph>
        {a mathematical formula}A′⊨OC(Π), then {a mathematical formula}A′⊨Πˆ. Therefore, the reduct of {a mathematical formula}A′ on {a mathematical formula}τ(Π) is a model of {a mathematical formula}Πˆ since {a mathematical formula}Πˆ mentions no comparison predicates. It remains to show that for all {a mathematical formula}S⊆[Pint(Π)]A′, S is externally supported. Otherwise, there exists {a mathematical formula}S⊆[Pint(Π)]A′ that is not externally supported. In the following, we will construct an infinite sequence of ground atoms:{a mathematical formula} such that
       </paragraph>
       <list>
        <list-item label="(i)">
         {a mathematical formula}Pi(ai)∈S, {a mathematical formula}i≥1;
        </list-item>
        <list-item label="(ii)">
         {a mathematical formula}A′⊨≤Pi+1Pi(ai+1ai)∧¬≤PiPi+1(aiai+1), {a mathematical formula}i≥1;
        </list-item>
        <list-item label="(iii)">
         {a mathematical formula}Pi(ai)≠Pj(aj), {a mathematical formula}i≠j.
        </list-item>
       </list>
       <paragraph>
        This is a contradiction since S is finite. By {a mathematical formula}A′⊨Trans(Π), we only need to consider (i) and (ii), since (iii) is a consequence of (ii). We construct the sequence by induction. Assume that {a mathematical formula}P1(a1) is a ground atom in S. If we already have {a mathematical formula}P1(a1),…,Pi(ai), we will find {a mathematical formula}Pi+1(ai+1) as follows. Since {a mathematical formula}A′⊨Pi(ai) and {a mathematical formula}A′ is a model of {a mathematical formula}OC(Π), there exists a rule {a mathematical formula}Pi(x)←Body(r) with local variables {a mathematical formula}yr and an assignment {a mathematical formula}xyr/aibr such that{a mathematical formula} By assumption, S is not externally supported. Consider the rule r and the assignment {a mathematical formula}xyr/aibr,
       </paragraph>
       <list>
        <list-item label="•">
         either there is an atom {a mathematical formula}β∈Pos(r)∖PosAgg(r) such that {a mathematical formula}β[xyr/aibr]∈S,
        </list-item>
        <list-item label="•">
         or there is an aggregate atom δ of the form (1) such that{a mathematical formula} where{a mathematical formula}
        </list-item>
       </list>
       <paragraph>
        This completes the proof.  □
       </paragraph>
      </paragraph>
     </section>
     <section label="3.3">
      <section-title>
       A negative result on non-convex aggregates
      </section-title>
      <paragraph>
       Theorem 1 shows that the stable models of a normal program with convex aggregates can be captured by its ordered completion. However, this result does not hold for non-convex aggregates. Consider the following example.
      </paragraph>
      <paragraph label="Example 9">
       Let {a mathematical formula}Π2 be the following program with a single rule:{a mathematical formula} Here, P is the only intensional predicate and {a mathematical formula}R1,R2 are extensional predicates. Now let {a mathematical formula}M be a structure on {a mathematical formula}τ(Π2) such that{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} In addition, let {a mathematical formula}M′ be a {a mathematical formula}τ(Π2)≤-structure expanded from {a mathematical formula}M such that{a mathematical formula} We now show that, under the non-convex aggregate context {a mathematical formula}AC2 in Example 2, {a mathematical formula}M′ is a model of {a mathematical formula}OC(Π2) but {a mathematical formula}M is not a stable model of {a mathematical formula}Π2.On the one side, {a mathematical formula}OC(Π2) is the conjunction of {a mathematical formula}Trans(Π2) and the following sentences:{a mathematical formula}{a mathematical formula} It is obvious that {a mathematical formula}M′⊨Trans(Π2). To show {a mathematical formula}M′ is a model of (25), it suffices to verify that{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} To show {a mathematical formula}M′ is a model of (26), it suffices to verify that{a mathematical formula}{a mathematical formula}On the other side, to show that {a mathematical formula}M is not a stable of {a mathematical formula}Π2, it suffices to show that {a mathematical formula}M is not a model of (8). Indeed, let {a mathematical formula}U′={a}⊂PM. Then we have {a mathematical formula}M⊨U&lt;P[U/U′] and {a mathematical formula}M⊨r1⁎[U/U′]. Hence, {a mathematical formula}M⊭¬∃U(U&lt;P∧r1⁎). □
      </paragraph>
      <paragraph>
       In fact, convex aggregate is a maximal subclass for this task. That is, for any given non-convex aggregate context, we can always construct a normal program with these aggregates such that it can never be captured in first-order logic with the same type of aggregates, providing some general assumptions in the complexity theory. Actually, we can prove a stronger result that normal programs under any given non-convex aggregate context are able to capture the full expressive power of disjunctive programs (without aggregates).
      </paragraph>
      <paragraph>
       First of all, we introduce some background. A disjunctive program with aggregates (or disjunctive program) is a finite set of disjunctive rules of the form{a mathematical formula} where {a mathematical formula}αi ({a mathematical formula}1≤i≤k) are standard atoms, {a mathematical formula}βi ({a mathematical formula}1≤i≤l), and {a mathematical formula}γj ({a mathematical formula}1≤j≤m) are atoms. The stable models of a disjunctive program are defined as the models of {a mathematical formula}SM(Π), where {a mathematical formula}SM(Π) is the same as (8) except that for a disjunctive rule r of the form (27), {a mathematical formula}r⁎ is the universal closure of the formula{a mathematical formula}
      </paragraph>
      <paragraph>
       Our negative result is inspired by Ferraris' work [16]. In order to obtain the complexity results for propositional normal programs with arbitrary aggregate atom, Ferraris proved the following two facts:
      </paragraph>
      <paragraph>
       (Fact 1) Every propositional disjunctive rule of the form{a mathematical formula} can be equivalently transformed into a set of rules with implications in the bodies as follows{a mathematical formula}(Fact 2) An implication {a mathematical formula}p→q is strongly equivalent to the following aggregate atom{a mathematical formula} where two expressions are said to be strongly equivalent in Answer Set Programming if replacing one by another in any logic program does not change the answer sets.
      </paragraph>
      <paragraph>
       Therefore, any propositional disjunctive program without aggregate atom can be equivalently transformed into a propositional normal program with aggregates similar to (30). As a consequence, the complexity of checking the existence of answer sets of propositional normal program with arbitrary aggregate atom is {a mathematical formula}Σ2P-complete, which is higher than that of normal program with monotone and antimonotone aggregate atom (NP-complete).
      </paragraph>
      <paragraph>
       We extend Ferraris' result in an essential way in the sense that the above procedure can be applied for every non-convex aggregate context. That is, given any non-convex aggregate context, we can use it to simulate implications, thus to simulate disjunctive rules. The full proof of this result in the first-order case is rather technical and tedious. We provide a sketch of the proof here, and leave the very long detailed full proof in Appendix A.
      </paragraph>
      <paragraph label="Lemma 2">
       Let{a mathematical formula}ACbe a polynomial and non-convex aggregate context. Then, on finite structures, every disjunctive program{a mathematical formula}ΓDwithout aggregates can be polynomially translated into a normal program{a mathematical formula}ΓNwith some aggregates from{a mathematical formula}AC.
      </paragraph>
      <paragraph label="Proof">
       (Sketch). First, since {a mathematical formula}AC is a non-convex aggregate context, there exist three multisets {a mathematical formula}M1,M2,M3 such that {a mathematical formula}op(M1)⪯N and {a mathematical formula}op(M3)⪯N hold while {a mathematical formula}op(M1)⪯N does not hold, where {a mathematical formula}op∈ACag is an aggregate symbol, {a mathematical formula}⪯∈ACop is a comparison operator, and {a mathematical formula}N∈ACnum is a number. Let
       <list>
        {a mathematical formula}M1={{m1,…,mN1}};{a mathematical formula}M2∖M1={{mN1+1,…,mN2}};{a mathematical formula}M3∖M2={{mN2+1,…,mN3}},Then, we introduce some new predicates and constants to build the program
       </list>
       <paragraph>
        {a mathematical formula}ΓN. Let {a mathematical formula}QD1,…QDN3 be {a mathematical formula}N3 new predicates. The program {a mathematical formula}ΓN contains some rules and constraints such that if {a mathematical formula}M is a stable model of {a mathematical formula}ΓN, then {a mathematical formula}M⊨QDi(di), if and only if {a mathematical formula}fM(diM)=mi, where {a mathematical formula}di ({a mathematical formula}1≤i≤N3) is a tuple of new constants. In addition, let {a mathematical formula}QM1,QM2,QM3 be three new predicates. With the help of {a mathematical formula}QD1,…QDN3, the program {a mathematical formula}ΓN is built such that if {a mathematical formula}M is a stable model of {a mathematical formula}ΓN, then{a mathematical formula}{a mathematical formula}{a mathematical formula} where cn is a new constant for N. Note that such {a mathematical formula}M does not exist if the aggregate context is convex.Furthermore, for every rule r of the form (27) and two atoms {a mathematical formula}Pi(vi),Pj(vj) ({a mathematical formula}1≤i,j≤k) in {a mathematical formula}Head(r), a new predicate {a mathematical formula}Qr,i,j is introduced. With some carefully defined rules and constraints in {a mathematical formula}ΓN and the new predicates introduced above, the aggregate {a mathematical formula}op〈x:Qr,i,j(x,vi,vj)〉⪯cn behaves exactly the same as the implication {a mathematical formula}Pj(vi)→Pi(vi). This is similar to the (Fact 2) in Ferraris' work [16].Now, we present the main idea of the translation. The normal program with aggregates {a mathematical formula}ΓN has three parts of the rules:{a mathematical formula} where {a mathematical formula}AGG is a set of normal rules with aggregates which could simulate the disjunctive rules, and {a mathematical formula}DEF and {a mathematical formula}CST are sets of rules to define the new predicates.Let {a mathematical formula}r∈ΓD∖ΓD⊥ be a rule of the form (27). Then, r is translated into k rules in {a mathematical formula}ΓN of the form:{a mathematical formula} where:
       </paragraph>
       <list>
        <list-item label="•">
         {a mathematical formula}1≤i≤k, and k is the number of atoms in the head of r,
        </list-item>
        <list-item label="•">
         {a mathematical formula}P1(v1),…,Pk(vk) are atoms in the head of r,
        </list-item>
        <list-item label="•">
         x is a tuple of distinct new variables,
        </list-item>
        <list-item label="•">
         {a mathematical formula}NotLitsNew(Var(r)) denotes the set of negative atoms of the form {a mathematical formula}notx=c, where x is a variable in r and c is a new constant not in {a mathematical formula}τ(ΓD).
        </list-item>
       </list>
       <paragraph>
        Intuitively, the rules defined above play the same roles in first-order case as those rules (29) do in the propositional case. This is similar to (Fact 1) in Ferraris' work [16].Finally, we show that a structure {a mathematical formula}MD on {a mathematical formula}τ(ΓD) is a stable model of {a mathematical formula}ΓD if and only if there is a structure {a mathematical formula}MN on {a mathematical formula}τ(ΓN) such that {a mathematical formula}MN is a stable model of {a mathematical formula}ΓN, where {a mathematical formula}MD and {a mathematical formula}MN agree on all interpretations of predicates and constants in {a mathematical formula}τ(ΓD).  □
       </paragraph>
      </paragraph>
      <paragraph>
       Our negative result follows from Lemma 2 since disjunctive programs without aggregates can capture the complexity class {a mathematical formula}Σ2P[9] but first-order logic with new predicates can only capture the complexity class NP[15].
      </paragraph>
      <paragraph label="Theorem 2">
       Let{a mathematical formula}ACbe a polynomial and non-convex aggregate context. Then, there exists a normal program with aggregates Π such that it cannot be translated into any first-order sentences (with extra predicates) on finite structures with the aggregate context{a mathematical formula}ACunless{a mathematical formula}NP=coNP.
      </paragraph>
      <paragraph label="Proof">
       By Lemma 2, the following program {a mathematical formula}ΠD3-uncolor (a disjunctive program without aggregates) for 3-uncolorability can be translated into a normal program with aggregates {a mathematical formula}ΠN3-uncolor:{a mathematical formula}Assume that {a mathematical formula}NP≠coNP. As 3-uncolorability is a coNP-complete problem, by Fagin's theorem [15], it cannot be captured in existential second-order logic on finite structures. Note that adding polynomial aggregate atoms into first-order logic (existential second-order logic) does not increase the expressive power in finite model theory. So 3-uncolorability cannot be captured in existential second-order logic with polynomial aggregates either. Hence, it cannot be translated into any first-order sentences (with extra predicates) on finite structures with the polynomial aggregate context {a mathematical formula}AC.  □
      </paragraph>
     </section>
    </section>
    <section label="4">
     <section-title>
      Implementation and experimental results
     </section-title>
     <paragraph>
      Based on Theorem 1, we have implemented a new system, called GROCv2 (GRounder on Ordered Completion Version 2), for computing answer sets of first-order normal logic programs with convex aggregates. This work is an extension of the prototype implementation GROC [2], which can only handle normal programs without aggregates.
     </paragraph>
     <paragraph>
      Following the basic ideas of GROC, GROCv2 computes the answer sets of a normal program with convex aggregates together with an extensional database as follows.
     </paragraph>
     <list>
      <list-item label="1.">
       First, GROCv2 translates the program into its enhanced ordered completion (see Definition 7).
      </list-item>
      <list-item label="2.">
       Then, GROCv2 grounds the ordered completion into propositional theories (with modular theories for dealing with comparison predicates) based on the extensional database.
      </list-item>
      <list-item label="3.">
       Finally, GROCv2 calls an SMT solver to compute a classical model of the propositional theories, which is corresponding to an answer set of the original program with the extensional database according to Theorem 1.
      </list-item>
     </list>
     <paragraph>
      Note that this is significantly different from traditional ASP solvers that ground the logic programs directly into propositional programs. There are several potential benefits. First of all, the classical first-order semantics is much simpler than the stable model semantics. Therefore, more solving techniques, e.g. heuristic methods and simplification techniques, can be applied. Secondly, the results of grounding in GROCv2 are propositional theories, which can normally be solved more easily than propositional programs. Thirdly, Step 1 is a polynomial translation and it can be done offline. Moreover, some traditional techniques might be used here to simplify the first-order formula. Finally, Step 3 calls an SMT solver, which is used as a black box. Hence, it can be improved by new advances in the SAT/SMT community.
     </paragraph>
     <paragraph>
      The main disadvantage of GROCv2 is that a number of new predicates (namely the comparison predicates) are introduced, which would potentially result in a bigger grounding theory. In principle, this is certainly the case. That is, ordered completion needs to introduce {a mathematical formula}n2 number of new predicates, where n is the number of intensional predicates in the program. However, in practice, the actual cost is not that much for many benchmark problems. One reason is that we only need to introduce the comparison predicates for those predicates in the same strongly connected component in the predicate dependency graph. This will significantly reduce the number of new predicates introduced. For instance, for the traveling salesman problem, we only need to introduce 1 (instead of 9) comparison predicate.
     </paragraph>
     <paragraph>
      Also, note that we use SMT solvers in Step 3 instead of SAT solvers in GROCv2. The only reason is that SMT solvers are more efficient for dealing with comparison atoms and aggregates. In principle, one can use a SAT solver instead.
     </paragraph>
     <paragraph>
      The key part of GROCv2 is Step 2 – the grounder that transforms the ordered completion together with an extensional database into propositional theories (with modular theories and aggregates). For this purpose, we first introduce some background about propositional SMT (Satisfiability Modulo Theories) with aggregates. In general, propositional SMT formulas are classical propositional formulas enhanced with a modular theory to express some components that cannot be easily handled in propositional logic, for instance {a mathematical formula}3x+y≤10. However, for dealing with comparison atoms mentioned in this paper, we only need a simple modular theory to compare the values of two numbers mapped from propositional atoms.
     </paragraph>
     <paragraph label="Definition 9">
      Let {a mathematical formula}D be a set of propositional atoms. A propositional SMT formula with aggregates (or SMT formula for short) on {a mathematical formula}D is defined as{a mathematical formula} where {a mathematical formula}α,α1,α2∈D, {a mathematical formula}op∈AG is an aggregate symbol, {a mathematical formula}⪯∈CO is a comparison symbol, {a mathematical formula}c1,…,ck∈Z are integer constants, and {a mathematical formula}ϕ1,…,ϕk are SMT formulas.
     </paragraph>
     <paragraph>
      The semantics of SMT formulas is similar to that of propositional formulas. Let {a mathematical formula}I⊆D be a set of propositional atoms, and F a function from {a mathematical formula}D to {a mathematical formula}Z. Given an aggregate context {a mathematical formula}AC, the satisfaction relation between a pair {a mathematical formula}(I,F) and an SMT formula ϕ, denoted by {a mathematical formula}(I,F)⊨ACϕ (or simply {a mathematical formula}(I,F)⊨ϕ if {a mathematical formula}AC is clear from the context), is defined as:
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨AC⊤;
      </list-item>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨ACα, if α is an atom and {a mathematical formula}α∈I;
      </list-item>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨AC(α1,α2)&lt;, if {a mathematical formula}F(α1)&lt;F(α2);
      </list-item>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨ACop〈c1:ϕ1,…,ck:ϕk〉⪯c, if {a mathematical formula}op∈ACag, {a mathematical formula}⪯∈ACco, M is in the domain of {a mathematical formula}opAC and {a mathematical formula}opAC(M)⪯c, where{a mathematical formula}
      </list-item>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨ACϕ1∧ϕ2, if {a mathematical formula}(I,F)⊨ACϕ1 and {a mathematical formula}(I,F)⊨ACϕ2;
      </list-item>
      <list-item label="•">
       {a mathematical formula}(I,F)⊨AC¬ϕ1, if it is not the case that {a mathematical formula}(I,F)⊨ACϕ1.
      </list-item>
     </list>
     <paragraph>
      A set of propositional atoms {a mathematical formula}I⊆D is a model of ϕ if there exists a function F from {a mathematical formula}D to {a mathematical formula}Z such that {a mathematical formula}(I,F)⊨ϕ.
     </paragraph>
     <paragraph>
      Now, we are able to ground a first-order formula with aggregates into SMT formulas defined above under a given domain. Let σ and {a mathematical formula}σ′ be two signatures such that they contain the same constants and the set of predicates in {a mathematical formula}σ′ is a subset of that in σ. Let {a mathematical formula}A be a structure on {a mathematical formula}σ′. By {a mathematical formula}DA, we denote the set{a mathematical formula} Let Φ be a first-order formula with aggregates on {a mathematical formula}σ≤, and {a mathematical formula}y/a an assignment such that {a mathematical formula}free(Φ)⊆y. The grounding of Φ on {a mathematical formula}x/a with respect to {a mathematical formula}A, denoted by {a mathematical formula}GRA(Φ,y/a), is an SMT formula defined recursively as follows:
     </paragraph>
     <list>
      <list-item label="•">
       ⊤, if {a mathematical formula}Φ=α is either an equality atom or a standard atom of the form {a mathematical formula}P(t) such that P is a predicate in {a mathematical formula}σ′, and {a mathematical formula}A⊨α[y/a];
      </list-item>
      <list-item label="•">
       ¬⊤, if {a mathematical formula}Φ=α is either an equality atom or a standard atom of the form {a mathematical formula}P(t) such that P is a predicate in {a mathematical formula}σ′, and {a mathematical formula}A⊭α[y/a];
      </list-item>
      <list-item label="•">
       {a mathematical formula}P(t)[y/a], if {a mathematical formula}Φ=P(t) is a standard atom such that P is a predicate in σ but not in {a mathematical formula}σ′;
      </list-item>
      <list-item label="•">
       {a mathematical formula}(P(t1)[y/a],Q(t2)[y/a])&lt;, if {a mathematical formula}Φ=≤PQ(t1t2) such that {a mathematical formula}≤PQ is a comparison predicate in {a mathematical formula}σ≤;
      </list-item>
      <list-item label="•">
       {a mathematical formula}op〈M⁎〉⪯fA(t[y/a]), if {a mathematical formula}Φ=δ is an aggregate atom of the form (1), where{a mathematical formula} and{a mathematical formula}
      </list-item>
      <list-item label="•">
       {a mathematical formula}¬GRA(Φ1,y/a), if Φ is of the form {a mathematical formula}¬Φ1;
      </list-item>
      <list-item label="•">
       {a mathematical formula}GRA(Φ1,y/a)∨GRA(Φ2,y/a), if Φ is of the form {a mathematical formula}Φ1∨Φ2;
      </list-item>
      <list-item label="•">
       {a mathematical formula}GRA(⋀a∈Dom(A)Φ1[y/a],y/a), if Φ is of the form {a mathematical formula}∀yΦ1.
      </list-item>
     </list>
     <paragraph>
      If Φ is a formula without free variables, then the grounding of Φ with respect to {a mathematical formula}A is simply written as {a mathematical formula}GRA(Φ).
     </paragraph>
     <paragraph>
      The following theorem shows that we can compute the models of ordered completions by grounding.
     </paragraph>
     <paragraph label="Theorem 3">
      Let Π be a program, and{a mathematical formula}Aea finite structure on{a mathematical formula}τext(Π). Let{a mathematical formula}Abe a structure on{a mathematical formula}τ(Π)≤, which is an expansion of{a mathematical formula}Aeand{a mathematical formula}A⊨Trans(Π). Then,{a mathematical formula}A⊨OC(Π)iff{a mathematical formula}IA⊨GRAe(OC(Π)), where{a mathematical formula}
     </paragraph>
     <paragraph label="Proof">
      Let {a mathematical formula}P(a), {a mathematical formula}Q(b), and {a mathematical formula}R(c) be three elements in {a mathematical formula}IA. Since {a mathematical formula}A⊨Trans(Π), we have {a mathematical formula}A⊨≤PQ(xy)∧≤QR(yz)→≤PR(xz)[xyz/abc].Therefore, there exists a function {a mathematical formula}FA from {a mathematical formula}IA to {a mathematical formula}Z such that:
      <list>
       {a mathematical formula}FA(P(a))≠FA(Q(b)) if {a mathematical formula}P(a) and {a mathematical formula}Q(b) are different;{a mathematical formula}FA(P(a))&lt;FA(Q(b)) if and only if {a mathematical formula}A⊨≤PQ(xy)[xy/ab].It suffices to prove the following result.
      </list>
      <paragraph>
       Let Φ be a formula on{a mathematical formula}τ(Π)≤, and{a mathematical formula}y/aan assignment such that{a mathematical formula}free(Φ)⊆y. Then,{a mathematical formula}A⊨Φ[y/a]if and only if{a mathematical formula}(IA,FA)⊨GRAe(Φ,y/a).We prove this by induction on the structure of Φ.
      </paragraph>
      <list>
       <list-item label="•">
        It is straightforward that {a mathematical formula}A⊨⊤ if and only if {a mathematical formula}(IA,FA)⊨GRAe(⊤), and {a mathematical formula}A⊨P(t)[y/a] if and only if {a mathematical formula}(IA,FA)⊨GRAe(P(t),y/a), where {a mathematical formula}P∈τext(Π).
       </list-item>
       <list-item label="•">
        For intensional predicate {a mathematical formula}P∈τint(Π), we also have {a mathematical formula}A⊨P(t)[y/a] if and only if {a mathematical formula}IA⊨GRAe(P(t),y/a) by noticing that {a mathematical formula}P(a)∈IA if and only if {a mathematical formula}a∈PA for every tuple a that matches the arity of P.
       </list-item>
       <list-item label="•">
        For a comparison atom {a mathematical formula}≤PQ(t1t2), {a mathematical formula}A⊨≤PQ(t1t2)[y/a], where {a mathematical formula}free(t1t2)⊆y, if and only if{a mathematical formula} if and only if{a mathematical formula} if and only if{a mathematical formula}
       </list-item>
       <list-item label="•">
        If {a mathematical formula}Φ=δ is an aggregate atom of the form (1) such that {a mathematical formula}free(Φ)⊆y, we will show that {a mathematical formula}A⊨δ[y/a] if and only if {a mathematical formula}(IA,FA)⊨GRAe(δ,y/a). Consider the following set and multiset:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} We have {a mathematical formula}M1=M2 by noticing that{a mathematical formula} if and only if{a mathematical formula} if and only if{a mathematical formula} Hence, {a mathematical formula}A⊨δ[y/a] if and only if {a mathematical formula}(IA,FA)⊨GRAe(δ,y/a).
       </list-item>
       <list-item label="•">
        If Φ is of the form {a mathematical formula}¬Φ1, {a mathematical formula}Φ1∧Φ2 and {a mathematical formula}∀xΦ1, it is also straightforward to see that {a mathematical formula}A⊨Φ[y/a] if and only if {a mathematical formula}(IA,FA)⊨GRAe(Φ,y/a). □
       </list-item>
      </list>
     </paragraph>
     <paragraph>
      Based on Theorem 3, we have implemented a new solver GROCv2. Now we report some experimental results. We use Z3 (version 4.3.2){sup:7} in GROCv2 as the underlying SMT solver. We compare our approach GROCv2 + Z3 with three state-of-the-art ASP solvers, namely DLV (version 4.2.1),{sup:8} CLASP (version 3.0.0),{sup:9} and CMODELS (version 3.85).{sup:10} We use GRINGO (version 3.0.5){sup:11} as the grounder for the solvers CLASP and CMODELS. The reason why we choose CLASP, DLV, and CMODELS here is because the first two are representative ASP solvers based on conflict analysis, while the last is a representative solver based on loop formulas.
     </paragraph>
     <paragraph>
      We are mainly interested in non-tight programs as for tight programs, ordered completion is just Clark's completion. In this paper, we consider three benchmark programs, the bounded-traveling salesman problem, the Nurikabe puzzle, and the weight-bounded dominating set problem.
     </paragraph>
     <paragraph>
      Table 1, Table 2 report our results for the bounded traveling salesman program. Here, Table 1 contains the results for our randomly generated instances while Table 2 contains the results taken from the ASPARAGUS benchmark suite.{sup:12} For randomly generated instances, “rand_x_y_i” represents a random graph with x number of nodes and y edges and of instance i. We set the timeouts to be 1000.00 s, denoted by “—” in the tables. Note that we also include the grounding time for CLASP as well as CMODELS. For clarity, we pick up the best solver for each instance, highlighted by bold fonts. From Table 1, Table 2, it can be observed that GROCv2 + Z3 and GRINGO + CLASP outperform DLV and GRINGO + CMODELS in most cases on the bounded traveling salesman program while the previous two solvers are comparable. Interestingly, for randomly generated instances, GROCv2 + Z3 seems to have an advantage over GRINGO + CLASP on big problem instances.
     </paragraph>
     <paragraph>
      Table 3 reports the experimental results on the Nurikabe puzzle. Here, we omit the results of DLV as it seems not to return the correct answers. One can obtain a similar conclusion on this program. That is, GROCv2 + Z3 and GRINGO + CLASP are slightly better than GRINGO + CMODELS and the previous two are comparable with each other. Again, for randomly generated instances, the bigger the problem is, the better GROCv2 + Z3 performs in comparison with GRINGO + CLASP. Table 4 reports our experiments on the weight-bounded dominating set program with the instances from the ASPARAGUS benchmark suites.{sup:13} On this program, GRINGO + CLASP is the clear winner. In addition, GROCv2 + Z3 performs slightly worse than DLV as well, although it is comparable to GRINGO + CMODELS.
     </paragraph>
     <paragraph>
      To sum up, our solver GROCv2 + Z3 is comparable to other state-of-the-art ASP solvers in the literature. Since this is a first implementation so that many simplified techniques, e.g., first-order simplification of ordered completion, are not employed, we believe that ordered completion provides a new promising way to implement answer set programming. We have done some experimental analysis on other benchmark programs as well, including N-queens, bounded-spanning tree and projected hamiltonian cycle. For more details about our solver and the benchmark program instances, please see the following link http://staff.scm.uws.edu.au/~yzhou/?page_id=212. Unfortunately, the current version of GROCv2 does not support functions so that it is not able to handle some benchmark programs. We leave it to our future investigations.
     </paragraph>
    </section>
    <section label="5">
     <section-title>
      Related work
     </section-title>
     <paragraph>
      As a crucial building block of answer set programs, aggregates are extensively studied in the literature [4], [10], [13], [16], [21], [22], [23]. Although the syntactic form of aggregates is usually presented in a first-order language, its semantics is normally defined propositionally via grounding. Recently, several approaches are proposed to define a genuine first-order semantics for aggregates. An early attempt is due to Lee and Meng [22], although a more restricted form only for the choice and counting aggregates already appeared in [21]. In fact, our semantics for first-order aggregates is essentially equivalent to Lee and Meng's definition, when restricted into the syntax with aggregates of the form (1) although there is a slight difference. Lee and Meng's stable model semantics considers the number constant symbols from {a mathematical formula}Z as part of the signature so that the domains of the underlying structure are assumed to contain the numbers from {a mathematical formula}Z. On the contrary, our notion does not consider numbers in the domain of a structure {a mathematical formula}A. Instead, we use a partial function {a mathematical formula}fA that maps the domain elements of {a mathematical formula}Dom(A) to integers. This is addressed in Definition 3 by the notion of an extended structure. The only difference between extended structures and standard first-order structures is the function {a mathematical formula}fA that maps elements of {a mathematical formula}Dom(A) to {a mathematical formula}Z. It should be noted that our notion of an extended structure generalizes the notion by that of Lee and Meng [22] since we can always map domain elements with number symbols into the numbers they represent, e.g., if {a mathematical formula}Dom(A) contains the number symbols −1 and 3, then we can simply set {a mathematical formula}fA(−1)=−1 and {a mathematical formula}fA(3)=3, where {a mathematical formula}fA will be partially fixed for the number symbols from {a mathematical formula}Z for all structures {a mathematical formula}A. The reason for our notion is that it is more abstract in the sense that it does not consider number symbols in the meta-level. Furthermore, it also allows us to only consider finite domains since Lee and Meng's notion always assumes all numbers from {a mathematical formula}Z to be presented in the domain of all underlying structures.
     </paragraph>
     <paragraph>
      An alternative definition of aggregates is the FLP semantics [13], which is extended into the first-order case recently [4]. The FLP semantics is inherently different from the stable model semantics for aggregates. For instance, the former satisfies the anti-chain property [13] while the latter does not. However, these two semantics coincide if we only allow positive atoms in aggregates, that is, {a mathematical formula}Ng(δ)=∅ for any aggregate atoms of the form (1). In fact, this is the case for many ASP benchmark programs, including the benchmark programs we tested in Section 4.
     </paragraph>
     <paragraph>
      Another aggregate framework that is related to our work is the SP semantics of [30]. The SP semantics of normal programs with aggregates is defined via a fixed point operator that behaves identically to the three-valued immediate consequence operator “{a mathematical formula}ΦPagg” independently proposed in [26]. Although the semantics itself is based on a fixed point type characterization, which is different from our translational approach, this framework is related to our work in the sense that our aggregate syntax of the form (1) is similar to their notion of an intensional multiset of the form{a mathematical formula} where {a mathematical formula}{x,z1,…,zr}⊆y1,…,ym (see Definition 1 of [30]).
     </paragraph>
     <paragraph>
      Aggregates are also defined for HEX programs [10], which is an extension of logic programs by introducing higher order external atoms. The semantics of aggregates in HEX programs is also defined in a similar manner as the FLP semantics. Interestingly, it is shown that external atoms in HEX programs generalize the notion of aggregate atoms [10].
     </paragraph>
     <paragraph>
      Our definition of convex aggregates is a lift of Liu and Truszczyński's notion [23] to the first-order case, although the syntax is presented quite differently. In fact, Liu and Truszczyński observed that normal programs with polynomial, convex aggregates do not increase the computational complexity. For instance, checking the existence of answer sets for normal programs and normal programs with polynomial, convex aggregates are both in NP. However, the negative result that convex aggregate is the maximal subclass for the above property is not considered. In other words, we discover that normal programs with non-convex aggregates will inevitably jump into another complexity level. From Lemma 2, normal programs with non-convex aggregates can capture disjunctive programs, thus checking the existence of answer sets for such programs is {a mathematical formula}Σ2P complete.
     </paragraph>
     <paragraph>
      Our negative result (see Lemma 2 and Theorem 2) is inspired by Ferraris' work [16]. Ferraris' work considered monotone and antimonotone aggregates but not the generalized concept of convex aggregates. He showed that, in the propositional case, there exists an aggregate context such that disjunctive programs can be converted into normal logic programs with aggregate atoms under this context. We further proved that this is the case for all non-convex aggregate context, both in the propositional case and in the first-order case. As a consequence, convex aggregates exactly draw a boundary of the expressive power as well as computational complexity of aggregates in normal logic programs. That is, in the propositional case, the complexity of checking the answer set existence for normal logic programs with any convex aggregate atoms is NP-complete, which is the same as that for normal logic program without aggregates. In contrast, the complexity of checking the answer set existence for normal logic programs under any non-convex aggregate context is {a mathematical formula}Σ2P-complete, which is on a higher complexity level. In the first-order case, our result shows that normal logic programs with any convex aggregate atoms can be converted into first-order logic with the same type of aggregates (see Theorem 1), while this can never be done for normal logic programs under any non-convex aggregate context providing some general assumptions in the complexity theory (see Theorem 2).
     </paragraph>
     <paragraph>
      Interestingly, Alviano and Faber [1] recently have obtained a similar result for the FLP semantics in the propositional case. That is, under the FLP semantics, propositional programs with convex aggregates will not increase the complexity. However, adding a simple non-convex aggregates will result in a complexity jump from the first level of polynomial hierarchy to the second level. In this paper, we are mainly focused on the Ferraris' semantics but not the FLP semantics. Nevertheless, following the proofs, our results hold for the FLP semantics as well. The main difference is that we consider the first-order case instead of the propositional case. We show that convex aggregates draw the boundary not only on complexity but also on expressiveness (i.e., translatability to classic first-order logic with aggregates) as well.
     </paragraph>
     <paragraph>
      Finally, we would address the relation of our work with the first-order loop formulas approach of Lee and Meng [22]. A main difference is that first-order loop formulas work for arbitrary aggregates while our enhanced ordered completion only works for convex aggregates. This is partially because first-order loop formulas are infinite theories in general while ordered completions always produce finite theories. From a semantic viewpoint, loop formulas is about the encoding of the external support of a set of atoms (which is infinite at the first-order level), while the ordered completion is about the encoding of a derivation order, although they both imply the stability of a model for the class of normal program with convex aggregates.
     </paragraph>
    </section>
    <section label="6">
     <section-title>
      Conclusion
     </section-title>
     <paragraph>
      The main contributions of this paper are as follows. Firstly, we extended the notion of ordered completion for first-order programs with aggregates, and showed that the stable models of a program with convex aggregates are corresponding to the models of its ordered completion on finite structures (Theorem 1). This is an important extension as most ASP benchmark programs for real world problems need to use aggregates and these aggregates are indeed convex. Secondly, we showed that convex aggregate is a maximal subclass for the above task. More precisely, given a non-convex aggregate context, we can always construct a normal program under this aggregate context that can never be translated into a first-order sentence with the same type of aggregates providing some assumptions in the complexity theory (Theorem 2). To the best of our knowledge, our negative result is one of the first two results [1] to show that convex aggregates exactly draw a boundary of the expressive power as well as the computational complexity of aggregate atoms in answer set programming. Finally, we showed that we can ground a program with an extensional database into a propositional SMT theory in order to compute the answer sets (Theorem 3). Based on this, we implement an ASP solver and compare it with some modern ASP solvers. The experiments show that this new direction of answer set solving is promising, particularly for non-tight programs on large problem instances.
     </paragraph>
    </section>
   </content>
   <appendices>
    <section label="Appendix A">
     Proof of Lemma 2
     <paragraph label="Lemma 3">
      We present the full proof of Lemma 2 in this section. In the following, we always assume a non-convex aggregate context {a mathematical formula}AC and a disjunctive program {a mathematical formula}ΓD. In Appendix A.1, we will define a translation from {a mathematical formula}ΓD to a normal program {a mathematical formula}ΓN with the same type of aggregates. Lemma 2 can be decomposed into the following two lemmas. Let{a mathematical formula}MNbe a structure on{a mathematical formula}τ(ΓN). If{a mathematical formula}MNis a stable model of{a mathematical formula}ΓN, then there exists a stable model{a mathematical formula}MDof{a mathematical formula}ΓDsuch that{a mathematical formula}MNand{a mathematical formula}MDagree on all interpretations of constants and predicates in{a mathematical formula}τ(ΓD).
     </paragraph>
     <paragraph label="Lemma 4">
      Let{a mathematical formula}MDbe a structure on{a mathematical formula}τ(ΓD). If{a mathematical formula}MDis a stable model of{a mathematical formula}ΓD, then there exists a stable model{a mathematical formula}MNof{a mathematical formula}ΓNsuch that{a mathematical formula}MDand{a mathematical formula}MNagree on all interpretations of constants and predicates in{a mathematical formula}τ(ΓD).
     </paragraph>
     <paragraph>
      Lemma 3 will be shown in Appendix A.2, and Lemma 4 will be shown in Appendix A.3.
     </paragraph>
     <paragraph>
      We first introduce some notations. Recall that the aggregate context {a mathematical formula}AC is non-convex. By Definition 6, there exist three multisets of tuples {a mathematical formula}M1,M2,M3 such that {a mathematical formula}M1⊆M2, {a mathematical formula}op(M1)⪯N and {a mathematical formula}op(M3)⪯N hold while {a mathematical formula}op(M1)⪯N does not hold, where {a mathematical formula}op∈ACag is an aggregate symbol, {a mathematical formula}⪯∈ACop is a comparison operator, and {a mathematical formula}N∈ACnum is a number. Let
     </paragraph>
     <list>
      <list-item label="•">
       {a mathematical formula}M1={{m1,…,mN1}},
      </list-item>
      <list-item label="•">
       {a mathematical formula}M2∖M1={{mN1+1,…,mN2}},
      </list-item>
      <list-item label="•">
       {a mathematical formula}M3∖M2={{mN2+1,…,mN3}},
      </list-item>
     </list>
     <paragraph>
      where {a mathematical formula}N1,N2,N3 are the size of {a mathematical formula}M1,M2,M3 respectively, and {a mathematical formula}0≤N1&lt;N2&lt;N3. Without loss of generality, we assume all tuples in {a mathematical formula}M3 are of the same length K.
     </paragraph>
     <paragraph>
      We introduce some new constants. Let {a mathematical formula}Cnew be a set of new constants{a mathematical formula} where cn is a new constant for N, cc is a special new constant which is used in rule (A.12) for Proposition 5, and the rest of new constants are for the tuples of numbers in {a mathematical formula}M1,M2,M3. We use D to denote the following set of tuples of constants{a mathematical formula} where {a mathematical formula}ds{a mathematical formula}(1≤s≤N3) is the tuple of constants obtained from {a mathematical formula}ms∈M3 by replacing each {a mathematical formula}m∈ms by {a mathematical formula}cm,s. Notice that {a mathematical formula}di and {a mathematical formula}dj{a mathematical formula}(1≤i≠j≤N3) are always different tuples of constants. We use {a mathematical formula}NotLitNew(x) to denote the set of negated atoms{a mathematical formula} where x is a tuple of variables. Intuitively, {a mathematical formula}NotLitNew(x) means that variables in x and constants in {a mathematical formula}Cnew∖{cc} will never be mapped to the same domain elements.
     </paragraph>
     <paragraph>
      We introduce some new predicates for the program. Let {a mathematical formula}Pnew be a set of new predicates{a mathematical formula} where{a mathematical formula}{a mathematical formula}{a mathematical formula} Intuitively, {a mathematical formula}Q is a set of predicates for constructing aggregate atoms, {a mathematical formula}QD for representing elements in a tuple, and {a mathematical formula}QM for encoding {a mathematical formula}M1,M2,M3.
     </paragraph>
     <paragraph>
      Furthermore, we introduce some new predicates and tuples of predicates for the second-order formulas like (8). Let U be a set of new predicates{a mathematical formula} We use {a mathematical formula}PD and {a mathematical formula}UD to denote the tuple of predicates in {a mathematical formula}Pint(ΓD) and the tuple of the correspondence predicates in {a mathematical formula}{UP|P∈Pint(ΓD)} respectively. We use {a mathematical formula}PN and {a mathematical formula}UN to denote the tuple of predicates in {a mathematical formula}Pint(ΓD)∪Pnew and the tuple of the correspondence predicates in {a mathematical formula}U respectively.
     </paragraph>
     <section label="A.1">
      <section-title>
       The translation from disjunctive programs to normal programs with non-convex aggregates
      </section-title>
      <paragraph>
       In this section, we define a normal program with aggregates, denoted by {a mathematical formula}ΓN, which captures the answer sets of {a mathematical formula}ΓD. In general, {a mathematical formula}ΓN is a normal program with aggregates built from {a mathematical formula}τ(ΓD) together with the set of new constants {a mathematical formula}Cnew and the set of new predicates {a mathematical formula}Pnew. It is the union of three sets of rules:{a mathematical formula} where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}AGG is a set of normal rules with aggregates, which simulates the disjunctive rules;
       </list-item>
       <list-item label="•">
        {a mathematical formula}DEF is a set of rules about the new predicates in {a mathematical formula}Q;
       </list-item>
       <list-item label="•">
        {a mathematical formula}CST is a set of rules about the new predicates in {a mathematical formula}QD and {a mathematical formula}QM.
       </list-item>
      </list>
      <paragraph>
       Now we define the sets of rules {a mathematical formula}AGG, {a mathematical formula}DEF and {a mathematical formula}CST. Without loss of generality, we assume that there is no constant in the heads of the rules in {a mathematical formula}ΓD. Otherwise, we remove the constants in the head of a rule by using equalities. For example, {a mathematical formula}P(x,c)←E(x,y) can be rewritten as {a mathematical formula}P(x,z)←E(x,y),z=c when c is a constant.
      </paragraph>
      <paragraph>
       Let {a mathematical formula}r∈ΓD∖ΓD⊥ be a rule of the form (27). Let {a mathematical formula}v1,…,vk be the tuples of variables occurring in {a mathematical formula}α1,…,αk in the head of r. By {a mathematical formula}riN, we denote the rule:{a mathematical formula} where:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}1≤i≤k, and k is the number of atoms in the head of r;
       </list-item>
       <list-item label="•">
        x is a tuple of distinct new variables and {a mathematical formula}|x|=K;
       </list-item>
       <list-item label="•">
        {a mathematical formula}Var(r) is the tuple of variables in r.
       </list-item>
      </list>
      <paragraph>
       We will show that, together with the rules in {a mathematical formula}DEF and {a mathematical formula}CST, normal rules {a mathematical formula}r1N,…,rkN exactly capture the disjunctive rule r. Let {a mathematical formula}AGG be the following set of rules:{a mathematical formula}
      </paragraph>
      <paragraph>
       Then, we define the rules in {a mathematical formula}DEF. Let r be a rule of the form (27), and assume that {a mathematical formula}αi=Pi(vi) and {a mathematical formula}αj=Pj(vj). For every predicate {a mathematical formula}Qr,i,j∈Q, we use {a mathematical formula}DEF(Qr,i,j) to denote the set of rules:{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula}{a mathematical formula} Let {a mathematical formula}DEF be the following set of rules:{a mathematical formula}
      </paragraph>
      <paragraph>
       Finally, let {a mathematical formula}CST be the set of the following rules:
      </paragraph>
      <list>
       <list-item label="•">
        for predicate {a mathematical formula}P∈τ(ΓD), {a mathematical formula}c∈Cnew∖{cc} and {a mathematical formula}1≤i≤j,{a mathematical formula} where j is the arity of P;
       </list-item>
       <list-item label="•">
        for constant {a mathematical formula}c1∈τ(ΓD) and {a mathematical formula}c2∈Cnew∖{cc},{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}c∈Cnew∖{cc},{a mathematical formula}
       </list-item>
       <list-item label="•">
        for two different constants {a mathematical formula}c1,c2∈Cnew∖{cn,cc},{a mathematical formula}
       </list-item>
       <list-item label="•">
        {a mathematical formula}{a mathematical formula}{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}1≤i≤N1,{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}1≤i≤N2,{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}1≤i≤N3,{a mathematical formula}
       </list-item>
       <list-item label="•">
        {a mathematical formula}{a mathematical formula}{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}1≤i≤N3,{a mathematical formula}
       </list-item>
       <list-item label="•">
        for {a mathematical formula}1≤i≤N3 and {a mathematical formula}1≤j≤K,{a mathematical formula} where {a mathematical formula}mi=(m1,…,mj,…,mK) is a tuple in {a mathematical formula}M3.
       </list-item>
      </list>
      <paragraph>
       Given a disjunctive program {a mathematical formula}ΓD, the number of the rules of {a mathematical formula}ΓN is polynomial, and the length of each rule is also polynomial. So, {a mathematical formula}ΓN can be built in polynomial time with respect to the length of {a mathematical formula}ΓD.
      </paragraph>
      <paragraph>
       Next, we prove some propositions which could illustrate why we define these rules. Proposition 2 shows the properties of the sets of new predicates {a mathematical formula}QD and {a mathematical formula}QM. Proposition 3 and Proposition 4 show that the implication can also be simulated by aggregate atoms when the aggregate context is non-convex.
      </paragraph>
      <paragraph label="Proposition 2">
       Let {a mathematical formula}M be a structure on {a mathematical formula}τ(ΓN). We use {a mathematical formula}Dom1(M) and {a mathematical formula}Dom2(M) to denote two subsets of {a mathematical formula}Dom(M) such that{a mathematical formula}{a mathematical formula} We have the following proposition. Let{a mathematical formula}Mbe a structure on{a mathematical formula}τ(ΓN)such that{a mathematical formula}M⊨DEF∪CST. Then,
      </paragraph>
      <list>
       <list-item>
        For predicate{a mathematical formula}P∈τ(ΓD), if{a mathematical formula}a∈PMthen{a mathematical formula}a∈Dom1(M)|a|.
       </list-item>
       <list-item>
        For predicate{a mathematical formula}QDi,{a mathematical formula}(1≤i≤N3),{a mathematical formula}QDiM={diM}.
       </list-item>
       <list-item>
        For predicate{a mathematical formula}QMi(i=1,2,3),{a mathematical formula}QMiM={d1M,…,dNiM}.
       </list-item>
      </list>
      <paragraph label="Proof">
       {a mathematical formula}M is a model of rule (A.10), so (1) holds. {a mathematical formula}M is a model of rules (A.23) and (A.24), so (2) holds. {a mathematical formula}M is a model of rules (A.17), (A.18), (A.19) and (A.20), (A.21), (A.22), so (3) holds.  □
      </paragraph>
      <paragraph label="Proposition 3">
       Let{a mathematical formula}Mbe a structure on{a mathematical formula}τ(ΓN)such that{a mathematical formula}M⊨DEF∪CST. Then,{a mathematical formula}where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}r∈ΓDbe a rule of the form(27),
       </list-item>
       <list-item label="•">
        {a mathematical formula}αi=Pi(vi)and{a mathematical formula}αj=Pj(vj)({a mathematical formula}1≤i≠j≤k) are two atoms in the head of r,
       </list-item>
       <list-item label="•">
        {a mathematical formula}b∈Dom(M)|b|and{a mathematical formula}c∈Dom(M)|c|.
       </list-item>
      </list>
      <paragraph label="Proof">
       The proposition is a direct consequence of the following three statements:
       <list>
        {a mathematical formula}M⊨¬Pj(vj)→(op〈x:Qr,i,j(x,vi,vj)〉⪯cn)[vivj/bc];{a mathematical formula}M⊨(¬Pi(vi)∧Pj(vj))→(op〈x:Qr,i,j(x,vi,vj)〉⪯̸cn)[vivj/bc]; and{a mathematical formula}M⊨(Pi(vi)∧Pj(vj))→(op〈x:Qr,i,j(x,vi,vj)〉⪯cn)[vivj/bc].(2) Assume that
       </list>
       <paragraph>
        {a mathematical formula}M⊨(¬Pi(vi∧Pj(vj))[v1vj/bc]. Let {a mathematical formula}a∈Dom(M)K be a tuple of domain elements. By rules (A.3), (A.4) and (A.7), {a mathematical formula}abc∈Qr,i,jM if and only if there exists {a mathematical formula}1≤s≤N2 such that {a mathematical formula}M⊨QDs(x)[x/a]. Furthermore, by rules (A.18) and (A.21), {a mathematical formula}abc∈Qr,i,jM if and only if {a mathematical formula}a∈QM2M. We have{a mathematical formula} if and only if{a mathematical formula} So, neither rule (A.27) nor rule (A.28) holds, since {a mathematical formula}M is a model of rule (A.15).(3) Assume that {a mathematical formula}M⊨(Pi(vi∧Pj(vj))[v1vj/bc]. Let {a mathematical formula}a∈Dom(M)K be a tuple of domain elements. By rules (A.3), (A.4), (A.5) and (A.8), {a mathematical formula}abc∈Qr,i,jM if and only if there exists {a mathematical formula}1≤s≤N3 such that {a mathematical formula}M⊨QDs(x)[x/a]. Furthermore, by rules (A.19) and (A.22), {a mathematical formula}abc∈Qr,i,jM if and only if {a mathematical formula}a∈QM3M. We have{a mathematical formula} if and only if{a mathematical formula} So, both rule (A.29) and rule (A.30) hold, since {a mathematical formula}M is a model of rule (A.16).  □
       </paragraph>
      </paragraph>
      <paragraph>
       Let {a mathematical formula}M be a structure on {a mathematical formula}τ(ΓN) and {a mathematical formula}U a structure on {a mathematical formula}τ(ΓN)∪UN. {a mathematical formula}U is called a{a mathematical formula}Q-reserve extension of {a mathematical formula}M if {a mathematical formula}U is an extension of {a mathematical formula}M and
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}UPU=UPM if {a mathematical formula}UP∈UN and {a mathematical formula}P∈QD∪QM,
       </list-item>
       <list-item label="•">
        {a mathematical formula}abc∈UPU if and only if at least one of the following holds:{a mathematical formula}{a mathematical formula}{a mathematical formula} where
       </list-item>
      </list>
      <paragraph label="Proposition 4">
       Let{a mathematical formula}Mbe a structure on{a mathematical formula}τ(ΓN)such that{a mathematical formula}M⊨DEF∪CST. If{a mathematical formula}Uis a{a mathematical formula}Q-reserve extension of{a mathematical formula}Mthen,{a mathematical formula}where
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}r∈ΓDis a rule of form(27),
       </list-item>
       <list-item label="•">
        {a mathematical formula}αi=Pi(vi)and{a mathematical formula}αj=Pj(vj)(1≤i≠j≤k)are two atoms in the head of r,
       </list-item>
       <list-item label="•">
        {a mathematical formula}b∈Dom(M)|b|and{a mathematical formula}c∈Dom(M)|c|.
       </list-item>
      </list>
      <paragraph label="Proof">
       The proof is similar to that of Proposition 3. We will show:
       <list>
        {a mathematical formula}U⊨¬UPj(vj)→(op〈x:UQr,i,j(x,vi,vj)〉⪯cn)[vivj/bc]{a mathematical formula}U⊨(¬UPi(vi)∧UPj(vj))→(op〈x:UQr,i,j(x,vi,vj)〉⪯̸cn)[vivj/bc]{a mathematical formula}U⊨(UPi(vi)∧UPj(vj))→(op〈x:UQr,i,j(x,vi,vj)〉⪯cn)[vivj/bc](2) Assume that
       </list>
       <paragraph>
        {a mathematical formula}U⊨(¬UPi(vi∧UPj(vj))[v1vj/bc]. Let {a mathematical formula}a∈Dom(M)K be a tuple of domain elements. By (A.31), if {a mathematical formula}abc∈Qr,i,jM, then {a mathematical formula}a∈QM2M. We have{a mathematical formula} if and only if{a mathematical formula} So, neither rule (A.36) nor rule (A.37) holds, since {a mathematical formula}U is a model of rule (A.15), and {a mathematical formula}QM2U=UQM2U.(3) Assume that {a mathematical formula}U⊨(UPi(vi∧UPj(vj))[v1vj/bc]. Let {a mathematical formula}a∈Dom(M)K be a tuple of domain elements. By (A.33), if {a mathematical formula}abc∈Qr,i,jM then {a mathematical formula}a∈QM3M. We have{a mathematical formula} if and only if{a mathematical formula} So, both rule (A.38) and rule (A.39) hold, since {a mathematical formula}U is a model of rule (A.16), and {a mathematical formula}QM3U=UQM3U.  □
       </paragraph>
      </paragraph>
     </section>
     <section label="A.2">
      The proof of Lemma 3
      <paragraph>
       In this section, we will show that if {a mathematical formula}MN is a stable model of {a mathematical formula}ΓN, then there exists a stable model {a mathematical formula}MD of {a mathematical formula}ΓD such that {a mathematical formula}MN and {a mathematical formula}MD agree on all interpretations of constants and predicates in {a mathematical formula}τ(ΓD).
      </paragraph>
      <paragraph>
       Let {a mathematical formula}MN be a stable model of {a mathematical formula}ΓN. By {a mathematical formula}MD, we denote the structure on {a mathematical formula}τ(ΓD) such that
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}Dom(MD)=Dom1(MN),
       </list-item>
       <list-item label="•">
        {a mathematical formula}fMD(c)=fMN(c), for every constant {a mathematical formula}c∈Dom(MD),
       </list-item>
       <list-item label="•">
        {a mathematical formula}cMD=cMN, for every constant {a mathematical formula}c∈Dom(MD),
       </list-item>
       <list-item label="•">
        {a mathematical formula}a∈PMD if and only if {a mathematical formula}a∈PMN and {a mathematical formula}a∈Dom(MD)|a|, for every predicate {a mathematical formula}P∈τ(ΓD).
       </list-item>
      </list>
      <paragraph>
       Proposition 5 shows that {a mathematical formula}MD is well defined in the sense that the domain of {a mathematical formula}MD is not empty. Proposition 6 shows that {a mathematical formula}MN and {a mathematical formula}MD agree on the interpretations of all constants and predicates in {a mathematical formula}τ(ΓD).
      </paragraph>
      <paragraph label="Proposition 5">
       {a mathematical formula}Dom(MD)contains at least one domain elements.
      </paragraph>
      <paragraph label="Proof">
       {a mathematical formula}MN is a model of rule (A.12). So cc is interpreted to a domain element different to any other constants in {a mathematical formula}Cnew. Thus, {a mathematical formula}ccMN∈Dom(MD).  □
      </paragraph>
      <paragraph label="Proposition 6">
       Let{a mathematical formula}P∈τ(ΓD)be a predicate, and{a mathematical formula}a∈Dom(MN)|a|a tuple of domain elements that matches the arity of P. Then,{a mathematical formula}a∈PMDif and only if{a mathematical formula}a∈PMN.
      </paragraph>
      <paragraph label="Proof">
       By Proposition 2, if {a mathematical formula}a∈PMN then {a mathematical formula}a∈Dom(MD)|a|. So, by the construction of {a mathematical formula}MD, {a mathematical formula}a∈PMD if and only if {a mathematical formula}a∈PMN.  □
      </paragraph>
      <paragraph>
       Now, we present the proof of Lemma 3.
      </paragraph>
      <paragraph label="Proof">
       We first show that {a mathematical formula}MD⊨ΓDˆ. Otherwise, there exist a rule r of the form (27) and a substitution θ on {a mathematical formula}Var(r) such that {a mathematical formula}MD⊭rˆθ. So {a mathematical formula}MD⊨Body(r)θ and {a mathematical formula}MD⊭αiθ ({a mathematical formula}1≤i≤k). We also have {a mathematical formula}MN⊭αiθ ({a mathematical formula}1≤i≤k), by Proposition 6. Then, by Proposition 3, we have {a mathematical formula}MN⊨op〈x:Qr,i,jx,vi,vj)〉⪯cnθ ({a mathematical formula}1≤i≠j≤k). When we consider the rule {a mathematical formula}r′∈ΓN of the form (A.1), we have {a mathematical formula}MN⊨Body(r′)θ and {a mathematical formula}MN⊭Head(r′)θ. This is a contradiction to the fact that {a mathematical formula}MN is a stable model of {a mathematical formula}ΓN.It remains to show{a mathematical formula} We show this by contradiction. Otherwise, there exists a structure {a mathematical formula}UD on {a mathematical formula}τ(ΓD)∪UD such that {a mathematical formula}UD⊨UD&lt;PD and {a mathematical formula}UD⊨⋀r∈ΓDr⁎ˆ.Let {a mathematical formula}UN be a {a mathematical formula}Q-reserve extension of {a mathematical formula}MN such that {a mathematical formula}UPUN=UPUD when P is an intensional predicate in {a mathematical formula}ΓD. In the following, we will show that{a mathematical formula} which is a contradiction to the fact that {a mathematical formula}MN is a stable model of {a mathematical formula}ΓN.It suffices to show:
       <list>
        {a mathematical formula}UN⊨UN&lt;PN;{a mathematical formula}UN⊨r⁎, for rule {a mathematical formula}r∈CST,{a mathematical formula}UN⊨r⁎, for rule {a mathematical formula}r∈DEF,{a mathematical formula}UN⊨r⁎, for rule {a mathematical formula}r∈AGG.(a) Consider the predicates
       </list>
       <paragraph>
        P and {a mathematical formula}UP:
       </paragraph>
       <list>
        <list-item label="•">
         If P is an intensional predicate in {a mathematical formula}ΓD, then {a mathematical formula}UPUN=UPUD. We also have {a mathematical formula}UD⊨UD&lt;PD. So we have {a mathematical formula}UN⊨UD&lt;PD;
        </list-item>
        <list-item label="•">
         If {a mathematical formula}P∈QD∪QM, then {a mathematical formula}UPUN=UPMN. So we have {a mathematical formula}UN⊨UP=P;
        </list-item>
        <list-item label="•">
         If P is a predicate of the form {a mathematical formula}Qr,i,j∈Q, {a mathematical formula}r∈ΓD is a rule of the form (27), and {a mathematical formula}αi=Pi(vi) and {a mathematical formula}αj=Pj(vj) are two atoms in the head of r, we also have {a mathematical formula}UD⊨UD&lt;PD. Notice that {a mathematical formula}QMiUN=QMiMN, {a mathematical formula}i=1,2,3, and that {a mathematical formula}PiUN⊆PiMN and {a mathematical formula}PjUN⊆PjMN.
        </list-item>
       </list>
       <paragraph>
        So we have {a mathematical formula}UN⊨UN&lt;PN.(b) Let r be a rule of the form (A.17), (A.18), (A.19), or (A.23), we have {a mathematical formula}UN⊨r⁎, since {a mathematical formula}UPUN=UPMN for {a mathematical formula}P∈QD∪QM.(c) Let r be a rule of the form (A.3). Let {a mathematical formula}vivj/bc be an assignment on {a mathematical formula}Dom(UN), and {a mathematical formula}ds a tuple in D, where {a mathematical formula}(1≤s≤N1). We have {a mathematical formula}dsUN∈QM1UN, since {a mathematical formula}UN is a model of rules (A.17) and (A.20). If {a mathematical formula}UN⊨NotLitsNew(vivj)[vivj/bc], we have {a mathematical formula}bc∈Dom(MD|bc|). By (A.31), {a mathematical formula}UN⊨UQr,i,j(ds,vi,vj)[vivj/bc]. Thus, {a mathematical formula}UN⊨r⁎.Let r be a rule of the form (A.4). Let {a mathematical formula}vivj/bc be an assignment on {a mathematical formula}Dom(UN), and {a mathematical formula}ds a tuple in D, where {a mathematical formula}(N1&lt;s≤N2). We have {a mathematical formula}dsUN∈QM2UN, since {a mathematical formula}UN is a model of rules (A.18) and (A.21). If {a mathematical formula}UN⊨UPj(vj)∧NotLitsNew(vivj)[vivj/bc], we have {a mathematical formula}b∈Dom(MD)|b| and {a mathematical formula}c∈UPjUN. By (A.32), {a mathematical formula}UN⊨UQr,i,j(ds,vi,vj)[vivj/bc]. Thus, {a mathematical formula}UN⊨r⁎.Let r be a rule of the form (A.5). Let {a mathematical formula}vivj/bc be an assignment on {a mathematical formula}Dom(UN), and {a mathematical formula}ds ({a mathematical formula}N2&lt;s≤N3), be a tuple in D. We have {a mathematical formula}dsUN∈QM3UN, since {a mathematical formula}UN is a model of rules (A.19) and (A.22). If {a mathematical formula}UN⊨UPi(vi)∧UPj(vj)[vivj/bc], we have {a mathematical formula}b∈UPiUN and {a mathematical formula}c∈UPjUN. By (A.33), {a mathematical formula}UN⊨UQr,i,j(ds,vi,vj)[vivj/bc]. Thus, {a mathematical formula}UN⊨r⁎.(d) Let r be a rule of the form (27), and {a mathematical formula}riN a rule of the (A.1), {a mathematical formula}1≤i≤k. We will show {a mathematical formula}UN⊨(riN)⁎ by contradiction.Assume that there exists an assignment θ such that {a mathematical formula}UN⊨Body(riN⁎)θ and {a mathematical formula}UN⊭αi⁎θ. By {a mathematical formula}UN⊨Body(riN⁎), we have{a mathematical formula} where {a mathematical formula}i≠j and {a mathematical formula}1≤j≤k. So we have{a mathematical formula} by Proposition 4. Since {a mathematical formula}UN⊭αi⁎θ, we have {a mathematical formula}UN⊭αj⁎θ, {a mathematical formula}1≤j≤k.However, {a mathematical formula}UD, {a mathematical formula}UD and {a mathematical formula}UN agree on every predicate in {a mathematical formula}τ(ΓD). Therefore, we also have {a mathematical formula}UD⊨Body(r⁎)θ and {a mathematical formula}UD⊭αj⁎θ, {a mathematical formula}1≤j≤k. This is a contradiction, since {a mathematical formula}UD⊨r⁎.  □
       </paragraph>
      </paragraph>
     </section>
     <section label="A.3">
      The proof of Lemma 4
      <paragraph>
       In this section, we will show that if {a mathematical formula}MD is a stable model of {a mathematical formula}ΓD, then there exists a stable model {a mathematical formula}MN of {a mathematical formula}ΓN such that {a mathematical formula}MD and {a mathematical formula}MN agree on all interpretations of constants and predicates in {a mathematical formula}τ(ΓD).
      </paragraph>
      <paragraph>
       Let {a mathematical formula}MD be a structure on {a mathematical formula}τ(Γ). By {a mathematical formula}MN, we denote the structure on {a mathematical formula}τ(ΓN) such that:
      </paragraph>
      <list>
       <list-item label="•">
        {a mathematical formula}Dom(MN)=Dom1(MN)∪Dom2(MN), where {a mathematical formula}Dom1(MN)=Dom(MD) and {a mathematical formula}Dom2(MN)={cMN|c∈Cnew∖{cc}} is a set of new domain elements;
       </list-item>
       <list-item label="•">
        the constants in {a mathematical formula}τ(ΓD) are interpreted the same as those in {a mathematical formula}MD, the new constant {a mathematical formula}c∈Cnew∖{cc} is interpreted as the new domain element {a mathematical formula}cMN, and cc is interpreted as any of the domain element in {a mathematical formula}Dom1(MD);
       </list-item>
       <list-item label="•">
        {a mathematical formula}
       </list-item>
       <list-item label="•">
        {a mathematical formula}PMN=PMD if P is a predicate in {a mathematical formula}τ(ΓD);
       </list-item>
       <list-item label="•">
        {a mathematical formula}QMiMN={d1MN,…,dNiMN} if {a mathematical formula}QMi is a predicate in {a mathematical formula}QM, {a mathematical formula}i=1,2,3;
       </list-item>
       <list-item label="•">
        {a mathematical formula}QDiMN={diMN} if {a mathematical formula}QDi is a predicate in {a mathematical formula}QD, {a mathematical formula}1≤i≤N3;
       </list-item>
       <list-item label="•">
        {a mathematical formula}abc∈Qr,i,jMN if and only if at least one of the following holds:{a mathematical formula}{a mathematical formula}{a mathematical formula} where
       </list-item>
      </list>
      <paragraph>
       Now, we present the proof of Lemma 4.
      </paragraph>
      <paragraph label="Proof">
       First, we show that {a mathematical formula}MN is a model of {a mathematical formula}ΓN. It suffices to show that {a mathematical formula}ΓN is a model of the rules in {a mathematical formula}CST, {a mathematical formula}DEF and {a mathematical formula}AGG.(1) Consider the rules in {a mathematical formula}CST.
       <list>
        {a mathematical formula}MN is a model of rule (A.10), since {a mathematical formula}PMN=PMD if P is a predicate in {a mathematical formula}τ(ΓD);{a mathematical formula}MN is a model of rules (A.11) and (A.12), since the constant cc and constants in {a mathematical formula}τ(ΓD) are interpreted as the domain elements in {a mathematical formula}Dom1(MN) while constants in {a mathematical formula}Cnew are interpreted as domain elements in {a mathematical formula}Dom2(MN);{a mathematical formula}MN is a model of rule (A.13), since constants in {a mathematical formula}Cnew∖{cc} are always interpreted as new distinct domain elements in {a mathematical formula}Dom2(MN);{a mathematical formula}MN is a model of rule (A.14), since{a mathematical formula}{a mathematical formula} and {a mathematical formula}op(M1)⪯N;Similarly to rule (A.14), {a mathematical formula}MN is a model of rules (A.15) and (A.16);{a mathematical formula}MN is a model of rules (A.17), (A.18), (A.19), (A.20), (A.21), (A.22), (A.23), (A.24), since {a mathematical formula}QMiMN={d1MN,…,dNiMN}(i=1,2,3) and {a mathematical formula}QDiMN={diMN} ({a mathematical formula}1≤i≤N3).(2) Consider the rules in
       </list>
       <paragraph>
        {a mathematical formula}DEF.
       </paragraph>
       <list>
        <list-item label="•">
         Let r be a rule of the form (A.3). Let {a mathematical formula}vivj/bc be an assignment on {a mathematical formula}Dom(MN) and {a mathematical formula}ds a tuple in D, where {a mathematical formula}(1≤s≤N1). If {a mathematical formula}MN⊨NotLitsNew(vivj)[vivj/bc], then {a mathematical formula}bc∈Dom1(MD)|bc|. By (A.44), we have {a mathematical formula}MN⊨Qr,i,j(ds,vi,vj)[vivj/bc]. So, {a mathematical formula}MN is a model of r. Similarly, {a mathematical formula}MN is a model of rules of the form (A.4) and (A.5).
        </list-item>
        <list-item label="•">
         Let r be a rule of the form (A.6). Let {a mathematical formula}xvivj/abc be an assignment on {a mathematical formula}Dom(MN). If {a mathematical formula}MN⊨Qr,i,j(ds,vi,vj)∧¬Pj(vj)[xvivj/abc], then (A.42) holds but (A.43) and (A.44) do not hold. So we have {a mathematical formula}a∈{d1MN,…,dN1MN}. Thus, {a mathematical formula}MN is a model of rule (A.6). Similarly, {a mathematical formula}MN is a model of rules of the form (A.7) and (A.8).
        </list-item>
       </list>
       <paragraph>
        This completes the proof.  □
       </paragraph>
      </paragraph>
     </section>
    </section>
   </appendices>
  </root>
 </body>
</html>